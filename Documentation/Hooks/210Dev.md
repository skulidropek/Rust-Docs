# Hook Definitions

## OnTurretClearList(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the turret clear list is triggered.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <param name="player">The player who triggered the clear list.</param>
/// <returns>
/// Returns `null` to allow the clear list to proceed, or any non-null value to prevent it from clearing.
/// </returns>
object OnTurretClearList(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.name} has been cleared by player {player.UserIDString}");
    if (player.userID == 123456)
    {
        Puts($"Player {player.UserIDString} is not allowed to clear the list.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			SendNetworkUpdate();
		}
	}

```

## OnHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter drops a crate.
/// </summary>
/// <param name="helicopter">The helicopter that dropped the crate.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityID()} dropped a crate.");
}
```
```

### Source Code from the Library

```csharp

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

```

## OnDispenserGather(ResourceDispenser,BaseEntity,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser gathers an item.
/// </summary>
/// <param name="dispenser">The dispenser that gathered the item.</param>
/// <param name="entity">The entity from which the item was gathered.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the dispenser will give the item to the entity as normal.
/// </returns>
object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
{
    Puts($"Dispenser {dispenser} gathered an item from entity {entity}.");
    if (item.itemid == 123) // Example: If the item ID is 123
    {
        Puts($"Item with ID {item.itemid} was not allowed to be gathered.");
        return "Not allowed";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float num3 = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		float num4 = num3 * destroyFraction * 2f;
		if (itemAmt.amount <= num3 + num4)
		{
			float num5 = (num3 + num4) / itemAmt.amount;
			num3 /= num5;
			num4 /= num5;
		}
		itemAmt.amount -= Mathf.Floor(num3);
		itemAmt.amount -= Mathf.Floor(num4);
		if (num3 < 1f)
		{
			num3 = ((UnityEngine.Random.Range(0f, 1f) <= num3) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (num3 >= 1f)
		{
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, Mathf.FloorToInt(num3), 0uL);
			if (item != null && Interface.CallHook("OnDispenserGather", this, entity, item) == null)
			{
				OverrideOwnership(item, attackWeapon);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed in the shop.
/// </summary>
/// <param name="shopFront">The shop front where the trade was completed.</param>
/// <returns>
/// Returns `null` to allow the trade completion, or any non-null value to prevent the trade from being completed.
/// </returns>
object OnShopCompleteTrade(ShopFront shopFront)
{
    Puts($"Trade completed in shop {shopFront.name}.");
    if (shopFront.itemsSold > 10)
    {
        Puts($"Shop {shopFront.name} has sold more than 10 items. Trade completion prevented.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			for (int num = vendorInventory.capacity - 1; num >= 0; num--)
			{
				Item slot = vendorInventory.GetSlot(num);
				Item slot2 = customerInventory.GetSlot(num);
				if ((bool)customerPlayer && slot != null)
				{
					customerPlayer.GiveItem(slot);
				}
				if ((bool)vendorPlayer && slot2 != null)
				{
					vendorPlayer.GiveItem(slot2);
				}
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnPlayerInput(BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player's input is received.
/// </summary>
/// <param name="player">The player whose input is being processed.</param>
/// <param name="inputState">The current state of the player's input, including button presses and releases.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the input will be handled as normal.
/// </returns>
object OnPlayerInput(BasePlayer player, InputState inputState)
{
    Puts($"Player {player.UserID} has received new input.");
    if (inputState.buttons.Contains(BUTTON.FIRE_PRIMARY) && !player.IsSpectating())
    {
        // Handle primary fire button press
        return null;
    }
    else if (inputState.buttons.Contains(BUTTON.JUMP))
    {
        // Handle jump button press
        player.Jump();
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## OnPlayerVoice(BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a player sends voice data.
/// </summary>
/// <param name="player">The player sending the voice data.</param>
/// <param name="data">The voice data being sent.</param>
/// <returns>
/// Returns `null` to allow the voice data to be broadcasted, or any non-null value to prevent it from being broadcasted.
/// </returns>
object OnPlayerVoice(BasePlayer player, byte[] data)
{
    Puts($"Player {player.UserIDString} is sending voice data.");
    if (data.Length > 1024)
    {
        Puts($"Player {player.UserIDString} has sent too much voice data. Data length: {data.Length}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnReceivedVoice(byte[] data)
	{
		if (Interface.CallHook("OnPlayerVoice", this, data) == null && Network.Net.sv.write.Start())
		{
			Network.Net.sv.write.PacketID(Message.Type.VoiceData);
			Network.Net.sv.write.UInt32(net.ID);
			Network.Net.sv.write.BytesWithSize(data);
			Network.Net.sv.write.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f))
			{
				priority = Priority.Immediate
			});
		}
	}

```

## OnPlayerRecovered(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecovered(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered from being wounded.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	private void WoundingTick()
	{
		using (TimeWarning.New("WoundingTick"))
		{
			if (IsDead())
			{
				return;
			}
			if (secondsSinceWoundedStarted >= woundedDuration)
			{
				if (UnityEngine.Random.Range(0, 100) < 20)
				{
					SetPlayerFlag(PlayerFlags.Wounded, b: false);
					Interface.CallHook("OnPlayerRecovered", this);
				}
				else
				{
					Die();
				}
			}
			else
			{
				Invoke(WoundingTick, 1f);
			}
		}
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a rocket is launched.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="projectile">The projectile that was launched.</param>
void OnRocketLaunched(BasePlayer player, BaseEntity projectile)
{
    Puts($"Rocket launched by {player.displayName} at position {projectile.transform.position}");
    Interface.CallHook("OnRocketLaunched", player, projectile);
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "magazine_empty");
			return;
		}
		primaryMagazine.contents--;
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		bool num = msg.read.Bit();
		BaseEntity mounted = player.GetParentEntity();
		if (mounted == null)
		{
			mounted = player.GetMounted();
		}
		if (num)
		{
			if (mounted != null)
			{
				vector = mounted.transform.TransformPoint(vector);
				vector2 = mounted.transform.TransformDirection(vector2);
			}
			else
			{
				vector = player.eyes.position;
				vector2 = player.eyes.BodyForward();
			}
		}
		if (!ValidateEyePos(player, vector))
		{
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		float num2 = GetAimCone() + component.projectileSpread;
		if (num2 > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);
		}
		float num3 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1236478737))
		{
			num3 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num3);
		if (!(baseEntity == null))
		{
			baseEntity.creatorEntity = player;
			ServerProjectile component2 = baseEntity.GetComponent<ServerProjectile>();
			if ((bool)component2)
			{
				component2.InitializeVelocity(player.GetInheritedProjectileVelocity() + vector2 * component2.speed);
			}
			baseEntity.Spawn();
			StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
			Interface.CallHook("OnRocketLaunched", player, baseEntity);
			GetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));
		}
	}

```

## OnCrateDropped(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a crate is dropped.
/// </summary>
/// <param name="crate">The crate that was dropped.</param>
/// <returns>No return behavior.</returns>
void OnCrateDropped(HackableLockedCrate crate)
{
    Puts($"Crate {crate.CrateID} has been dropped.");
}
```
```

### Source Code from the Library

```csharp

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", this);
	}

```

## OnTurretToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret's online status is toggled.
/// </summary>
/// <param name="turret">The AutoTurret whose online status has been toggled.</param>
/// <returns>
/// Returns `null` to allow the turret's online status to be toggled, or any non-null value to prevent the toggle.
/// </returns>
object OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret.GetReference().ToString()} has been {(turret.HasFlag(Flags.On) ? "enabled" : "disabled")}.");
    if (turret.IsOffline())
    {
        return "Cannot toggle offline turret.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != HasFlag(Flags.On) && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			booting = false;
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
			}
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped.
/// </summary>
/// <param name="item">The item being dropped.</param>
/// <param name="baseEntity">The BaseEntity representing the dropped item, or null if the item cannot be dropped.</param>
/// <returns>No return behavior.</returns>
void OnItemDropped(Item item, BaseEntity baseEntity)
{
    Puts($"Item {item.info.name} has been dropped.");
    if (baseEntity != null && baseEntity is BasePlayer)
    {
        Puts($"The item was dropped by player {((BasePlayer)baseEntity).displayName}");
    }
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		RemoveFromWorld();
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item was removed.</param>
/// <param name="item">The item that was removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.name} has been removed from container {container.name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		if (onPreItemRemove != null)
		{
			onPreItemRemove(item);
		}
		itemList.Remove(item);
		item.parent = null;
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: false);
		}
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## CanSetBedPublic(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called when a player tries to set their bed public or private.
/// </summary>
/// <param name="player">The player attempting to set the bed's visibility.</param>
/// <param name="bed">The sleeping bag being modified.</param>
/// <returns>
/// Returns `null` if the player is allowed to change the bed's visibility, or any non-null value to prevent them from doing so.
/// </returns>
object CanSetBedPublic(BasePlayer player, SleepingBag bed)
{
    Puts($"Player {player.UserIDString} tried to set their bed public or private.");
    if (bed.IsOwner(player))
    {
        return null;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not own the sleeping bag and cannot change its visibility.");
        return true;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsPublic() && Interface.CallHook("CanSetBedPublic", msg.player, this) == null)
		{
			SetPublic(flag);
			if (!IsPublic())
			{
				deployerUserID = msg.player.userID;
			}
			SendNetworkUpdate();
		}
	}

```

## OnStructureDemolish(BuildingBlock,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a structure is demolished.
/// </summary>
/// <param name="structure">The structure being demolished.</param>
/// <param name="player">The player demolishing the structure.</param>
/// <param name="isForced">Whether the demolition was forced or not.</param>
/// <returns>
/// Returns `null` to allow the structure to be demolished, or any non-null value to prevent it from being demolished.
/// </returns>
object OnStructureDemolish(BuildingBlock structure, BasePlayer player, bool isForced)
{
    Puts($"Structure {structure.name} has been demolished by player {player.UserIDString}.");
    if (isForced && structure.isProtected)
    {
        Puts($"Demolition of protected structure {structure.name} was forced.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## OnLootSpawn(LootContainer)

```csharp
```csharp
/// <summary>
/// Called when loot is spawned.
/// </summary>
/// <param name="lootContainer">The LootContainer that was spawned.</param>
/// <returns>
/// Returns `null` to allow the loot container to spawn normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be logged as a message.
/// </returns>
object OnLootSpawn(LootContainer lootContainer)
{
    Puts($"Loot has been spawned in {lootContainer.GetPosition()}");
    if (lootContainer.GetWeight() > 1000)
    {
        Puts($"Warning: Loot container is overweight! Weight: {lootContainer.GetWeight()}");
        return "Overweight";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void SpawnLoot()
	{
		if (inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				Invoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a new grade.
/// </summary>
/// <param name="structure">The structure being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="grade">The new grade of the structure.</param>
/// <returns>
/// Returns a non-null value to override the default upgrade behavior. 
/// If `null` is returned, the structure is upgraded as normal.
/// </returns>
object OnStructureUpgrade(BaseBuilding structure, BasePlayer player, BuildingGrade.Enum grade)
{
    Puts($"Structure {structure.GetReference()} has been upgraded by player {player.UserIDString} to grade {grade}.");
    if (grade == BuildingGrade.Enum.Premium && !player.HasPermission("premium.upgrades"))
    {
        Puts($"Player {player.UserIDString} does not have permission to upgrade structures to premium grade.");
        return "Error: Player lacks required permission.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void DoUpgradeToGrade(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
			ConstructionGrade constructionGrade = GetGrade(@enum);
			if (!(constructionGrade == null) && CanChangeToGrade(@enum, msg.player) && CanAffordUpgrade(@enum, msg.player) && !(base.SecondsSinceAttacked < 30f) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum) == null)
			{
				PayForUpgrade(constructionGrade, msg.player);
				SetGrade(@enum);
				SetHealthToMax();
				StartBeingRotatable();
				SendNetworkUpdate();
				UpdateSkin();
				ResetUpkeepTime();
				BuildingManager.server.GetBuilding(buildingID)?.Dirty();
				Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + @enum.ToString().ToLower() + ".prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## CanHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can drop a crate.
/// </summary>
/// <param name="helicopter">The helicopter attempting to drop the crate.</param>
/// <returns>
/// Returns `true` if the helicopter is allowed to drop the crate, and `false` otherwise.
/// If any other type of object is returned, it will be treated as a custom reason for not dropping the crate.
/// </returns>
object CanHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityId()} attempting to drop crate.");
    if (helicopter.IsLowOnFuel())
    {
        Puts($"Helicopter {helicopter.GetReference().GetEntityId()} is low on fuel and cannot drop crate.");
        return "Not enough fuel.";
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player who is starting to sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has started sleeping.");
    if (player.GetPlayerFlag(PlayerFlags.Admin))
    {
        Puts($"Admin player {player.UserIDString} has started sleeping. Allowing them to sleep without restrictions.");
    }
    else
    {
        Puts($"Non-admin player {player.UserIDString} has started sleeping. Disabling their inventory and crafting while they sleep.");
        // Disable inventory and crafting for non-admin players who are sleeping
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping())
		{
			EnsureDismounted();
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			sleepStartTime = UnityEngine.Time.time;
			if (!sleepingPlayerList.Contains(this))
			{
				sleepingPlayerList.Add(this);
			}
			CancelInvoke(InventoryUpdate);
			CancelInvoke(TeamUpdate);
			inventory.loot.Clear();
			inventory.crafting.CancelAll(returnItems: true);
			UpdatePlayerCollider(state: true);
			UpdatePlayerRigidbody(state: false);
			Interface.CallHook("OnPlayerSleep", this);
		}
	}

```

## CanRenameBed(BasePlayer,SleepingBag,string)

```csharp
```csharp
/// <summary>
/// Called to check if a player can rename a bed.
/// </summary>
/// <param name="player">The player attempting to rename the bed.</param>
/// <param name="bed">The bed being renamed.</param>
/// <param name="newName">The proposed new name for the bed.</param>
/// <returns>
/// Returns `null` if the player can rename the bed, or any non-null value to prevent renaming.
/// </returns>
object CanRenameBed(BasePlayer player, SleepingBag bed, string newName)
{
    Puts($"Player {player.UserIDString} is trying to rename their sleeping bag.");
    if (newName == "Admin's Bed")
    {
        Puts($"Player {player.displayName} cannot rename the bed to '{newName}'.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("CanRenameBed", msg.player, this, text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
		}
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an entity.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntity(BasePlayer looter, BaseEntity entity)
{
    Puts($"Player {looter.UserIDString} started looting entity {entity.baseEntityID}");
    if (entity is BaseCorpse corpse && corpse.IsBoss)
    {
        Puts($"Player {looter.UserIDString} cannot loot the boss entity {entity.baseEntityID}");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!targetEntity)
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		MarkDirty();
		return true;
	}

```

## OnItemScrap(ResearchTable,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is scrapped for research.
/// </summary>
/// <param name="researchTable">The research table used to scrap the item.</param>
/// <param name="item">The item being scrapped.</param>
/// <returns>
/// Returns a non-negative integer representing the amount of research points gained from scrapping the item. 
/// If `null` is returned, the default research point value will be used.
/// </returns>
object OnItemScrap(ResearchTable researchTable, Item item)
{
    Puts($"Item {item.info.name} has been scrapped for research.");
    if (item.info.rarity == Rarity.VeryRare)
    {
        Puts($"Item {item.info.name} is a Very Rare item. Scrapping will yield 1000 research points.");
        return 1000;
    }
    int result = ScrapForResearchDefault(item);
    return result;
}

// Default research point value for scrapping an item
int ScrapForResearchDefault(Item item)
{
    switch (item.info.rarity)
    {
        case Rarity.Common:
            return 20;
        case Rarity.Uncommon:
            return 75;
        case Rarity.Rare:
            return 250;
        case Rarity.VeryRare:
            return 1000;
        default:
            return 750;
    }
}
```
```

### Source Code from the Library

```csharp

	public int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnItemScrap", this, item);
		if (obj is int)
		{
			return (int)obj;
		}
		int result = 0;
		if (item.info.rarity == Rarity.Common)
		{
			result = 20;
		}
		if (item.info.rarity == Rarity.Uncommon)
		{
			result = 75;
		}
		if (item.info.rarity == Rarity.Rare)
		{
			result = 250;
		}
		if (item.info.rarity == Rarity.VeryRare || item.info.rarity == Rarity.None)
		{
			result = 750;
		}
		return result;
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base combat entity is hurt.
/// </summary>
/// <param name="entity">The base combat entity that was hurt.</param>
/// <param name="hitInfo">Information about the hit, including the initiator and damage types.</param>
object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} has been hurt by {hitInfo.Initiator} with damage type {hitInfo.damageTypes.GetMajorityDamageType()}.");
    // You can add custom logic here to handle the hurt event
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50L))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			health = num - info.damageTypes.Total();
			SendNetworkUpdate();
			if (ConVar.Global.developer > 1)
			{
				Debug.Log(string.Concat("[Combat]".PadRight(10), base.gameObject.name, " hurt ", info.damageTypes.GetMajorityDamageType(), "/", info.damageTypes.Total(), " - ", health.ToString("0"), " health left"));
			}
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (markAttackerHostile && baseCombatEntity2 != null && baseCombatEntity2 != this)
			{
				baseCombatEntity2.MarkHostileFor();
			}
			if (lastDamage != DamageType.Decay)
			{
				lastAttackedTime = UnityEngine.Time.time;
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;
				}
			}
			if (health <= 0f)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.Log(info, num, health, "killed");
				}
				else
				{
					initiatorPlayer.stats.combat.Log(info, num, health);
				}
			}
		}
	}

```

## IOnPlayerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a player issues a command.
/// </summary>
/// <param name="arg">The argument passed to the command.</param>
/// <returns>
/// Returns a non-null value to override the default command behavior. 
/// If `null` is returned, the command is executed as normal.
/// </returns>
object IOnPlayerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Player {arg.Player().displayName} has issued the command: {arg.GetString(0)}");
    // Add custom logic here to handle the command
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!basePlayer || basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper)
		{
			if (basePlayer.NextChatTime == 0f)
			{
				basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup - 30f;
			}
			if (basePlayer.NextChatTime > UnityEngine.Time.realtimeSinceStartup)
			{
				basePlayer.NextChatTime += 2f;
				float num = basePlayer.NextChatTime - UnityEngine.Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(basePlayer.net.connection, "chat.add", 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					basePlayer.Kick("Chatting too fast");
				}
				return;
			}
		}
		string text = arg.GetString(0, "text").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0)
		{
			return;
		}
		if (text.StartsWith("/") || text.StartsWith("\\"))
		{
			if (Interface.CallHook("IOnPlayerCommand", arg) == null)
			{
			}
			return;
		}
		text = EscapeRichText(text);
		if (Interface.CallHook("IOnPlayerChat", arg) != null)
		{
			return;
		}
		if (serverlog)
		{
			DebugEx.Log($"[CHAT] {basePlayer.ToString()} : {text}", StackTraceLogType.None);
		}
		string text2 = "#5af";
		if (basePlayer.IsAdmin)
		{
			text2 = "#af5";
		}
		if (basePlayer.IsDeveloper)
		{
			text2 = "#fa5";
		}
		string text3 = EscapeRichText(basePlayer.displayName);
		basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup + 1.5f;
		ChatEntry chatEntry = default(ChatEntry);
		chatEntry.Message = text;
		chatEntry.UserId = basePlayer.userID;
		chatEntry.Username = basePlayer.displayName;
		chatEntry.Color = text2;
		chatEntry.Time = Epoch.Current;
		ChatEntry chatEntry2 = chatEntry;
		History.Add(chatEntry2);
		RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		if (Server.globalchat)
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add2", basePlayer.userID, text, text3, text2, 1f);
			arg.ReplyWith("");
			return;
		}
		float num2 = 2500f;
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			float sqrMagnitude = (activePlayer.transform.position - basePlayer.transform.position).sqrMagnitude;
			if (!(sqrMagnitude > num2))
			{
				ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", basePlayer.userID, text, text3, text2, Mathf.Clamp01(num2 - sqrMagnitude + 0.2f));
			}
		}
		arg.ReplyWith("");
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the vending broadcast toggle is changed.
/// </summary>
/// <param name="vendingMachine">The vending machine that was toggled.</param>
/// <param name="player">The player who performed the action.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending broadcast toggle changed by {player.displayName} for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an item.
/// </summary>
/// <param name="player">The player starting to loot the item.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} started looting item: {item.name}");
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
			MarkDirty();
		}
	}

```

## OnReloadMagazine(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player reloads their magazine.
/// </summary>
/// <param name="player">The player reloading the magazine.</param>
/// <param name="projectile">The projectile being reloaded.</param>
/// <returns>
/// Returns `null` to allow the magazine to be reloaded, or any non-null value to prevent it from being reloaded.
/// </returns>
object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} is reloading their magazine.");
    if (projectile.ammoType == "rare")
    {
        Puts($"Player {player.displayName} cannot reload rare ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected void ReloadMagazine()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((bool)ownerPlayer && Interface.CallHook("OnReloadMagazine", ownerPlayer, this) == null)
		{
			primaryMagazine.Reload(ownerPlayer);
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret sets its target.
/// </summary>
/// <param name="turret">The helicopter turret setting the target.</param>
/// <param name="target">The entity being targeted by the helicopter turret.</param>
/// <returns>
/// Returns `null` to allow the helicopter turret to set its target, or any non-null value to prevent it from setting its target.
/// </returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts($"Helicopter Turret {turret.GetReference()} is targeting entity {target.UserIDString}.");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"Helicopter Turret {turret.GetReference()} has been prevented from targeting admin player {player.UserIDString}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## OnPlayerDie(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player dies.
/// </summary>
/// <param name="player">The player who died.</param>
/// <param name="info">Information about the hit that caused the death, if any.</param>
/// <returns>
/// Returns `null` to allow the player to die normally. If a non-null value is returned, it will override the default dying behavior.
/// </returns>
object OnPlayerDie(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} has died.");
    if (info != null && info.Attacker != null)
    {
        Puts($"Player was killed by {info.Attacker.UserIDString} with a {info.Weapon}.");
        return "Killed by another player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead())
			{
				if (Belt != null && ShouldDropActiveItem())
				{
					UnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + vector.normalized * 3f);
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDie", this, info) == null)
				{
					base.Die(info);
				}
			}
		}
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a BasePlayer is hurt.
/// </summary>
public override void IOnBasePlayerHurt(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.displayName} has been hurt.");
    // Add custom logic here if needed
    return null;
}

// Note: The original Hurt method will be called after this hook returns.
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || IsImmortal() || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		if (info.damageTypes.Get(DamageType.Drowned) > 5f && drownEffect.isValid)
		{
			Effect.server.Run(drownEffect.resourcePath, this, StringPool.Get("head"), UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((bool)initiatorPlayer && initiatorPlayer != this)
		{
			if (initiatorPlayer.InSafeZone() || InSafeZone())
			{
				initiatorPlayer.MarkHostileFor(1800f);
			}
			if (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(DamageType.Explosion) > 0f)
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);
			}
		}
		base.Hurt(info);
		if (EACServer.playerTracker != null && info.Initiator != null && info.Initiator is BasePlayer)
		{
			BasePlayer basePlayer = info.Initiator.ToPlayer();
			if (net.connection != null && basePlayer.net.connection != null)
			{
				EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
				EasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(basePlayer.net.connection);
				PlayerTakeDamage eventParams = default(PlayerTakeDamage);
				eventParams.DamageTaken = (int)info.damageTypes.Total();
				eventParams.HitBoneID = (int)info.HitBone;
				eventParams.WeaponID = 0;
				eventParams.DamageFlags = (info.isHeadshot ? PlayerTakeDamageFlags.PlayerTakeDamageCriticalHit : PlayerTakeDamageFlags.PlayerTakeDamageNormalHit);
				if (info.Weapon != null)
				{
					Item item = info.Weapon.GetItem();
					if (item != null)
					{
						eventParams.WeaponID = item.info.itemid;
					}
				}
				UnityEngine.Vector3 position = basePlayer.eyes.position;
				UnityEngine.Vector3 eulerAngles = basePlayer.eyes.rotation.eulerAngles;
				UnityEngine.Vector3 position2 = eyes.position;
				UnityEngine.Vector3 eulerAngles2 = eyes.rotation.eulerAngles;
				eventParams.AttackerPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position.x, position.y, position.z);
				eventParams.AttackerViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(eulerAngles.x, eulerAngles.y, eulerAngles.z);
				eventParams.VictimPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position2.x, position2.y, position2.z);
				eventParams.VictimViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
				EACServer.playerTracker.LogPlayerTakeDamage(client, client2, eventParams);
			}
		}
		metabolism.SendChangesToClient();
		if (info.PointStart != UnityEngine.Vector3.zero)
		{
			ClientRPCPlayer(null, this, "DirectionalDamage", info.PointStart, (int)info.damageTypes.GetMajorityDamageType());
		}
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be wounded.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="hitInfo">Information about the hit that caused this call.</param>
/// <returns>
/// Returns `true` if the player can be wounded, or `false` otherwise. 
/// If a non-boolean value is returned, it will override the default behavior.
/// </returns>
object CanBeWounded(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Checking if {player.UserIDString} can be wounded by {hitInfo.WeaponPrefab.name}.");
    if (hitInfo.WeaponPrefab.name == "Melee")
    {
        Puts($"Player {player.UserIDString} cannot be wounded by melee attacks.");
        return false;
    }
    if (hitInfo.isHeadshot)
    {
        Puts($"Player {player.UserIDString} cannot be wounded by headshots.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastWoundedTime < 60f)
		{
			return false;
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnNpcStopMoving(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC stops moving.
/// </summary>
/// <param name="npc">The NPC that stopped moving.</param>
/// <returns>No return behavior.</returns>
void OnNpcStopMoving(NPCPlayerApex npc)
{
    Puts($"NPC {npc.name} has stopped moving.");
}
```
```

### Source Code from the Library

```csharp

	public void StopMoving()
	{
		if (Interface.CallHook("OnNpcStopMoving", this) == null)
		{
			IsStopped = true;
			finalDestination = GetPosition();
		}
	}

```

## OnPlayerRecover(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecover(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered from being wounded.");
}
```
```

### Source Code from the Library

```csharp

	public void StopWounded()
	{
		if (IsDead() || Interface.CallHook("OnPlayerRecover", this) == null)
		{
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			CancelInvoke(WoundingTick);
		}
	}

```

## OnNpcPlayerTarget(Rust.Ai.HTN.BaseNpcMemory,BaseNpc)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npcMemory">The memory of the NPC that targeted the player.</param>
/// <param name="baseNpc">The base NPC that targeted the player.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the player, or any non-null value to prevent them from targeting the player.
/// </returns>
object OnNpcPlayerTarget(Rust.Ai.HTN.BaseNpcMemory npcMemory, BaseNpc baseNpc)
{
    Puts($"NPC {baseNpc.Name} has targeted a player.");
    if (npcMemory.GetAggroTarget() == null)
    {
        Puts($"NPC {baseNpc.Name} does not have an aggro target.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RememberPrimaryAnimal(BaseNpc animal)
	{
		if (Interface.CallHook("OnNpcPlayerTarget", this, animal) != null)
		{
			return;
		}
		for (int i = 0; i < NpcContext.AnimalsInRange.Count; i++)
		{
			AnimalInfo primaryKnownAnimal = NpcContext.AnimalsInRange[i];
			if (primaryKnownAnimal.Animal == animal)
			{
				PrimaryKnownAnimal = primaryKnownAnimal;
				break;
			}
		}
	}

```

## CanUnlock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock the object.
/// </summary>
/// <param name="player">The player attempting to unlock.</param>
/// <param name="lock">The lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to unlock, or any non-null value to prevent them from unlocking.
/// </returns>
object CanUnlock(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} is attempting to unlock {lock.name}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Access denied: Only admins can unlock";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amountToConsume">The amount of the item to consume. Defaults to 1.</param>
/// <returns>No return behavior.</returns>
void OnItemUse(Item item, int amountToConsume)
{
    Puts($"Item {item.name} has been used.");
    if (amountToConsume > item.maxStackSize)
    {
        Puts($"Warning: Attempted to consume more than the maximum stack size of {item.maxStackSize} for item {item.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			Interface.CallHook("OnItemUse", this, amountToConsume);
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## OnCrateLanded(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate lands on the ground.
/// </summary>
/// <param name="crate">The landed crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateLanded(HackableLockedCrate crate)
{
    Puts($"Hackable locked crate landed at position {crate.transform.position}");
}
```
```

### Source Code from the Library

```csharp

	public void LandCheck()
	{
		RaycastHit hitInfo;
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", this);
		}
		else if (UnityEngine.Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1218511105))
		{
			Effect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);
			hasLanded = true;
			CancelInvoke(LandCheck);
		}
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
Based on the provided code snippet, I will create a method structure for `OnWeaponFired` with the correct return type.

```csharp
/// <summary>
/// Called when a weapon is fired.
/// </summary>
/// <param name="baseProjectile">The base projectile.</param>
/// <param name="basePlayer">The player who fired the weapon.</param>
/// <param name="itemModProjectile">The item mod projectile component.</param>
/// <param name="projectileShoot">The projectile shoot data.</param>
/// <returns>The result of the hook call.</returns>
public object OnWeaponFired(BaseProjectile baseProjectile, BasePlayer basePlayer, ItemModProjectile itemModProjectile, ProjectileShoot projectileShoot)
{
    // Hook implementation
}
```

In this method structure, I have added a summary to describe what the `OnWeaponFired` hook does. The parameters are also documented with their respective types and descriptions.

The return type of the `OnWeaponFired` method is set to `object`, which means it can return any type of object. This is because the `Interface.CallHook` function returns an `object` type, and we need to capture that result in our hook implementation.

Please note that you should replace the comment `// Hook implementation` with your actual code for handling the `OnWeaponFired` hook.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_missing");
			return;
		}
		ItemDefinition ammoType = primaryMagazine.ammoType;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (ammoType.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_mismatch");
			return;
		}
		if (!UsingInfiniteAmmoCheat)
		{
			primaryMagazine.contents--;
		}
		ItemModProjectile component = ammoType.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection);
		player.CleanupExpiredProjectiles();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.Log(this, "duplicate_id");
			}
			else if (ValidateEyePos(player, projectile.startPos))
			{
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, ammoType);
				CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
			}
		}
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count());
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);
		player.MarkHostileFor();
		UpdateItemCondition();
		DidAttackServerside();
		float num = 0f;
		if (component.projectileObject != null)
		{
			GameObject gameObject = component.projectileObject.Get();
			if (gameObject != null)
			{
				Projectile component2 = gameObject.GetComponent<Projectile>();
				if (component2 != null)
				{
					foreach (DamageTypeEntry damageType in component2.damageTypes)
					{
						num += damageType.amount;
					}
				}
			}
		}
		float num2 = NoiseRadius;
		if (IsSilenced())
		{
			num2 *= AI.npc_gun_noise_silencer_modifier;
		}
		Sensation sensation = default(Sensation);
		sensation.Type = SensationType.Gunshot;
		sensation.Position = player.transform.position;
		sensation.Radius = num2;
		sensation.DamagePotential = num;
		sensation.InitiatorPlayer = player;
		sensation.Initiator = player;
		Sense.Stimulate(sensation);
		if (EACServer.playerTracker == null)
		{
			return;
		}
		using (TimeWarning.New("LogPlayerShooting"))
		{
			UnityEngine.Vector3 networkPosition = player.GetNetworkPosition();
			UnityEngine.Vector3 eulerAngles = player.GetNetworkRotation().eulerAngles;
			int weaponID = GetItem()?.info.itemid ?? 0;
			EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(player.net.connection);
			PlayerUseWeapon eventParams = default(PlayerUseWeapon);
			eventParams.Position = new EasyAntiCheat.Server.Cerberus.Vector3(networkPosition.x, networkPosition.y, networkPosition.z);
			eventParams.ViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(eulerAngles.x, eulerAngles.y, eulerAngles.z);
			eventParams.WeaponID = weaponID;
			EACServer.playerTracker.LogPlayerUseWeapon(client, eventParams);
		}
	}

```

## CanBuild(Planner,Construction,Construction.Target)

```csharp
```csharp
/// <summary>
/// Determines whether a player can build at the specified location.
/// </summary>
/// <param name="planner">The planner instance.</param>
/// <param name="construction">The construction instance.</param>
/// <param name="target">The target instance.</param>
/// <returns>
/// Returns a non-null value to override the default building behavior. 
/// If `null` is returned, the player can build as normal.
/// </returns>
object CanBuild(Planner planner, Construction construction, Construction.Target target)
{
    Puts($"Player {planner.GetOwnerPlayer().Username} attempting to build at location {target.Position}");
    if (Interface.CallHook("CanBuild", this, construction, target) != null)
    {
        return null;
    }
    // Additional building logic can be added here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ChatMessage("Couldn't find Construction " + msg.blockID);
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			ownerPlayer.ChatMessage("Can't afford to place!");
			return;
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ChatMessage("Building is blocked!");
			return;
		}
		Deployable deployable = GetDeployable();
		Construction.Target target = default(Construction.Target);
		BaseEntity baseEntity = null;
		if (msg.entity != 0)
		{
			baseEntity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if (!baseEntity)
			{
				ownerPlayer.ChatMessage("Couldn't find entity " + msg.entity);
				return;
			}
			msg.position = baseEntity.transform.TransformPoint(msg.position);
			msg.normal = baseEntity.transform.TransformDirection(msg.normal);
			msg.rotation = baseEntity.transform.rotation * msg.rotation;
			if (msg.socket == 0)
			{
				if ((bool)deployable && deployable.setSocketParent && baseEntity.Distance(msg.position) > 1f)
				{
					ownerPlayer.ChatMessage("Parent too far away: " + baseEntity.Distance(msg.position));
					return;
				}
				if (baseEntity is Door)
				{
					ownerPlayer.ChatMessage("Can't deploy on door");
					return;
				}
			}
			target.entity = baseEntity;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != "" && target.entity != null)
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				else
				{
					ownerPlayer.ChatMessage("Invalid Socket!");
				}
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.valid = true;
		if (Interface.CallHook("CanBuild", this, construction, target) != null)
		{
			return;
		}
		if ((bool)deployable && deployable.placeEffect.isValid)
		{
			if ((bool)baseEntity && msg.socket != 0)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.TransformPoint(target.socket.worldPosition), baseEntity.transform.up);
			}
			else
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, msg.position, msg.normal);
			}
		}
		DoBuild(target, construction);
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret authorizes a player.
/// </summary>
/// <param name="turret">The AutoTurret that authorized the player.</param>
/// <param name="player">The BasePlayer who was authorized by the turret.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent the authorization.
/// </returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"AutoTurret {turret.name} has authorized player {player.displayName}");
    if (player.UserIDString == "admin")
    {
        Puts($"AutoTurret {turret.name} has denied authorization to admin");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!IsOnline() && Interface.CallHook("OnTurretAuthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = rpc2.player.userID;
			playerNameID.username = rpc2.player.displayName;
			authorizedPlayers.Add(playerNameID);
			SendNetworkUpdate();
		}
	}

```

## IOnNpcPlayerTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC player target is set.
/// </summary>
/// <param name="npcPlayer">The NPC player apex.</param>
/// <param name="target">The base entity being targeted.</param>
/// <returns>
/// Returns a float value indicating the NPC's desire to attack the target, on a scale of 0 (no interest) to 1 (high interest). 
/// If `null` is returned, the default behavior will be used.
/// </returns>
float IOnNpcPlayerTarget(NPCPlayerApex npcPlayer, BaseEntity target)
{
    Puts($"NPC {npcPlayer.UserIDString} has set its target to {target.UserIDString}");
    if (target == null || !target.IsValid())
    {
        return 0f;
    }
    if (target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
    {
        return 1f;
    }
    return 0.5f;
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		if (target == null)
		{
			return 0f;
		}
		object obj = Interface.CallHook("IOnNpcPlayerTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
		{
			return 0f;
		}
		if (target.GetType() == GetType())
		{
			return 0f;
		}
		if (target.Health() <= 0f)
		{
			return 0f;
		}
		return 1f;
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, DroppedItemContainer entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.GetDisplayName()}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Not allowed: Only admins can loot this entity.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine if a world projectile can be created.
/// </summary>
/// <param name="info">The hit info.</param>
/// <param name="itemDef">The item definition.</param>
/// <returns>
/// Returns `null` if the projectile can be created, or a non-null value to override the default behavior.
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
{
    Puts($"Determining if world projectile can be created for {info.hitEntity} with item {itemDef.name}");
    // Add custom logic here to determine if a world projectile can be created
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			return;
		}
		baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		component.AddForce(projectileVelocity.normalized * 200f);
		component.WakeUp();
	}

```

## OnEntityMounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is mounted by a player.
/// </summary>
/// <param name="entity">The entity being mounted.</param>
/// <param name="player">The player mounting the entity.</param>
/// <returns>
/// Returns `null` to allow the entity to be mounted, or any non-null value to prevent it from being mounted.
/// </returns>
object OnEntityMounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has mounted entity {entity.name}");
    if (entity.name == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to mount entity {entity.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			TriggerParent triggerParent = player.FindTrigger<TriggerParent>();
			if ((bool)triggerParent)
			{
				triggerParent.OnTriggerExit(player.GetComponent<Collider>());
			}
			player.MountObject(this);
			player.MovePosition(mountAnchor.transform.position);
			player.transform.rotation = mountAnchor.transform.rotation;
			player.ServerRotation = mountAnchor.transform.rotation;
			player.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			SetFlag(Flags.Busy, b: true);
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the oven is toggled on or off.
/// </summary>
/// <param name="oven">The oven being toggled.</param>
/// <param name="player">The player who toggled the oven.</param>
/// <returns>
/// Returns `null` to allow the oven to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts($"Oven {oven.GetGlobalName()} was toggled by player {player.UserIDString}.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot toggle the oven.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag != IsOn() && Interface.CallHook("OnOvenToggle", this, msg.player) == null && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				StartCooking();
			}
			else
			{
				StopCooking();
			}
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="entity">The locked entity being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the locked entity, or `false` otherwise.
/// If a non-null value other than `bool` is returned, it will be used as the return value instead of `true` or `false`.
/// </returns>
object CanUseLockedEntity(BasePlayer player, CodeLock entity)
{
    Puts($"Player {player.UserIDString} attempted to use locked entity {entity.EntityID}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.UserIDString} is an admin and can access the locked entity");
        return true;
    }
    else if (whitelistPlayers.Contains(player.userID))
    {
        Puts($"Player {player.UserIDString} is on the whitelist and can access the locked entity");
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to use the locked entity");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		if (!IsLocked())
		{
			return true;
		}
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## OnServerMessage(string,string,string,ulong)

```csharp
```csharp
/// <summary>
/// Called when a server message is broadcasted.
/// </summary>
/// <param name="message">The message being broadcasted.</param>
/// <param name="username">The username of the user who sent the message, defaults to "SERVER" if not provided.</param>
/// <param name="color">The color of the message, defaults to "#eee" if not provided.</param>
/// <param name="userid">The ID of the user who sent the message, defaults to 0 if not provided.</param>
/// <returns>
/// Returns `null` to allow the message to be broadcasted as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the message from being broadcasted.
/// </returns>
object OnServerMessage(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
{
    Puts($"Server message: {message} from {username} (ID: {userid})");
    if (userid == 1234567890uL) // Block a specific user's messages
    {
        Puts($"Blocking server message from user with ID {userid}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", message, username, color, userid) == null)
		{
			string text = EscapeRichText(username);
			ConsoleNetwork.BroadcastToAllClients("chat.add", 0, "<color=" + color + ">" + text + "</color> " + message);
			ChatEntry chatEntry = default(ChatEntry);
			chatEntry.Message = message;
			chatEntry.UserId = userid;
			chatEntry.Username = username;
			chatEntry.Color = color;
			chatEntry.Time = Epoch.Current;
			ChatEntry chatEntry2 = chatEntry;
			History.Add(chatEntry2);
			RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		}
	}

```

## IOnServerUsersRemove(ulong)

```csharp
```csharp
/// <summary>
/// Called when a user is removed from the server.
/// </summary>
/// <param name="uid">The ID of the user being removed.</param>
/// <returns>No return behavior.</returns>
void IOnServerUsersRemove(ulong uid)
{
    Puts($"User with ID {uid} has been removed from the server.");
}
```
```

### Source Code from the Library

```csharp

	public static void Remove(ulong uid)
	{
		Interface.CallHook("IOnServerUsersRemove", uid);
		if (users.ContainsKey(uid))
		{
			users.Remove(uid);
		}
	}

```

## OnItemRemove(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from the game.
/// </summary>
/// <param name="item">The item being removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemove(Item item)
{
    Puts($"Item {item.info.name} has been removed.");
    if (item.info.category == "Forbidden")
    {
        Puts($"Item {item.info.name} is a forbidden item and cannot be removed.");
        // Add any additional logic to handle the removal of forbidden items
    }
}
```
```

### Source Code from the Library

```csharp

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = UnityEngine.Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		if (isServer)
		{
			ItemManager.RemoveItem(this, fTime);
		}
	}

```

## OnPlayerKicked(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="player">The player being kicked.</param>
/// <param name="reason">The reason for kicking the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void Kick(string reason)
	{
		if (IsConnected)
		{
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason);
		}
	}

```

## OnPlayerSpawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a new player spawns.
/// </summary>
/// <param name="player">The newly spawned player.</param>
/// <returns>
/// Returns `null` to allow the player to spawn normally, or any non-null value to override the default spawning behavior. 
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object OnPlayerSpawn(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has spawned.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is a VIP and gets special treatment.");
        return "Welcome, VIP!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SpawnNewPlayer(Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer) == null)
		{
			basePlayer.health = 0f;
			basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
			basePlayer.ResetLifeStateOnSpawn = false;
			basePlayer.limitNetworking = true;
			basePlayer.Spawn();
			basePlayer.limitNetworking = false;
			basePlayer.PlayerInit(connection);
			if (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife)
			{
				basePlayer.Respawn();
			}
			else
			{
				basePlayer.SendRespawnOptions();
			}
			DebugEx.Log(basePlayer.net.connection.ToString() + " joined [" + basePlayer.net.connection.os + "/" + basePlayer.net.connection.ownerid + "]", StackTraceLogType.None);
		}
	}

```

## CanRecycle(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled.
/// </summary>
/// <param name="recycler">The recycler checking the item.</param>
/// <param name="item">The item being checked for recyclability.</param>
/// <returns>
/// Returns `true` if the item can be recycled, or `false` otherwise.
/// If a non-null value is returned, it will override the default recyclability behavior.
/// </returns>
object CanRecycle(Recycler recycler, Item item)
{
    Puts($"Checking if item {item.info.name} can be recycled by {recycler.UserIDString}");
    if (item.info.Blueprint != null && itemStackSize >= 10)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted (in this case, a corpse).</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, LootableCorpse entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot corpse {entity.GetGlobalID()}");
    if (player.IsAdmin())
    {
        return null;
    }
    else
    {
        return "You do not have permission to loot this corpse.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if ((bool)player && player.CanInteract() && CanLoot() && containers != null && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			SetFlag(Flags.Open, b: true);
			ItemContainer[] array = containers;
			foreach (ItemContainer container in array)
			{
				player.inventory.loot.AddContainer(container);
			}
			player.inventory.loot.SendImmediate();
			ClientRPCPlayer(null, player, "RPC_ClientLootCorpse");
			SendNetworkUpdate();
		}
	}

```

## OnDeleteVendingOffer(VendingMachine,int)

```csharp
```csharp
/// <summary>
/// Called when a vending offer is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was on.</param>
/// <param name="offerIndex">The index of the offer being deleted.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, int offerIndex)
{
    Puts($"Deleted vending offer {offerIndex} from vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", this, num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## CanVendingAcceptItem(VendingMachine,Item,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a vending machine can accept an item.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being attempted to be accepted.</param>
/// <param name="targetSlot">The slot on the vending machine where the item is being placed.</param>
/// <returns>
/// Returns `true` if the vending machine can accept the item, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior and be used as the return value.
/// </returns>
object CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)
{
    Puts($"Vending machine {vendingMachine.name} attempting to accept item {item.displayName} into slot {targetSlot}");
    if (item.isAdminOnly && !CanPlayerAdmin(vendingMachine.owner))
    {
        Puts($"Vending machine {vendingMachine.name} cannot accept admin-only item {item.displayName} because the owner is not an administrator");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if (transactionActive)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (inventory.itemList.Contains(item))
		{
			return true;
		}
		if (ownerPlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(ownerPlayer);
	}

```

## OnPlayerInit(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's initialization process begins.
/// </summary>
/// <param name="player">The player being initialized.</param>
/// <returns>
/// Returns `null` to allow the default initialization behavior. 
/// If a non-null value is returned, it will override the default behavior and be used instead.
/// </returns>
object OnPlayerInit(BasePlayer player)
{
    Puts($"Initializing player {player.UserIDString}...");
    // Add custom initialization code here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PlayerInit(Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10L))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			userID = c.userid;
			UserIDString = userID.ToString();
			_displayName = c.username.ToPrintable(32);
			c.player = this;
			tickInterpolator.Reset(base.transform.position);
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			ClientRPCPlayer(null, this, "StartLoading");
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			Interface.CallHook("OnPlayerInit", this);
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
			}
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is deauthorized.
/// </summary>
/// <param name="turret">The AutoTurret instance that was deauthorized.</param>
/// <param name="player">The player who deauthorized the turret.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.name} has been deauthorized by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			SendNetworkUpdate();
		}
	}

```

## OnPlayerRevive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is revived.
/// </summary>
/// <param name="reviver">The player who performed the revive.</param>
/// <param name="victim">The player being revived.</param>
/// <returns>
/// Returns `null` to allow the revival to proceed normally, or any non-null value to prevent the revival from happening.
/// If a string is returned, it will be displayed as a message to the victim when they are revived.
/// </returns>
object OnPlayerRevive(BasePlayer reviver, BasePlayer victim)
{
    Puts($"Player {reviver.UserIDString} has revived player {victim.UserIDString}.");
    if (reviver.IsWounded())
    {
        Puts($"Player {reviver.UserIDString} cannot revive themselves.");
        return "Cannot revive yourself.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			if (player != GetOwnerPlayer() && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				player.StopWounded();
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## OnSignUpdated(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated.
/// </summary>
/// <param name="sign">The signage that was updated.</param>
/// <param name="player">The player who performed the update.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.SignID} has been updated by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				textureID = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				SendNetworkUpdate();
				Interface.CallHook("OnSignUpdated", this, msg.player);
			}
		}
	}

```

## OnSwitchAmmo(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player switches ammo.
/// </summary>
/// <param name="player">The player switching ammo.</param>
/// <param name="projectile">The projectile being switched to.</param>
/// <returns>
/// Returns a non-null value to override the default ammo switch behavior. 
/// If `null` is returned, the ammo switch will proceed as normal.
/// </returns>
object OnSwitchAmmo(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} switched ammo to {projectile.definition.displayName}");
    if (projectile.definition.ammoType == "restricted")
    {
        Puts($"Player {player.UserIDString} cannot switch to restricted ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnSwitchAmmo", ownerPlayer, this) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				primaryMagazine.contents = 0;
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if a target can be targeted by the helicopter turret.
/// </summary>
/// <param name="potentialTarget">The potential target entity.</param>
/// <param name="turret">The helicopter turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBeTargeted(BaseCombatEntity potentialTarget, HelicopterTurret turret)
{
    Puts($"Checking if {potentialTarget.displayName} can be targeted by the helicopter turret.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## CanEntityBeHostile(BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether an entity can be hostile.
/// </summary>
/// <param name="entity">The entity to check.</param>
/// <returns>
/// Returns `true` if the entity can be hostile, and `false` otherwise.
/// If a non-bool value is returned by the hook, it will be treated as `true`.
/// </returns>
bool CanEntityBeHostile(BaseCombatEntity entity)
{
    object obj = Interface.CallHook("CanEntityBeHostile", entity);
    if (obj is bool)
    {
        return (bool)obj;
    }
    Puts($"Entity {entity.UserIDString} can be hostile because {obj}");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
Here is the method structure for `OnMeleeAttack(BasePlayer, HitInfo)`:

/// <summary>
/// Called when a melee attack occurs.
/// </summary>
/// <param name="player">The player who performed the attack.</param>
/// <param name="hitInfo">Information about the hit.</param>
/// <returns>Returns true if the attack is valid, false otherwise.</returns>
bool OnMeleeAttack(BasePlayer player, HitInfo hitInfo)
{
    // Minimal code to demonstrate functionality
    Puts("OnMeleeAttack called!");
    
    // If ReturnType is void, do not include the return statement
    return true; // Or another value depending on the methods functionality
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50L))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo hitInfo = Facepunch.Pool.Get<HitInfo>();
			hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
			hitInfo.Initiator = player;
			hitInfo.Weapon = this;
			hitInfo.WeaponPrefab = this;
			hitInfo.Predicted = msg.connection;
			hitInfo.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, hitInfo) != null)
			{
				return;
			}
			if (hitInfo.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.Log(hitInfo, "melee_nan");
				return;
			}
			if (ConVar.AntiHack.melee_protection > 0 && (bool)hitInfo.HitEntity)
			{
				bool flag = true;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTime + num2 + num3) * num;
				if (ConVar.AntiHack.projectile_protection >= 2)
				{
					float num5 = hitInfo.HitEntity.MaxVelocity() + hitInfo.HitEntity.GetParentVelocity().magnitude;
					float num6 = hitInfo.HitEntity.BoundsPadding() + num4 * num5;
					float num7 = hitInfo.HitEntity.Distance(hitInfo.HitPositionWorld);
					if (num7 > num6)
					{
						string shortPrefabName2 = base.ShortPrefabName;
						string shortPrefabName3 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName2 + " on " + shortPrefabName3 + " with " + num7 + "m > " + num6 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_distance");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					float num8 = hitInfo.Initiator.MaxVelocity() + hitInfo.Initiator.GetParentVelocity().magnitude;
					float num9 = hitInfo.Initiator.BoundsPadding() + num4 * num8 + num * maxDistance;
					float num10 = hitInfo.Initiator.Distance(hitInfo.HitPositionWorld);
					if (num10 > num9)
					{
						string shortPrefabName4 = base.ShortPrefabName;
						string shortPrefabName5 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num10 + "m > " + num9 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_distance");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					Vector3 pointStart = hitInfo.PointStart;
					Vector3 vector = hitInfo.HitPositionWorld + hitInfo.HitNormalWorld.normalized * 0.001f;
					Vector3 center = player.eyes.center;
					Vector3 position = player.eyes.position;
					Vector3 vector2 = pointStart;
					Vector3 vector3 = hitInfo.PositionOnRay(vector);
					Vector3 vector4 = vector;
					bool num11 = GamePhysics.LineOfSight(center, position, vector2, vector3, vector4, 2162688);
					if (!num11)
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
					}
					else
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_direct_los", 1, Stats.Server);
					}
					if (!num11)
					{
						string shortPrefabName6 = base.ShortPrefabName;
						string shortPrefabName7 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat("Line of sight (", shortPrefabName6, " on ", shortPrefabName7, ") ", center, " ", position, " ", vector2, " ", vector3, " ", vector4));
						player.stats.combat.Log(hitInfo, "melee_los");
						flag = false;
					}
				}
				if (!flag)
				{
					AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
					return;
				}
			}
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50L))
			{
				DoAttackShared(hitInfo);
			}
		}
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a melee item is thrown.
/// </summary>
/// <param name="basePlayer">The BasePlayer who threw the item.</param>
/// <param name="item">The Item that was thrown.</param>
void OnMeleeThrown(BasePlayer basePlayer, Item item)
{
    Puts($"BasePlayer {basePlayer.displayName} threw an item.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (player == null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsProjectile)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "item_missing");
				return;
			}
			ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
			if (component == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "mod_missing");
				return;
			}
			ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
			if (projectileShoot.projectiles.Count != 1)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "count_mismatch");
				return;
			}
			player.CleanupExpiredProjectiles();
			foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.Log(this, "duplicate_id");
				}
				else if (ValidateEyePos(player, projectile.startPos))
				{
					player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, item);
					Effect effect = new Effect();
					effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
					effect.scale = 1f;
					effect.pooledString = component.projectileObject.resourcePath;
					effect.number = projectile.seed;
					EffectNetwork.Send(effect);
				}
			}
			item.SetParent(null);
			Interface.CallHook("OnMeleeThrown", player, item);
			if (!canAiHearIt)
			{
				return;
			}
			float num = 0f;
			if (component.projectileObject != null)
			{
				GameObject gameObject = component.projectileObject.Get();
				if (gameObject != null)
				{
					Projectile component2 = gameObject.GetComponent<Projectile>();
					if (component2 != null)
					{
						foreach (DamageTypeEntry damageType in component2.damageTypes)
						{
							num += damageType.amount;
						}
					}
				}
			}
			if (player != null)
			{
				Sensation sensation = default(Sensation);
				sensation.Type = SensationType.ThrownWeapon;
				sensation.Position = player.transform.position;
				sensation.Radius = 50f;
				sensation.DamagePotential = num;
				sensation.InitiatorPlayer = player;
				sensation.Initiator = player;
				Sense.Stimulate(sensation);
			}
		}
	}

```

## OnTerrainInitialized()

```csharp
```csharp
/// <summary>
/// Called after the terrain has been initialized.
/// </summary>
void OnTerrainInitialized()
{
    Puts("Terrain initialization complete.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallDistance">The distance the player fell.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLand(BasePlayer player, float fallDistance)
{
    Puts($"Player {player.UserIDString} has landed after falling {fallDistance} units.");
    if (fallDistance > 50f)
    {
        Puts($"Player {player.displayName} suffered severe injuries from the fall.");
        // Apply additional damage or effects here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (float.IsNaN(num) || float.IsInfinity(num))
		{
			return;
		}
		float num2 = Mathf.InverseLerp(-15f, -100f, num);
		if (num2 != 0f && Interface.CallHook("OnPlayerLand", this, num2) == null)
		{
			metabolism.bleeding.Add(num2 * 0.5f);
			float num3 = num2 * 500f;
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num2);
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that died.</param>
/// <param name="info">Information about the hit that killed the entity, if any.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity.name} has died.");
    if (info != null && info.Attacker != null)
    {
        Puts($"Entity was killed by {info.Attacker.name} with damage: {info.Damage}");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		Interface.CallHook("OnEntityDeath", this, info);
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
		}
		health = 0f;
		lifestate = LifeState.Dead;
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine admin menu is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <param name="player">The player opening the admin menu.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} opened admin menu for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			SendSellOrders(player);
			PlayerOpenLoot(player);
			ClientRPCPlayer(null, player, "CLIENT_OpenAdminMenu");
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can bypass the queue.
/// </summary>
/// <param name="connection">The player's connection.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue, or `false` otherwise.
/// If this method returns `null`, it will be treated as returning `false`.
/// </returns>
bool CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if {connection.UserIDString} can bypass queue...");
    bool result = (bool)Interface.CallHook("CanBypassQueue", connection);
    if (result)
    {
        return true;
    }
    if (DeveloperList.Contains(connection.userid))
    {
        return true;
    }
    ServerUsers.User user = ServerUsers.Get(connection.userid);
    if (user != null && user.group == ServerUsers.UserGroup.Moderator)
    {
        return true;
    }
    if (user != null && user.group == ServerUsers.UserGroup.Owner)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		return false;
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The Bradley APC instance.</param>
/// <returns>
/// Returns `null` to allow the APC to initialize normally, or any non-null value to override the default initialization behavior.
/// </returns>
object OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Bradley APC initialized at position: {apc.transform.position}");
    // If you want to change the destination of the APC, do it here
    apc.destination = new Vector3(10.0f, 5.0f, 2.0f);
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## IOnServerUsersSet(ulong,ServerUsers.UserGroup,string,string)

```csharp
```csharp
/// <summary>
/// Called when a server user's information is set.
/// </summary>
/// <param name="steamId">The Steam ID of the user.</param>
/// <param name="group">The group the user belongs to.</param>
/// <param name="username">The username of the user.</param>
/// <param name="notes">Any additional notes about the user.</param>
/// <returns>No return behavior.</returns>
void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string username, string notes)
{
    Puts($"User {username} with SteamID {steamId} has been set to group {group} with notes: {notes}");
}
```
```

### Source Code from the Library

```csharp

	public static void Set(ulong uid, UserGroup group, string username, string notes)
	{
		Interface.CallHook("IOnServerUsersSet", uid, group, username, notes);
		Remove(uid);
		User value = new User
		{
			steamid = uid,
			group = group,
			username = username,
			notes = notes
		};
		users.Add(uid, value);
	}

```

## CanPickupEntity(BasePlayer,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pickup an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or any non-null value to override the default behavior.
/// If a string is returned, the player will be notified with the provided message as the reason they cannot pick up the entity.
/// If `null` is returned, the player's ability to pick up the entity is determined by the game's default rules.
/// </returns>
object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
{
    Puts($"Player {player.UserIDString} attempting to pick up entity {entity.EntityID}");
    if (entity.IsLocked())
    {
        return "Cannot pick up locked entity.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (pickup.enabled)
		{
			if (pickup.requireBuildingPrivilege)
			{
				if (player.CanBuild())
				{
					if (pickup.requireHammer)
					{
						return player.IsHoldingEntity<Hammer>();
					}
					return true;
				}
				return false;
			}
			return true;
		}
		return false;
	}

```

## OnConsumeFuel(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The item being consumed as fuel.</param>
/// <param name="burnable">The burnable item used to determine the fuel consumption behavior.</param>
/// <returns>No return behavior.</returns>
void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel {fuel.info.name} consumed by oven {oven.info.name}");
    if (burnable.fuelAmount <= 0)
    {
        Puts($"Error: Burnable item has no fuel amount");
        return;
    }
    // Additional logic can be added here to handle the consumption of fuel
}
```
```

### Source Code from the Library

```csharp

	private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		Interface.CallHook("OnConsumeFuel", this, fuel, burnable);
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);
			if (!item.MoveToContainer(inventory))
			{
				OvenFull();
				item.Drop(inventory.dropPosition, inventory.dropVelocity);
			}
		}
		if (fuel.amount <= 1)
		{
			fuel.Remove();
			return;
		}
		fuel.amount--;
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
	}

```

## OnMapImageUpdated()

```csharp
```csharp
/// <summary>
/// Called when a map image is updated.
/// </summary>
void OnMapImageUpdated()
{
    Puts("Map image has been updated.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	public void ImageUpdate(RPCMessage msg)
	{
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}

```

## OnQuarryEnabled(MiningQuarry)

```csharp
```csharp
/// <summary>
/// Called when a quarry is enabled.
/// </summary>
/// <param name="quarry">The mining quarry that has been enabled.</param>
/// <returns>No return behavior.</returns>
void OnQuarryEnabled(MiningQuarry quarry)
{
    Puts($"Quarry {quarry.name} has been enabled.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void SetOn(bool isOn)
	{
		SetFlag(Flags.On, isOn);
		engineSwitchPrefab.instance.SetFlag(Flags.On, isOn);
		SendNetworkUpdate();
		engineSwitchPrefab.instance.SendNetworkUpdate();
		if (isOn)
		{
			InvokeRepeating(ProcessResources, processRate, processRate);
			Interface.CallHook("OnQuarryEnabled", this);
		}
		else
		{
			CancelInvoke(ProcessResources);
		}
	}

```

## OnTurretModeToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the turret mode is toggled.
/// </summary>
/// <param name="turret">The AutoTurret instance whose mode was toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretModeToggle(AutoTurret turret)
{
    Puts($"Turret {turret.GetGlobalName()} mode toggled to {(turret.GetFlag(Flags.Reserved1) ? "Peacekeeper" : "Default")}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetPeacekeepermode(bool isOn)
	{
		if (PeacekeeperMode() != isOn)
		{
			SetFlag(Flags.Reserved1, isOn);
			Effect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnTurretModeToggle", this);
		}
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="message">The text of the chat message.</param>
/// <param name="player">The player who sent the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be displayed, or any non-null value to prevent it from being displayed.
/// </returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Player {player.UserIDString} said: {message}");
    if (message.ToLower() == "bad word")
    {
        Puts($"Player {player.displayName} used a bad word and was muted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 0, msg);
		}
	}

```

## CanAssignBed(BasePlayer,SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called to check if a bed can be assigned to a player.
/// </summary>
/// <param name="player">The player attempting to assign the bed.</param>
/// <param name="sleepingBag">The sleeping bag being assigned.</param>
/// <param name="bedId">The ID of the bed being assigned.</param>
/// <returns>
/// Returns `null` if the bed can be assigned, or any non-null value to prevent assignment.
/// </returns>
object CanAssignBed(BasePlayer player, SleepingBag sleepingBag, ulong bedId)
{
    Puts($"Player {player.UserIDString} is trying to assign bed {bedId} with sleeping bag {sleepingBag.name}");
    if (bedId == 1234567890L)
    {
        Puts($"Bed {bedId} is reserved for VIP players.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void AssignToFriend(RPCMessage msg)
	{
		if (msg.player.CanInteract() && deployerUserID == msg.player.userID)
		{
			ulong num = msg.read.UInt64();
			if (num != 0L && Interface.CallHook("CanAssignBed", msg.player, this, num) == null)
			{
				deployerUserID = num;
				SendNetworkUpdate();
			}
		}
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is upgraded.
/// </summary>
/// <param name="oldItem">The original item being upgraded.</param>
/// <param name="newItem">The upgraded item.</param>
/// <param name="player">The player who performed the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnItemUpgrade(Item oldItem, Item newItem, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has successfully upgraded their {oldItem.info.name} to a {newItem.info.name}.");
    if (newItem.info.category == "rare")
    {
        Puts($"The upgraded item is rare! Player {player.UserIDString} will receive a bonus reward.");
        // Add bonus reward logic here
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (UnityEngine.Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap trigger is snapped to an object.
/// </summary>
/// <param name="trapTrigger">The trap trigger that was snapped.</param>
/// <param name="objectSnapped">The object that the trap trigger was snapped to.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trapTrigger, GameObject objectSnapped)
{
    Puts($"Trap {trapTrigger.name} snapped to object {objectSnapped.name}");
}
```
```

### Source Code from the Library

```csharp

	internal override void OnObjectAdded(GameObject obj)
	{
		Interface.CallHook("OnTrapSnapped", this, obj);
		base.OnObjectAdded(obj);
		_trap.ObjectEntered(obj);
	}

```

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating.
/// </summary>
/// <param name="player">The player starting to spectate.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} started spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to spectate with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnPlayerRespawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player respawning.</param>
/// <returns>
/// Returns a non-null value to override the default respawn behavior. 
/// If a `SpawnPoint` object is returned, the player will respawn at that location and rotation.
/// If `null` is returned, the player will respawn at the default spawn point.
/// </returns>
object OnPlayerRespawn(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.IsAdmin)
    {
        SpawnPoint adminSpawn = new SpawnPoint(player.transform.position + Vector3.forward * 10, Quaternion.identity);
        return adminSpawn;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint();
		object obj = Interface.CallHook("OnPlayerRespawn", this);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
```csharp
/// <summary>
/// Called when a new resource deposit is created.
/// </summary>
/// <param name="resourceDeposit">The newly created resource deposit.</param>
void OnResourceDepositCreated(ResourceDeposit resourceDeposit)
{
    Puts($"New resource deposit created at position {resourceDeposit.origin}.");
    if (resourceDeposit.Contains(ItemManager.FindItemDefinition("hq.metal.ore")))
    {
        Puts($"This resource deposit contains HQ metal ore, which is a rare and valuable resource.");
    }
    else
    {
        Puts($"This resource deposit does not contain any HQ metal ore.");
    }
    Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
}
```
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		UnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)
		};
		if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else if (0 == 0)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
			float num = 0f;
			num = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num2 = 0f;
			num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num3 = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
				{
					num3 += 0.25f;
				}
			}
			else
			{
				num3 += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num3)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity being killed.</param>
/// <returns>No return behavior.</returns>
void OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity.ShortName} has been killed.");
    if (entity is BasePlayer player && player.UserIDString == "admin")
    {
        Puts($"Admin player {player.displayName} was killed.");
        // Additional logic for admin players
    }
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
			return;
		}
		Interface.CallHook("OnEntityKill", this);
		OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
		DoEntityDestroy();
		TerminateOnClient(mode);
		TerminateOnServer();
		EntityDestroy();
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is patrolling.
/// </summary>
/// <param name="apc">The Bradley APC performing the patrol.</param>
/// <returns>
/// Returns `null` to allow the APC to continue patrolling, or any non-null value to override the default patrol behavior.
/// If a string is returned, it will be used as a message to display in the console.
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC {apc.GetId()} is patrolling.");
    if (apc.GetPosition() == Vector3.zero)
    {
        Puts("Bradley APC has reached its final destination.");
        return "Bradley APC has reached its final destination.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		PathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		BasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);
		BasePathNode basePathNode = null;
		bool flag = false;
		List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			basePathNode = nodes[nodes.Count - 1];
		}
		else
		{
			basePathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) > 2f))
		{
			return;
		}
		if (closestToPoint == basePathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.transform.position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
		else
		{
			if (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].transform.position);
				}
			}
			foreach (BasePathNode item in path)
			{
				currentPath.Add(item.transform.position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
	}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can use napalm.
/// </summary>
/// <param name="helicopter">The helicopter in question.</param>
/// <returns>
/// Returns `true` if the helicopter is allowed to use napalm, and `false` otherwise.
/// If no return value is specified, returns whether 30 seconds have passed since the last time napalm was used.
/// </returns>
bool CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter can use napalm...");
    if (helicopter.IsOnFire())
    {
        Puts("Helicopter is on fire, cannot use napalm.");
        return false;
    }
    object obj = Interface.CallHook("CanHelicopterUseNapalm", helicopter);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford an upgrade.
/// </summary>
/// <param name="player">The player attempting the upgrade.</param>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="grade">The grade of the upgrade.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the return value.
/// </returns>
bool CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum grade)
{
    Puts($"Checking if {player.UserIDString} can afford upgrade to {grade} for {buildingBlock.name}");
    object obj = Interface.CallHook("CanAffordUpgrade", player, buildingBlock, grade);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // Default implementation: check if the player has enough resources
    foreach (ItemAmount item in GetGrade(grade).costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
        {
            Puts($"Player {player.UserIDString} does not have enough resources to afford upgrade to {grade} for {buildingBlock.name}");
            return false;
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount item in GetGrade(iGrade).costToBuild)
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## CanResearchItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to research an item.
/// </summary>
/// <param name="player">The player attempting to research the item.</param>
/// <param name="item">The item being researched.</param>
/// <returns>
/// Returns `null` to allow the player to research the item, or any non-null value to prevent them from researching it.
/// </returns>
object CanResearchItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} is attempting to research item {item.info.name}.");
    if (item.info.category == "Forbidden")
    {
        Puts($"Player {player.displayName} does not have permission to research the forbidden item {item.info.name}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## CanStackItem(Item,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if two items can be stacked together.
/// </summary>
/// <param name="item1">The first item.</param>
/// <param name="item2">The second item.</param>
/// <returns>
/// Returns `true` if the items can be stacked, or any non-null value to override the default stacking behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the items cannot be stacked.
/// </returns>
object CanStackItem(Item item1, Item item2)
{
    Puts($"Checking if {item1.info.itemid} and {item2.info.itemid} can be stacked.");
    if (item1 == item2)
    {
        return true;
    }
    if (item1.info.stackable <= 1 || item2.info.stackable <= 1)
    {
        return null;
    }
    if (item1.info.itemid != item2.info.itemid)
    {
        return null;
    }
    if ((item1.hasCondition && item1.condition != item1.maxCondition) ||
        (item2.hasCondition && item2.condition != item2.maxCondition))
    {
        return null;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (info.stackable <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != maxCondition)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.maxCondition)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		return true;
	}

```

## CanDemolish(BasePlayer,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can demolish the current object.
/// </summary>
/// <param name="player">The player attempting to demolish.</param>
/// <param name="objectBeingDemolished">The object being demolished, which could be a building or other structure.</param>
/// <returns>
/// Returns `true` if the player can demolish the object, and `false` otherwise.
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object CanDemolish(BasePlayer player, BuildingBlock objectBeingDemolished)
{
    Puts($"Player {player.UserIDString} is attempting to demolish {objectBeingDemolished.GetType().Name}.");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.HasPrivilege("demolish"))
    {
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsDemolishable())
		{
			return HasDemolishPrivilege(player);
		}
		return false;
	}

```

## OnFindBurnable(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when an oven is searching for a burnable item.
/// </summary>
/// <param name="oven">The oven searching for a burnable item.</param>
/// <returns>
/// Returns the first burnable item found in the inventory, or `null` if no suitable item is found.
/// If the return value is an `Item`, it will be returned as such. Otherwise, it will be returned as an `object`.
/// </returns>
object OnFindBurnable(BaseOven oven)
{
    Puts($"Oven {oven.GetDisplayName()} is searching for a burnable item.");
    Item burnableItem = FindBurnable();
    if (burnableItem != null)
    {
        return burnableItem;
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	private Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (inventory == null)
		{
			return null;
		}
		foreach (Item item in inventory.itemList)
		{
			if ((bool)item.info.GetComponent<ItemModBurnable>() && (fuelType == null || item.info == fuelType))
			{
				return item;
			}
		}
		return null;
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret starts up.
/// </summary>
/// <param name="turret">The AutoTurret instance starting up.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally, or any non-null value to prevent it from starting up.
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"Turret {turret.name} has started up.");
    if (turret.isMalfunctioning)
    {
        Puts($"Turret {turret.name} is malfunctioning and will not start up.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
```csharp
/// <summary>
/// Called when a player's tick is processed.
/// </summary>
/// <param name="player">The player whose tick is being processed.</param>
/// <param name="tick">The player's tick data.</param>
/// <param name="wasPlayerStalled">Whether the player was stalled during this tick.</param>
/// <returns>
/// Returns a non-null value to override the default tick processing behavior. 
/// If `null` is returned, the tick is processed as normal.
/// </returns>
object OnPlayerTick(BasePlayer player, PlayerTick tick, bool wasPlayerStalled)
{
    Puts($"Processing tick for player {player.displayName}.");
    if (wasPlayerStalled)
    {
        Puts($"Player {player.displayName} was stalled during this tick.");
        // Add custom logic here to handle stalled players
    }
    else
    {
        // Add custom logic here to handle non-stalled players
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## IOnPlayerChat(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="arg">The console system argument containing the chat message.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the message is sent as normal.
/// </returns>
object IOnPlayerChat(ConsoleSystem.Arg arg)
{
    Puts($"Player {arg.Player().displayName} has sent a chat message: {arg.GetString(0, "text")}");
    // You can add custom logic here to handle the chat message
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!basePlayer || basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper)
		{
			if (basePlayer.NextChatTime == 0f)
			{
				basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup - 30f;
			}
			if (basePlayer.NextChatTime > UnityEngine.Time.realtimeSinceStartup)
			{
				basePlayer.NextChatTime += 2f;
				float num = basePlayer.NextChatTime - UnityEngine.Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(basePlayer.net.connection, "chat.add", 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					basePlayer.Kick("Chatting too fast");
				}
				return;
			}
		}
		string text = arg.GetString(0, "text").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0)
		{
			return;
		}
		if (text.StartsWith("/") || text.StartsWith("\\"))
		{
			if (Interface.CallHook("IOnPlayerCommand", arg) == null)
			{
			}
			return;
		}
		text = EscapeRichText(text);
		if (Interface.CallHook("IOnPlayerChat", arg) != null)
		{
			return;
		}
		if (serverlog)
		{
			DebugEx.Log($"[CHAT] {basePlayer.ToString()} : {text}", StackTraceLogType.None);
		}
		string text2 = "#5af";
		if (basePlayer.IsAdmin)
		{
			text2 = "#af5";
		}
		if (basePlayer.IsDeveloper)
		{
			text2 = "#fa5";
		}
		string text3 = EscapeRichText(basePlayer.displayName);
		basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup + 1.5f;
		ChatEntry chatEntry = default(ChatEntry);
		chatEntry.Message = text;
		chatEntry.UserId = basePlayer.userID;
		chatEntry.Username = basePlayer.displayName;
		chatEntry.Color = text2;
		chatEntry.Time = Epoch.Current;
		ChatEntry chatEntry2 = chatEntry;
		History.Add(chatEntry2);
		RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		if (Server.globalchat)
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add2", basePlayer.userID, text, text3, text2, 1f);
			arg.ReplyWith("");
			return;
		}
		float num2 = 2500f;
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			float sqrMagnitude = (activePlayer.transform.position - basePlayer.transform.position).sqrMagnitude;
			if (!(sqrMagnitude > num2))
			{
				ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", basePlayer.userID, text, text3, text2, Mathf.Clamp01(num2 - sqrMagnitude + 0.2f));
			}
		}
		arg.ReplyWith("");
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a code is entered into the lock.
/// </summary>
/// <param name="lock">The CodeLock instance.</param>
/// <param name="player">The player who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>
/// Returns `null` to allow the code to be accepted, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnCodeEntered(CodeLock lock, BasePlayer player, string code)
{
    Puts($"Player {player.UserID} entered code '{code}' into lock {lock}");
    if (code == "1234")
    {
        return "Access granted!";
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 10f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
			}
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
		}
	}

```

## CanUseHelicopter(BasePlayer,CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the helicopter.
/// </summary>
/// <param name="player">The player attempting to use the helicopter.</param>
/// <param name="helicopterController">The AI controller for the helicopter.</param>
/// <returns>
/// Returns `null` to allow the player to use the helicopter, or any non-null value to prevent them from using it.
/// </returns>
object CanUseHelicopter(BasePlayer player, CH47HelicopterAIController helicopterController)
{
    Puts($"Player {player.UserIDString} is attempting to use the helicopter.");
    if (helicopterController.IsUnderMaintenance())
    {
        Puts($"The helicopter is currently under maintenance and cannot be used by {player.displayName}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void AttemptMount(BasePlayer player)
	{
		if (Interface.CallHook("CanUseHelicopter", player, this) == null)
		{
			base.AttemptMount(player);
		}
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC wants to eat a given entity.
/// </summary>
/// <param name="npc">The NPC in question.</param>
/// <param name="entity">The entity the NPC is considering eating.</param>
/// <returns>
/// Returns `true` if the NPC wants to eat the entity, and `false` otherwise.
/// If a non-null value other than `bool` is returned, it will be used as the return value instead of the default behavior.
/// </returns>
object CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc.name} wants to eat {entity.name}");
    if (entity.HasTrait(TraitFlag.Poisoned))
    {
        Puts($"Entity {entity.name} is poisoned and cannot be eaten.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player attacks another entity.
/// </summary>
/// <param name="player">The player performing the attack.</param>
/// <param name="info">Information about the attack, including the hit entity and damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default attack behavior to occur. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnPlayerAttack(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} attacked entity {info.HitEntity?.ToString()} with damage {info.Damage}.");
    if (info.HitEntity is BaseCombatEntity combatEntity && combatEntity.IsCritical)
    {
        Puts($"Critical hit on entity {combatEntity.ToString()}!");
        return "Critical Hit";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", GetOwnerPlayer(), info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50L))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (info.DoHitEffects)
		{
			if (base.isServer)
			{
				using (TimeWarning.New("ImpactEffect", 20L))
				{
					Effect.server.ImpactEffect(info);
				}
			}
			else
			{
				using (TimeWarning.New("ImpactEffect", 20L))
				{
					Effect.client.ImpactEffect(info);
				}
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50L))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay);
		}
	}

```

## OnHelicopterKilled(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter is killed.
/// </summary>
/// <param name="helicopter">The helicopter that was killed.</param>
/// <returns>
/// Returns `null` to allow the helicopter's death to be handled normally, or any non-null value to override the default behavior.
/// </returns>
object OnHelicopterKilled(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetDisplayName()} has been killed.");
    if (helicopter.GetDisplayName() == "Enemy Helicopter")
    {
        Puts($"Enemy helicopter {helicopter.GetDisplayName()} has been destroyed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterKilled", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player disconnects from the server.
/// </summary>
/// <param name="player">The disconnected player.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} disconnected with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void OnDisconnected(string strReason, Connection connection)
	{
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		Rust.Global.SteamServer.Auth.EndSession(connection.userid);
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((bool)basePlayer)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is being accepted into the container.
/// </summary>
/// <param name="item">The item being accepted.</param>
/// <param name="targetPos">The position in the container where the item will be placed.</param>
/// <returns>
/// Returns a non-null value to override the default acceptance behavior. 
/// If `CanAcceptResult.CannotAccept` is returned, the item cannot be accepted into the container.
/// If `CanAcceptResult.CannotAcceptRightNow` is returned, the item can be accepted into the container, but there are not enough available slots to accommodate it.
/// </returns>
object CanAcceptItem(ItemContainer container, Item item, int targetPos)
{
    Puts($"Item {item.info.name} is being accepted into container {container.info.name} at position {targetPos}.");
    if (item.info.itemType == ItemType.Key && !container.info.hasLock)
    {
        Puts($"Item {item.info.name} cannot be accepted into container {container.info.name} because it does not have a lock.");
        return CanAcceptResult.CannotAccept;
    }
    object obj = Interface.CallHook("CanAcceptItem", container, item, targetPos);
    if (obj is CanAcceptResult)
    {
        return obj;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (onlyAllowedItem != null && onlyAllowedItem != item.info)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			int[] array = new int[32];
			foreach (ItemSlot availableSlot in availableSlots)
			{
				array[(int)Mathf.Log((float)availableSlot, 2f)]++;
			}
			foreach (Item item2 in itemList)
			{
				for (int i = 0; i < 32; i++)
				{
					if (((uint)item2.info.occupySlots & (uint)(1 << i)) != 0)
					{
						array[i]--;
					}
				}
			}
			for (int j = 0; j < 32; j++)
			{
				if (((uint)item.info.occupySlots & (uint)(1 << j)) != 0 && array[j] <= 0)
				{
					return CanAcceptResult.CannotAcceptRightNow;
				}
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		return CanAcceptResult.CanAccept;
	}

```

## OnEntityDismounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is dismounted.
/// </summary>
/// <param name="entity">The entity that was dismounted.</param>
/// <param name="player">The player who dismounted the entity.</param>
object OnEntityDismounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Entity {entity.name} has been dismounted by player {player.displayName}");
    // You can add custom logic here to handle the dismounting of the entity
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		if (lite)
		{
			_mounted.DismountObject();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			return;
		}
		Vector3 dismountPosition = GetDismountPosition(player);
		if (dismountPosition == DISMOUNT_POS_INVALID)
		{
			dismountPosition = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(dismountPosition);
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", dismountPosition);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			SetFlag(Flags.Busy, b: false);
		}
		else
		{
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(dismountPosition);
			_mounted.SendNetworkUpdateImmediate();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPCPlayer(null, player, "ForcePositionToParentOffset", baseEntity.transform.InverseTransformPoint(dismountPosition), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPCPlayer(null, player, "ForcePositionTo", dismountPosition);
				Interface.CallHook("OnEntityDismounted", this, player);
			}
		}
	}

```

## CanLootEntity(BasePlayer,ResourceContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.EntityID}");
    if (entity.IsLocked)
    {
        Puts($"Entity {entity.EntityID} is locked and cannot be looted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.IsVisible(3f)]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The container from which the items were dropped.</param>
/// <returns>
/// Returns `true` to override the default drop behavior, or `false` to allow the items to be dropped normally.
/// If `null` is returned, the default drop behavior will be used.
/// </returns>
bool OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping items from container {container}.");
    if (container.itemList.Count > 10)
    {
        Puts($"Not dropping items from container {container}, as it contains too many items.");
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position, float chance = 1f)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			if (!(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				float num2 = UnityEngine.Random.Range(0f, 2f);
				item.RemoveFromContainer();
				BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
				if (baseEntity == null)
				{
					item.Remove();
				}
				else if (num2 > 0f)
				{
					baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
					baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
				}
			}
		}
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to repair a structure.
/// </summary>
/// <param name="structure">The structure being repaired.</param>
/// <param name="player">The player attempting the repair.</param>
/// <returns>
/// Returns `null` to allow the repair to proceed, or any non-null value to prevent the repair from happening.
/// If a string is returned, the player will be notified with the provided message as the reason for not being able to repair.
/// </returns>
object OnStructureRepair(BaseCombatEntity structure, BasePlayer player)
{
    Puts($"Player {player.Name} has attempted to repair structure {structure.EntityId}.");
    if (player.Name == "Admin")
    {
        Puts($"Player {player.Name} has been blocked from repairing structures due to being an admin.");
        return "Blocked: Admins are not allowed to repair.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		if (SecondsSinceAttacked <= 30f)
		{
			OnRepairFailed();
			return;
		}
		float num = MaxHealth() - health;
		float num2 = num / MaxHealth();
		if (num <= 0f || num2 <= 0f)
		{
			OnRepairFailed();
			return;
		}
		List<ItemAmount> list = RepairCost(num2);
		if (list == null)
		{
			return;
		}
		float num3 = list.Sum((ItemAmount x) => x.amount);
		if (num3 > 0f)
		{
			float a = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			a = Mathf.Min(a, 50f / num);
			if (a <= 0f)
			{
				OnRepairFailed();
				return;
			}
			int num4 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(a * item.amount);
				int num5 = player2.inventory.Take(null, item.itemid, amount);
				if (num5 > 0)
				{
					num4 += num5;
					player2.Command("note.inv", item.itemid, num5 * -1);
				}
			}
			float num6 = (float)num4 / num3;
			health += num * num6;
			SendNetworkUpdate();
		}
		else
		{
			health += num;
			SendNetworkUpdate();
		}
		if (health >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallDistance">The distance the player fell.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanded(BasePlayer player, float fallDistance)
{
    Puts($"Player {player.UserIDString} has landed after falling {fallDistance} units.");
    if (fallDistance > 50f)
    {
        Puts($"Player {player.displayName} suffered severe injuries from the fall.");
        // Apply additional damage or effects here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (float.IsNaN(num) || float.IsInfinity(num))
		{
			return;
		}
		float num2 = Mathf.InverseLerp(-15f, -100f, num);
		if (num2 != 0f && Interface.CallHook("OnPlayerLand", this, num2) == null)
		{
			metabolism.bleeding.Add(num2 * 0.5f);
			float num3 = num2 * 500f;
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num2);
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if the helicopter can strafe.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
bool CanHelicopterStrafe(PatrolHelicopterAI ai)
{
    Puts("Helicopter attempting to strafe.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= 20f)
		{
			return CanInterruptState();
		}
		return false;
	}

```

## OnHelicopterAttacked(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter is attacked.
/// </summary>
/// <param name="helicopter">The helicopter being attacked.</param>
/// <returns>
/// Returns `null` to allow the helicopter to be damaged normally, or any non-null value to prevent it from taking damage.
/// </returns>
object OnHelicopterAttacked(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetDisplayName()} is being attacked.");
    if (helicopter.GetHealthFraction() <= 0.5f)
    {
        Puts($"Helicopter {helicopter.GetDisplayName()} has been severely damaged and will self-destruct.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttacked", this) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved7, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the network should be allowed to connect to a BasePlayer.
/// </summary>
/// <param name="player">The player to check.</param>
/// <returns>
/// Returns `true` to allow the network to connect, or `false` to deny it.
/// If any other value is returned (e.g. a string), it will be treated as an error message and used to kick the player.
/// </returns>
object CanNetworkTo(BasePlayer player)
{
    Puts($"Checking if network can connect to {player.UserIDString}...");
    if (player.IsBanned)
    {
        Puts($"Network denied: Player is banned.");
        return "You are banned from this server.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the player's active item should be dropped.
/// </summary>
/// <param name="player">The player whose active item is being considered for drop.</param>
/// <returns>
/// Returns `true` to allow the player's active item to be dropped, or `false` to prevent it from being dropped.
/// If a non-bool value is returned, the default behavior will be used (i.e., the item will be dropped).
/// </returns>
bool CanDropActiveItem(BasePlayer player)
{
    Puts($"Checking if {player.UserIDString}'s active item should be dropped.");
    // For example, let's say we want to prevent players from dropping their active items in a specific area
    if (player.transform.position.x < -1000 && player.transform.position.z < -1000)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## IOnServerInitialized()

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
void IOnServerInitialized()
{
    Puts("Server initialization complete.");
    // Add any additional logic or setup required after server initialization here.
}
```
```

### Source Code from the Library

```csharp

	public void OpenConnection()
	{
		useQueryPort = ConVar.Server.queryport > 0 && ConVar.Server.queryport != ConVar.Server.port;
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			return;
		}
		StartSteamServer();
		Network.Net.sv.callbackHandler = this;
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		EACServer.DoStartup();
		InvokeRepeating("EACUpdate", 1f, 1f);
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		Interface.CallHook("IOnServerInitialized");
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an entity is built.
/// </summary>
/// <param name="planner">The planner that built the entity.</param>
/// <param name="gameObject">The GameObject of the built entity.</param>
void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
{
    Puts($"Entity {gameObject.name} has been built by {planner.name}.");
    // Add custom logic here if needed
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())
		{
			return;
		}
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ChatMessage("Target socket is not female. (" + target.socket.socketName + ")");
				return;
			}
			if (target.entity != null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ChatMessage("Target socket is occupied. (" + target.socket.socketName + ")");
				return;
			}
		}
		else if (ConVar.AntiHack.eye_protection >= 2)
		{
			Vector3 center = ownerPlayer.eyes.center;
			Vector3 position = ownerPlayer.eyes.position;
			Vector3 origin = target.ray.origin;
			Vector3 position2 = target.position;
			if (!GamePhysics.LineOfSight(center, position, origin, position2, 2162688, 0.01f))
			{
				ownerPlayer.ChatMessage("Line of sight blocked.");
				return;
			}
		}
		Construction.lastPlacementError = "No Error";
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			ownerPlayer.ChatMessage("Can't place: " + Construction.lastPlacementError);
		}
		if (!(gameObject != null))
		{
			return;
		}
		Interface.CallHook("OnEntityBuilt", this, gameObject);
		Deployable deployable = GetDeployable();
		if (deployable != null)
		{
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
			if (deployable.setSocketParent && target.entity != null && target.entity.SupportsChildDeployables() && (bool)baseEntity)
			{
				baseEntity.SetParent(target.entity, worldPositionStays: true);
			}
			if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
			{
				(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
			}
			if (deployable.copyInventoryFromItem)
			{
				StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
				if ((bool)component2)
				{
					component2.ReceiveInventoryFromItem(GetOwnerItem());
				}
			}
			ItemModDeployable modDeployable = GetModDeployable();
			if (modDeployable != null)
			{
				modDeployable.OnDeployed(baseEntity, ownerPlayer);
			}
		}
		PayForPlacement(ownerPlayer, component);
	}

```

## CanHackCrate(BasePlayer,HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called to determine if a crate can be hacked.
/// </summary>
/// <param name="player">The player attempting to hack the crate.</param>
/// <param name="crate">The crate being attempted to be hacked.</param>
/// <returns>
/// Returns `null` to allow the crate to be hacked, or any non-null value to prevent it from being hacked.
/// </returns>
object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
{
    Puts($"Player {player.UserIDString} is attempting to hack crate {crate.CrateID}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} has admin privileges and can hack the crate.");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} does not have admin privileges and cannot hack the crate.");
        return "Access denied: Not an administrator.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", msg.player, this) == null)
		{
			StartHacking();
		}
	}

```

## CanChangeCode(BasePlayer,CodeLock,string,bool)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to change the code on a CodeLock.
/// </summary>
/// <param name="player">The player attempting to change the code.</param>
/// <param name="codeLock">The CodeLock being modified.</param>
/// <param name="newCode">The new code being set.</param>
/// <param name="isGuest">Whether the code is for a guest or not.</param>
/// <returns>
/// Returns `null` to allow the code change, or any non-null value to prevent it.
/// If a string is returned, the player will be notified with the provided message as the reason.
/// </returns>
object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuest)
{
    Puts($"Player {player.UserIDString} attempted to change the code on {codeLock.name} to '{newCode}' as a guest: {isGuest}");
    if (newCode.Length != 4)
    {
        Puts($"Invalid code length. Code must be exactly 4 characters long.");
        return "Error: Invalid code length.";
    }
    // Additional validation or logic can go here
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (IsLocked() || text.Length != 4 || (!hasCode && flag))
		{
			return;
		}
		if (!hasCode && !flag)
		{
			SetFlag(Flags.Locked, b: true);
		}
		if (Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is crafted.
/// </summary>
/// <param name="itemCraftTask">The task associated with the crafting process.</param>
/// <param name="owner">The player who initiated the crafting process.</param>
/// <param name="fromTempBlueprint">The blueprint used for crafting, if any.</param>
/// <returns>
/// Returns a non-null value to override the default crafting behavior. 
/// If `true` is returned, the crafting process will be allowed as normal.
/// If `false` is returned, the crafting process will be cancelled.
/// </returns>
object OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)
{
    Puts($"Player {owner.displayName} has initiated an item craft task.");
    if (itemCraftTask.blueprint.targetItem.itemid == 12345)
    {
        Puts($"Player {owner.displayName} is attempting to craft a restricted item.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null)
	{
		if (!CanCraft(bp, amount))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		CollectIngredients(bp, itemCraftTask, amount, owner);
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.owner = owner;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			return (bool)obj;
		}
		queue.Enqueue(itemCraftTask);
		if (itemCraftTask.owner != null)
		{
			itemCraftTask.owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## OnExplosiveThrown(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an explosive is thrown.
/// </summary>
/// <param name="player">The player who threw the explosive.</param>
/// <param name="explosive">The explosive entity that was thrown.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the explosive was thrown successfully.
/// </returns>
object OnExplosiveThrown(BasePlayer player, BaseEntity explosive)
{
    Puts($"Player {player.displayName} threw an explosive.");
    if (explosive.name == "Grenade")
    {
        Puts($"Player {player.displayName} threw a grenade.");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} threw an unknown explosive.");
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoThrow(RPCMessage msg)
	{
		if (!HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		Vector3 vector = msg.read.Vector3();
		Vector3 normalized = msg.read.Vector3().normalized;
		float num = Mathf.Clamp01(msg.read.Float());
		if (msg.player.isMounted || msg.player.HasParent())
		{
			vector = msg.player.eyes.position;
		}
		else if (!ValidateEyePos(msg.player, vector))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation((overrideAngle == Vector3.zero) ? (-normalized) : overrideAngle));
		if (baseEntity == null)
		{
			return;
		}
		baseEntity.creatorEntity = msg.player;
		baseEntity.SetVelocity(msg.player.GetInheritedThrowVelocity() + normalized * maxThrowVelocity * num + msg.player.estimatedVelocity * 0.5f);
		if (tumbleVelocity > 0f)
		{
			baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * tumbleVelocity);
		}
		baseEntity.Spawn();
		StartAttackCooldown(repeatDelay);
		Interface.CallHook("OnExplosiveThrown", msg.player, baseEntity);
		UseItemAmount(1);
		BasePlayer player = msg.player;
		if (!(player != null))
		{
			return;
		}
		TimedExplosive timedExplosive = baseEntity as TimedExplosive;
		if (timedExplosive != null)
		{
			float num2 = 0f;
			foreach (DamageTypeEntry damageType in timedExplosive.damageTypes)
			{
				num2 += damageType.amount;
			}
			Sensation sensation = default(Sensation);
			sensation.Type = SensationType.ThrownWeapon;
			sensation.Position = player.transform.position;
			sensation.Radius = 50f;
			sensation.DamagePotential = num2;
			sensation.InitiatorPlayer = player;
			sensation.Initiator = player;
			sensation.UsedEntity = timedExplosive;
			Sense.Stimulate(sensation);
		}
		else
		{
			Sensation sensation = default(Sensation);
			sensation.Type = SensationType.ThrownWeapon;
			sensation.Position = player.transform.position;
			sensation.Radius = 50f;
			sensation.DamagePotential = 0f;
			sensation.InitiatorPlayer = player;
			sensation.Initiator = player;
			sensation.UsedEntity = this;
			Sense.Stimulate(sensation);
		}
	}

```

## OnEntityMarkHostile(BaseCombatEntity,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile.
/// </summary>
/// <param name="entity">The entity being marked as hostile.</param>
/// <param name="duration">The duration for which the entity should be considered hostile, in seconds. Defaults to 60 seconds.</param>
/// <returns>
/// Returns `null` to allow the entity to be marked as hostile, or any non-null value to prevent it from being marked.
/// </returns>
object OnEntityMarkHostile(BaseCombatEntity entity, float duration)
{
    Puts($"Entity {entity.UserIDString} has been marked as hostile for {duration} seconds.");
    if (entity is Player player && player.IsAdmin)
    {
        Puts($"Player {player.displayName} has been exempted from being marked as hostile.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			float b = UnityEngine.Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, b);
		}
	}

```

## OnCreateWorldProjectile(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="hitInfo">The hit info of the projectile.</param>
/// <param name="itemDefinition">The item definition of the projectile.</param>
/// <returns>
/// Returns `null` to allow the default creation behavior. 
/// If a non-null value is returned, it will override the default creation behavior.
/// </returns>
object OnCreateWorldProjectile(HitInfo hitInfo, ItemDefinition itemDefinition)
{
    Puts($"A world projectile has been created at position {hitInfo.HitPositionWorld} with velocity {hitInfo.ProjectileVelocity}.");
    if (hitInfo.DidHit && hitInfo.HitEntity != null && hitInfo.HitBone != 0)
    {
        Puts($"The projectile stuck to entity {hitInfo.HitEntity.name} on bone {hitInfo.HitBone}.");
        return "Projectile stuck to entity.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			return;
		}
		baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		component.AddForce(projectileVelocity.normalized * 200f);
		component.WakeUp();
	}

```

## CanUseVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the vending machine.
/// </summary>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the vending machine, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} attempted to use vending machine {vendingMachine.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.HasEnoughMoney(vendingMachine.price))
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName = "")
	{
		object obj = Interface.CallHook("CanUseVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="block">The building block being modified.</param>
/// <param name="grade">The new grade to be applied.</param>
/// <returns>
/// Returns `true` if the player can change the grade, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and determine whether the player can change the grade.
/// </returns>
bool CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
{
    Puts($"Player {player.UserIDString} attempted to change the grade of building block {block.BlockName} to {grade}.");
    object obj = Interface.CallHook("CanChangeGrade", player, block, grade);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If no hook returns a value, check if the player has upgrade privilege and if upgrades are not blocked
    return HasUpgradePrivilege(grade, player) && !IsUpgradeBlocked();
}
```
```

### Source Code from the Library

```csharp

	private bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasUpgradePrivilege(iGrade, player))
		{
			return !IsUpgradeBlocked();
		}
		return false;
	}

```

## IOnNpcPlayerSenseVision(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses a player in its vision range.
/// </summary>
/// <param name="npc">The NPC sensing the player.</param>
/// <returns>
/// Returns `null` to allow the NPC to sense the player, or any non-null value to prevent the NPC from sensing the player.
/// </returns>
object IOnNpcPlayerSenseVision(NPCPlayerApex npc)
{
    Puts($"NPC {npc.GetBaseEntity().GetDisplayName()} senses a player in its vision range.");
    if (npc.GetBaseEntity().GetDisplayName() == "Hostile NPC")
    {
        Puts($"NPC {npc.GetBaseEntity().GetDisplayName()} is hostile and will attack any player in its vision range.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void _FindPlayersInVisionRange()
	{
		if (AI.ignoreplayers || base.transform == null || Interface.CallHook("IOnNpcPlayerSenseVision", this) != null)
		{
			return;
		}
		PlayerQueryResultCount = Query.Server.GetPlayersInSphere(base.transform.position, Stats.VisionRange, PlayerQueryResults, delegate(BasePlayer player)
		{
			if (player == null || !player.isServer || player.IsDead())
			{
				return false;
			}
			if (player.IsSleeping() && player.secondsSleeping < NPCAutoTurret.sleeperhostiledelay)
			{
				return false;
			}
			float num = Stats.VisionRange * Stats.VisionRange;
			return !((player.ServerPosition - ServerPosition).sqrMagnitude > num);
		});
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a player buys an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine the item was purchased from.</param>
/// <param name="player">The player who made the purchase.</param>
/// <param name="itemIndex">The index of the item purchased.</param>
/// <param name="quantity">The quantity of the item purchased.</param>
/// <returns>
/// Returns `null` to allow the purchase to complete normally, or any non-null value to cancel the purchase.
/// </returns>
object OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer player, int itemIndex, int quantity)
{
    Puts($"Player {player.UserIDString} bought {quantity} x {itemIndex} from vending machine {vendingMachine.name}");
    if (itemIndex == 5 && quantity > 10)
    {
        Puts($"Player {player.displayName} attempted to buy more than 10 of item {itemIndex}, purchase cancelled.");
        return "Purchase cancelled: Exceeded maximum quantity.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void BuyItem(RPCMessage rpc)
	{
		if (OccupiedCheck(rpc.player))
		{
			int num = rpc.read.Int32();
			int num2 = rpc.read.Int32();
			if (Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2) == null)
			{
				SetPendingOrder(rpc.player, num, num2);
				Invoke(CompletePendingOrder, GetBuyDuration());
			}
		}
	}

```

## IOnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets another entity.
/// </summary>
/// <param name="npc">The NPC that targeted the entity.</param>
/// <param name="target">The entity that was targeted by the NPC.</param>
/// <returns>
/// Returns a float value indicating how much the NPC wants to attack the target, on a scale of 0 to 1.
/// If `null` is returned, the default behavior will be used.
/// </returns>
float IOnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} targeted entity {target.UserIDString}");
    if (target is Player player && player.IsSpectating)
    {
        Puts($"NPC {npc.name} does not want to attack spectating player {player.UserIDString}");
        return 0;
    }
    return WantsToAttack(target);
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to check if a target can be targeted by the turret.
/// </summary>
/// <param name="target">The target entity.</param>
/// <param name="turret">The auto turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BaseCombatEntity target, AutoTurret turret)
{
    Puts($"Checking if {target} can be targeted by {turret}.");
    if (target == null || !target.IsValid())
    {
        return false;
    }
    // Additional checks can go here...
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.GetList<RaycastHit>();
		Vector3 position = eyePos.transform.position;
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);
		for (int i = 0; (float)i < (CheckPeekers() ? 3f : 1f); i++)
		{
			Vector3 normalized = (vector + vector2 * visibilityOffsets[i] - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);
			for (int j = 0; j < obj3.Count; j++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);
				if ((!(entity != null) || !entity.isClient) && (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) && (!(entity != null) || !entity.EqualNetID(this)))
				{
					if (entity != null && (entity == obj || entity.EqualNetID(obj)))
					{
						Facepunch.Pool.FreeList(ref obj3);
						return true;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj3);
		return false;
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned.
/// </summary>
/// <param name="entity">The entity that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity {entity.EntityID} has been spawned.");
    if (entity is BasePlayer player && player.UserIDString == "admin")
    {
        Puts($"Admin player {player.displayName} has been spawned.");
        // Perform any admin-specific actions here
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player picks up an item.
/// </summary>
/// <param name="item">The item being picked up.</param>
/// <param name="player">The player picking up the item.</param>
/// <returns>
/// Returns `null` to allow the player to pick up the item, or any non-null value to prevent them from picking it up.
/// </returns>
object OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} picked up item: {item.displayName}");
    if (item.name == "rare_item")
    {
        Puts($"Player {player.displayName} is not allowed to pick up the rare item.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && item != null && allowPickup && Interface.CallHook("OnItemPickup", item, msg.player) == null)
		{
			ClientRPC(null, "PickupSound");
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can target a player.
/// </summary>
/// <param name="helicopter">The helicopter attempting to target the player.</param>
/// <param name="player">The player being targeted.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player, and `false` otherwise.
/// If this method is not implemented or returns a non-boolean value, the default behavior will be used.
/// </returns>
bool CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Helicopter {helicopter.GetReference()} attempting to target player {player.UserIDString}.");
    if (player.IsDead || player.IsInvisible)
    {
        return false;
    }
    // Additional logic can be added here to determine if the helicopter can target the player
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## OnPlayerConnected(Network.Message)

```csharp
```csharp
/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="packet">The message packet containing information about the connected player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(Network.Message packet)
{
    Puts($"Player {packet.connection.info.Get("username")} has connected to the server.");
    if (packet.connection.info.Get("isModerator") == "true")
    {
        Puts($"Player {packet.connection.info.Get("username")} is a moderator.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void ClientReady(Message packet)
	{
		packet.connection.decryptIncoming = true;
		using ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read);
		foreach (ClientReady.ClientInfo item in clientReady.clientInfo)
		{
			packet.connection.info.Set(item.name, item.value);
		}
		connectionQueue.JoinedGame(packet.connection);
		Interface.CallHook("OnPlayerConnected", packet);
		using (TimeWarning.New("ClientReady"))
		{
			using (TimeWarning.New("SpawnPlayerSleeping"))
			{
				if (SpawnPlayerSleeping(packet.connection))
				{
					return;
				}
			}
			using (TimeWarning.New("SpawnNewPlayer"))
			{
				SpawnNewPlayer(packet.connection);
			}
		}
	}

```

## OnRotateVendingMachine(VendingMachine,unknown)

```csharp
```csharp
/// <summary>
/// Called when a vending machine is rotated.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="unknownParam">An unknown parameter, likely used for future extensions or debugging purposes.</param>
/// <returns>
/// Returns `null` to allow the vending machine to be rotated, or any non-null value to prevent rotation.
/// </returns>
object OnRotateVendingMachine(VendingMachine vendingMachine, object unknownParam)
{
    Puts($"Vending Machine {vendingMachine.name} has been rotated.");
    if (unknownParam is string && (string)unknownParam == "debug")
    {
        Puts("Debug mode enabled. Vending machine rotation will be prevented.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RotateVM(RPCMessage msg)
	{
		if (Interface.CallHook("OnRotateVendingMachine", this, null) == null && msg.player.CanBuild() && IsInventoryEmpty())
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The storage container being used for looting.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.UserIDString} has finished looting the entity.");
    if (container.GetItemCount() == 0)
    {
        Puts($"The storage container is now empty.");
        // Optional: Remove or reset the container
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a hammer hits an entity.
/// </summary>
/// <param name="owner">The player who wielded the hammer.</param>
/// <param name="info">Information about the hit, including the entity and damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default behavior of repairing the entity. 
/// If a non-null value is returned, it will override the repair behavior.
/// </returns>
object OnHammerHit(BasePlayer owner, HitInfo info)
{
    Puts($"Player {owner.UserIDString} hit an entity with their hammer.");
    if (info.HitEntity is BaseBuilding)
    {
        Puts($"The entity hit was a building.");
        return "Cannot repair buildings.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			if (ownerPlayer != null && base.isServer)
			{
				using (TimeWarning.New("DoRepair", 50L))
				{
					baseCombatEntity.DoRepair(ownerPlayer);
				}
			}
		}
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing its ground.
/// </summary>
/// <param name="entity">The BaseEntity that is missing its ground.</param>
/// <returns>
/// Returns `null` to allow the entity to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has lost contact with the ground.");
    if (entity is BaseCombatEntity combatEntity && combatEntity.IsPlayerControlled)
    {
        Puts($"Player-controlled entity {entity.UserIDString} has been destroyed due to losing ground contact.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (baseEntity != null && Interface.CallHook("OnEntityGroundMissing", baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldHealth">The player's old health value.</param>
/// <param name="newHealth">The player's new health value.</param>
/// <returns>No return behavior.</returns>
void OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Player {player.UserIDString} health changed from {oldHealth} to {newHealth}");
}
```
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) == null)
		{
			base.OnHealthChanged(oldvalue, newvalue);
			metabolism.isDirty = true;
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client authenticates with the server.
/// </summary>
/// <param name="connection">The client connection.</param>
/// <returns>
/// Returns `null` to allow the client to authenticate normally, or any non-null value to override the default authentication behavior. 
/// If a string is returned, the client will be kicked with the provided message as the reason.
/// </returns>
object OnClientAuth(Network.Connection connection)
{
    Puts($"Client {connection} has authenticated with the server.");
    if (connection.userid == 1234567890)
    {
        Puts($"Client {connection} has been blocked from authenticating.");
        return "Blocked: Unauthorized client.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Connection.State.Connecting;
		if (packet.read.UInt8() != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String();
		packet.connection.username = packet.read.String();
		Interface.CallHook("OnClientAuth", packet.connection);
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.unread >= 4)
		{
			text = packet.read.String();
		}
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their branch is '", text, "' not '", branch, "'"), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2151)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2151), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2151)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2151), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize();
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
			}
			else
			{
				auth.OnNewConnection(packet.connection);
			}
		}
	}

```

## OnNpcDestinationSet(NPCPlayerApex,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an NPC's destination is set.
/// </summary>
/// <param name="npc">The NPC whose destination is being set.</param>
/// <param name="newDestination">The new destination for the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC's destination to be set, or any non-null value to prevent it from being set.
/// </returns>
object OnNpcDestinationSet(NPCPlayerApex npc, Vector3 newDestination)
{
    Puts($"NPC {npc.name} is being moved to destination: {newDestination}");
    if (newDestination == Vector3.zero)
    {
        Puts($"NPC {npc.name} cannot be moved to the origin.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void SetDestination(Vector3 newDestination)
	{
		if (Interface.CallHook("OnNpcDestinationSet", this, newDestination) == null)
		{
			base.SetDestination(newDestination);
			Destination = newDestination;
		}
	}

```

## OnExplosiveDropped(BasePlayer,UnityEngine.RaycastHit)

```csharp
```csharp
/// <summary>
/// Called when an explosive is dropped.
/// </summary>
/// <param name="player">The player who dropped the explosive.</param>
/// <param name="hitInfo">Information about the hit point where the explosive was dropped.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the explosive is dropped as normal.
/// </returns>
object OnExplosiveDropped(BasePlayer player, RaycastHit hitInfo)
{
    Puts($"Player {player.displayName} has dropped an explosive at position {hitInfo.point}.");
    if (hitInfo.entity != null && hitInfo.entity is StabilityEntity)
    {
        return "Stability entity detected. Explosive will only damage parent.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDrop(RPCMessage msg)
	{
		if (!HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		Vector3 vector = msg.read.Vector3();
		Vector3 normalized = msg.read.Vector3().normalized;
		if (msg.player.isMounted || msg.player.HasParent())
		{
			vector = msg.player.eyes.position;
		}
		else if (!ValidateEyePos(msg.player, vector))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation(Vector3.up));
		if (baseEntity == null)
		{
			return;
		}
		if (UnityEngine.Physics.SphereCast(new Ray(vector, normalized), 0.05f, out var hitInfo, 1.5f, 1236478737))
		{
			Vector3 point = hitInfo.point;
			Vector3 normal = hitInfo.normal;
			BaseEntity entity = RaycastHitEx.GetEntity(hitInfo);
			if ((bool)entity && entity is StabilityEntity && baseEntity is TimedExplosive)
			{
				entity = entity.ToServer<BaseEntity>();
				TimedExplosive obj = baseEntity as TimedExplosive;
				obj.onlyDamageParent = true;
				obj.DoStick(point, normal, entity);
			}
			else
			{
				baseEntity.SetVelocity(normalized);
			}
		}
		else
		{
			baseEntity.SetVelocity(normalized);
		}
		baseEntity.creatorEntity = msg.player;
		baseEntity.Spawn();
		StartAttackCooldown(repeatDelay);
		Interface.CallHook("OnExplosiveDropped", msg.player, hitInfo);
		UseItemAmount(1);
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be targeted for helicopter strafing.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <param name="target">The potential target player.</param>
/// <returns>
/// Returns `true` if the player can be targeted, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanHelicopterStrafeTarget(PatrolHelicopterAI ai, BasePlayer target)
{
    Puts($"Checking if {target.displayName} can be targeted for helicopter strafing...");
    if (target.IsAdmin())
    {
        Puts($"Cannot target admin {target.displayName} for helicopter strafing.");
        return true;
    }
    // Additional checks or logic can go here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidStrafeTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return !ply.IsNearEnemyBase();
	}

```

## InitLogging()

```csharp
```csharp
/// <summary>
/// Called when logging is initialized.
/// </summary>
void InitLogging()
{
    Puts("Logging initialized.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

```

## OnItemDeployed(Deployer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is deployed on a base entity.
/// </summary>
/// <param name="deployer">The deployer of the item.</param>
/// <param name="baseEntity">The base entity where the item was deployed.</param>
object OnItemDeployed(Deployable deployer, BaseEntity baseEntity)
{
    Puts($"Item {deployer.name} has been deployed on {baseEntity.displayName}.");
    if (baseEntity is BaseBuilding && ((BaseBuilding)baseEntity).IsLocked())
    {
        Puts($"Deployment of item {deployer.name} on {baseEntity.displayName} has been blocked due to locked building.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || !ownerPlayer.CanBuild())
		{
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity);
		UseItemAmount(1);
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that was locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.EntityID} has been locked by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## OnHelicopterDropDoorOpen(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the helicopter's drop door is opened or closed.
/// </summary>
/// <param name="controller">The AI controller of the CH47 helicopter.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropDoorOpen(CH47HelicopterAIController controller)
{
    Puts($"Drop door on {controller.GetDisplayName()} opened: {controller.IsDropDoorOpen}");
}
```
```

### Source Code from the Library

```csharp

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="signage">The signage being updated (not used in this implementation).</param>
/// <returns>
/// Returns `true` if the player is allowed to update the sign, or `false` otherwise.
/// </returns>
bool CanUpdateSign(BasePlayer player, Signage signage)
{
    Puts($"Checking if {player.UserIDString} can update a sign");
    
    // If Interface.CallHook returns a boolean value, return that
    object obj = Interface.CallHook("CanUpdateSign", player, signage);
    if (obj is bool)
    {
        return (bool)obj;
    }
    
    // Otherwise, check the player's permissions and ownership
    if (player.IsAdmin || player.IsDeveloper)
    {
        Puts($"{player.UserIDString} has admin privileges, allowing sign update");
        return true;
    }
    else if (!player.CanBuild())
    {
        Puts($"{player.UserIDString} does not have build permission, denying sign update");
        return false;
    }
    else if (IsLocked() && player.userID != base.OwnerID)
    {
        Puts($"{player.UserIDString} is trying to update a locked sign without ownership, denying access");
        return false;
    }
    
    // If all checks pass, allow the player to update the sign
    Puts($"{player.UserIDString} has permission to update the sign");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player's looting session ends.
/// </summary>
/// <param name="playerLoot">The PlayerLoot object associated with the ended looting session.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot playerLoot)
{
    Puts($"Player {playerLoot.Player.UserIDString} has finished looting.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		containers.Clear();
		entitySource = null;
		itemSource = null;
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the mailbox, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Player {player.UserIDString} attempting to access mailbox {mailbox.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and will receive a special spawn reward.");
        // Reward the admin with something
    }
    else
    {
        Puts($"Player {player.displayName} is not an admin and will receive the standard spawn items.");
        // Give the player their default spawn items
    }
}
```
```

### Source Code from the Library

```csharp

	public void RespawnAt(UnityEngine.Vector3 position, Quaternion rotation)
	{
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		ServerPerformance.spawns++;
		SetParent(null, worldPositionStays: true);
		base.transform.position = position;
		base.transform.rotation = rotation;
		tickInterpolator.Reset(position);
		lastTickTime = 0f;
		StopWounded();
		StopSpectating();
		UpdateNetworkGroup();
		UpdatePlayerCollider(state: true);
		UpdatePlayerRigidbody(state: false);
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		InitializeHealth(StartHealth(), StartMaxHealth());
		inventory.GiveDefaultItems();
		SendNetworkUpdateImmediate();
		ClientRPCPlayer(null, this, "StartLoading");
		if (net != null)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", this);
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a healing item is used on a player.
/// </summary>
/// <param name="medicalTool">The medical tool being used.</param>
/// <param name="player">The player receiving the healing effect.</param>
/// <returns>
/// Returns `null` to allow the healing effect to be applied, or any non-null value to prevent the healing effect from being applied.
/// </returns>
object OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)
{
    Puts($"Medical tool {medicalTool.name} used on player {player.displayName}");
    if (player.IsWounded() && !player.HasBandage())
    {
        Puts($"Player {player.displayName} is wounded and has no bandages. Healing effect applied.");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} is not wounded or already has a bandage. No healing effect applied.");
        return "No healing effect applied.";
    }
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			if (player != GetOwnerPlayer() && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				player.StopWounded();
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## CanExperiment(BasePlayer,Workbench)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to begin an experiment.
/// </summary>
/// <param name="player">The player attempting to begin the experiment.</param>
/// <param name="workbench">The workbench being used for the experiment.</param>
/// <returns>
/// Returns `null` to allow the experiment to proceed, or any non-null value to prevent the experiment from starting.
/// </returns>
object CanExperiment(BasePlayer player, Workbench workbench)
{
    Puts($"Player {player.UserID} is attempting to begin an experiment on workbench {workbench.name}.");
    if (player.GetRole() == "Admin")
    {
        return null;
    }
    else
    {
        return "You do not have permission to perform this action.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !playerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("CanExperiment", player, this) != null)
			{
				return;
			}
			Item slot = inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
		}
	}

```

## OnRecycleItem(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled.
/// </summary>
/// <param name="recycler">The recycler that called this method.</param>
/// <param name="item">The item being recycled.</param>
/// <returns>
/// Returns a non-null value to override the default recycling behavior. 
/// If `null` is returned, the item is recycled as normal.
/// </returns>
object OnRecycleItem(Recycler recycler, Item item)
{
    Puts($"Item {item.info.shortname} has been recycled.");
    if (item.info.Blueprint.scrapFromRecycle > 0)
    {
        int num = item.info.Blueprint.scrapFromRecycle;
        if (item.hasCondition)
        {
            num = Mathf.CeilToInt((float)num * item.conditionNormalized);
        }
        Item newItem = ItemManager.CreateByName("scrap", num, 0uL);
        MoveItemToOutput(newItem);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = recycleEfficiency;
		for (int i = 0; i < 6; i++)
		{
			Item slot = inventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			if (Interface.CallHook("OnRecycleItem", this, slot) != null && !HasRecyclable())
			{
				StopRecycling();
				return;
			}
			if (!(slot.info.Blueprint != null))
			{
				continue;
			}
			if (slot.hasCondition)
			{
				num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
			}
			int num2 = 1;
			if (slot.amount > 1)
			{
				num2 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.info.stackable * 0.1f));
			}
			if (slot.info.Blueprint.scrapFromRecycle > 0)
			{
				int num3 = slot.info.Blueprint.scrapFromRecycle * num2;
				if (slot.info.stackable == 1 && slot.hasCondition)
				{
					num3 = Mathf.CeilToInt((float)num3 * slot.conditionNormalized);
				}
				if (num3 >= 1)
				{
					Item newItem = ItemManager.CreateByName("scrap", num3, 0uL);
					MoveItemToOutput(newItem);
				}
			}
			slot.UseItem(num2);
			foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
			{
				if (ingredient.itemDef.shortname == "scrap")
				{
					continue;
				}
				float num4 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
				int num5 = 0;
				if (num4 <= 1f)
				{
					for (int j = 0; j < num2; j++)
					{
						if (UnityEngine.Random.Range(0f, 1f) <= num4 * num)
						{
							num5++;
						}
					}
				}
				else
				{
					num5 = Mathf.CeilToInt(Mathf.Clamp(num4 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount) * (float)num2);
				}
				if (num5 <= 0)
				{
					continue;
				}
				int num6 = Mathf.CeilToInt((float)num5 / (float)ingredient.itemDef.stackable);
				for (int k = 0; k < num6; k++)
				{
					int num7 = ((num5 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num5);
					Item newItem2 = ItemManager.Create(ingredient.itemDef, num7, 0uL);
					if (!MoveItemToOutput(newItem2))
					{
						flag = true;
					}
					num5 -= num7;
					if (num5 <= 0)
					{
						break;
					}
				}
			}
			break;
		}
		if (flag || !HasRecyclable())
		{
			StopRecycling();
		}
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger.
/// </summary>
/// <param name="trigger">The trigger that the entity left.</param>
/// <param name="entity">The entity that left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.ClassName} has left trigger {trigger.EntityId}");
}
```
```

### Source Code from the Library

```csharp

	internal virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null)
		{
			Interface.CallHook("OnEntityLeave", this, ent);
			entityContents.Remove(ent);
		}
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="lock">The lock on the entity, which could be a key or other type of lock.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, and `false` otherwise.
/// If `null` is returned, the default behavior will be used (i.e., the player cannot use the locked entity unless they have permission).
/// </returns>
bool CanUseLockedEntity(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} attempted to use locked entity with key {lock.KeyID}");
    if (lock.IsMasterKey())
    {
        return true;
    }
    // Check if the player has permission to use the locked entity
    if (HasPermission(player, Permission.UseLockedEntity))
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container that the item was added to.</param>
/// <param name="item">The item that was added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been added to container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's sleep has ended.
/// </summary>
/// <param name="player">The player whose sleep has ended.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has woken up from sleep.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and will not be affected by the wake-up event.");
        return;
    }
    // Additional logic can be added here to handle the player's wake-up
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (!IsSleeping())
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.Sleeping, b: false);
		sleepStartTime = -1f;
		sleepingPlayerList.Remove(this);
		InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
		if (RelationshipManager.TeamsEnabled())
		{
			InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
		}
		UpdatePlayerCollider(state: true);
		UpdatePlayerRigidbody(state: true);
		Interface.CallHook("OnPlayerSleepEnded", this);
		if (EACServer.playerTracker == null || net.connection == null)
		{
			return;
		}
		using (TimeWarning.New("playerTracker.LogPlayerSpawn"))
		{
			EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
			EACServer.playerTracker.LogPlayerSpawn(client, 0, 0);
		}
	}

```

## OnItemResearch(ResearchTable,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player researches an item.
/// </summary>
/// <param name="researchTable">The research table being used.</param>
/// <param name="item">The item being researched.</param>
/// <param name="player">The player performing the research.</param>
/// <returns>No return behavior.</returns>
void OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has started researching item {item.info.name}.");
    if (item.info.category == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to research restricted items.");
        return;
    }
    // Additional logic can be added here based on the requirements.
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## CanLock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to lock the object.
/// </summary>
/// <param name="player">The player attempting to lock the object.</param>
/// <param name="lock">The KeyLock object being locked.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} attempted to lock {lock.name}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Not allowed: Only admins can lock this object.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Lock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			LockLock(rpc.player);
			SendNetworkUpdate();
		}
	}

```

## CanLock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called when a player tries to lock the object.
/// </summary>
/// <param name="player">The player attempting to lock the object.</param>
/// <param name="lockObject">The CodeLock object being locked.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(BasePlayer player, CodeLock lockObject)
{
    Puts($"Player {player.UserIDString} is trying to lock the code lock.");
    if (lockObject.IsLocked())
    {
        Puts($"The code lock is already locked by another player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", rpc.player, this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable quantity of an item.
/// </summary>
/// <param name="item">The item being checked.</param>
/// <returns>
/// Returns a non-negative integer representing the maximum stackable quantity. 
/// If `null` is returned, the default maximum stackable quantity will be used.
/// </returns>
object OnMaxStackable(Item item)
{
    Puts($"Checking max stackable for item {item.name}...");
    if (item.category == "Rare")
    {
        Puts($"Item {item.name} has a custom max stackable of 10.");
        return 10;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## CanDismountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when an entity is being dismounted.
/// </summary>
/// <param name="entity">The entity being dismounted.</param>
/// <param name="player">The player who is dismounting the entity.</param>
/// <returns>
/// Returns `null` to allow the entity to be dismounted, or any non-null value to prevent it from being dismounted.
/// </returns>
object CanDismountEntity(BasePlayer player, BaseMountable entity)
{
    Puts($"Player {player.displayName} is attempting to dismount entity {entity.name}.");
    if (player.userID == 123456789) // Example: Prevent a specific user from dismounting the entity
    {
        return "Access denied.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		if (lite)
		{
			_mounted.DismountObject();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			return;
		}
		Vector3 dismountPosition = GetDismountPosition(player);
		if (dismountPosition == DISMOUNT_POS_INVALID)
		{
			dismountPosition = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(dismountPosition);
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", dismountPosition);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			SetFlag(Flags.Busy, b: false);
		}
		else
		{
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(dismountPosition);
			_mounted.SendNetworkUpdateImmediate();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPCPlayer(null, player, "ForcePositionToParentOffset", baseEntity.transform.InverseTransformPoint(dismountPosition), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPCPlayer(null, player, "ForcePositionTo", dismountPosition);
				Interface.CallHook("OnEntityDismounted", this, player);
			}
		}
	}

```

## IOnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a new user attempts to connect to the server.
/// </summary>
/// <param name="connection">The connection object for the incoming user.</param>
/// <returns>
/// Returns `null` if the user is approved as normal. 
/// If a non-null value is returned, it will override the default approval behavior and kick the user with the provided message as the reason.
/// </returns>
object IOnUserApprove(Connection connection)
{
    Puts($"User {connection.username} with SteamID {connection.userid} has attempted to connect.");
    if (connection.token == null || connection.token.Length < 32)
    {
        Reject(connection, "Invalid Token");
        return true;
    }
    if (connection.userid == 0L)
    {
        Reject(connection, "Invalid SteamID");
        return true;
    }
    if (connection.protocol != 2151)
    {
        if (!DeveloperList.Contains(connection.userid))
        {
            Reject(connection, "Incompatible Version");
            return true;
        }
        DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)", StackTraceLogType.None);
    }
    if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
    {
        Reject(connection, "You are banned from this server");
        return true;
    }
    object result = Interface.CallHook("OnUserApprove", connection);
    if (result != null)
    {
        return result;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0L)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2151)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)", StackTraceLogType.None);
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			Reject(connection, "You are banned from this server");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log(connection.ToString() + " has auth level 1", StackTraceLogType.None);
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log(connection.ToString() + " has auth level 2", StackTraceLogType.None);
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log(connection.ToString() + " is a developer", StackTraceLogType.None);
			connection.authLevel = 3u;
		}
		if (IsConnected(connection.userid))
		{
			Reject(connection, "You are already connected!");
		}
		else if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser bonus is assigned to a player.
/// </summary>
/// <param name="dispenser">The dispenser that triggered the bonus.</param>
/// <param name="player">The player who received the bonus.</param>
/// <param name="item">The item that was given as a bonus.</param>
/// <returns>
/// Returns `null` to allow the player to receive the bonus, or any non-null value to override the default behavior.
/// If an `Item` is returned, it will be used instead of the original item.
/// </returns>
object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} received a bonus from dispenser {dispenser.displayName}.");
    if (item.name == "Golden Coin")
    {
        Puts($"Player {player.UserIDString} was given a rare Golden Coin as a bonus!");
        return new Item(item.def, 2, 0uL);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction)
	{
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			Item item = ItemManager.Create(finishBonu.itemDef, Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction)), 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnRconConnection(System.Net.IPEndPoint)

```csharp
```csharp
/// <summary>
/// Called when an RCON connection is established.
/// </summary>
/// <param name="endpoint">The IP endpoint of the connecting client.</param>
/// <returns>
/// Returns a non-null value to override the default behavior and close the socket. 
/// If `null` is returned, the RCON connection will be processed as normal.
/// </returns>
object OnRconConnection(System.Net.IPEndPoint endpoint)
{
    Puts($"RCON connection from {endpoint} established.");
    if (endpoint.Address.ToString() == "192.168.1.1")
    {
        Puts($"Ignoring RCON connection from {endpoint} - banned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", iPEndPoint) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnTick()

```csharp
```csharp
/// <summary>
/// Called every tick.
/// </summary>
void OnTick()
{
    Puts("Server is ticking...");
    // Perform any necessary server-side tasks here
    // For example, you could update the server's state or perform some calculations
}
```
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		if (Rust.Global.SteamServer != null)
		{
			Interface.CallHook("OnTick");
			Rust.Global.SteamServer.Update();
		}
		RCon.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## OnPlayerActiveItemChanged(BasePlayer,Item,Item)

```csharp
```csharp
/// <summary>
/// Called when a player's active item changes.
/// </summary>
/// <param name="player">The player whose active item has changed.</param>
/// <param name="oldItem">The old active item.</param>
/// <param name="newItem">The new active item.</param>
object OnPlayerActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
{
    Puts($"Player {player.UserIDString} has changed their active item from {oldItem?.displayName ?? "null"} to {newItem?.displayName ?? "null"}.");
    if (newItem == null && oldItem != null)
    {
        // Handle the case where the player dropped an item
        return;
    }
    else if (newItem != null && oldItem != null && newItem == oldItem)
    {
        // Handle the case where the player's active item hasn't actually changed
        return;
    }
    // Add any additional logic here as needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal void UpdateActiveItem(uint itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = 0u;
		}
		Item activeItem = GetActiveItem();
		svActiveItemID = 0u;
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnPlayerActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger.
/// </summary>
/// <param name="trigger">The trigger that was entered.</param>
/// <param name="entity">The entity that entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has entered trigger {trigger.name}");
}
```
```

### Source Code from the Library

```csharp

	internal virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			Interface.CallHook("OnEntityEnter", this, ent);
			entityContents.Add(ent);
		}
	}

```

## OnItemCraftCancelled(ItemCraftTask)

```csharp
```csharp
/// <summary>
/// Called when an item craft task is cancelled.
/// </summary>
/// <param name="task">The cancelled item craft task.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task)
{
    Puts($"Item craft task {task.taskUID} has been cancelled.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID, bool ReturnItems)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (itemCraftTask.owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask);
		itemCraftTask.owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0 && ReturnItems)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))
					{
						takenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition + UnityEngine.Random.value * Vector3.down + UnityEngine.Random.insideUnitSphere, itemCraftTask.owner.inventory.containerMain.dropVelocity);
						itemCraftTask.owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
		}
		return true;
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret is shutting down.
/// </summary>
/// <param name="turret">The AutoTurret instance being shut down.</param>
/// <returns>
/// Returns `null` to allow the turret to shut down normally, or any non-null value to prevent it from shutting down.
/// </returns>
object OnTurretShutdown(AutoTurret turret)
{
    Puts($"Turret {turret.GetReference().ToString()} is shutting down.");
    if (turret.GetReference() == "Turret 1")
    {
        Puts($"Turret {turret.GetReference()} has been overridden from shutting down.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if (!IsOffline() && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## CanMountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when an entity is mounted by a player.
/// </summary>
/// <param name="player">The player mounting the entity.</param>
/// <param name="entity">The entity being mounted.</param>
/// <returns>
/// Returns `null` to allow the entity to be mounted, or any non-null value to prevent it from being mounted.
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object CanMountEntity(BasePlayer player, BaseMountable entity)
{
    Puts($"Player {player.UserIDString} tried to mount {entity.name}.");
    if (entity.name == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to mount {entity.name}.");
        return "Access denied: Mounting restricted.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			TriggerParent triggerParent = player.FindTrigger<TriggerParent>();
			if ((bool)triggerParent)
			{
				triggerParent.OnTriggerExit(player.GetComponent<Collider>());
			}
			player.MountObject(this);
			player.MovePosition(mountAnchor.transform.position);
			player.transform.rotation = mountAnchor.transform.rotation;
			player.ServerRotation = mountAnchor.transform.rotation;
			player.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			SetFlag(Flags.Busy, b: true);
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the recycler is toggled on or off.
/// </summary>
/// <param name="recycler">The recycler being toggled.</param>
/// <param name="player">The player who toggled the recycler.</param>
/// <returns>
/// Returns `null` to allow the recycler to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts($"Recycler {recycler.name} has been toggled by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot toggle the recycler.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || msg.player == null || Interface.CallHook("OnRecyclerToggle", this, msg.player) != null || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

```

## OnAddVendingOffer(VendingMachine,ProtoBuf.VendingMachine.SellOrder)

```csharp
```csharp
/// <summary>
/// Called when a new vending offer is added.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was added to.</param>
/// <param name="sellOrder">The sell order details of the new offer.</param>
object OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"New vending offer added to {vendingMachine.name} with item ID {sellOrder.itemToSellID}, amount {sellOrder.itemToSellAmount}, currency ID {sellOrder.currencyID}, and amount per item {sellOrder.currencyAmountPerItem}");
    if (sellOrder.currencyID == 123 && sellOrder.itemToSellID == 456)
    {
        Puts($"Vending offer with item ID {sellOrder.itemToSellID} and currency ID {sellOrder.currencyID} has been blocked.");
        return "Blocked: Invalid item or currency.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = itemToSellID;
			sellOrder.itemToSellAmount = itemToSellAmount;
			sellOrder.currencyID = currencyToUseID;
			sellOrder.currencyAmountPerItem = currencyAmount;
			sellOrder.currencyIsBP = bpState == 3 || bpState == 2;
			sellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", this, sellOrder);
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player ends spectating.
/// </summary>
/// <param name="player">The player ending spectation.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to end spectating normally. 
/// If any non-null value is returned, it will override the default behavior and prevent the player from ending spectation.
/// </returns>
object OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} ended spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to end spectation with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## CanUnlock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called when a player tries to unlock the object.
/// </summary>
/// <param name="player">The player trying to unlock.</param>
/// <param name="lock">The lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to unlock, or any non-null value to prevent them from unlocking.
/// If a string is returned, the player will be notified with the provided message as the reason.
/// </returns>
object CanUnlock(BasePlayer player, CodeLock lock)
{
    Puts($"Player {player.UserIDString} tried to unlock {lock.name}");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is not allowed to unlock");
        return "Access denied: Unauthorized user";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null)
		{
			if (whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectUnlocked.resourcePath);
				SetFlag(Flags.Locked, b: false);
				SendNetworkUpdate();
			}
			else
			{
				ClientRPCPlayer(null, rpc.player, "EnterUnlockCode");
			}
		}
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed.
/// </summary>
/// <param name="trap">The bear trap being armed.</param>
/// <param name="player">The player who triggered the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to be armed, or any non-null value to prevent it from arming.
/// </returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Bear trap {trap.GetReference()} has been armed by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot trigger traps.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## CanAdministerVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} attempting to administer vending machine {vendingMachine.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.HasPermission("can_admin_vending"))
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

```

## OnItemSplit(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is being split into smaller quantities.
/// </summary>
/// <param name="item">The item being split.</param>
/// <param name="splitAmount">The amount to split the item by.</param>
/// <returns>
/// Returns a new `Item` object if the split should be overridden, or `null` if the original behavior should occur.
/// If a non-null value is returned, it will be used as the new item being created instead of splitting the original item.
/// </returns>
object OnItemSplit(Item item, int splitAmount)
{
    Puts($"Item {item.info.itemid} is being split by {splitAmount} units.");
    if (splitAmount == 1)
    {
        Puts($"Item {item.info.itemid} cannot be split into single units.");
        return null;
    }
    // Return a new item object to override the default splitting behavior
    Item newItem = ItemManager.CreateByItemID(item.info.itemid, 5, 0uL);
    newItem.amount = splitAmount / 2;
    return newItem;
}
```
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		MarkDirty();
		return item;
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when the item loses a certain amount of condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>
/// Returns `null` to allow the item to lose condition, or any non-null value to prevent it from losing condition.
/// If a string is returned, the item will be destroyed with the provided message as the reason.
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Item {item.info.shortname} lost {amount} condition.");
    if (amount > 0.5f)
    {
        Puts($"Item {item.info.shortname} has been severely damaged.");
        return "Destroyed: Excessive damage.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to disarm a trap.
/// </summary>
/// <param name="landmine">The landmine being disarmed.</param>
/// <param name="player">The player attempting to disarm the landmine.</param>
/// <returns>
/// Returns `null` to allow the player to disarm the landmine, or any non-null value to prevent them from disarming it.
/// </returns>
object OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is attempting to disarm landmine at position {landmine.Position}");
    if (player.HasFlag(Flags.Admin))
    {
        Puts($"Player {player.displayName} has been granted admin privileges and can now disarm the landmine.");
        return null;
    }
    return "Access denied: You do not have permission to disarm this landmine.";
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if (rpc.player.net.ID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			if (UnityEngine.Random.Range(0, 100) < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## OnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
void OnServerShutdown()
{
    Puts("Server shutdown initiated.");
    // Perform any necessary cleanup or actions before shutting down
}
```
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("OnServerShutdown");
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## CanNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC is about to attack another entity.
/// </summary>
/// <param name="npc">The NPC performing the attack.</param>
/// <param name="target">The target of the attack.</param>
/// <returns>
/// Returns `null` to allow the NPC to perform the attack, or any non-null value to prevent the attack from happening.
/// </returns>
object CanNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} is about to attack {target.UserIDString}");
    if (target.IsPlayer && !target.IsSpectator)
    {
        Puts($"NPC {npc.name} cannot attack player {target.UserIDString}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if ((bool)AttackTarget && AttackReady() && Interface.CallHook("CanNpcAttack", this, AttackTarget) == null && !((AttackTarget.ServerPosition - ServerPosition).magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(null, "Attack", AttackTarget.ServerPosition);
			}
		}
	}

```

## OnReloadWeapon(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player starts reloading their weapon.
/// </summary>
/// <param name="player">The player starting to reload.</param>
/// <param name="projectile">The projectile being reloaded, if applicable.</param>
/// <returns>
/// Returns `null` to allow the player to start reloading, or any non-null value to prevent them from reloading.
/// </returns>
object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} started reloading their weapon.");
    if (projectile != null && projectile.ammoType == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to reload restricted ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnReloadWeapon", player, this) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			StartReloadCooldown(reloadTime);
		}
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a vending transaction is attempted.
/// </summary>
/// <param name="vendingMachine">The vending machine that initiated the transaction.</param>
/// <param name="buyer">The player attempting to buy an item from the vending machine.</param>
/// <param name="sellOrderId">The ID of the sell order being executed.</param>
/// <param name="numberOfTransactions">The number of transactions being performed (default is 1).</param>
/// <returns>
/// Returns a non-null value to override the default transaction behavior. 
/// If `true` is returned, the transaction will be allowed as normal.
/// If `false` is returned, the transaction will be cancelled and no items will be dispensed or currency taken.
/// </returns>
object OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
{
    Puts($"Vending machine {vendingMachine.name} has been used by player {buyer.displayName}.");
    if (sellOrderId < 0 || sellOrderId > vendingMachine.sellOrders.Count)
    {
        return false;
    }
    ProtoBuf.VendingMachine.SellOrder sellOrder = vendingMachine.sellOrders[sellOrderId];
    List<Item> list = buyer.inventory.FindItemsByItemID(sellOrder.itemToSellID);
    if (sellOrder.itemToSellIsBP)
    {
        list = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
            where x.blueprintTarget == sellOrder.itemToSellID
            select x).ToList();
    }
    if (list == null || list.Count == 0)
    {
        return false;
    }
    numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
    int num = sellOrder.itemToSellAmount * numberOfTransactions;
    int num2 = list.Sum((Item x) => x.amount);
    if (num > num2)
    {
        return false;
    }
    List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
    if (sellOrder.currencyIsBP)
    {
        source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
            where x.blueprintTarget == sellOrder.currencyID
            select x).ToList();
    }
    source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
    if (source.Count == 0)
    {
        return false;
    }
    int num3 = source.Sum((Item x) => x.amount);
    int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
    if (num3 < num4)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
	{
		if (sellOrderId < 0 || sellOrderId > sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> list = inventory.FindItemsByItemID(sellOrder.itemToSellID);
		if (sellOrder.itemToSellIsBP)
		{
			list = (from x in inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.itemToSellID
				select x).ToList();
		}
		if (list == null || list.Count == 0)
		{
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = list.Sum((Item x) => x.amount);
		if (num > num2)
		{
			return false;
		}
		List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
		if (source.Count == 0)
		{
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
		if (num3 < num4)
		{
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item2 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item2.amount);
			Item takenCurrencyItem = ((item2.amount > num6) ? item2.SplitItem(num6) : item2);
			TakeCurrencyItem(takenCurrencyItem);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		int num7 = 0;
		foreach (Item item3 in list)
		{
			int num8 = num - num7;
			Item item = ((item3.amount > num8) ? item3.SplitItem(num8) : item3);
			if (item == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item.amount;
				GiveSoldItem(item, buyer);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## OnCrateHackEnd(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a crate hack has ended.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateHackEnd(HackableLockedCrate crate)
{
    Puts($"Crate hack on {crate.crateName} has ended.");
    if (crate.isLootable)
    {
        Puts($"Crate {crate.crateName} is now lootable.");
    }
    else
    {
        Puts($"Crate {crate.crateName} is not lootable.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", this);
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			CancelInvoke(HackProgress);
		}
		ClientRPC(null, "UpdateHackProgress", (int)hackSeconds, (int)requiredHackSeconds);
	}

```

## OnItemResearched(ResearchTable,int)

```csharp
```csharp
/// <summary>
/// Called when an item is researched.
/// </summary>
/// <param name="researchTable">The research table used to research the item.</param>
/// <param name="amountOfScrapUsed">The amount of scrap used in the research process.</param>
object OnItemResearched(ResearchTable researchTable, int amountOfScrapUsed)
{
    Puts($"Item {researchTable.GetItemName()} has been researched using {amountOfScrapUsed} units of scrap.");
    if (amountOfScrapUsed > 1000)
    {
        Puts($"Warning: Item {researchTable.GetItemName()} was researched with excessive amount of scrap ({amountOfScrapUsed}).");
        return "Excessive Scrap Used";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", this, num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount <= num)
				{
					inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
				item.blueprintTarget = targetItem.info.itemid;
				if (!item.MoveToContainer(inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## OnPlayerWound(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is wounded.
/// </summary>
/// <param name="player">The player who was wounded.</param>
/// <returns>
/// Returns `null` to allow the player to be wounded, or any non-null value to prevent them from being wounded.
/// </returns>
object OnPlayerWound(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been wounded.");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot be wounded.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartWounded()
	{
		if (!IsWounded() && Interface.CallHook("OnPlayerWound", this) == null)
		{
			stats.Add("wounded", 1);
			woundedDuration = UnityEngine.Random.Range(40f, 50f);
			woundedStartTime = UnityEngine.Time.realtimeSinceStartup;
			SetPlayerFlag(PlayerFlags.Wounded, b: true);
			SendNetworkUpdateImmediate();
			Invoke(WoundingTick, 1f);
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="lootableCorpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts($"Player {player.UserIDString} stopped looting {lootableCorpse.DisplayName}");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## IOnNpcPlayerSenseClose(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses a player in close range.
/// </summary>
/// <param name="npc">The NPC sensing the player.</param>
/// <returns>No return behavior.</returns>
void IOnNpcPlayerSenseClose(NPCPlayerApex npc)
{
    Puts($"NPC {npc.name} sensed a player in close range.");
}
```
```

### Source Code from the Library

```csharp

	private void _FindEntitiesInCloseRange()
	{
		if (Interface.CallHook("IOnNpcPlayerSenseClose", this) != null)
		{
			return;
		}
		EntityQueryResultCount = Query.Server.GetInSphere(base.transform.position, Stats.CloseRange, EntityQueryResults, delegate(BaseEntity entity)
		{
			if (entity == null || !entity.isServer || entity.IsDestroyed)
			{
				return false;
			}
			return (entity is BaseNpc || entity is TimedExplosive) ? true : false;
		});
	}

```

## OnHelicopterOutOfCrates(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter runs out of crates.
/// </summary>
/// <param name="helicopter">The helicopter that ran out of crates.</param>
/// <returns>
/// Returns `true` if the helicopter should stop its current action and return to base, or `false` otherwise.
/// If no value is returned, the helicopter will continue with its current action.
/// </returns>
bool OnHelicopterOutOfCrates(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityId()} has run out of crates.");
    if (helicopter.GetReference().GetDistanceToBase() < 100f)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

```

## IOnRconInitialize()

```csharp
```csharp
/// <summary>
/// Called when the RCON system is initialized.
/// </summary>
void IOnRconInitialize()
{
    Puts("RCon initialization complete.");
}
```
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", ""));
		if (Password == "password" || Password == "")
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPEndPoint ip, string id, string msg)
			{
				lock (Commands)
				{
					Command item = JsonConvert.DeserializeObject<Command>(msg);
					item.Ip = ip;
					item.ConnectionId = id;
					Commands.Enqueue(item);
				}
			};
			listenerNew.Start();
			Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			Debug.Log("RCon Started on " + Port);
			Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a turret targets an entity.
/// </summary>
/// <param name="turret">The AutoTurret that has targeted the entity.</param>
/// <param name="entity">The BaseCombatEntity that is being targeted by the turret.</param>
/// <returns>
/// Returns `null` to allow the turret to target the entity, or any non-null value to prevent the turret from targeting the entity.
/// </returns>
object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
{
    Puts($"Turret {turret.name} has targeted entity {entity.displayName}.");
    if (entity is Player player && player.IsSpectator())
    {
        Puts($"Player {player.displayName} is a spectator and cannot be targeted by the turret.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);
			}
			target = targ;
		}
	}

```

## OnCrateHack(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to hack a locked crate.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>
/// Returns `null` to allow the hacking process to continue, or any non-null value to prevent the hacking process.
/// If a string is returned, it will be displayed as a message to the player attempting to hack the crate.
/// </returns>
object OnCrateHack(HackableLockedCrate crate)
{
    Puts($"Player attempted to hack {crate.crateName}.");
    if (crate.isUnhackable)
    {
        Puts($"Player cannot hack {crate.crateName}, it is unhackable.");
        return "This crate is unhackable.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", this);
		SetFlag(Flags.Reserved1, b: true);
		InvokeRepeating(HackProgress, 1f, 1f);
		ClientRPC(null, "UpdateHackProgress", 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when a resource is gathered from a quarry.
/// </summary>
/// <param name="quarry">The mining quarry that gathered the resource.</param>
/// <param name="item">The item that was gathered.</param>
void OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts($"Resource {item.info.name} gathered from quarry {quarry.quarryName}.");
    if (item.info.category == "rare")
    {
        Puts($"Rare resource {item.info.name} detected. Sending alert to administrators.");
        // Send alert to administrators
    }
    else if (item.info.category == "hazardous")
    {
        Puts($"Hazardous material {item.info.name} detected. Taking safety precautions.");
        // Take safety precautions
    }
}
```
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			resource.workDone += workToAdd;
			if (!(resource.workDone < resource.workNeeded))
			{
				int num = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
				resource.workDone -= (float)num * resource.workNeeded;
				Item item = ItemManager.Create(resource.type, num, 0uL);
				Interface.CallHook("OnQuarryGather", this, item);
				if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a BasePlayer is attacked.
/// </summary>
public override void IOnBasePlayerAttacked(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.displayName} was attacked by {info.InitiatorPlayer.displayName}");
    
    // Check if any wearable items on the player's inventory protect the hit area
    float health_old = player.health;
    if (player.isServer)
    {
        HitArea boneArea = info.boneArea;
        if (boneArea != (HitArea)(-1))
        {
            List<Item> obj = Facepunch.Pool.GetList<Item>();
            obj.AddRange(player.inventory.containerWear.itemList);
            for (int i = 0; i < obj.Count; i++)
            {
                Item item = obj[i];
                if (item != null)
                {
                    ItemModWearable component = item.info.GetComponent<ItemModWearable>();
                    if (!(component == null) && component.ProtectsArea(boneArea))
                    {
                        item.OnAttacked(info);
                    }
                }
            }
            Facepunch.Pool.FreeList(ref obj);
            player.inventory.ServerUpdate(0f);
        }
    }

    // Call the base method to handle the attack
    base.OnAttacked(info);

    // Check if the player is wounded or dead and log it in their stats
    if (player.stats != null)
    {
        if (player.IsWounded())
        {
            player.stats.combat.Log(info, health_old, player.health, "wounded");
        }
        else if (player.IsDead())
        {
            player.stats.combat.Log(info, health_old, player.health, "killed");
        }
        else
        {
            player.stats.combat.Log(info, health_old, player.health);
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float health_old = base.health;
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.GetList<Item>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortal())
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			if (isMounted)
			{
				GetMounted().MounteeTookDamage(this, info);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				Effect effect = new Effect();
				effect.Init(Effect.Type.Generic, base.transform.position, base.transform.forward);
				effect.pooledString = "assets/bundled/prefabs/fx/takedamage_hit.prefab";
				EffectNetwork.Send(effect, net.connection);
			}
			string text = StringPool.Get(info.HitBone);
			bool flag = UnityEngine.Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) > 0.4f;
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1);
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.Log(info, health_old, base.health, "wounded");
			}
			else if (IsDead())
			{
				stats.combat.Log(info, health_old, base.health, "killed");
			}
			else
			{
				stats.combat.Log(info, health_old, base.health);
			}
		}
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is rotated.
/// </summary>
/// <param name="block">The building block being rotated.</param>
/// <param name="player">The player who initiated the rotation.</param>
/// <returns>
/// Returns `null` to allow the structure to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnStructureRotate(BuildingBlock block, BasePlayer player)
{
    Puts($"Structure {block.name} has been rotated by player {player.UserIDString}");
    if (block.name == "Forbidden Structure")
    {
        Puts($"Player {player.displayName} is not allowed to rotate the structure {block.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotate && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			UpdateSkin(force: true);
			SendNetworkUpdateImmediate();
			ClientRPC(null, "RefreshSkin");
		}
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <param name="target">The object that entered the trap's trigger area.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(BearTrap trap, GameObject target)
{
    Puts($"Trap triggered by {target.name} at position: {target.transform.position}");
    if (target.CompareTag("Player"))
    {
        Puts($"Player detected in trap area. Preventing trap trigger.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is finished.
/// </summary>
/// <param name="task">The ItemCraftTask that was completed.</param>
/// <param name="item">The crafted item.</param>
object OnItemCraftFinished(ItemCraftTask task, Item item)
{
    Puts($"Item crafting task {task.taskUID} has been completed.");
    if (task.blueprint.targetItem.shortname == "crafting_test")
    {
        Puts($"Item crafting test has been completed with result: {item.info.itemid} x {item.amount}");
        return new ItemAmount(item.info, item.amount);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item.amount = task.blueprint.amountToCreate;
		if (item.hasCondition && task.conditionScale != 1f)
		{
			item.maxCondition *= task.conditionScale;
			item.condition = item.maxCondition;
		}
		item.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					takenItem.UseItem(num);
					num -= num2;
				}
				_ = 0;
			}
		}
		Facepunch.Rust.Analytics.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		task.owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item);
		item.instanceData = task.instanceData;
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			task.owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		if (task.owner.inventory.GiveItem(item))
		{
			task.owner.Command("note.inv", item.info.itemid, item.amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		task.owner.Command("note.inv", item.info.itemid, item.amount);
		task.owner.Command("note.inv", item.info.itemid, -item.amount);
		item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="landmine">The landmine that was triggered.</param>
/// <param name="victim">The player who triggered the landmine.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(Landmine landmine, BasePlayer victim)
{
    Puts($"Landmine {landmine.name} triggered by player {victim.displayName}");
    if (victim.isSuperAdmin)
    {
        Puts($"Player {victim.displayName} is a super admin and cannot trigger the landmine.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## CanLootEntity(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `true` to allow the player to loot the entity, or `false` to prevent them from doing so.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanLootEntity(BasePlayer player, StorageContainer entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.name}");
    if (entity.IsLocked())
    {
        Puts($"Entity {entity.name} is locked and cannot be looted");
        return false;
    }
    // Add custom logic here to determine if the player can loot the entity
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen)
	{
		object obj = Interface.CallHook("CanLootEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsLocked())
		{
			player.ChatMessage("Can't loot right now");
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int)

```csharp
```csharp
/// <summary>
/// Called to check if a craft can be performed.
/// </summary>
/// <param name="craftTask">The item crafter performing the craft.</param>
/// <param name="blueprint">The blueprint for the item being crafted.</param>
/// <param name="amount">The amount of items being crafted.</param>
/// <returns>
/// Returns `true` if the craft can be performed, or any non-null value to override the default behavior. 
/// If a string is returned, it will be displayed as an error message.
/// </returns>
object CanCraft(ItemCrafter craftTask, ItemBlueprint blueprint, int amount)
{
    Puts($"Checking if craft of {amount}x {blueprint.targetItem.name} can be performed.");
    if (amount < 1 || amount > blueprint.targetItem.craftingStackable)
    {
        Puts($"Invalid amount: {amount}. Must be between 1 and {blueprint.targetItem.craftingStackable}.");
        return "Invalid amount.";
    }
    object result = Interface.CallHook("CanCraft", craftTask, blueprint, amount);
    if (result is bool)
    {
        return result;
    }
    foreach (ItemAmount ingredient in blueprint.ingredients)
    {
        if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
        {
            Puts($"Missing required item: {ingredient.itemname} x{(int)ingredient.amount * amount}.");
            return $"Missing required item: {ingredient.itemname} x{(int)ingredient.amount * amount}.";
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1)
	{
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is hunting.
/// </summary>
/// <param name="bradleyApc">The Bradley APC instance.</param>
/// <returns>
/// Returns a non-null value to override the default hunting behavior. 
/// If `null` is returned, the Bradley APC will continue with its normal hunting routine.
/// </returns>
object OnBradleyApcHunt(BradleyAPC bradleyApc)
{
    Puts($"The Bradley APC {bradleyApc.GetId()} has started hunting.");
    if (bradleyApc.GetCurrentTarget().GetDistance() > 100f)
    {
        Puts($"The Bradley APC {bradleyApc.GetId()} is too far away from its target to engage.");
        return "Too Far Away";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			BasePathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			BasePathNode basePathNode = null;
			List<BasePathNode> nearNodes = Facepunch.Pool.GetList<BasePathNode>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<BasePathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (BasePathNode item2 in nearNodes)
			{
				Stack<BasePathNode> path = new Stack<BasePathNode>();
				if (targetInfo.entity.IsVisible(item2.transform.position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					basePathNode = item2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].transform.position);
					}
				}
				foreach (BasePathNode item3 in stack)
				{
					currentPath.Add(item3.transform.position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = basePathNode.transform.position;
			}
			Facepunch.Pool.FreeList(ref nearNodes);
			Facepunch.Pool.FreeList(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the target player can be looted, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is attempting to loot player {target.UserIDString}");
    if (looter == target)
    {
        return false;
    }
    object result = Interface.CallHook("CanLootPlayer", looter, target);
    if (result is bool)
    {
        return result;
    }
    // If a non-bool value is returned, it will override the default behavior
    return result;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		if (!IsWounded())
		{
			return IsSleeping();
		}
		return true;
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a Bradley APC can target the specified entity.
/// </summary>
/// <param name="bradleyAPC">The Bradley APC attempting to target.</param>
/// <param name="entity">The entity being targeted.</param>
/// <returns>
/// Returns `true` if the Bradley APC can target the entity, and `false` otherwise.
/// If a non-bool value is returned, it will be used as the result instead of this method's default behavior.
/// </returns>
object CanBradleyApcTarget(BradleyAPC bradleyAPC, BaseEntity entity)
{
    Puts($"Bradley APC {bradleyAPC.transform.position} attempting to target {entity.UserIDString} at {entity.transform.position}");
    if (entity == null || !VisibilityTest(entity))
    {
        return false;
    }
    // Additional logic can be added here to determine if the Bradley APC can target the entity
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.transform.position, base.transform.position) < viewDistance))
		{
			return false;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			flag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position, position);
		}
		else
		{
			Debug.LogWarning("Standard vis test!");
			flag = IsVisible(ent.CenterPoint());
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return flag;
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
```csharp
/// <summary>
/// Called to determine if two dropped items can be combined.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>
/// Returns `null` to allow the combination, or any non-null value to prevent it.
/// </returns>
object CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts($"Checking if items {item1.info.name} and {item2.info.name} can be combined.");
    if (item1.info.stackable <= 1 || item2.item == null || item1.info != item2.info || (item2.IsBlueprint() && item2.blueprintTarget != item1.blueprintTarget))
    {
        Puts($"Items cannot be combined due to stackability or blueprint target mismatch.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || item.info.stackable <= 1 || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget))
		{
			return;
		}
		int num = di.item.amount + item.amount;
		if (num <= item.info.stackable && num != 0)
		{
			di.DestroyItem();
			di.Kill();
			item.amount = num;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
		}
	}

```

## OnOpenVendingShop(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player opens a vending shop.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player opening the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingShop(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has opened a vending shop with ID {vendingMachine.id}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player))
		{
			SendSellOrders(msg.player);
			PlayerOpenLoot(msg.player, customerPanel);
			Interface.CallHook("OnOpenVendingShop", this, msg.player);
		}
	}

```

## IOnRunCommandLine()

```csharp
```csharp
/// <summary>
/// Called when the command line is run.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRunCommandLine()
{
    Puts("Command line has been executed.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The console argument.</param>
/// <returns>
/// Returns `true` to allow the command to execute, or `false` to prevent it from executing.
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// If `null` is returned, the default behavior of allowing the command to execute will occur.
/// </returns>
object IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Executing server command: {arg.cmd.FullName}");
    if (arg.Invalid)
    {
        Puts("Invalid argument");
        return "Invalid argument";
    }
    // Add custom logic here
    return null;
}
```
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null)
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## OnGroupCreated(string,string,int)

```csharp
```csharp
/// <summary>
/// Called when a new group is created.
/// </summary>
/// <param name="group">The name of the newly created group.</param>
/// <param name="title">The title of the newly created group.</param>
/// <param name="rank">The rank associated with the newly created group.</param>
/// <returns>No return behavior.</returns>
void OnGroupCreated(string group, string title, int rank)
{
    Puts($"Group {group} with title '{title}' and rank {rank} has been created.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string group, string title, int rank)
	{
		if (GroupExists(group) || string.IsNullOrEmpty(group))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = title,
			Rank = rank
		};
		group = group.ToLower();
		groupdata.Add(group, value);
		Interface.CallHook("OnGroupCreated", group, title, rank);
		return true;
	}

```

## OnUserNameUpdated(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's saved nickname is updated.
/// </summary>
/// <param name="id">The player's ID.</param>
/// <param name="oldName">The player's old nickname.</param>
/// <param name="newName">The player's new nickname.</param>
/// <returns>No return behavior.</returns>
void OnUserNameUpdated(string id, string oldName, string newName)
{
    Puts($"Player's name changed from {oldName} to {newName} for ID {id}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string id, string nickname)
	{
		if (UserExists(id))
		{
			UserData userData = GetUserData(id);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = nickname.Sanitize();
			userData.LastSeenNickname = nickname.Sanitize();
			Interface.CallHook("OnUserNameUpdated", id, lastSeenNickname, obj);
		}
	}

```

## OnGroupRankSet(string,int)

```csharp
```csharp
/// <summary>
/// Called when a group's rank is set.
/// </summary>
/// <param name="group">The name of the group.</param>
/// <param name="rank">The new rank for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupRankSet(string group, int rank)
{
    Puts($"Group {group} has been set to rank {rank}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string group, int rank)
	{
		if (!GroupExists(group))
		{
			return false;
		}
		group = group.ToLower();
		if (!groupdata.TryGetValue(group, out var value))
		{
			return false;
		}
		if (value.Rank == rank)
		{
			return true;
		}
		value.Rank = rank;
		Interface.CallHook("OnGroupRankSet", group, rank);
		return true;
	}

```

## OnGroupTitleSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's title is set.
/// </summary>
/// <param name="group">The name of the group whose title is being changed.</param>
/// <param name="title">The new title for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupTitleSet(string group, string title)
{
    Puts($"Group {group} has been renamed to {title}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string group, string title)
	{
		if (!GroupExists(group))
		{
			return false;
		}
		group = group.ToLower();
		if (!groupdata.TryGetValue(group, out var value))
		{
			return false;
		}
		if (value.Title == title)
		{
			return true;
		}
		value.Title = title;
		Interface.CallHook("OnGroupTitleSet", group, title);
		return true;
	}

```

## OnPermissionRegistered(string,Oxide.Core.Plugins.Plugin)

```csharp
```csharp
/// <summary>
/// Called when a new permission is registered.
/// </summary>
/// <param name="name">The name of the registered permission.</param>
/// <param name="owner">The plugin that registered the permission.</param>
/// <returns>No return behavior.</returns>
void OnPermissionRegistered(string name, Plugin owner)
{
    Puts($"Permission '{name}' has been registered by plugin {owner.Title}");
    if (name == "admin-only")
    {
        Puts($"Warning: Permission '{name}' is reserved for Oxide core plugins.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string name, Plugin owner)
	{
		if (string.IsNullOrEmpty(name))
		{
			return;
		}
		name = name.ToLower();
		if (PermissionExists(name))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", name, owner.Title);
			return;
		}
		if (!permset.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>();
			permset.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(name);
		Interface.CallHook("OnPermissionRegistered", name, owner);
		string text = owner.Name.ToLower() + ".";
		if (!name.StartsWith(text) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", text, name, owner.Title);
		}
	}

```

## OnGroupParentSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's parent is set.
/// </summary>
/// <param name="group">The ID of the group whose parent is being set.</param>
/// <param name="parent">The ID of the new parent group.</param>
/// <returns>No return behavior.</returns>
void OnGroupParentSet(string group, string parent)
{
    Puts($"Group {group} has been assigned a new parent: {parent}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string group, string parent)
	{
		if (!GroupExists(group))
		{
			return false;
		}
		group = group.ToLower();
		if (!groupdata.TryGetValue(group, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parent))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parent) || group.Equals(parent.ToLower()))
		{
			return false;
		}
		parent = parent.ToLower();
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parent))
		{
			return true;
		}
		if (HasCircularParent(group, parent))
		{
			return false;
		}
		value.ParentGroup = parent;
		Interface.CallHook("OnGroupParentSet", group, parent);
		return true;
	}

```

## OnGroupDeleted(string)

```csharp
```csharp
/// <summary>
/// Called when a group is deleted.
/// </summary>
/// <param name="group">The name of the deleted group.</param>
/// <returns>No return behavior.</returns>
void OnGroupDeleted(string group)
{
    Puts($"Group {group} has been deleted.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string group)
	{
		if (!GroupExists(group))
		{
			return false;
		}
		group = group.ToLower();
		bool num = groupdata.Remove(group);
		if (userdata.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(group)))
		{
			SaveUsers();
		}
		if (num)
		{
			Interface.CallHook("OnGroupDeleted", group);
		}
		return true;
	}

```

## OnRconCommand(System.Net.IPEndPoint,string,string[])

```csharp
```csharp
/// <summary>
/// Called when an RCON command is received.
/// </summary>
/// <param name="sender">The IP endpoint of the sender.</param>
/// <param name="commandName">The name of the RCON command being executed.</param>
/// <param name="args">The arguments passed with the RCON command.</param>
/// <returns>
/// Returns `true` to override the default behavior and prevent the command from executing.
/// If `null` is returned, the command will be executed as normal.
/// </returns>
object OnRconCommand(IPEndPoint sender, string commandName, string[] args)
{
    Puts($"Received RCON command '{commandName}' from {sender} with arguments: [{string.Join(", ", args)}]");
    if (args.Length > 0 && args[0].ToLower() == "shutdown")
    {
        Puts("Shutting down the server due to RCON command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconCommand")]
	private object IOnRconCommand(IPEndPoint sender, string command)
	{
		if (sender != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (!string.IsNullOrEmpty(message?.Message))
			{
				string[] array = Oxide.Core.CommandLine.Split(message.Message);
				if (array.Length >= 1)
				{
					string obj = array[0].ToLower();
					string[] obj2 = array.Skip(1).ToArray();
					if (Interface.CallHook("OnRconCommand", sender, obj, obj2) != null)
					{
						return true;
					}
				}
			}
		}
		return null;
	}

```

## OnDestroyUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a UI element is destroyed.
/// </summary>
/// <param name="player">The player whose UI was destroyed.</param>
/// <param name="elem">The ID of the destroyed UI element.</param>
/// <returns>No return behavior.</returns>
void OnDestroyUI(BasePlayer player, string elem)
{
    Puts($"UI for player {player.UserIDString} with ID {elem} has been destroyed.");
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		if (player?.net != null)
		{
			Interface.CallHook("OnDestroyUI", player, elem);
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "DestroyUI", elem);
			return true;
		}
		return false;
	}

```

## OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a user issues a command.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The actual command being executed (e.g. /help, /kick).</param>
/// <param name="args">Any arguments passed with the command (e.g. /kick Player1).</param>
/// <returns>
/// Returns a non-null value to override the default command handling behavior.
/// If `null` is returned, the command will be handled as normal.
/// </returns>
object OnUserCommand(IPlayer player, string command, string[] args)
{
    Puts($"Player {player.Id} issued command: /{command} {string.Join(" ", args)}");
    if (command == "admin" && !player.HasPermission(Permissions.Admin))
    {
        Puts($"Player {player.Id} does not have permission to use the admin command.");
        return "Access denied: You do not have permission to use this command.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(ConsoleSystem.Arg arg)
	{
		string text = arg.GetString(0).Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command == null)
		{
			return;
		}
		BasePlayer basePlayer = arg.Connection.player as BasePlayer;
		IPlayer player = basePlayer?.IPlayer;
		if (player != null)
		{
			object obj = Interface.CallHook("OnPlayerCommand", arg);
			object obj2 = Interface.CallHook("OnUserCommand", player, command, args);
			if (obj == null && obj2 == null && !Covalence.CommandSystem.HandleChatMessage(player, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				player.Reply(string.Format(lang.GetMessage("UnknownCommand", this, player.Id), command));
			}
		}
	}

```

## OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>
/// Returns `null` to allow the player to respawn normally, or any non-null value to override the default respawn behavior.
/// If a string is returned, it will be used as a message to display to the player when they respawn.
/// </returns>
object OnUserRespawn(IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
    if (player.Name == "Admin")
    {
        Puts($"Player {player.Name} is an admin and will not be notified of their respawn.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer player)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.CallHook("OnUserRespawn", iPlayer);
	}

```

## OnEntityTakeDamage(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that took the damage.</param>
/// <param name="info">Information about the hit, including the attacker and damage dealt.</param>
/// <returns>No return behavior.</returns>
void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity.EntityID} took {info.Damage} damage from {info.Attacker.EntityID}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo info)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.CallHook("OnEntityTakeDamage", entity, info);
		}
		return null;
	}

```

## OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user disconnects from the server.
/// </summary>
/// <param name="iPlayer">The IPlayer instance representing the disconnected user.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnUserDisconnected(IPlayer iPlayer, string reason)
{
    Puts($"User {iPlayer.Name} has disconnected from the server with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer player, string reason)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(player);
	}

```

## OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnUserRespawned(IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer player)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", iPlayer);
		}
	}

```

## OnServerInitialized(bool)

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
/// <param name="initialized">Whether the server has been successfully initialized.</param>
/// <returns>No return behavior.</returns>
void OnServerInitialized(bool initialized)
{
    Puts($"Server initialization complete: {initialized}");
    if (!initialized)
    {
        Puts("Error initializing server. Please check logs for details.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			Oxide.Core.Analytics.Collect();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools(that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", serverInitialized);
		}
	}

```

## OnNpcPlayerTarget(BaseEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npcBody">The body of the NPC.</param>
/// <param name="targetPlayer">The player targeted by the NPC.</param>
/// <returns>
/// Returns `true` to override the default behavior and prevent the NPC from targeting the player, or `null` to allow the NPC to target the player as normal.
/// </returns>
object OnNpcPlayerTarget(BaseEntity npcBody, BasePlayer targetPlayer)
{
    Puts($"NPC has targeted player {targetPlayer.UserIDString}.");
    if (targetPlayer.UserID == 123456)
    {
        Puts($"Player with ID {targetPlayer.UserID} is not allowed to be targeted by the NPC.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnHtnNpcPlayerTarget")]
	private object IOnHtnNpcPlayerTarget(IHTNAgent npc, BasePlayer target)
	{
		if (npc != null && Interface.CallHook("OnNpcPlayerTarget", npc.Body, target) != null)
		{
			npc.AiDomain.NpcContext.BaseMemory.Forget(0f);
			npc.AiDomain.NpcContext.BaseMemory.PrimaryKnownEnemyPlayer.PlayerInfo.Player = null;
			return true;
		}
		return null;
	}

```

## OnPlayerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a player issues a command.
/// </summary>
/// <param name="arg">The argument containing the command and its parameters.</param>
/// <returns>
/// Returns `null` to allow the command to be handled normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the response to the player's command.
/// </returns>
object OnPlayerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Player {arg.Connection.player.UserIDString} issued the command: /{arg.GetString(0)}");
    if (arg.GetString(0) == "kick")
    {
        Puts($"Player {arg.Connection.player.displayName} is not allowed to use the kick command.");
        return "You do not have permission to use this command.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(ConsoleSystem.Arg arg)
	{
		string text = arg.GetString(0).Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command == null)
		{
			return;
		}
		BasePlayer basePlayer = arg.Connection.player as BasePlayer;
		IPlayer player = basePlayer?.IPlayer;
		if (player != null)
		{
			object obj = Interface.CallHook("OnPlayerCommand", arg);
			object obj2 = Interface.CallHook("OnUserCommand", player, command, args);
			if (obj == null && obj2 == null && !Covalence.CommandSystem.HandleChatMessage(player, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				player.Reply(string.Format(lang.GetMessage("UnknownCommand", this, player.Id), command));
			}
		}
	}

```

## CanUserLogin(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user attempts to login.
/// </summary>
/// <param name="username">The username of the user attempting to login.</param>
/// <param name="steamId">The Steam ID of the user attempting to login.</param>
/// <param name="ipAddress">The IP address of the user attempting to login.</param>
/// <returns>
/// Returns a non-null value to override the default login behavior. 
/// If `true` is returned, the user will be allowed to login.
/// If `false` or a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object CanUserLogin(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} is attempting to login.");
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from logging in.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		if (obj2 == null)
		{
			obj2 = obj3;
		}
		object obj4 = obj2;
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object obj6 = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 == null)
		{
			obj5 = obj6;
		}
		return obj5;
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

```

## CanClientLogin(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client attempts to login.
/// </summary>
/// <param name="connection">The client's connection information.</param>
/// <returns>
/// Returns `true` to reject the client's login attempt, or `false` to allow it. 
/// If a string is returned, the client will be kicked with the provided message as the reason.
/// </returns>
object CanClientLogin(Network.Connection connection)
{
    Puts($"Client {connection.username} has attempted to login.");
    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"Client {connection.username} from IP {connection.ipaddress} has been blocked from logging in.");
        return "Blocked: Unauthorized IP address.";
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		if (obj2 == null)
		{
			obj2 = obj3;
		}
		object obj4 = obj2;
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object obj6 = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 == null)
		{
			obj5 = obj6;
		}
		return obj5;
	}

```

## OnUserBanned(string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is banned from the server.
/// </summary>
/// <param name="name">The username of the banned user.</param>
/// <param name="steamId">The Steam ID of the banned user.</param>
/// <param name="ipAddress">The IP address of the banned user.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string name, string steamId, string ipAddress, string reason)
{
    Puts($"User {name} with SteamID {steamId}, IP {ipAddress} has been banned: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

```

## OnNpcPlayerTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC player targets a base entity.
/// </summary>
/// <param name="npc">The NPC player apex.</param>
/// <param name="target">The base entity being targeted.</param>
/// <returns>
/// Returns `null` to allow the NPC player to target the entity, or any non-null value to prevent them from targeting it.
/// If a float is returned, it will be used as a priority override for the targetting behavior.
/// </returns>
object OnNpcPlayerTarget(NPCPlayerApex npc, BaseEntity target)
{
    Puts($"NPC {npc.EntityId} has targeted entity {target.EntityId}");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"NPC {npc.EntityId} cannot target admin player {player.UserIDString}");
        return 1f;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcPlayerTarget")]
	private object IOnNpcPlayerTarget(NPCPlayerApex npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcPlayerTarget", npc, target) != null)
		{
			return 0f;
		}
		return null;
	}

```

## OnPlayerChat(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="arg">The argument containing the chat message and other information.</param>
/// <returns>
/// Returns `null` to allow the chat message to be sent as normal, or any non-null value to prevent the chat message from being sent.
/// If a string is returned, it will be displayed in the chat log instead of the original message.
/// </returns>
object OnPlayerChat(ConsoleSystem.Arg arg)
{
    Puts($"Player {arg.Connection.player.UserIDString} sent chat message: {arg.GetString(0).Trim()}");
    if (arg.GetString(0).Trim().Contains("badword"))
    {
        Puts($"Player {arg.connection.player.displayName} used a bad word in their chat message.");
        return "Bad language detected.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ConsoleSystem.Arg arg)
	{
		string text = arg.GetString(0).Trim();
		if (string.IsNullOrEmpty(text))
		{
			return true;
		}
		IPlayer player = (arg.Connection.player as BasePlayer)?.IPlayer;
		if (player == null)
		{
			return null;
		}
		object obj = Interface.CallHook("OnPlayerChat", arg);
		object obj2 = Interface.CallHook("OnUserChat", player, text);
		if (obj == null)
		{
			obj = obj2;
		}
		return obj;
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a base entity.
/// </summary>
/// <param name="npc">The NPC that is targeting.</param>
/// <param name="target">The entity being targeted by the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the entity, or any non-null value to prevent the NPC from targeting.
/// If a float is returned, it will be used as the range at which the NPC will attack the target.
/// </returns>
object OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} has targeted entity {target.UserIDString}");
    if (target is Player player && player.IsSpectator())
    {
        Puts($"NPC {npc.name} will not attack spectator {player.UserIDString}");
        return 5f;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcTarget", npc, target) != null)
		{
			npc.SetFact(BaseNpc.Facts.HasEnemy, 0);
			npc.SetFact(BaseNpc.Facts.EnemyRange, 3);
			npc.SetFact(BaseNpc.Facts.AfraidRange, 1);
			return 0f;
		}
		return null;
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The IPlayer object representing the kicked user.</param>
/// <param name="reason">The reason for kicking the user.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(IPlayer player, string reason)
{
    Puts($"User {player.Name} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer player, string reason)
	{
		if (player.IPlayer != null)
		{
			Interface.CallHook("OnUserKicked", player.IPlayer, reason);
		}
	}

```

## OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user connects to the server.
/// </summary>
/// <param name="player">The IPlayer object representing the connected user.</param>
/// <returns>No return behavior.</returns>
void OnUserConnected(IPlayer player)
{
    Puts($"User {player.Name} has connected to the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerInit")]
	private void OnPlayerInit(BasePlayer player)
	{
		lang.SetLanguage(player.net.connection.info.GetString("global.language", "en"), player.UserIDString);
		Covalence.PlayerManager.PlayerConnected(player);
		IPlayer player2 = Covalence.PlayerManager.FindPlayerById(player.UserIDString);
		if (player2 != null)
		{
			player.IPlayer = player2;
			Interface.CallHook("OnUserConnected", player2);
		}
	}

```

## OnNpcPlayerTarget(NPCPlayerApex,BasePlayer)

```csharp
Here's the code with a hook method added:

```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC that targeted the player.</param>
/// <param name="player">The player who was targeted.</param>
/// <returns>
/// Returns `true` to prevent the player from being sensed by the NPC, or `null` to allow the player to be sensed.
/// </returns>
object OnNpcPlayerTarget(NPCPlayerApex npc, BasePlayer player)
{
    Puts($"NPC {npc.UserIDString} targeted player {player.UserIDString}");
    // Add custom logic here if needed
    return null;
}
```

You can call this hook method from the `GetPlayersSensed` function like so:

```csharp
object obj = (((UnityEngine.Object)(object)basePlayer != null && (UnityEngine.Object)(object)npc != null && (UnityEngine.Object)(object)basePlayer != (UnityEngine.Object)(object)npc) ? Interface.CallHook("OnNpcPlayerTarget", npc, basePlayer) : null);
```

This will allow you to customize the behavior of NPCs targeting players.
```

### Source Code from the Library

```csharp

	private int GetPlayersSensed(NPCPlayerApex npc, Vector3 position, float distance, BaseEntity[] targetList)
	{
		return BaseEntity.Query.Server.GetInSphere(position, distance, targetList, delegate(BaseEntity entity)
		{
			BasePlayer basePlayer = entity as BasePlayer;
			object obj = (((UnityEngine.Object)(object)basePlayer != null && (UnityEngine.Object)(object)npc != null && (UnityEngine.Object)(object)basePlayer != (UnityEngine.Object)(object)npc) ? Interface.CallHook("OnNpcPlayerTarget", npc, basePlayer) : null);
			if (obj != null)
			{
				foreach (Memory.SeenInfo item in npc.AiContext.Memory.All)
				{
					if ((UnityEngine.Object)(object)item.Entity == (UnityEngine.Object)(object)basePlayer)
					{
						npc.AiContext.Memory.All.Remove(item);
						break;
					}
				}
				foreach (Memory.ExtendedInfo item2 in npc.AiContext.Memory.AllExtended)
				{
					if ((UnityEngine.Object)(object)item2.Entity == (UnityEngine.Object)(object)basePlayer)
					{
						npc.AiContext.Memory.AllExtended.Remove(item2);
						break;
					}
				}
			}
			return (UnityEngine.Object)(object)basePlayer != null && obj == null && basePlayer.isServer && !basePlayer.IsSleeping() && !basePlayer.IsDead() && basePlayer.Family != npc.Family;
		});
	}

```

## OnLoseCondition(object[])

```csharp
```csharp
/// <summary>
/// Called when an item loses a certain amount of condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>No return behavior.</returns>
void OnLoseCondition(object[] args)
{
    Item item = (Item)args[0];
    float amount = (float)args[1];
    Puts($"Item {item.name} has lost {amount} condition.");
    if (item.condition <= 0f && item.condition < ((Item)item).condition)
    {
        Puts($"Item {item.name} is now broken.");
        item.OnBroken();
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

```

## OnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The argument containing information about the command.</param>
/// <returns>
/// Returns `null` to allow the command to execute normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the response to the command. 
/// If `true` is returned, the command will be executed with its original parameters.
/// </returns>
object OnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Server command '{arg.cmd.FullName}' has been executed.");
    if (arg.cmd.FullName == "admin.say")
    {
        Puts($"Admin-only command '{arg.cmd.FullName}' has been executed by {arg.Player().Name}.");
        return "This is a secret message.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && (UnityEngine.Object)(object)arg.Player() == null))
		{
			return true;
		}
		if (!(arg.cmd.FullName != "chat.say"))
		{
			return null;
		}
		return Interface.CallHook("OnServerCommand", arg);
	}

```

## OnPlayerBanned(string,ulong,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="name">The name of the banned player.</param>
/// <param name="steamId">The Steam ID of the banned player.</param>
/// <param name="ipAddress">The IP address of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string name, ulong steamId, string ipAddress, string reason)
{
    Puts($"Player {name} with SteamID {steamId} and IP {ipAddress} has been banned: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

```

## OnEntityTakeDamage(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity (in this case, a player) takes damage.
/// </summary>
/// <param name="entity">The entity taking the damage.</param>
/// <param name="info">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns `true` to allow the entity to take the damage, or any non-null value to prevent them from taking the damage.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnEntityTakeDamage(BasePlayer entity, HitInfo info)
{
    Puts($"Entity {entity.UserIDString} took {info.damageType} damage from {info.attacker.UserIDString}.");
    if (info.damageType == "explosive")
    {
        Puts($"Entity {entity.UserIDString} was damaged by an explosive device.");
        return "You were hit by a grenade!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer player, HitInfo info)
	{
		if (!serverInitialized || (UnityEngine.Object)(object)player == null || info == null || player.IsDead() || isPlayerTakingDamage || player is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", player, info) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			player.OnAttacked(info);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

```

## OnUserApproved(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="username">The username of the approved user.</param>
/// <param name="steamId">The Steam ID of the approved user.</param>
/// <param name="ipAddress">The IP address of the approved user.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object OnUserApproved(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been approved to join the server.");
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    // Additional logic can be added here, for example:
    // if (username.Contains("admin"))
    // {
    //     Puts($"User {username} is an admin and will be approved as normal.");
    //     return null;
    // }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		if (obj2 == null)
		{
			obj2 = obj3;
		}
		object obj4 = obj2;
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object obj6 = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 == null)
		{
			obj5 = obj6;
		}
		return obj5;
	}

```

## OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The text of the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be broadcast as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for suppressing the message.
/// </returns>
object OnUserChat(IPlayer player, string message)
{
    Puts($"Player {player.Name} sent chat message: {message}");
    if (message.ToLower() == "test")
    {
        Puts($"Player {player.Name} is testing the chat system.");
        return "Test message suppressed.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ConsoleSystem.Arg arg)
	{
		string text = arg.GetString(0).Trim();
		if (string.IsNullOrEmpty(text))
		{
			return true;
		}
		IPlayer player = (arg.Connection.player as BasePlayer)?.IPlayer;
		if (player == null)
		{
			return null;
		}
		object obj = Interface.CallHook("OnPlayerChat", arg);
		object obj2 = Interface.CallHook("OnUserChat", player, text);
		if (obj == null)
		{
			obj = obj2;
		}
		return obj;
	}

```

## CanUseUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the UI.
/// </summary>
/// <param name="player">The player attempting to use the UI.</param>
/// <param name="json">The JSON data related to the UI.</param>
/// <returns>
/// Returns `null` to allow the player to use the UI, or any non-null value to prevent them from using it.
/// </returns>
object CanUseUI(BasePlayer player, string json)
{
    Puts($"Player {player.UserIDString} is attempting to use the UI with JSON: {json}");
    if (json == "restricted")
    {
        Puts($"Player {player.displayName} does not have permission to use the restricted UI.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AddUi(BasePlayer player, string json)
	{
		if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
		{
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "AddUI", json);
			return true;
		}
		return false;
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned player.</param>
/// <param name="steamId">The Steam ID of the unbanned player.</param>
/// <param name="ipAddress">The IP address of the unbanned player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} with SteamID {steamId} and IP {ipAddress} has been unbanned.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

```

## OnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="connection">The connection object for the user being approved.</param>
/// <returns>
/// Returns `null` to allow the default approval behavior, or a non-null value to override it. 
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object OnUserApprove(Connection connection)
{
    Puts($"User {connection.username} has been approved to join the server.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		if (obj2 == null)
		{
			obj2 = obj3;
		}
		object obj4 = obj2;
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object obj6 = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 == null)
		{
			obj5 = obj6;
		}
		return obj5;
	}

```

## CanPickupEntity(BasePlayer,DoorCloser)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pickup an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanPickupEntity(BasePlayer player, DoorCloser entity)
{
    Puts($"Player {player.UserIDString} attempting to pick up {entity.GetType().Name}");
    if (entity.IsLocked)
    {
        Puts($"Player {player.displayName} cannot pick up locked {entity.GetType().Name}");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer player, DoorCloser entity)
	{
		object obj;
		bool flag = default(bool);
		int num;
		if ((obj = Interface.CallHook("CanPickupEntity", player, entity)) is bool)
		{
			flag = (bool)obj;
			num = 1;
		}
		else
		{
			num = 0;
		}
		if (((uint)num & (flag ? 1u : 0u)) == 0)
		{
			return null;
		}
		return true;
	}

```

