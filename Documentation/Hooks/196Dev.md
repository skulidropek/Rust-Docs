# Hook Definitions

## OnPlayerRecover(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecover(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered from being wounded.");
}
```
```

### Source Code from the Library

```csharp

	public void StopWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			CancelInvoke(WoundingTick);
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is finished.
/// </summary>
/// <param name="task">The ItemCraftTask that was completed.</param>
/// <param name="item">The crafted item.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If null, the item will be added to the player's inventory as normal.
/// </returns>
object OnItemCraftFinished(ItemCraftTask task, Item item)
{
    Puts($"Item crafting task {task.taskUID} has been completed.");
    if (item.info.itemid == 12345)
    {
        Puts($"Item with ID {item.info.itemid} has been flagged for special handling.");
        return "Special handling required.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong num = 0uL;
		Facepunch.Steamworks.Inventory.Definition definition = Rust.Global.SteamServer.Inventory.FindDefinition(task.skinID);
		if (definition != null)
		{
			num = definition.GetProperty<ulong>("workshopdownload");
		}
		if (num == 0)
		{
			num = (ulong)task.skinID;
		}
		Item item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, num);
		item.amount = task.blueprint.amountToCreate;
		if (item.hasCondition && task.conditionScale != 1f)
		{
			item.maxCondition *= task.conditionScale;
			item.condition = item.maxCondition;
		}
		item.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num2 = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int amount = takenItem.amount;
					int num3 = Mathf.Min(amount, num2);
					takenItem.UseItem(num2);
					num2 -= num3;
				}
				if (num2 > 0)
				{
				}
			}
		}
		Facepunch.Rust.Analytics.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		task.owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item);
		item.instanceData = task.instanceData;
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			task.owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		if (task.owner.inventory.GiveItem(item))
		{
			task.owner.Command("note.inv", item.info.itemid, item.amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		task.owner.Command("note.inv", item.info.itemid, item.amount);
		task.owner.Command("note.inv", item.info.itemid, -item.amount);
		item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnServerShutdown(unknown)

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerShutdown()
{
    Puts("Server shutdown initiated.");
    // No specific action needed for this hook, as it's primarily used to notify other scripts of the shutdown.
}
```
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("OnServerShutdown", null);
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		foreach (BasePlayer basePlayer in array)
		{
			basePlayer.Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## OnSignUpdated(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated.
/// </summary>
/// <param name="sign">The signage that was updated.</param>
/// <param name="player">The player who performed the update.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.SignID} has been updated by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void UpdateSign(RPCMessage msg)
	{
		if (CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null)
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				textureID = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				Interface.CallHook("OnSignUpdated", this, msg.player);
				SendNetworkUpdate();
			}
		}
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if a target can be targeted by the auto turret.
/// </summary>
/// <param name="target">The target entity.</param>
/// <param name="autoTurret">The auto turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BaseCombatEntity target, AutoTurret autoTurret)
{
    Puts($"Checking if {target} can be targeted by {autoTurret}.");
    // Custom logic to determine if the target can be targeted
    // For example:
    if (target == null || target.IsDead())
    {
        return false;
    }
    // ...
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.GetList<RaycastHit>();
		Vector3 position = eyePos.transform.position;
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 normalized = (vector - position).normalized;
		Vector3 vector2 = Vector3.Cross(normalized, Vector3.up);
		for (int i = 0; i < 3; i++)
		{
			Vector3 vector3 = vector + vector2 * visibilityOffsets[i];
			Vector3 normalized2 = (vector3 - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized2), 0f, obj3, num * 1.1f, 1084434689);
			for (int j = 0; j < obj3.Count; j++)
			{
				RaycastHit hit = obj3[j];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == obj || entity.EqualNetID(obj)))
				{
					Facepunch.Pool.FreeList(ref obj3);
					return true;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj3);
		return false;
	}

```

## OnReloadWeapon(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player starts reloading their weapon.
/// </summary>
/// <param name="player">The player starting to reload.</param>
/// <param name="projectile">The projectile being reloaded, if applicable.</param>
/// <returns>
/// Returns `null` to allow the player to start reloading, or any non-null value to prevent them from reloading.
/// </returns>
object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} started reloading their weapon.");
    if (projectile != null && projectile.ammoType == "rare")
    {
        Puts($"Player {player.displayName} is trying to reload a rare ammo type. Reloading cancelled.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnReloadWeapon", player, this) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			StartReloadCooldown(reloadTime);
		}
	}

```

## OnItemDeployed(Deployer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is deployed on a base entity.
/// </summary>
/// <param name="deployer">The deployable item that was used to deploy the entity.</param>
/// <param name="baseEntity">The base entity where the item was deployed.</param>
object OnItemDeployed(Deployable deployer, BaseEntity baseEntity)
{
    Puts($"Item {deployer.name} has been deployed on {baseEntity.displayName}");
    if (baseEntity is BaseBuilding && ((BaseBuilding)baseEntity).GetSlot(deployer.slot) != null)
    {
        Puts($"Slot {deployer.slot} on {baseEntity.displayName} already occupied");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || !ownerPlayer.CanBuild())
		{
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity);
		UseItemAmount(1);
	}

```

## IOnPlayerChat(ConsoleSystem.Arg)

```csharp
Here is the method structure for `IOnPlayerChat(ConsoleSystem.Arg)`:

```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="arg">The console argument containing the chat message.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. 
/// If a string is returned, the player will be kicked with the provided message as the reason. 
/// If `null` is returned, the chat message is processed normally.
/// </returns>
object IOnPlayerChat(ConsoleSystem.Arg arg)
{
    // Minimal code to demonstrate functionality
    Puts("IOnPlayerChat called!");
    
    // Return a non-null value to override the default chat behavior
    return null;
}
```

Note that this method structure assumes that `Interface.CallHook` is used in the context, and the return type is determined based on how the return value (`obj`) is used. In this case, since no specific usage of the return value is mentioned, we assume a default return type of `object`.
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!basePlayer || basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper)
		{
			if (basePlayer.NextChatTime == 0f)
			{
				basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup - 30f;
			}
			if (basePlayer.NextChatTime > UnityEngine.Time.realtimeSinceStartup)
			{
				basePlayer.NextChatTime += 2f;
				float num = basePlayer.NextChatTime - UnityEngine.Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(basePlayer.net.connection, "chat.add", 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					basePlayer.Kick("Chatting too fast");
				}
				return;
			}
		}
		string text = arg.GetString(0, "text").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0 || Interface.CallHook("IOnPlayerChat", arg) != null || text.StartsWith("/") || text.StartsWith("\\") || (text.Contains("<") && (StringEx.Contains(text, "<size", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<color", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<material", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<quad", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<b>", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<i>", CompareOptions.IgnoreCase))))
		{
			return;
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured(ConsoleColor.DarkYellow, basePlayer.displayName + ": ", ConsoleColor.DarkGreen, text);
			DebugEx.Log($"[CHAT] {basePlayer.ToString()} : {text}", StackTraceLogType.None);
		}
		string text2 = "#5af";
		if (basePlayer.IsAdmin)
		{
			text2 = "#af5";
		}
		if (basePlayer.IsDeveloper)
		{
			text2 = "#fa5";
		}
		string displayName = basePlayer.displayName;
		displayName = displayName.Replace('<', '[').Replace('>', ']');
		basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup + 1.5f;
		ChatEntry chatEntry = default(ChatEntry);
		chatEntry.Message = text;
		chatEntry.UserId = basePlayer.userID;
		chatEntry.Username = basePlayer.displayName;
		chatEntry.Color = text2;
		chatEntry.Time = Epoch.Current;
		ChatEntry chatEntry2 = chatEntry;
		History.Add(chatEntry2);
		RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		if (Server.globalchat)
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add2", basePlayer.userID, text, displayName, text2, 1f);
			arg.ReplyWith(string.Empty);
			return;
		}
		float num2 = 2500f;
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			float sqrMagnitude = (activePlayer.transform.position - basePlayer.transform.position).sqrMagnitude;
			if (!(sqrMagnitude > num2))
			{
				ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", basePlayer.userID, text, displayName, text2, Mathf.Clamp01(num2 - sqrMagnitude + 0.2f));
			}
		}
		arg.ReplyWith(string.Empty);
	}

```

## OnDoorKnocked(Door,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a door is knocked.
/// </summary>
/// <param name="door">The door that was knocked.</param>
/// <param name="player">The player who knocked the door.</param>
/// <returns>No return behavior.</returns>
void OnDoorKnocked(BaseEntity door, BasePlayer player)
{
    Puts($"Door {door.name} has been knocked by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_KnockDoor(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && knockEffect.isValid && !(UnityEngine.Time.realtimeSinceStartup < nextKnockTime))
		{
			nextKnockTime = UnityEngine.Time.realtimeSinceStartup + 0.5f;
			Effect.server.Run(knockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnDoorKnocked", this, rpc.player);
		}
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base player is hurt.
/// </summary>
/// <param name="basePlayer">The base player being hurt.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the base player's normal hurt logic will be executed.
/// </returns>
object IOnBasePlayerHurt(BasePlayer basePlayer, HitInfo hitInfo)
{
    Puts($"Base player {basePlayer} has been hurt by {hitInfo.Initiator} with damage type {hitInfo.damageTypes.GetMajorityDamageType()}");
    if (hitInfo.Initiator is BasePlayer && hitInfo.Initiator != basePlayer)
    {
        return "PvE mode enabled, returning damage to initiator";
    }
    // Additional logic can be added here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || IsImmortal() || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			basePlayer.Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		base.Hurt(info);
		if (EACServer.playerTracker != null && info.Initiator != null && info.Initiator is BasePlayer)
		{
			BasePlayer basePlayer2 = info.Initiator.ToPlayer();
			if (net.connection != null && basePlayer2.net.connection != null)
			{
				EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
				EasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(basePlayer2.net.connection);
				PlayerTakeDamage eventParams = default(PlayerTakeDamage);
				eventParams.DamageTaken = (int)info.damageTypes.Total();
				eventParams.HitBoneID = (int)info.HitBone;
				eventParams.WeaponID = 0;
				if (info.Weapon != null)
				{
					Item item = info.Weapon.GetItem();
					if (item != null)
					{
						eventParams.WeaponID = item.info.itemid;
					}
				}
				UnityEngine.Vector3 position = basePlayer2.eyes.position;
				UnityEngine.Vector3 eulerAngles = basePlayer2.eyes.rotation.eulerAngles;
				UnityEngine.Vector3 position2 = eyes.position;
				UnityEngine.Vector3 eulerAngles2 = eyes.rotation.eulerAngles;
				eventParams.AttackerPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position.x, position.y, position.z);
				eventParams.AttackerViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(eulerAngles.x, eulerAngles.y, eulerAngles.z);
				eventParams.VictimPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position2.x, position2.y, position2.z);
				eventParams.VictimViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
				EACServer.playerTracker.LogPlayerTakeDamage(client, client2, eventParams);
			}
		}
		metabolism.SendChangesToClient();
		if (info.PointStart != UnityEngine.Vector3.zero)
		{
			ClientRPCPlayer(null, this, "DirectionalDamage", info.PointStart, (int)info.damageTypes.GetMajorityDamageType());
		}
	}

```

## OnCreateWorldProjectile(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="hitInfo">Information about the hit that triggered the projectile creation.</param>
/// <param name="item">The item definition of the projectile.</param>
/// <returns>
/// Returns `null` to allow the projectile to be created as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for rejecting the projectile creation.
/// </returns>
object OnCreateWorldProjectile(HitInfo hitInfo, ItemDefinition item)
{
    Puts($"Creating world projectile at {hitInfo.HitPositionWorld} with item {item.Name}.");
    if (hitInfo.HitEntity != null && hitInfo.HitEntity.GetComponent<Rigidbody>() == null)
    {
        return "Rejected: Entity does not have a rigidbody.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem == null) ? ItemManager.Create(itemDef, 1, 0uL) : recycleItem);
		BaseEntity baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		if (!info.DidHit)
		{
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			if (info.HitEntity == null)
			{
				component.isKinematic = true;
				return;
			}
			Quaternion localRotation = ((info.HitBone != 0) ? Quaternion.LookRotation(info.HitNormalLocal * -1f) : Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)));
			component.isKinematic = true;
			baseEntity.SetParent(info.HitEntity, info.HitBone);
			baseEntity.transform.localPosition = info.HitPositionLocal;
			baseEntity.transform.localRotation = localRotation;
		}
		else
		{
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## OnRconConnection(unknown)

```csharp
```csharp
/// <summary>
/// Called when an RCON connection is established.
/// </summary>
/// <param name="connection">The RCON connection.</param>
/// <returns>
/// Returns `null` to allow the connection, or any non-null value to reject the connection.
/// If a string is returned, the client will be kicked with the provided message as the reason.
/// </returns>
object OnRconConnection(Socket connection)
{
    Puts("RCON connection established.");
    if (connection.RemoteEndPoint.Address.ToString() == "192.168.1.1")
    {
        Puts("Rejecting RCON connection from banned IP.");
        return "Banned: Unauthorized IP address.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", null) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine admin menu is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <param name="player">The player opening the admin menu.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} opened admin menu for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			SendSellOrders(player);
			PlayerOpenLoot(player);
			ClientRPCPlayer(null, player, "CLIENT_OpenAdminMenu");
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## OnPlayerInput(BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player's input is received.
/// </summary>
/// <param name="player">The player whose input is being processed.</param>
/// <param name="inputState">The current state of the player's input.</param>
/// <returns>
/// Returns `null` to allow the default behavior to occur. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnPlayerInput(BasePlayer player, InputState inputState)
{
    Puts($"Player {player.UserIDString} has received new input.");
    // Add custom logic here if needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null || Interface.CallHook("OnPlayerInput", this, serverInput) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can use napalm.
/// </summary>
/// <param name="helicopter">The helicopter in question.</param>
/// <returns>
/// Returns `true` if the helicopter can use napalm, and `false` otherwise.
/// If `null` is returned, the default behavior will be to allow the helicopter to use napalm after a 30-second cooldown period.
/// </returns>
bool CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter {helicopter.GetReference().name} can use napalm.");
    object obj = Interface.CallHook("CanHelicopterUseNapalm", helicopter);
    if (obj is bool)
    {
        return (bool)obj;
    }
    else if (obj == null)
    {
        Puts($"Helicopter {helicopter.GetReference().name} cannot use napalm at this time.");
        return false;
    }
    else
    {
        Puts($"Helicopter {helicopter.GetReference().name} is not allowed to use napalm by default.");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to disarm a trap.
/// </summary>
/// <param name="landmine">The landmine being disarmed.</param>
/// <param name="player">The player attempting to disarm the landmine.</param>
/// <returns>
/// Returns `null` to allow the player to disarm the landmine, or any non-null value to prevent them from disarming it.
/// </returns>
object OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to disarm landmine at location {landmine.transform.position}");
    if (player.HasFlag(Flags.Admin))
    {
        Puts($"Player {player.displayName} is an admin and can't be prevented from disarming the landmine.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if (rpc.player.net.ID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			int num = UnityEngine.Random.Range(0, 100);
			if (num < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when the item loses a certain amount of condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>
/// Returns `null` to allow the item to lose condition, or any non-null value to prevent it from losing condition.
/// If a string is returned, the item will be destroyed with the provided message as the reason.
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Item {item.info.shortname} lost {amount} condition.");
    if (amount > 0.5f)
    {
        Puts($"Item {item.info.shortname} has been severely damaged.");
        return "Destroyed: Excessive damage.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## CanMountEntity(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is mounted by a player.
/// </summary>
/// <param name="entity">The entity being mounted.</param>
/// <param name="player">The player mounting the entity.</param>
/// <returns>
/// Returns `null` to allow the entity to be mounted, or any non-null value to prevent it from being mounted.
/// </returns>
object CanMountEntity(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to mount {entity.name}");
    if (entity.IsBroken())
    {
        Puts($"Cannot mount {entity.name} because it's broken");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && Interface.CallHook("CanMountEntity", this, player) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			player.MountObject(this);
			player.MovePosition(mountAnchor.transform.position);
			player.transform.rotation = mountAnchor.transform.rotation;
			player.ServerRotation = mountAnchor.transform.rotation;
			player.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			SetFlag(Flags.Busy, b: true);
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after falling.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallDistance">The distance the player fell.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLand(BasePlayer player, float fallDistance)
{
    Puts($"Player {player.UserIDString} landed after falling from a height of {fallDistance} units.");
    if (fallDistance > 50f)
    {
        Puts($"Player {player.displayName} suffered severe injuries from the fall.");
        // Apply additional damage or effects here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (float.IsNaN(num) || float.IsInfinity(num))
		{
			return;
		}
		float num2 = Mathf.InverseLerp(-15f, -100f, num);
		if (num2 != 0f && Interface.CallHook("OnPlayerLand", this, num2) == null)
		{
			metabolism.bleeding.Add(num2 * 0.5f);
			float num3 = num2 * 500f;
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num2);
		}
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an item.
/// </summary>
/// <param name="player">The player starting to loot the item.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} started looting item: {item.name}");
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			MarkDirty();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
		}
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player's looting session ends.
/// </summary>
/// <param name="playerLoot">The PlayerLoot object associated with the ended looting session.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot playerLoot)
{
    Puts($"Player {playerLoot.Player.UserIDString} has finished looting.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		containers.Clear();
		entitySource = null;
		itemSource = null;
	}

```

## CanAssignBed(SleepingBag,BasePlayer,ulong)

```csharp
```csharp
/// <summary>
/// Called to check if a bed can be assigned to a player.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being considered for assignment.</param>
/// <param name="player">The player who would be using the sleeping bag.</param>
/// <param name="bedId">The ID of the bed being considered for assignment.</param>
/// <returns>
/// Returns `null` to allow the bed to be assigned, or any non-null value to prevent it from being assigned.
/// </returns>
object CanAssignBed(SleepingBag sleepingBag, BasePlayer player, ulong bedId)
{
    Puts($"Checking if bed {bedId} can be assigned to player {player.UserIDString}");
    // If the bed is already occupied by another player, return a non-null value to prevent assignment
    if (sleepingBag.IsOccupied())
    {
        Puts($"Bed {bedId} is already occupied by another player");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void AssignToFriend(RPCMessage msg)
	{
		if (msg.player.CanInteract() && deployerUserID == msg.player.userID)
		{
			ulong num = msg.read.UInt64();
			if (num != 0 && Interface.CallHook("CanAssignBed", this, msg.player, num) == null)
			{
				deployerUserID = num;
				SendNetworkUpdate();
			}
		}
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a rocket is launched.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="rocket">The launched rocket entity.</param>
object OnRocketLaunched(BasePlayer player, BaseEntity rocket)
{
    Puts($"Player {player.UserIDString} launched a rocket.");
    if (rocket != null)
    {
        // Perform any necessary actions when the rocket is launched
        return rocket;
    }
    else
    {
        // Handle the case where the rocket was not successfully created
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "magazine_empty");
			return;
		}
		primaryMagazine.contents--;
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		if (!ValidateEyePos(player, vector))
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Eye position (" + base.ShortPrefabName + ")");
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		float num = GetAimCone() + component.projectileSpread;
		if (num > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num, vector2);
		}
		float num2 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num2, 1101212417))
		{
			num2 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num2);
		if (!(baseEntity == null))
		{
			baseEntity.creatorEntity = player;
			baseEntity.SendMessage("InitializeVelocity", vector2 * 1f);
			baseEntity.Spawn();
			Interface.CallHook("OnRocketLaunched", msg.player, baseEntity);
			StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
			GetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));
		}
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret authorizes a player.
/// </summary>
/// <param name="turret">The AutoTurret that authorized the player.</param>
/// <param name="player">The BasePlayer who was authorized by the turret.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent the authorization.
/// </returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.name} has authorized player {player.displayName}");
    if (player.UserIDString == "admin")
    {
        Puts($"Player {player.displayName} is already authorized by the turret.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!IsOnline() && Interface.CallHook("OnTurretAuthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = rpc2.player.userID;
			playerNameID.username = rpc2.player.displayName;
			authorizedPlayers.Add(playerNameID);
			SendNetworkUpdate();
		}
	}

```

## OnItemSplit(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is being split into smaller quantities.
/// </summary>
/// <param name="item">The item being split.</param>
/// <param name="splitAmount">The amount to split the item by.</param>
/// <returns>
/// Returns a new `Item` object if the split should be overridden, or `null` to allow the default splitting behavior.
/// </returns>
object OnItemSplit(Item item, int splitAmount)
{
    Puts($"Item {item.info.itemid} is being split into {splitAmount} pieces.");
    if (splitAmount == 1)
    {
        return null;
    }
    // If you want to override the default splitting behavior, return a new Item object here.
    return null;
}
```
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		MarkDirty();
		return item;
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player ends spectating.
/// </summary>
/// <param name="player">The player ending spectation.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to end spectating normally. 
/// If any non-null value is returned, it will override the default behavior and prevent the player from ending spectation.
/// </returns>
object OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} ended spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to end spectation with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## CanLock(CodeLock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player tries to lock the code.
/// </summary>
/// <param name="codeLock">The CodeLock object being locked.</param>
/// <param name="player">The player attempting to lock the code.</param>
/// <returns>
/// Returns `null` to allow the player to lock the code, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(CodeLock codeLock, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to lock the code.");
    if (player.userID == 123456) // Example: Prevent a specific user from locking the code
    {
        Puts($"Player {player.displayName} is not allowed to lock the code.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", this, rpc.player) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnItemScrap(ResearchTable,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is scrapped for research.
/// </summary>
/// <param name="researchTable">The research table being used.</param>
/// <param name="item">The item being scrapped.</param>
/// <returns>
/// Returns the number of scraps obtained from scrapping the item. If `null` is returned, the default scrap value will be used.
/// </returns>
object OnItemScrap(ResearchTable researchTable, Item item)
{
    Puts($"Item {item.info.name} has been scrapped for research on table {researchTable.name}");
    if (item.info.rarity == Rarity.VeryRare)
    {
        return 1000;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnItemScrap", this, item);
		if (obj is int)
		{
			return (int)obj;
		}
		int result = 0;
		if (item.info.rarity == Rarity.Common)
		{
			result = 20;
		}
		if (item.info.rarity == Rarity.Uncommon)
		{
			result = 75;
		}
		if (item.info.rarity == Rarity.Rare)
		{
			result = 250;
		}
		if (item.info.rarity == Rarity.VeryRare || item.info.rarity == Rarity.None)
		{
			result = 750;
		}
		return result;
	}

```

## CanCraft(PlayerBlueprints,ItemDefinition,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can craft an item.
/// </summary>
/// <param name="player">The player attempting to craft the item.</param>
/// <param name="itemDefinition">The definition of the item being crafted.</param>
/// <param name="skinItemId">The ID of the skin item required for crafting (0 if not applicable).</param>
/// <returns>
/// Returns `true` if the player can craft the item, or any non-null value to override the default behavior. 
/// If a string is returned, the player will be notified with the provided message as the reason.
/// If `null` is returned, the default crafting rules apply.
/// </returns>
object CanCraft(PlayerBlueprints player, ItemDefinition itemDefinition, int skinItemId)
{
    Puts($"Player {player.UserIDString} is attempting to craft {itemDefinition.name} with skin ID {skinItemId}.");
    if (skinItemId != 0 && !steamInventory.HasItem(skinItemId))
    {
        Puts($"Player {player.displayName} does not have the required skin item for crafting {itemDefinition.name}.");
        return "Missing required skin item.";
    }
    if (base.baseEntity.currentCraftLevel < (float)itemDefinition.Blueprint.workbenchLevelRequired)
    {
        Puts($"Player {player.displayName} does not meet the craft level requirement for {itemDefinition.name}.");
        return "Insufficient craft level.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(int itemid, int skinItemId)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemid);
		if (itemDefinition == null)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, itemDefinition, skinItemId);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (skinItemId != 0 && !steamInventory.HasItem(skinItemId))
		{
			return false;
		}
		if (base.baseEntity.currentCraftLevel < (float)itemDefinition.Blueprint.workbenchLevelRequired)
		{
			return false;
		}
		if (HasUnlocked(itemDefinition))
		{
			return true;
		}
		return false;
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity being killed.</param>
/// <returns>No return behavior.</returns>
void OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity.ShortName} has been killed.");
    if (entity is Player player && player.IsSpectating())
    {
        Puts($"Player {player.UserIDString} was spectating and has been killed.");
        // Handle the player's death as a spectator
    }
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
			return;
		}
		Interface.CallHook("OnEntityKill", this);
		OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
		Term(mode);
		DoEntityDestroy();
		EntityDestroy();
	}

```

## CanResearchItem(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to research an item.
/// </summary>
/// <param name="item">The item being researched.</param>
/// <param name="player">The player performing the research.</param>
/// <returns>
/// Returns `null` if the research is allowed, or any non-null value to prevent the research from happening.
/// </returns>
object CanResearchItem(Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to research item {item.info.name}.");
    if (item.amount > 1)
    {
        Puts($"Player {player.displayName} cannot research item {item.info.name} because it has multiple copies.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", targetItem, player) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## IOnServerUsersRemove(ulong)

```csharp
```csharp
/// <summary>
/// Called when a user is removed from the server.
/// </summary>
/// <param name="uid">The ID of the user being removed.</param>
/// <returns>No return behavior.</returns>
void IOnServerUsersRemove(ulong uid)
{
    Puts($"User with ID {uid} has been removed from the server.");
}
```
```

### Source Code from the Library

```csharp

	public static void Remove(ulong uid)
	{
		Interface.CallHook("IOnServerUsersRemove", uid);
		if (users.ContainsKey(uid))
		{
			users.Remove(uid);
		}
	}

```

## OnCupboardAuthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is authorized to access the cupboard.
/// </summary>
/// <param name="building">The building containing the cupboard.</param>
/// <param name="player">The player being authorized.</param>
/// <returns>
/// Returns `null` to allow the player to be authorized, or any non-null value to prevent them from accessing the cupboard.
/// </returns>
object OnCupboardAuthorize(BuildingPrivlidge building, BasePlayer player)
{
    Puts($"Player {player.displayName} has been authorized to access the cupboard.");
    if (player.UserIDString == "admin")
    {
        Puts($"Player {player.displayName} is already authorized to access the cupboard.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AddSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && CanAdministrate(rpc2.player) && Interface.CallHook("OnCupboardAuthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = rpc2.player.userID;
			playerNameID.username = rpc2.player.displayName;
			authorizedPlayers.Add(playerNameID);
			SendNetworkUpdate();
		}
	}

```

## OnItemResearched(ResearchTable,int)

```csharp
```csharp
/// <summary>
/// Called when an item is researched.
/// </summary>
/// <param name="researchTable">The research table used to research the item.</param>
/// <param name="amountOfScrapUsed">The amount of scrap used in the research process. If null, the default amount will be used.</param>
object OnItemResearched(ResearchTable researchTable, int? amountOfScrapUsed)
{
    Puts($"Item {researchTable.GetItemName()} has been researched.");
    if (amountOfScrapUsed.HasValue && amountOfScrapUsed.Value > 0)
    {
        Puts($"Amount of scrap used: {amountOfScrapUsed}");
    }
    else
    {
        Puts($"Default amount of scrap used.");
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", this, num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount <= num)
				{
					inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
				item.blueprintTarget = targetItem.info.itemid;
				if (!item.MoveToContainer(inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the mailbox, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Player {player.UserIDString} attempting to access mailbox {mailbox.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnTurretClearList(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the turret clear list is triggered.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <param name="player">The player who triggered the clear list.</param>
/// <returns>
/// Returns `null` to allow the clear list to proceed, or any non-null value to prevent it from clearing.
/// </returns>
object OnTurretClearList(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.GetReference()} has been cleared by player {player.UserIDString}.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot clear the list.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			SendNetworkUpdate();
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="entity">The locked entity being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the locked entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
bool CanUseLockedEntity(BasePlayer player, CodeLock entity)
{
    Puts($"Player {player.UserIDString} attempted to access locked entity {entity.EntityID}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.UserIDString} is an admin and can access the locked entity");
        return true;
    }
    else if (player.HasPermission(entity.GetPermissionName()))
    {
        Puts($"Player {player.UserIDString} has permission to access the locked entity");
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to access the locked entity");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## IOnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a new user connects to the server.
/// </summary>
/// <param name="connection">The connection object for the new user.</param>
/// <returns>
/// Returns `null` if the user is approved as normal. 
/// If a non-null value is returned, it will override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object IOnUserApprove(Connection connection)
{
    Puts($"New connection from {connection.userid} with token {connection.token}");
    if (connection.token == null || connection.token.Length < 32)
    {
        Reject(connection, "Invalid Token");
        return "Invalid Token";
    }
    // Additional approval logic can be added here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2054)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)", StackTraceLogType.None);
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			Reject(connection, "You are banned from this server");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log(connection.ToString() + " has auth level 1", StackTraceLogType.None);
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log(connection.ToString() + " has auth level 2", StackTraceLogType.None);
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log(connection.ToString() + " is a developer", StackTraceLogType.None);
			connection.authLevel = 3u;
		}
		if (IsConnected(connection.userid))
		{
			Reject(connection, "You are already connected!");
		}
		else if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnQuarryEnabled(MiningQuarry)

```csharp
```csharp
/// <summary>
/// Called when a quarry is enabled.
/// </summary>
/// <param name="quarry">The mining quarry that has been enabled.</param>
/// <returns>No return behavior.</returns>
void OnQuarryEnabled(MiningQuarry quarry)
{
    Puts($"Quarry {quarry.name} has been enabled.");
    if (quarry.isHighPriority)
    {
        Puts($"Quarry {quarry.name} is a high priority quarry.");
        // Perform additional actions for high-priority quarries
    }
}
```
```

### Source Code from the Library

```csharp

	private void SetOn(bool isOn)
	{
		SetFlag(Flags.On, isOn);
		engineSwitchPrefab.instance.SetFlag(Flags.On, isOn);
		SendNetworkUpdate();
		engineSwitchPrefab.instance.SendNetworkUpdate();
		if (isOn)
		{
			InvokeRepeating(ProcessResources, processRate, processRate);
			Interface.CallHook("OnQuarryEnabled", this);
		}
		else
		{
			CancelInvoke(ProcessResources);
		}
	}

```

## OnPlayerInit(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's initialization process begins.
/// </summary>
/// <param name="player">The player being initialized.</param>
/// <returns>
/// Returns a non-null value to override the default initialization behavior. 
/// If `null` is returned, the player is initialized as normal.
/// </returns>
object OnPlayerInit(BasePlayer player)
{
    Puts($"Initializing player {player.UserIDString}.");
    if (player.UserIDString == "admin")
    {
        Puts($"Admin player {player.UserIDString} has been blocked from initializing.");
        return "Blocked: Admin player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PlayerInit(Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10L))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			userID = c.userid;
			UserIDString = userID.ToString();
			_displayName = StringEx.ToPrintable(c.username, 32);
			c.player = this;
			tickInterpolator.Reset(base.transform.position);
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			ClientRPCPlayer(null, this, "StartLoading");
			Interface.CallHook("OnPlayerInit", this);
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			SendGlobalSnapshot();
			SendFullSnapshot();
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
			}
		}
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted (in this case, a corpse).</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, LootableCorpse entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot corpse {entity.GetGlobalID()}");
    if (player.IsAdmin())
    {
        return null;
    }
    // Add custom logic here to determine if the player can loot the entity
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !CanLoot() || containers == null)
		{
			return;
		}
		BasePlayer player = rpc.player;
		if (Interface.CallHook("CanLootEntity", player, this) == null)
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.StartLootingEntity(this);
			ItemContainer[] array = containers;
			foreach (ItemContainer container in array)
			{
				player.inventory.loot.AddContainer(container);
			}
			player.inventory.loot.SendImmediate();
			ClientRPCPlayer(null, player, "RPC_ClientLootCorpse");
			SendNetworkUpdate();
		}
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a hammer hits an entity.
/// </summary>
/// <param name="owner">The player who hit the entity.</param>
/// <param name="info">Information about the hit, including the entity and damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default behavior of repairing the entity. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnHammerHit(BasePlayer owner, HitInfo info)
{
    Puts($"Player {owner.UserIDString} hit an entity with their hammer.");
    if (info.HitEntity is BaseBuilding)
    {
        Puts($"The entity hit was a building.");
        return "Building cannot be repaired.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			if (ownerPlayer != null && base.isServer)
			{
				using (TimeWarning.New("DoRepair", 50L))
				{
					baseCombatEntity.DoRepair(ownerPlayer);
				}
			}
		}
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## CanEquipItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be equipped into a specific slot.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The item to equip.</param>
/// <param name="slot">The target equipment slot.</param>
/// <returns>
/// Returns `true` if the item can be equipped, or any non-null value to override the default behavior. 
/// If a string is returned, an error message will be displayed to the player.
/// </returns>
object CanEquipItem(PlayerInventory inventory, Item item, int slot)
{
    Puts($"Checking if item {item.info.name} can be equipped into slot {slot}...");
    object result = Interface.CallHook("CanEquipItem", inventory, item, slot);
    if (result is bool && !(bool)result)
    {
        return "Cannot equip item: Invalid slot.";
    }
    // Additional logic to check for conflicts with other items in the inventory...
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanEquipItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanEquipItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
		if (component == null)
		{
			return true;
		}
		Item[] array = containerBelt.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 2f);
				}
			}
		}
		return true;
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that was locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.name} has been locked by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container that the item was added to.</param>
/// <param name="item">The item that was added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been added to container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the recycler is toggled on or off.
/// </summary>
/// <param name="recycler">The recycler being toggled.</param>
/// <param name="player">The player who toggled the recycler.</param>
/// <returns>
/// Returns `null` to allow the recycler to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts($"Recycler {recycler.name} has been toggled by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot toggle the recycler.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || msg.player == null || Interface.CallHook("OnRecyclerToggle", this, msg.player) != null || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

```

## OnPlayerKicked(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="player">The player being kicked.</param>
/// <param name="reason">The reason for kicking the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void Kick(string reason)
	{
		if (IsConnected)
		{
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason);
		}
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford an upgrade.
/// </summary>
/// <param name="player">The player attempting the upgrade.</param>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="grade">The grade of the upgrade.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the return value.
/// </returns>
bool CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum grade)
{
    Puts($"Player {player.UserIDString} attempting to upgrade {buildingBlock.name} to grade {grade}");
    object obj = Interface.CallHook("CanAffordUpgrade", player, buildingBlock, grade);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // Default implementation
    ConstructionGrade constructionGrade = GetGrade(grade);
    foreach (ItemAmount item in constructionGrade.costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
        {
            Puts($"Player {player.UserIDString} does not have enough resources to upgrade {buildingBlock.name} to grade {grade}");
            return false;
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ConstructionGrade constructionGrade = GetGrade(iGrade);
		foreach (ItemAmount item in constructionGrade.costToBuild)
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallDistance">The distance the player fell.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanded(BasePlayer player, float fallDistance)
{
    Puts($"Player {player.UserIDString} has landed after falling {fallDistance} units.");
    if (fallDistance > 50f)
    {
        Puts($"Player {player.displayName} suffered severe injuries from the fall.");
        // Apply additional damage or effects here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (float.IsNaN(num) || float.IsInfinity(num))
		{
			return;
		}
		float num2 = Mathf.InverseLerp(-15f, -100f, num);
		if (num2 != 0f && Interface.CallHook("OnPlayerLand", this, num2) == null)
		{
			metabolism.bleeding.Add(num2 * 0.5f);
			float num3 = num2 * 500f;
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num2);
		}
	}

```

## CanPickupLock(BasePlayer,BaseLock)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to pick up a lock.
/// </summary>
/// <param name="player">The player attempting to pick up the lock.</param>
/// <param name="lock">The lock being picked up.</param>
/// <returns>
/// Returns `null` to allow the player to pick up the lock, or any non-null value to prevent them from picking it up.
/// </returns>
object CanPickupLock(BasePlayer player, BaseLock lock)
{
    Puts($"Player {player.UserIDString} is attempting to pick up lock {lock.lockID}");
    if (player.HasFlag("admin"))
    {
        Puts($"Player {player.UserIDString} has been granted admin privileges and can pick up the lock");
        return null;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to pick up the lock");
        return "Access denied";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_TakeLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && Interface.CallHook("CanPickupLock", rpc.player, this) == null)
		{
			Item item = ItemManager.Create(itemType, 1, skinID);
			if (item != null)
			{
				rpc.player.GiveItem(item);
			}
			Kill();
		}
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if a target can be targeted by the helicopter turret.
/// </summary>
/// <param name="potentialTarget">The potential target entity.</param>
/// <param name="turret">The helicopter turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBeTargeted(BaseCombatEntity potentialTarget, HelicopterTurret turret)
{
    Puts($"Checking if {potentialTarget.displayName} can be targeted by the helicopter turret.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the network should be allowed to connect to a BasePlayer.
/// </summary>
/// <param name="player">The player to check.</param>
/// <returns>
/// Returns `true` to allow the network to connect, or `false` to deny it.
/// If any other value is returned (e.g. a string), it will be treated as an error message and used to kick the player.
/// </returns>
object CanNetworkTo(BasePlayer player)
{
    Puts($"Checking if network can connect to {player.UserIDString}...");
    if (player.IsBanned)
    {
        Puts($"Network denied: Player is banned.");
        return "You are banned from this server.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## CanDemolish(BasePlayer,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Determines whether a player can demolish the current building.
/// </summary>
/// <param name="player">The player attempting to demolish.</param>
/// <param name="buildingBlock">The block being demolished (not used in this method).</param>
/// <returns>
/// Returns `true` if the player can demolish, or `false` otherwise.
/// If a non-null value is returned from Interface.CallHook("CanDemolish"), it will override the default behavior.
/// </returns>
bool CanDemolish(BasePlayer player, BuildingBlock buildingBlock)
{
    object obj = Interface.CallHook("CanDemolish", player, this);
    if (obj is bool)
    {
        return (bool)obj;
    }
    Puts($"Player {player.UserIDString} attempting to demolish.");
    return IsDemolishable() && HasDemolishPrivilege(player);
}
```
```

### Source Code from the Library

```csharp

	private bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsDemolishable() && HasDemolishPrivilege(player);
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <param name="target">The object that entered the trap's trigger area.</param>
/// <returns>No return behavior.</returns>
void OnTrapTrigger(BearTrap trap, GameObject target)
{
    Puts($"Trap {trap.name} triggered by {target.name}");
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can bypass the queue.
/// </summary>
/// <param name="connection">The player's connection.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue, or `false` otherwise.
/// If this method returns `null`, it will be treated as returning `false`.
/// </returns>
bool CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if {connection.UserIDString} can bypass queue...");
    bool result = (bool)Interface.CallHook("CanBypassQueue", connection);
    if (result)
    {
        return true;
    }
    if (DeveloperList.Contains(connection.userid))
    {
        return true;
    }
    ServerUsers.User user = ServerUsers.Get(connection.userid);
    if (user != null && user.group == ServerUsers.UserGroup.Moderator)
    {
        return true;
    }
    if (user != null && user.group == ServerUsers.UserGroup.Owner)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		return false;
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is hunting.
/// </summary>
/// <param name="bradleyApc">The Bradley APC instance.</param>
/// <returns>
/// Returns a non-null value to override the default hunting behavior. 
/// If `null` is returned, the Bradley APC will continue with its normal hunting routine.
/// </returns>
object OnBradleyApcHunt(BradleyAPC bradleyApc)
{
    Puts($"The Bradley APC {bradleyApc.GetId()} has started hunting.");
    if (bradleyApc.GetCurrentTarget().GetDistance() > 100f)
    {
        Puts($"The Bradley APC {bradleyApc.GetId()} is too far away from its target to engage.");
        return "Too Far Away";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			BasePathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			BasePathNode basePathNode = null;
			List<BasePathNode> nearNodes = Facepunch.Pool.GetList<BasePathNode>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<BasePathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (BasePathNode item2 in nearNodes)
			{
				Stack<BasePathNode> path = new Stack<BasePathNode>();
				if (targetInfo.entity.IsVisible(item2.transform.position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					basePathNode = item2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].transform.position);
					}
				}
				foreach (BasePathNode item3 in stack)
				{
					currentPath.Add(item3.transform.position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = basePathNode.transform.position;
			}
			Facepunch.Pool.FreeList(ref nearNodes);
			Facepunch.Pool.FreeList(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## OnExplosiveDropped(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an explosive is dropped.
/// </summary>
/// <param name="player">The player who dropped the explosive.</param>
/// <param name="explosive">The explosive entity that was dropped.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the explosive will be handled as normal.
/// </returns>
object OnExplosiveDropped(BasePlayer player, BaseEntity explosive)
{
    Puts($"Player {player.displayName} dropped an explosive.");
    if (explosive is TimedExplosive && ((BaseEntity)player).GetDistance(explosive) < 5f)
    {
        Puts($"Player {player.displayName} is too close to the explosive.");
        return "Too Close: Explosive cannot be used in this location.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoDrop(RPCMessage msg)
	{
		if (!HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		Vector3 vector = msg.read.Vector3();
		Vector3 normalized = msg.read.Vector3().normalized;
		if (!ValidateEyePos(msg.player, vector))
		{
			vector = msg.player.eyes.position;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation(Vector3.up));
		if (baseEntity == null)
		{
			return;
		}
		if (UnityEngine.Physics.SphereCast(new Ray(vector, normalized), 0.05f, out var hitInfo, 1.5f, 1101212417))
		{
			Vector3 point = hitInfo.point;
			Vector3 normal = hitInfo.normal;
			BaseEntity entity = RaycastHitEx.GetEntity(hitInfo);
			if ((bool)entity && entity is StabilityEntity && baseEntity is TimedExplosive)
			{
				entity = entity.ToServer<BaseEntity>();
				TimedExplosive timedExplosive = baseEntity as TimedExplosive;
				timedExplosive.onlyDamageParent = true;
				timedExplosive.DoStick(point, normal, entity);
			}
			else
			{
				baseEntity.SetVelocity(normalized);
			}
		}
		else
		{
			baseEntity.SetVelocity(normalized);
		}
		baseEntity.creatorEntity = msg.player;
		baseEntity.Spawn();
		Interface.CallHook("OnExplosiveDropped", msg.player, baseEntity);
		StartAttackCooldown(repeatDelay);
		UseItemAmount(1);
	}

```

## CanLootEntity(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `true` to allow the player to loot the entity, or `false` to prevent them from doing so.
/// If a non-bool value is returned, it will be treated as a custom reason for denying access.
/// </returns>
object CanLootEntity(BasePlayer player, StorageContainer entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot {entity.name}.");
    if (entity.IsLocked())
    {
        Puts($"Player {player.displayName} cannot loot {entity.name} because it's locked.");
        return "Locked: Entity is currently locked.";
    }
    // Add custom logic here to determine if the player can loot the entity
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen)
	{
		object obj = Interface.CallHook("CanLootEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsLocked())
		{
			player.ChatMessage("Can't loot right now");
			return false;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		SetFlag(Flags.Open, b: true);
		using (TimeWarning.New("PlayerOpenLoot"))
		{
			player.inventory.loot.StartLootingEntity(this);
			player.inventory.loot.AddContainer(inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", panelToOpen);
			SendNetworkUpdate();
		}
		return true;
	}

```

## IOnDisableServerConsole(unknown)

```csharp
```csharp
/// <summary>
/// Called when the server console is disabled.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnDisableServerConsole()
{
    Puts("Server console has been disabled.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	private void OnDisable()
	{
		if (Interface.CallHook("IOnDisableServerConsole", null) == null)
		{
			Output.OnMessage -= HandleLog;
			input.OnInputText -= OnInputText;
			console.Shutdown();
		}
	}

```

## OnReloadMagazine(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player reloads their magazine.
/// </summary>
/// <param name="player">The player reloading the magazine.</param>
/// <param name="projectile">The projectile being reloaded.</param>
/// <returns>
/// Returns `null` to allow the magazine to be reloaded, or any non-null value to prevent it from being reloaded.
/// </returns>
object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} is reloading their magazine.");
    if (projectile.ammoType == "rare")
    {
        Puts($"Player {player.displayName} cannot reload rare ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected void ReloadMagazine()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((bool)ownerPlayer && Interface.CallHook("OnReloadMagazine", ownerPlayer, this) == null)
		{
			primaryMagazine.Reload(ownerPlayer);
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## InitLogging(unknown)

```csharp
```csharp
/// <summary>
/// Called to initialize logging.
/// </summary>
/// <returns>No return behavior.</returns>
void InitLogging()
{
    Puts("Logging initialized");
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging", null);
		ItemManager.Initialize();
	}

```

## CanUnlock(KeyLock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock the object.
/// </summary>
/// <param name="lock">The KeyLock object being unlocked.</param>
/// <param name="player">The BasePlayer attempting to unlock the object.</param>
/// <returns>
/// Returns `null` to allow the player to unlock the object, or any non-null value to prevent them from unlocking it.
/// </returns>
object CanUnlock(KeyLock lock, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is attempting to unlock {lock.name}");
    if (player.IsAdmin())
    {
        return null;
    }
    else
    {
        return "You do not have permission to unlock this object.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", this, rpc.player) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnLiftUse(Lift,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player uses a lift.
/// </summary>
/// <param name="lift">The lift being used.</param>
/// <param name="player">The player using the lift.</param>
/// <returns>
/// Returns `null` to allow the player to use the lift, or any non-null value to prevent them from using it.
/// </returns>
object OnLiftUse(Lift lift, BasePlayer player)
{
    Puts($"Player {player.UserIDString} used the lift at position: {lift.transform.position}");
    if (lift.isBroken)
    {
        Puts($"The lift at position: {lift.transform.position} is currently broken.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_UseLift(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && Interface.CallHook("OnLiftUse", this, rpc.player) == null)
		{
			MoveUp();
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped.
/// </summary>
/// <param name="item">The item being dropped.</param>
/// <param name="baseEntity">The BaseEntity representing the dropped item, or null if the item cannot be dropped.</param>
/// <returns>No return behavior.</returns>
void OnItemDropped(Item item, BaseEntity baseEntity)
{
    Puts($"Item {item.info.name} has been dropped.");
    if (baseEntity != null && baseEntity is BasePlayer)
    {
        Puts($"The item was dropped by player {((BasePlayer)baseEntity).displayName}");
    }
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		RemoveFromWorld();
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## CanBuild(Planner,Construction,Construction.Target)

```csharp
```csharp
/// <summary>
/// Called to check if a player can build at the specified location.
/// </summary>
/// <param name="construction">The construction being placed.</param>
/// <param name="target">The target position and orientation for the placement.</param>
/// <returns>
/// Returns `null` to allow the player to build, or any non-null value to prevent building.
/// If a string is returned, the player will be notified with the provided message as the reason.
/// </returns>
object CanBuild(Construction construction, Construction.Target target)
{
    Puts($"Checking if player can build at {target.position}.");
    if (construction == null || !construction.canBypassBuildingPermission)
    {
        return "Cannot build: Building is blocked.";
    }
    // Additional checks can be added here as needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ChatMessage("Couldn't find Construction " + msg.blockID);
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			ownerPlayer.ChatMessage("Can't afford to place!");
			return;
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ChatMessage("Building is blocked!");
			return;
		}
		Construction.Target target = default(Construction.Target);
		BaseNetworkable baseNetworkable = null;
		if (msg.entity != 0)
		{
			baseNetworkable = BaseNetworkable.serverEntities.Find(msg.entity);
			if (!baseNetworkable)
			{
				ownerPlayer.ChatMessage("Couldn't find entity " + msg.entity);
				return;
			}
			target.entity = baseNetworkable as BaseEntity;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != string.Empty && target.entity != null)
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				else
				{
					ownerPlayer.ChatMessage("Invalid Socket!");
				}
			}
			else
			{
				Debug.Log("socket was 0");
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.valid = true;
		if (Interface.CallHook("CanBuild", this, construction, target) != null)
		{
			return;
		}
		Deployable deployable = GetDeployable();
		if ((bool)deployable && deployable.placeEffect.isValid)
		{
			if ((bool)baseNetworkable && msg.socket != 0)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseNetworkable.transform.TransformPoint(target.socket.worldPosition), baseNetworkable.transform.up);
			}
			else
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, msg.position, msg.normal);
			}
		}
		DoBuild(target, construction);
	}

```

## CanMoveItem(Item,PlayerInventory,uint,int,int)

```csharp
```csharp
/// <summary>
/// Called when an item is moved.
/// </summary>
/// <param name="item">The item being moved.</param>
/// <param name="playerInventory">The player's inventory.</param>
/// <param name="num">The number of items to move.</param>
/// <param name="num2">The container ID to move the item to.</param>
/// <param name="num3">The amount of items to move (optional).</param>
/// <returns>
/// Returns a non-null value to override the default movement behavior. 
/// If `null` is returned, the item will be moved as normal.
/// </returns>
object CanMoveItem(Item item, PlayerInventory playerInventory, uint num, int num2, int num3)
{
    Puts($"Item {item.info.name} with ID {item.id} is being moved from inventory {playerInventory.id} to container {num2}.");
    if (item.amount <= 0)
    {
        Puts($"Cannot move item {item.info.name} as it has no quantity.");
        return null;
    }
    if (num3 > item.info.stackable)
    {
        Puts($"Cannot move more than {item.info.stackable} items of type {item.info.name} at once.");
        return null;
    }
    // Add custom logic here to override the default movement behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server.FromOwner]
	[BaseEntity.RPC_Server]
	private void MoveItem(BaseEntity.RPCMessage msg)
	{
		uint id = msg.read.UInt32();
		uint num = msg.read.UInt32();
		int num2 = msg.read.Int8();
		int num3 = msg.read.UInt16();
		Item item = FindItemUID(id);
		if (item == null || Interface.CallHook("CanMoveItem", item, this, num, num2, num3) != null || !CanMoveItemsFrom(item.parent.entityOwner, item))
		{
			return;
		}
		if (num3 <= 0)
		{
			num3 = item.amount;
		}
		num3 = Mathf.Clamp(num3, 1, item.info.stackable);
		if (num == 0)
		{
			GiveItem(item);
			return;
		}
		ItemContainer itemContainer = FindContainer(num);
		if (itemContainer == null)
		{
			return;
		}
		ItemContainer parent = item.parent;
		if ((parent != null && parent.IsLocked()) || itemContainer.IsLocked() || itemContainer.PlayerItemInputBlocked())
		{
			return;
		}
		using (TimeWarning.New("Split"))
		{
			if (item.amount > num3)
			{
				Item item2 = item.SplitItem(num3);
				if (!item2.MoveToContainer(itemContainer, num2))
				{
					item.amount += item2.amount;
					item2.Remove();
				}
				ItemManager.DoRemoves();
				ServerUpdate(0f);
				return;
			}
		}
		if (item.MoveToContainer(itemContainer, num2))
		{
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnTurretModeToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the turret mode is toggled.
/// </summary>
/// <param name="turret">The AutoTurret instance whose mode was toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretModeToggle(AutoTurret turret)
{
    Puts($"Turret {turret.name} mode has been toggled.");
    if (turret.mode == "peacekeeper")
    {
        Puts($"Turret {turret.name} is now in combat mode.");
    }
    else
    {
        Puts($"Turret {turret.name} is now in peacekeeper mode.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetPeacekeepermode(bool isOn)
	{
		bool flag = PeacekeeperMode();
		if (flag != isOn)
		{
			SetFlag(Flags.Reserved1, isOn);
			Effect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnTurretModeToggle", this);
		}
	}

```

## OnCupboardDeauthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's authorization to access a cupboard is deauthorized.
/// </summary>
/// <param name="buildingPrivilege">The building privilege that was deauthorized.</param>
/// <param name="player">The player who had their authorization deauthorized.</param>
/// <returns>
/// Returns `null` to allow the player's authorization to be deauthorized, or any non-null value to prevent it.
/// </returns>
object OnCupboardDeauthorize(BuildingPrivilege buildingPrivilege, BasePlayer player)
{
    Puts($"Player {player.UserIDString} had their authorization to access cupboard {buildingPrivilege.name} deauthorized.");
    if (player.userID == 123456)
    {
        Puts($"Player {player.displayName} is not allowed to have their authorization deauthorized.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && CanAdministrate(rpc2.player) && Interface.CallHook("OnCupboardDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			SendNetworkUpdate();
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be targeted for helicopter strafing.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <param name="target">The BasePlayer target to check.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanHelicopterStrafeTarget(PatrolHelicopterAI ai, BasePlayer target)
{
    Puts($"Checking if {target.displayName} can be targeted for helicopter strafing...");
    if (target.IsAdmin())
    {
        Puts($"Admin {target.displayName} cannot be targeted.");
        return true;
    }
    // Additional checks or logic can go here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidStrafeTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return !ply.IsNearEnemyBase();
	}

```

## OnLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting another player.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="target">The player being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is looting player {target.UserIDString}");
    if (looter == target)
    {
        Puts($"Player {looter.UserIDString} cannot loot themselves.");
        return;
    }
    // Additional logic can be added here to handle the looting process
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingPlayer(BasePlayer player)
	{
		Clear();
		if ((bool)player && (bool)player.inventory)
		{
			AddContainer(player.inventory.containerWear);
			AddContainer(player.inventory.containerMain);
			AddContainer(player.inventory.containerBelt);
			PositionChecks = true;
			entitySource = player;
			itemSource = null;
			MarkDirty();
			Interface.CallHook("OnLootPlayer", GetComponent<BasePlayer>(), player);
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the gun trap.
/// </summary>
/// <param name="player">The player being checked.</param>
/// <param name="gunTrap">The gun trap doing the checking.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, GunTrap gunTrap)
{
    Puts($"Checking if {player.Name} can be targeted by {gunTrap.GetType().Name}...");
    // Custom logic to determine if the player can be targeted
    // For example:
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.IsModerator())
    {
        return false;
    }
    else
    {
        // Default behavior
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger(float offset, float radius)
	{
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		List<BasePlayer> obj2 = Pool.GetList<BasePlayer>();
		Vis.Entities(GetEyePosition() + base.transform.forward * offset, radius, obj2, 131072);
		bool flag = false;
		foreach (BasePlayer item in obj2)
		{
			if (item.IsSleeping() || !item.IsAlive() || item.IsBuildingAuthed())
			{
				continue;
			}
			object obj3 = Interface.CallHook("CanBeTargeted", item, this);
			if (obj3 is bool)
			{
				Pool.FreeList(ref obj);
				Pool.FreeList(ref obj2);
				return (bool)obj3;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1075904769);
			for (int i = 0; i < obj.Count; i++)
			{
				RaycastHit hit = obj[i];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		return flag;
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a BasePlayer is attacked.
/// </summary>
/// <param name="attacker">The player who performed the attack.</param>
/// <param name="info">Information about the attack, including the damage type and location.</param>
void IOnBasePlayerAttacked(BasePlayer attacker, HitInfo info)
{
    Puts($"Player {attacker.displayName} attacked another player with a {info.damageTypes.ToString()} at the {info.HitBone}.");
    
    // Check if any wearable items on the victim's inventory protect the hit area
    foreach (Item item in attacker.inventory.containerWear.itemList)
    {
        ItemModWearable component = item.info.GetComponent<ItemModWearable>();
        if (!(component == null) && component.ProtectsArea(info.boneArea))
        {
            // If a wearable item protects the hit area, call its OnAttacked method
            item.OnAttacked(info);
        }
    }

    // Check if the victim is wounded or dead and log it in their stats
    if (attacker.IsWounded())
    {
        attacker.stats.combat.Log(info, attacker.health, "wounded");
    }
    else if (attacker.IsDead())
    {
        attacker.stats.combat.Log(info, attacker.health, "killed");
    }
    else
    {
        attacker.stats.combat.Log(info, attacker.health);
    }

    // If the victim is dead, send a death effect to all players in range
    if (attacker.IsDead() && attacker.net != null)
    {
        Effect effect = new Effect();
        effect.Init(Effect.Type.Generic, attacker.transform.position, attacker.transform.forward);
        effect.pooledString = "assets/bundled/prefabs/fx/death.prefab";
        EffectNetwork.Send(effect, attacker.net.connection);
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float health_old = base.health;
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.GetList<Item>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortal())
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				Effect effect = new Effect();
				effect.Init(Effect.Type.Generic, base.transform.position, base.transform.forward);
				effect.pooledString = "assets/bundled/prefabs/fx/takedamage_hit.prefab";
				EffectNetwork.Send(effect, net.connection);
			}
			string text = StringPool.Get(info.HitBone);
			UnityEngine.Vector3 normalized = (info.PointEnd - info.PointStart).normalized;
			bool flag = UnityEngine.Vector3.Dot(normalized, eyes.BodyForward()) > 0.4f;
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (!(initiatorPlayer != null)) ? null : initiatorPlayer.net.connection);
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1);
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.Log(info, health_old, base.health, "wounded");
			}
			else if (IsDead())
			{
				stats.combat.Log(info, health_old, base.health, "killed");
			}
			else
			{
				stats.combat.Log(info, health_old, base.health);
			}
		}
	}

```

## OnRunPlayerMetabolism(PlayerMetabolism,BaseCombatEntity,float)

```csharp
Based on the provided code, I will create a method structure for `OnRunPlayerMetabolism` with a return type of `void`.

```csharp
/// <summary>
/// Description: This method handles player metabolism.
/// </summary>
/// <param name="playerMetabolism">The player's metabolism data.</param>
/// <returns>None</returns>
public void OnRunPlayerMetabolism(PlayerMetabolism playerMetabolism)
{
    // Handle player hydration
    if (playerMetabolism.Hydration.Fraction() <= 0f || playerMetabolism.RadiationPoison.value >= 100f)
    {
        playerMetabolism.Owner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, true);
    }

    // Handle temperature effects on hydration and heartrate
    if (playerMetabolism.Temperature.value > 40f)
    {
        playerMetabolism.Hydration.Add(Mathf.InverseLerp(40f, 200f, playerMetabolism.Temperature.value) * -1f);
    }
    else if (playerMetabolism.Temperature.value < 10f)
    {
        float num14 = Mathf.InverseLerp(20f, -100f, playerMetabolism.Temperature.value);
        playerMetabolism.Heartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num14), 2f * num14);
    }

    // Handle oxygen levels based on water factor
    float num15 = playerMetabolism.Owner.WaterFactor();
    if (num15 > 0.85f)
    {
        playerMetabolism.Oxygen.MoveTowards(0f, 0.1f);
    }
    else
    {
        playerMetabolism.Oxygen.MoveTowards(1f, 1f);
    }

    // Handle wetness levels based on temperature and water factor
    float f = Climate.GetRain(playerMetabolism.Owner.Eyes.Position) * 0.6f;
    float f2 = Climate.GetSnow(playerMetabolism.Owner.Eyes.Position) * 0.2f;
    playerMetabolism.Wetness.MoveTowards(Mathx.Max(playerMetabolism.Wetness.value, f, f2), 0.05f);
    if (num15 < playerMetabolism.Wetness.value)
    {
        playerMetabolism.Wetness.MoveTowards(0f, 0.2f * Mathf.InverseLerp(0f, 100f, playerMetabolism.Temperature.value));
    }

    // Handle poison levels based on wetness and radiation level
    if (playerMetabolism.Wetness.Fraction() > 0.4f && playerMetabolism.Owner.EstimatedSpeed > 0.25f && playerMetabolism.RadiationLevel.Fraction() == 0f)
    {
        playerMetabolism.RadiationPoison.Subtract(playerMetabolism.RadiationPoison.value * 0.2f * playerMetabolism.Wetness.Fraction());
    }

    // Handle radiation level and poison levels based on server settings
    if (ConVar.Server.Radiation)
    {
        playerMetabolism.RadiationLevel.Value = playerMetabolism.Owner.RadiationLevel;
        if (playerMetabolism.RadiationLevel.value > 0f)
        {
            playerMetabolism.RadiationPoison.Add(playerMetabolism.RadiationLevel.value);
        }
    }

    // Handle pending health
    if (playerMetabolism.PendingHealth.Value > 0f)
    {
        float num16 = Mathf.Min(2f * delta, playerMetabolism.PendingHealth.Value);
        playerMetabolism.Owner.Entity.Heal(num16);
        if (playerMetabolism.Owner.Entity.HealthFraction == 1f)
        {
            playerMetabolism.PendingHealth.Value = 0f;
        }
        else
        {
            playerMetabolism.PendingHealth.Subtract(num16);
        }
    }
}
```

Note that I've assumed the `PlayerMetabolism` class has properties for each of the variables used in the code, and that the `Owner` property refers to the player's entity.
```

### Source Code from the Library

```csharp

	protected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
	{
		if (Interface.CallHook("OnRunPlayerMetabolism", this, ownerEntity, delta) != null)
		{
			return;
		}
		float currentTemperature = owner.currentTemperature;
		float fTarget = owner.currentComfort;
		float currentCraftLevel = owner.currentCraftLevel;
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, currentCraftLevel == 1f);
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, currentCraftLevel == 2f);
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, currentCraftLevel == 3f);
		float num = currentTemperature;
		num -= DeltaWet() * 34f;
		float num2 = Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);
		float num3 = num2;
		float num4 = Mathf.InverseLerp(20f, -50f, currentTemperature);
		float num5 = Mathf.InverseLerp(20f, 30f, currentTemperature);
		num += num4 * 70f * num3;
		num += num5 * 10f * Mathf.Abs(num3);
		num += heartrate.value * 5f;
		temperature.MoveTowards(num, delta * 5f);
		if (temperature.value >= 40f)
		{
			fTarget = 0f;
		}
		comfort.MoveTowards(fTarget, delta / 5f);
		float num6 = 0.6f + 0.4f * comfort.value;
		if (calories.value > 100f && owner.healthFraction < num6 && radiation_poison.Fraction() < 0.25f && owner.SecondsSinceAttacked > 10f && !SignificantBleeding() && temperature.value >= 10f && hydration.value > 40f)
		{
			float num7 = Mathf.InverseLerp(calories.min, calories.max, calories.value);
			float num8 = 5f;
			float num9 = num8 * owner.MaxHealth() * 0.8f / 600f;
			num9 += num9 * num7 * 0.5f;
			float num10 = num9 / num8;
			num10 += num10 * comfort.value * 6f;
			ownerEntity.Heal(num10 * delta);
			calories.Subtract(num9 * delta);
			hydration.Subtract(num9 * delta * 0.2f);
		}
		float num11 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;
		float fTarget2 = Mathf.Clamp(0.05f + num11, 0f, 1f);
		heartrate.MoveTowards(fTarget2, delta * 0.1f);
		float num12 = heartrate.Fraction() * 0.375f;
		calories.MoveTowards(0f, delta * num12);
		float num13 = 1f / 120f;
		num13 += Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);
		num13 += heartrate.value * (1f / 15f);
		hydration.MoveTowards(0f, delta * num13);
		bool b = hydration.Fraction() <= 0f || radiation_poison.value >= 100f;
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);
		if (temperature.value > 40f)
		{
			hydration.Add(Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);
		}
		if (temperature.value < 10f)
		{
			float num14 = Mathf.InverseLerp(20f, -100f, temperature.value);
			heartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num14), delta * 2f * num14);
		}
		float num15 = owner.WaterFactor();
		if (num15 > 0.85f)
		{
			oxygen.MoveTowards(0f, delta * 0.1f);
		}
		else
		{
			oxygen.MoveTowards(1f, delta * 1f);
		}
		float f = 0f;
		float f2 = 0f;
		if (owner.IsOutside(owner.eyes.position))
		{
			f = Climate.GetRain(owner.eyes.position) * 0.6f;
			f2 = Climate.GetSnow(owner.eyes.position) * 0.2f;
		}
		wetness.value = Mathf.Max(wetness.value, num15);
		wetness.MoveTowards(Mathx.Max(wetness.value, f, f2), delta * 0.05f);
		if (num15 < wetness.value)
		{
			wetness.MoveTowards(0f, delta * 0.2f * Mathf.InverseLerp(0f, 100f, currentTemperature));
		}
		poison.MoveTowards(0f, delta * (5f / 9f));
		if (wetness.Fraction() > 0.4f && owner.estimatedSpeed > 0.25f && radiation_level.Fraction() == 0f)
		{
			radiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);
		}
		if (ConVar.Server.radiation)
		{
			radiation_level.value = owner.radiationLevel;
			if (radiation_level.value > 0f)
			{
				radiation_poison.Add(radiation_level.value * delta);
			}
		}
		if (pending_health.value > 0f)
		{
			float num16 = Mathf.Min(2f * delta, pending_health.value);
			ownerEntity.Heal(num16);
			if (ownerEntity.healthFraction == 1f)
			{
				pending_health.value = 0f;
			}
			else
			{
				pending_health.Subtract(num16);
			}
		}
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the player's active item should be dropped.
/// </summary>
/// <param name="player">The player whose active item is being considered for dropping.</param>
/// <returns>
/// Returns `true` to allow the player's active item to be dropped, or `false` to prevent it from being dropped.
/// If a non-bool value is returned, the default behavior will be used (i.e., the item will not be dropped).
/// </returns>
bool CanDropActiveItem(BasePlayer player)
{
    Puts($"Considering dropping active item for player {player.UserIDString}");
    if (player.IsAdmin)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnItemRepair(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to repair an item.
/// </summary>
/// <param name="player">The player attempting to repair the item.</param>
/// <param name="item">The item being repaired.</param>
/// <returns>
/// Returns `null` if the repair is allowed, or any non-null value to prevent the repair from occurring.
/// </returns>
object OnItemRepair(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is attempting to repair item {item.info.name}.");
    if (item.info.condition.repairable && !item.info.condition.repaired)
    {
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} cannot repair item {item.info.name}. Item is already repaired or not repairable.");
        return "Item is already repaired or not repairable.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RepairItem(RPCMessage msg)
	{
		Item slot = inventory.GetSlot(0);
		if (slot == null)
		{
			return;
		}
		ItemDefinition info = slot.info;
		ItemBlueprint component = info.GetComponent<ItemBlueprint>();
		if (!component || !info.condition.repairable || slot.condition == slot.maxCondition)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (Interface.CallHook("OnItemRepair", player, slot) != null || (!player.blueprints.HasUnlocked(info) && (!(info.Blueprint != null) || info.Blueprint.isResearchable)))
		{
			return;
		}
		float num = RepairCostFraction(slot);
		bool flag = false;
		List<ItemAmount> obj = GetRepairCostList(component);
		foreach (ItemAmount item in obj)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				int num2 = Mathf.CeilToInt(item.amount * num);
				if (num2 > amount)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Facepunch.Pool.Free(ref obj);
			return;
		}
		foreach (ItemAmount item2 in obj)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
			}
		}
		Facepunch.Pool.Free(ref obj);
		slot.DoRepair(maxConditionLostOnRepair);
		if (ConVar.Global.developer > 0)
		{
			Debug.Log("Item repaired! condition : " + slot.condition + "/" + slot.maxCondition);
		}
		Effect.server.Run("assets/bundled/prefabs/fx/repairbench/itemrepair.prefab", this, 0u, Vector3.zero, Vector3.zero);
	}

```

## OnCollectiblePickup(Item,BasePlayer,CollectibleEntity)

```csharp
```csharp
/// <summary>
/// Called when a player picks up a collectible item.
/// </summary>
/// <param name="item">The item being picked up.</param>
/// <param name="player">The player picking up the item.</param>
/// <param name="entity">The entity from which the item was picked up.</param>
/// <returns>No return behavior.</returns>
void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
{
    Puts($"Player {player.UserIDString} picked up collectible item {item.info.name}.");
    if (entity is SpecialItem specialItem && specialItem.isRare)
    {
        Puts($"Player {player.displayName} found a rare collectible item!");
        // Give the player a reward for finding a rare item
        player.GiveItem(ItemManager.Create("Golden Coin", 1, 0uL), GiveItemReason.Reputation);
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && itemList != null)
		{
			ItemAmount[] array = itemList;
			foreach (ItemAmount itemAmount in array)
			{
				Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
				Interface.CallHook("OnCollectiblePickup", item, msg.player, this);
				msg.player.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			itemList = null;
			if (pickupEffect.isValid)
			{
				Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
			}
			Kill();
		}
	}

```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when the stock level of a vending machine is refreshed.
/// </summary>
/// <param name="vendingMachine">The vending machine whose stock level is being refreshed.</param>
/// <param name="itemDefinition">The item definition for which the stock level is being refreshed. If null, all items are refreshed.</param>
object OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDefinition)
{
    Puts($"Refreshing stock level of vending machine {vendingMachine.name}.");
    if (itemDefinition != null)
    {
        Puts($"Refreshing stock level for item {itemDefinition.itemid}.");
    }
    else
    {
        Puts("Refreshing stock levels for all items.");
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		foreach (ProtoBuf.VendingMachine.SellOrder so in sellOrders.sellOrders)
		{
			if (!(itemDef == null) && itemDef.itemid != so.itemToSellID)
			{
				continue;
			}
			if (so.itemToSellIsBP)
			{
				List<Item> source = inventory.FindItemsByItemID(blueprintBaseDef.itemid);
				List<Item> list = source.Where((Item x) => x.blueprintTarget == so.itemToSellID).ToList();
				ProtoBuf.VendingMachine.SellOrder sellOrder = so;
				int inStock;
				if (list != null && list.Count() >= 0)
				{
					Interface.CallHook("OnRefreshVendingStock", this, itemDef);
					inStock = list.Sum((Item x) => x.amount) / so.itemToSellAmount;
				}
				else
				{
					inStock = 0;
				}
				sellOrder.inStock = inStock;
				continue;
			}
			List<Item> list2 = inventory.FindItemsByItemID(so.itemToSellID);
			ProtoBuf.VendingMachine.SellOrder sellOrder2 = so;
			int inStock2;
			if (list2 != null && list2.Count >= 0)
			{
				Interface.CallHook("OnRefreshVendingStock", this, itemDef);
				inStock2 = list2.Sum((Item x) => x.amount) / so.itemToSellAmount;
			}
			else
			{
				inStock2 = 0;
			}
			sellOrder2.inStock = inStock2;
		}
	}

```

## OnLiftUse(ProceduralLift,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player uses the lift.
/// </summary>
/// <param name="lift">The procedural lift being used.</param>
/// <param name="player">The player using the lift.</param>
/// <returns>
/// Returns `null` to allow the player to use the lift, or any non-null value to prevent them from using it.
/// </returns>
object OnLiftUse(ProceduralLift lift, BasePlayer player)
{
    Puts($"Player {player.UserIDString} used the lift at position {lift.transform.position}.");
    if (lift.IsBroken())
    {
        Puts($"The lift at position {lift.transform.position} is broken and cannot be used.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_UseLift(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && Interface.CallHook("OnLiftUse", this, rpc.player) == null && !IsBusy())
		{
			MoveToFloor((floorIndex + 1) % stops.Length);
		}
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a craft can be performed.
/// </summary>
/// <param name="itemCrafter">The item crafter attempting the craft.</param>
/// <param name="bp">The blueprint for the item being crafted.</param>
/// <param name="amount">The amount of items being crafted.</param>
/// <returns>
/// Returns `true` if the craft can be performed, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as an error message for the craft attempt.
/// </returns>
object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
{
    Puts($"Attempting to craft {bp.name} x{amount}");
    if (itemCrafter.GetCraftingProgress(bp) >= 1.0f)
    {
        return "Already crafting.";
    }
    object result = Interface.CallHook("CanCraft", itemCrafter, bp, amount);
    if (result is string)
    {
        Puts($"Craft attempt failed: {result}");
        return result;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1)
	{
		if (amount < 1 || amount > 9000)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## OnPlayerDropActiveItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player drops their active item.
/// </summary>
/// <param name="player">The player dropping the item.</param>
/// <param name="item">The item being dropped.</param>
/// <returns>
/// Returns `null` to allow the item to be dropped, or any non-null value to prevent it from being dropped.
/// </returns>
object OnPlayerDropActiveItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} is dropping their active item: {item.displayName}");
    if (item.name == "Medkit")
    {
        Puts($"Player {player.UserIDString} cannot drop the Medkit.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DropActive(Vector3 velocity)
	{
		Item activeItem = player.GetActiveItem();
		if (activeItem == null || Interface.CallHook("OnPlayerDropActiveItem", player, activeItem) != null)
		{
			return;
		}
		using (TimeWarning.New("PlayerBelt.DropActive"))
		{
			activeItem.Drop(player.eyes.position, velocity);
			player.svActiveItemID = 0u;
			player.SendNetworkUpdate();
		}
	}

```

## OnTick(unknown)

```csharp
```csharp
/// <summary>
/// Called every tick.
/// </summary>
void OnTick()
{
    Puts("Server is ticking...");
    // Minimal code to demonstrate functionality
}
```

Note: Since the return type of `OnTick` is unknown, I've assumed it's a void function. If it returns something else, please provide more context or information about what `OnTick` does in your specific use case.
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		if (Rust.Global.SteamServer != null)
		{
			Interface.CallHook("OnTick", null);
			Rust.Global.SteamServer.Update();
		}
		RCon.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## CanRecycle(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled.
/// </summary>
/// <param name="recycler">The recycler checking the item.</param>
/// <param name="item">The item being checked for recyclability.</param>
/// <returns>
/// Returns `true` if the item can be recycled, or `false` otherwise.
/// If a non-null value is returned, it will override the default recyclability behavior.
/// </returns>
object CanRecycle(Recycler recycler, Item item)
{
    Puts($"Checking if {item.info.Blueprint.name} can be recycled by {recycler.UserIDString}");
    if (item.info.Blueprint == null || item.info.Blueprint.category != "Materials")
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## CanUnlock(CodeLock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player tries to unlock the code lock.
/// </summary>
/// <param name="codeLock">The code lock being unlocked.</param>
/// <param name="player">The player attempting to unlock the code lock.</param>
/// <returns>
/// Returns `null` to allow the player to unlock the code lock, or any non-null value to prevent them from unlocking it.
/// </returns>
object CanUnlock(CodeLock codeLock, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to unlock the code lock.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is not allowed to unlock the code lock.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", this, rpc.player) == null)
		{
			if (whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectUnlocked.resourcePath);
				SetFlag(Flags.Locked, b: false);
				SendNetworkUpdate();
			}
			else
			{
				ClientRPCPlayer(null, rpc.player, "EnterUnlockCode");
			}
		}
	}

```

## OnAddVendingOffer(VendingMachine,BasePlayer,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when a vending machine offer is added.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was added to.</param>
/// <param name="player">The player who added the offer.</param>
/// <param name="itemDefinition">The item definition of the currency being used for the offer.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the offer is added as normal.
/// </returns>
object OnAddVendingOffer(VendingMachine vendingMachine, BasePlayer player, ItemDefinition itemDefinition)
{
    Puts($"Player {player.displayName} has added a new vending machine offer for {itemDefinition.name}.");
    if (itemDefinition == null)
    {
        Puts($"Error: Item definition is null.");
        return "Error: Item definition is null.";
    }
    // Add custom logic here to override the default behavior.
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_AddSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!CanPlayerAdmin(player))
		{
			return;
		}
		if (sellOrders.sellOrders.Count >= 7)
		{
			player.ChatMessage("Too many sell orders - remove some");
			return;
		}
		int num = msg.read.Int32();
		int value = msg.read.Int32();
		int num2 = msg.read.Int32();
		int value2 = msg.read.Int32();
		byte b = msg.read.UInt8();
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(num2);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			value2 = Mathf.Clamp(value2, 1, 10000);
			value = Mathf.Clamp(value, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = num;
			sellOrder.itemToSellAmount = value;
			sellOrder.currencyID = num2;
			sellOrder.currencyAmountPerItem = value2;
			sellOrder.currencyIsBP = b == 3 || b == 2;
			sellOrder.itemToSellIsBP = b == 3 || b == 1;
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			Interface.CallHook("OnAddVendingOffer", this, player, itemDefinition2);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## OnServerMessage(string,string,string,ulong)

```csharp
```csharp
/// <summary>
/// Called when a server message is broadcasted.
/// </summary>
/// <param name="message">The message being broadcasted.</param>
/// <param name="username">The username of the user who sent the message, defaults to "SERVER" if not provided.</param>
/// <param name="color">The color of the message, defaults to "#eee" if not provided.</param>
/// <param name="userid">The ID of the user who sent the message, defaults to 0 if not provided.</param>
/// <returns>
/// Returns `null` to allow the message to be broadcasted as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the message from being broadcasted.
/// </returns>
object OnServerMessage(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
{
    Puts($"Server message: {message} from {username} (ID: {userid})");
    if (userid == 1234567890uL)
    {
        Puts($"Server message from user ID {userid} has been blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", message, username, color, userid) == null)
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add", 0, "<color=" + color + ">" + username + "</color> " + message);
			ChatEntry chatEntry = default(ChatEntry);
			chatEntry.Message = message;
			chatEntry.UserId = userid;
			chatEntry.Username = username;
			chatEntry.Color = color;
			chatEntry.Time = Epoch.Current;
			ChatEntry chatEntry2 = chatEntry;
			History.Add(chatEntry2);
			RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		}
	}

```

## OnPlayerViolation(BasePlayer,AntiHackType,float)

```csharp
```csharp
/// <summary>
/// Called when a player is flagged for a violation.
/// </summary>
/// <param name="player">The player who committed the violation.</param>
/// <param name="type">The type of violation (e.g. speedhack, aimbot).</param>
/// <param name="amount">The severity of the violation.</param>
/// <returns>
/// Returns `null` to allow the player's violation level to be updated as normal.
/// If a non-null value is returned, it will override the default behavior and prevent the player's violation level from being updated.
/// </returns>
object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
{
    Puts($"Player {player.UserIDString} has been flagged for a {type} violation of {amount}.");
    if (type == AntiHackType.Speedhack && amount > 10f)
    {
        Puts($"Player {player.displayName} is suspected of using a speedhack and will be banned from the server.");
        return "Banned: Speedhack detected.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void AddViolation(BasePlayer ply, AntiHackType type, float amount)
	{
		if (Interface.CallHook("OnPlayerViolation", ply, type, amount) == null)
		{
			ply.lastViolationType = type;
			ply.lastViolationTime = UnityEngine.Time.realtimeSinceStartup;
			ply.violationLevel += amount;
			if ((ConVar.AntiHack.debuglevel >= 2 && amount > 0f) || ConVar.AntiHack.debuglevel >= 3)
			{
				LogToConsole(ply, type, "Added violation of " + amount + " in frame " + UnityEngine.Time.frameCount + " (now has " + ply.violationLevel + ")");
			}
			EnforceViolations(ply);
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="signage">The signage being updated (not used in this implementation).</param>
/// <returns>
/// Returns `true` if the player can update the sign, and `false` otherwise.
/// </returns>
bool CanUpdateSign(BasePlayer player, Signage signage)
{
    Puts($"Checking if {player.UserIDString} can update a sign");
    object obj = Interface.CallHook("CanUpdateSign", player, signage);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If no specific hook result, default to admin and developer permissions
    return player.IsAdmin || player.IsDeveloper;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## OnPlayerRespawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player respawning.</param>
/// <returns>
/// Returns a non-null value to override the default respawn behavior. 
/// If a `SpawnPoint` object is returned, the player will respawn at that location and rotation.
/// If `null` is returned, the player will respawn at the default spawn point.
/// </returns>
object OnPlayerRespawn(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.IsAdmin)
    {
        SpawnPoint adminSpawn = new SpawnPoint(player.transform.position + Vector3.forward * 10, Quaternion.identity);
        return adminSpawn;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint();
		object obj = Interface.CallHook("OnPlayerRespawn", this);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnPlayerActiveItemChanged(BasePlayer,Item,Item)

```csharp
```csharp
/// <summary>
/// Called when a player's active item changes.
/// </summary>
/// <param name="player">The player whose active item has changed.</param>
/// <param name="oldItem">The old active item.</param>
/// <param name="newItem">The new active item.</param>
object OnPlayerActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
{
    Puts($"Player {player.UserIDString} changed their active item from {oldItem.info.name} to {newItem.info.name}");
    if (oldItem == null && newItem != null)
    {
        // Handle the case where a new item was picked up
        return null;
    }
    else if (oldItem != null && newItem == null)
    {
        // Handle the case where an item was dropped or destroyed
        return oldItem;
    }
    else if (oldItem != null && newItem != null && oldItem.info.name == "Tool" && newItem.info.name == "Tool")
    {
        // Handle the case where a tool was swapped with another tool of the same type
        return null;
    }
    else
    {
        // Handle any other cases
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	internal void UpdateActiveItem(uint itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		Item activeItem = GetActiveItem();
		svActiveItemID = 0u;
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnPlayerActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnPlayerConnected(Network.Message)

```csharp
```csharp
/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="packet">The message packet containing information about the connected player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(Network.Message packet)
{
    Puts($"Player {packet.connection.info.Get("username")} has connected to the server.");
    if (packet.connection.info.Get("isModerator") == "true")
    {
        Puts($"Player {packet.connection.info.Get("username")} is a moderator.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void ClientReady(Message packet)
	{
		packet.connection.decryptIncoming = true;
		using ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read);
		foreach (ClientReady.ClientInfo item in clientReady.clientInfo)
		{
			packet.connection.info.Set(item.name, item.value);
		}
		connectionQueue.JoinedGame(packet.connection);
		Interface.CallHook("OnPlayerConnected", packet);
		using (TimeWarning.New("ClientReady"))
		{
			using (TimeWarning.New("SpawnPlayerSleeping"))
			{
				if (SpawnPlayerSleeping(packet.connection))
				{
					return;
				}
			}
			using (TimeWarning.New("SpawnNewPlayer"))
			{
				SpawnNewPlayer(packet.connection);
			}
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player disconnects from the server.
/// </summary>
/// <param name="player">The disconnected player.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} disconnected with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	private void OnDisconnected(string strReason, Connection connection)
	{
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		Rust.Global.SteamServer.Auth.EndSession(connection.userid);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((bool)basePlayer)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the oven is toggled on or off.
/// </summary>
/// <param name="oven">The oven being toggled.</param>
/// <param name="player">The player who toggled the oven.</param>
/// <returns>
/// Returns `null` to allow the oven to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts($"Oven {oven.GetGlobalID()} was toggled by player {player.UserIDString}.");
    if (oven.IsOn())
    {
        Puts($"Oven {oven.GetGlobalID()} is already on.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag != IsOn() && Interface.CallHook("OnOvenToggle", this, msg.player) == null && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				StartCooking();
			}
			else
			{
				StopCooking();
			}
		}
	}

```

## OnDeleteVendingOffer(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending offer is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the offer was deleted.</param>
/// <param name="player">The player who deleted the offer, if applicable.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending offer deleted on {vendingMachine.GetPositionString()} by {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				sellOrders.sellOrders.RemoveAt(num);
			}
			Interface.CallHook("OnDeleteVendingOffer", this, player);
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="message">The text of the chat message.</param>
/// <param name="player">The player who sent the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be displayed, or any non-null value to prevent it from being displayed.
/// </returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Player {player.UserIDString} said: {message}");
    if (message.ToLower() == "bad word")
    {
        Puts($"Player {player.displayName} used a bad word and was muted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 0, msg);
		}
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player picks up an item.
/// </summary>
/// <param name="item">The item being picked up.</param>
/// <param name="player">The player picking up the item.</param>
/// <returns>
/// Returns `null` to allow the player to pick up the item, or any non-null value to prevent them from picking it up.
/// </returns>
object OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} picked up item: {item.displayName}");
    if (item.isLocked)
    {
        Puts($"Player {player.UserIDString} tried to pick up locked item: {item.displayName}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && item != null && allowPickup && Interface.CallHook("OnItemPickup", item, msg.player) == null)
		{
			ClientRPC(null, "PickupSound");
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## OnDoorOpened(Door,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a door is opened.
/// </summary>
/// <param name="door">The door that was opened.</param>
/// <param name="player">The player who opened the door.</param>
/// <returns>No return behavior, this hook only notifies other scripts of the event.</returns>
void OnDoorOpened(BaseDoor door, BasePlayer player)
{
    Puts($"Door {door.name} has been opened by player {player.UserIDString}");
    if (door.name == "Secret Door")
    {
        Puts($"Player {player.displayName} has accessed a secret area.");
        // Trigger some event or notification here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_OpenDoor(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || IsOpen() || IsBusy() || IsLocked())
		{
			return;
		}
		BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
		if (baseLock != null)
		{
			if (!baseLock.OnTryToOpen(rpc.player))
			{
				return;
			}
			if (baseLock.IsLocked() && UnityEngine.Time.realtimeSinceStartup - decayResetTimeLast > 60f)
			{
				BuildingBlock buildingBlock = FindLinkedEntity<BuildingBlock>();
				if ((bool)buildingBlock)
				{
					Decay.BuildingDecayTouch(buildingBlock);
				}
				else
				{
					Decay.RadialDecayTouch(base.transform.position, 40f, 2097408);
				}
				decayResetTimeLast = UnityEngine.Time.realtimeSinceStartup;
			}
		}
		SetFlag(Flags.Open, b: true);
		SendNetworkUpdateImmediate();
		Interface.CallHook("OnDoorOpened", this, rpc.player);
	}

```

## OnItemAction(Item,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item action is performed.
/// </summary>
/// <param name="item">The item being acted upon.</param>
/// <param name="action">The action being performed (e.g. "drop", "use", etc.).</param>
/// <param name="player">The player performing the action.</param>
/// <returns>
/// Returns a non-null value to override the default behavior for this item action.
/// If `null` is returned, the default behavior will be used.
/// </returns>
object OnItemAction(Item item, string action, BasePlayer player)
{
    Puts($"Player {player.displayName} performed action '{action}' on item {item.name}");
    if (action == "craft")
    {
        // Custom crafting logic here
        return null;
    }
    else if (action == "use")
    {
        // Custom use logic here
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server.FromOwner]
	[BaseEntity.RPC_Server]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		uint id = msg.read.UInt32();
		string text = msg.read.String();
		Item item = FindItemUID(id);
		if (item == null || Interface.CallHook("OnItemAction", item, text, msg.player) != null || item.IsLocked() || !CanMoveItemsFrom(item.parent.entityOwner, item))
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.unread >= 4)
			{
				num = msg.read.Int32();
			}
			base.baseEntity.stats.Add("item_drop", 1);
			if (num < item.amount)
			{
				item.SplitItem(num)?.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 4f + Vector3Ex.Range(-0.5f, 0.5f));
			}
			else
			{
				item.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 4f + Vector3Ex.Range(-0.5f, 0.5f));
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable quantity of an item.
/// </summary>
/// <param name="item">The item being checked.</param>
/// <returns>
/// Returns the maximum stackable quantity, or a non-null integer value to override the default behavior.
/// If `null` is returned, the default behavior will be used.
/// </returns>
int OnMaxStackable(Item item)
{
    Puts($"Checking max stackable for item {item.name}");
    if (item.category == "Rare")
    {
        Puts($"Item {item.name} has a custom max stackable quantity of 10");
        return 10;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is being repaired.
/// </summary>
/// <param name="structure">The structure being repaired.</param>
/// <param name="player">The player performing the repair.</param>
/// <returns>
/// Returns `null` to allow the repair to proceed, or any non-null value to cancel the repair.
/// If a string is returned, the repair will be cancelled and the provided message will be displayed as the reason.
/// </returns>
object OnStructureRepair(BaseCombatEntity structure, BasePlayer player)
{
    Puts($"Structure {structure} is being repaired by player {player}");
    if (player.inventory.GetAmount(ItemID.None) < 1000f)
    {
        Puts("Not enough resources to repair the structure.");
        return "Insufficient resources.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		if (SecondsSinceAttacked <= 30f)
		{
			OnRepairFailed();
			return;
		}
		float num = MaxHealth() - health;
		float num2 = num / MaxHealth();
		if (num <= 0f || num2 <= 0f)
		{
			OnRepairFailed();
			return;
		}
		List<ItemAmount> list = RepairCost(num2);
		if (list == null)
		{
			return;
		}
		float num3 = list.Sum((ItemAmount x) => x.amount);
		if (num3 > 0f)
		{
			float a = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			a = Mathf.Min(a, 50f / num);
			if (a <= 0f)
			{
				OnRepairFailed();
				return;
			}
			int num4 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(a * item.amount);
				int num5 = player2.inventory.Take(null, item.itemid, amount);
				if (num5 > 0)
				{
					num4 += num5;
					player2.Command("note.inv", item.itemid, num5 * -1);
				}
			}
			float num6 = (float)num4 / num3;
			health += num * num6;
			SendNetworkUpdate();
		}
		else
		{
			health += num;
			SendNetworkUpdate();
		}
		if (health >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## OnNpcPlayerTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC player target is set.
/// </summary>
/// <param name="npc">The NPC setting the target.</param>
/// <param name="target">The entity being targeted by the NPC.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the NPC will set its target as normal.
/// If a float value is returned, it represents the strength of the NPC's desire to attack the target (0 = no interest, 1 = strong interest).
/// </returns>
object OnNpcPlayerTarget(NPCPlayerApex npc, BaseEntity target)
{
    Puts($"NPC {npc.UserIDString} has set its target to {target.UserIDString}");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"NPC {npc.UserIDString} has been instructed not to attack admin players");
        return 0f;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		if (target == null)
		{
			return 0f;
		}
		object obj = Interface.CallHook("OnNpcPlayerTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
		{
			return 0f;
		}
		if (target.GetType() == GetType())
		{
			return 0f;
		}
		if (target.Health() <= 0f)
		{
			return 0f;
		}
		return 1f;
	}

```

## IOnServerUsersSet(ulong,ServerUsers.UserGroup,string,string)

```csharp
```csharp
/// <summary>
/// Called when a server user's information is set.
/// </summary>
/// <param name="steamId">The Steam ID of the user.</param>
/// <param name="group">The group the user belongs to.</param>
/// <param name="username">The username of the user.</param>
/// <param name="notes">Any additional notes about the user.</param>
/// <returns>No return behavior.</returns>
void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string username, string notes)
{
    Puts($"User {username} with SteamID {steamId} has been set to group {group} with notes: {notes}");
}
```
```

### Source Code from the Library

```csharp

	public static void Set(ulong uid, UserGroup group, string username, string notes)
	{
		Interface.CallHook("IOnServerUsersSet", uid, group, username, notes);
		Remove(uid);
		User user = new User();
		user.steamid = uid;
		user.group = group;
		user.username = username;
		user.notes = notes;
		User value = user;
		users.Add(uid, value);
	}

```

## OnDispenserGather(ResourceDispenser,BaseEntity,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser gathers an item.
/// </summary>
/// <param name="dispenser">The dispenser that gathered the item.</param>
/// <param name="entity">The entity from which the item was gathered.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the dispenser will give the item to the entity as normal.
/// </returns>
object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
{
    Puts($"Dispenser {dispenser} gathered an item from entity {entity}.");
    if (item.itemid == 123) // Example: If the item ID is 123
    {
        Puts($"Item with ID {item.itemid} was not allowed to be gathered.");
        return "Not allowed";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float value = itemAmt.startAmount * num / num2;
		float num3 = Mathf.Clamp(value, 0f, itemAmt.amount);
		float num4 = num3 * destroyFraction * 2f;
		if (itemAmt.amount <= num3 + num4)
		{
			float num5 = (num3 + num4) / itemAmt.amount;
			num3 /= num5;
			num4 /= num5;
		}
		itemAmt.amount -= Mathf.Floor(num3);
		itemAmt.amount -= Mathf.Floor(num4);
		if (num3 < 1f)
		{
			num3 = ((!(UnityEngine.Random.Range(0f, 1f) <= num3)) ? 0f : 1f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (num3 >= 1f)
		{
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, Mathf.FloorToInt(num3), 0uL);
			if (item != null)
			{
				Interface.CallHook("OnDispenserGather", this, entity, item);
				OverrideOwnership(item, attackWeapon);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a healing item is used on a player.
/// </summary>
/// <param name="medicalTool">The medical tool being used.</param>
/// <param name="player">The player receiving the healing effect.</param>
/// <returns>
/// Returns `null` to allow the healing effect to be applied, or any non-null value to override the default behavior.
/// </returns>
object OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)
{
    Puts($"Medical tool {medicalTool.name} used on player {player.displayName}");
    if (player.IsWounded())
    {
        Puts($"Player {player.displayName} is already wounded.");
        return true;
    }
    // Additional logic can be added here to override the default healing effect
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			if (player != GetOwnerPlayer() && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				player.StopWounded();
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an entity is built.
/// </summary>
/// <param name="planner">The planner that built the entity.</param>
/// <param name="gameObject">The GameObject of the built entity.</param>
void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
{
    Puts($"Entity has been built by {planner}.");
    // Add custom logic here if needed
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())
		{
			return;
		}
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ChatMessage("Target socket is not female. (" + target.socket.socketName + ")");
				return;
			}
			if (target.entity != null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ChatMessage("Target socket is occupied. (" + target.socket.socketName + ")");
				return;
			}
		}
		Construction.lastPlacementError = "No Error";
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			ownerPlayer.ChatMessage("Can't place: " + Construction.lastPlacementError);
		}
		if (!(gameObject != null))
		{
			return;
		}
		Interface.CallHook("OnEntityBuilt", this, gameObject);
		Deployable deployable = GetDeployable();
		if (deployable != null)
		{
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
			if (deployable.setSocketParent && target.entity != null && (bool)baseEntity)
			{
				baseEntity.SetParent(target.entity);
				baseEntity.transform.position = target.entity.transform.InverseTransformPoint(baseEntity.transform.position);
			}
			if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
			{
				(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
			}
			if (deployable.copyInventoryFromItem)
			{
				StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
				if ((bool)component2)
				{
					component2.ReceiveInventoryFromItem(GetOwnerItem());
				}
			}
			ItemModDeployable modDeployable = GetModDeployable();
			if (modDeployable != null)
			{
				modDeployable.OnDeployed(baseEntity, ownerPlayer);
			}
		}
		PayForPlacement(ownerPlayer, component);
	}

```

## OnSurveyGather(SurveyCharge,Item)

```csharp
```csharp
/// <summary>
/// Called when a survey charge is gathered.
/// </summary>
/// <param name="surveyCharge">The survey charge being gathered.</param>
/// <param name="item">The item being dropped as a result of the survey charge gathering.</param>
public void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts($"Survey charge {surveyCharge} has been gathered and an item {item} is being dropped.");
    // You can add custom logic here to handle the survey charge gathering and item dropping.
    // For example, you could modify the item's properties or spawn additional entities.
    // If you want to override the default behavior of this hook, return a non-null value from your custom method.
    return;
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		base.Explode();
		if (WaterLevel.Test(base.transform.position))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);
		if (orCreate == null)
		{
			return;
		}
		Vector2i indexFrom = ResourceDepositManager.GetIndexFrom(base.transform.position);
		if (Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))
		{
			return;
		}
		Vector3 point = hitOut.point;
		Vector3 normal = hitOut.normal;
		List<SurveyCrater> obj = Pool.GetList<SurveyCrater>();
		Vis.Entities(base.transform.position, 10f, obj, 1);
		bool flag = obj.Count > 0;
		Pool.FreeList(ref obj);
		if (flag)
		{
			return;
		}
		bool flag2 = false;
		bool flag3 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag2 = true;
				if (resource.isLiquid)
				{
					flag3 = true;
				}
				for (int i = 0; i < num; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", this, item);
					float aimCone = 20f;
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, Vector3.up);
					BaseEntity baseEntity = item.Drop(base.transform.position + Vector3.up * 1f, modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation);
					baseEntity.SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
				}
			}
		}
		if (flag2)
		{
			string strPrefab = ((!flag3) ? craterPrefab.resourcePath : craterPrefab_Oil.resourcePath);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if ((bool)baseEntity2)
			{
				baseEntity2.Spawn();
			}
		}
	}

```

## OnSwitchAmmo(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player switches ammo.
/// </summary>
/// <param name="player">The player switching ammo.</param>
/// <param name="projectile">The projectile being switched to.</param>
/// <returns>
/// Returns a non-null value to override the default ammo switch behavior. 
/// If `null` is returned, the ammo switch will proceed as normal.
/// </returns>
object OnSwitchAmmo(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} switched ammo to {projectile.definition.ammoTypes[0].name}");
    if (projectile.definition.ammoTypes[0].itemid == 123)
    {
        Puts($"Player {player.UserIDString} cannot switch to this ammo.");
        return "Invalid ammo type.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnSwitchAmmo", ownerPlayer, this) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				primaryMagazine.contents = 0;
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## CanLock(KeyLock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to lock the object.
/// </summary>
/// <param name="lock">The KeyLock instance.</param>
/// <param name="player">The BasePlayer attempting to lock the object.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(KeyLock lock, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to lock the object.");
    if (lock.IsLockedBy(player))
    {
        Puts($"Player {player.UserIDString} is already locked by themselves.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Lock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", this, rpc.player) == null && HasLockPermission(rpc.player))
		{
			LockLock(rpc.player);
			SendNetworkUpdate();
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that died.</param>
/// <param name="info">Information about the hit that killed the entity, if any.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity.name} has died.");
    if (info != null && info.attacker != null)
    {
        Puts($"Killed by: {info.attacker.name}");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		Interface.CallHook("OnEntityDeath", this, info);
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
		}
		health = 0f;
		lifestate = LifeState.Dead;
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The container from which the items were dropped.</param>
/// <returns>
/// Returns `true` to prevent the default drop behavior, or `false` to allow it.
/// If `null` is returned, the default drop behavior will be used.
/// </returns>
bool OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping items from container {container.GetDisplayName()}");
    if (container.GetItemCount() == 0)
    {
        Puts("No items to drop.");
        return true;
    }
    // Custom logic here
    return false;
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position, float chance = 1f)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			if (!(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				float num2 = UnityEngine.Random.Range(0f, 2f);
				item.RemoveFromContainer();
				BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
				if (baseEntity == null)
				{
					item.Remove();
				}
				else if (num2 > 0f)
				{
					baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
					baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
				}
			}
		}
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret is shutting down.
/// </summary>
/// <param name="turret">The AutoTurret instance being shut down.</param>
/// <returns>
/// Returns `null` to allow the turret to shut down normally, or any non-null value to prevent it from shutting down.
/// </returns>
object OnTurretShutdown(AutoTurret turret)
{
    Puts($"Turret {turret.GetReference().GetEntityId()} is shutting down.");
    if (turret.GetReference().GetEntityId() == 12345)
    {
        Puts($"Turret {turret.GetReference().GetEntityId()} has been blocked from shutting down.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if (!IsOffline() && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## OnConsumeFuel(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The item being consumed as fuel.</param>
/// <param name="burnable">The burnable item used to determine the fuel consumption behavior.</param>
/// <returns>No return behavior.</returns>
void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel {fuel.info.name} consumed by oven {oven.info.name}");
    if (burnable.fuelAmount <= 0)
    {
        Puts($"Error: Burnable item has no fuel amount");
        return;
    }
    // Additional logic can be added here to handle the consumption of fuel
}
```
```

### Source Code from the Library

```csharp

	private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		Interface.CallHook("OnConsumeFuel", this, fuel, burnable);
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);
			if (!item.MoveToContainer(inventory))
			{
				OvenFull();
				item.Drop(inventory.dropPosition, inventory.dropVelocity);
			}
		}
		if (fuel.amount <= 1)
		{
			fuel.Remove();
			return;
		}
		fuel.amount--;
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
```csharp
/// <summary>
/// Called to determine if two dropped items can be combined.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>
/// Returns `null` to allow the combination, or any non-null value to prevent it.
/// </returns>
object CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts($"Checking if items {item1.item.info.name} and {item2.item.info.name} can be combined.");
    if (item1.item.info.stackable == 1 || item2.item.info.stackable == 1)
    {
        Puts($"Combination prevented: One of the items is not stackable.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item != null && di.item != null && Interface.CallHook("CanCombineDroppedItem", this, di) == null && item.info.stackable > 1 && !(di.item.info != item.info) && (!di.item.IsBlueprint() || di.item.blueprintTarget == item.blueprintTarget))
		{
			int num = di.item.amount + item.amount;
			if (num <= item.info.stackable && num != 0)
			{
				di.DestroyItem();
				di.Kill();
				item.amount = num;
				item.MarkDirty();
				Invoke(IdleDestroy, GetDespawnDuration());
				Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret sets its target.
/// </summary>
/// <param name="turret">The helicopter turret setting the target.</param>
/// <param name="target">The entity being targeted by the helicopter turret.</param>
/// <returns>
/// Returns `null` to allow the helicopter turret to set its target, or any non-null value to prevent it from setting its target.
/// </returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts($"Helicopter turret {turret.GetReference()} is targeting entity {target.UserIDString}.");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"Player {player.UserIDString} is being targeted by helicopter turret {turret.GetReference()}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="block">The building block being modified.</param>
/// <param name="grade">The new grade to be applied.</param>
/// <returns>
/// Returns `true` if the player can change the grade, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
{
    Puts($"Player {player.UserIDString} attempted to change the grade of {block.BlockName} to {grade}.");
    if (grade == BuildingGrade.Enum.Premium && !player.HasPremiumSubscription())
    {
        Puts($"Player {player.displayName} does not have a premium subscription and cannot upgrade to Premium grade.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return HasUpgradePrivilege(iGrade, player) && !IsUpgradeBlocked();
	}

```

## OnStructureDemolish(BuildingBlock,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a structure is demolished.
/// </summary>
/// <param name="structure">The structure being demolished.</param>
/// <param name="player">The player demolishing the structure.</param>
/// <param name="isForced">Whether the demolition was forced or not.</param>
/// <returns>
/// Returns `null` to allow the structure to be demolished, or any non-null value to prevent it from being demolished.
/// </returns>
object OnStructureDemolish(BuildingBlock structure, BasePlayer player, bool isForced)
{
    Puts($"Structure {structure.name} has been demolished by player {player.UserIDString}.");
    if (isForced && structure.isImportant)
    {
        Puts($"Demolition of important structure {structure.name} was forced.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a new grade.
/// </summary>
/// <param name="structure">The structure being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="grade">The new grade of the structure.</param>
/// <returns>
/// Returns a non-null value to override the default upgrade behavior. 
/// If `null` is returned, the structure is upgraded as normal.
/// </returns>
object OnStructureUpgrade(BuildingBlock structure, BasePlayer player, BuildingGrade.Enum grade)
{
    Puts($"Structure {structure.name} has been upgraded by player {player.UserIDString} to grade {grade}.");
    if (grade == BuildingGrade.Enum.Premium && !player.HasPermission("premium_upgrade"))
    {
        Puts($"Player {player.UserIDString} does not have permission to upgrade to premium grade.");
        return "Error: Player does not have required permission.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void DoUpgradeToGrade(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
			ConstructionGrade constructionGrade = GetGrade(@enum);
			if (!(constructionGrade == null) && CanChangeToGrade(@enum, msg.player) && CanAffordUpgrade(@enum, msg.player) && !(base.SecondsSinceAttacked < 30f) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum) == null)
			{
				PayForUpgrade(constructionGrade, msg.player);
				SetGrade(@enum);
				SetHealthToMax();
				StartBeingRotatable();
				SendNetworkUpdate();
				UpdateSkin();
				ResetUpkeepTime();
				BuildingManager.server.GetBuilding(buildingID)?.Dirty();
				Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + @enum.ToString().ToLower() + ".prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item was removed.</param>
/// <param name="item">The item that was removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been removed from container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		if (onPreItemRemove != null)
		{
			onPreItemRemove(item);
		}
		itemList.Remove(item);
		item.parent = null;
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: false);
		}
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed.
/// </summary>
/// <param name="trap">The bear trap being armed.</param>
/// <param name="player">The player who triggered the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to be armed, or any non-null value to prevent it from arming.
/// </returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Bear trap {trap.name} has been armed by player {player.UserIDString}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot trigger traps.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The Bradley APC instance.</param>
/// <returns>
/// Returns `null` to allow the APC to initialize normally, or any non-null value to override the default initialization behavior.
/// </returns>
object OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Bradley APC initialized at position: {apc.transform.position}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="lootableCorpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts($"Player {player.UserIDString} stopped looting {lootableCorpse.DisplayName}");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is patrolling.
/// </summary>
/// <param name="apc">The Bradley APC performing the patrol.</param>
/// <returns>
/// Returns `null` to allow the APC to continue patrolling, or any non-null value to override the default patrol behavior.
/// If a string is returned, it will be used as a message to display in the console.
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC {apc.GetId()} is patrolling.");
    if (apc.GetPosition() == Vector3.zero)
    {
        Puts("Bradley APC has reached its final destination.");
        return "Bradley APC has reached its final destination.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		PathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		BasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);
		BasePathNode basePathNode = null;
		bool flag = false;
		List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			basePathNode = nodes[nodes.Count - 1];
		}
		else
		{
			basePathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) > 2f))
		{
			return;
		}
		if (closestToPoint == basePathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.transform.position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
		else
		{
			if (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].transform.position);
				}
			}
			foreach (BasePathNode item in path)
			{
				currentPath.Add(item.transform.position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
```csharp
/// <summary>
/// Called when a new resource deposit is created.
/// </summary>
/// <param name="resourceDeposit">The newly created resource deposit.</param>
void OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit resourceDeposit)
{
    Puts($"New resource deposit created at position {resourceDeposit.origin}.");
}
```
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		uint seed = new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt);
		UnityEngine.Random.InitState((int)seed);
		ResourceDeposit resourceDeposit = new ResourceDeposit();
		resourceDeposit.origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20);
		float num = UnityEngine.Random.Range(0f, 1f);
		if (num < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else if (0 == 0)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
			float num2 = 0f;
			if (World.Procedural)
			{
				float num3 = ((!(TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f)) ? 0f : 1f);
				num2 = num3 * 0.25f;
			}
			else
			{
				num2 = 0.1f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num4 = 0f;
			if (World.Procedural)
			{
				float num5 = ((!(TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)) ? 0f : 1f);
				num4 = num5 * (0.25f + 0.25f * ((!TerrainMeta.TopologyMap.GetTopology(pos, 8)) ? 0f : 1f) + 0.25f * ((!TerrainMeta.TopologyMap.GetTopology(pos, 1)) ? 0f : 1f));
			}
			else
			{
				num4 = 0.1f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num4)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num6 = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
				{
					num6 += 0.25f;
				}
			}
			else
			{
				num6 += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num6)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret starts up.
/// </summary>
/// <param name="turret">The AutoTurret instance starting up.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally, or any non-null value to prevent it from starting up.
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"Turret {turret.name} has started up.");
    if (turret.isMalfunctioning)
    {
        Puts($"Turret {turret.name} is malfunctioning and cannot start up.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## CanWearItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be worn.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The item to check.</param>
/// <param name="targetSlot">The slot where the item would be worn.</param>
/// <returns>
/// Returns `true` if the item can be worn, or any non-null value to override the default behavior. 
/// If a string is returned, an error message will be displayed.
/// </returns>
object CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
{
    Puts($"Checking if item {item.info.name} can be worn in slot {targetSlot}.");
    if (item.info.name == "Forbidden Item")
    {
        Puts($"Item {item.info.name} cannot be worn due to its forbidden nature.");
        return "Cannot wear: Forbidden item.";
    }
    object result = Interface.CallHook("CanWearItem", inventory, item, targetSlot);
    if (result is bool)
    {
        return result;
    }
    // Additional logic can go here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanWearItem(Item item, int targetSlot)
	{
		ItemModWearable component = item.info.GetComponent<ItemModWearable>();
		if (component == null)
		{
			return false;
		}
		object obj = Interface.CallHook("CanWearItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Item[] array = containerWear.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModWearable component2 = item2.info.GetComponent<ItemModWearable>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 2f);
				}
			}
		}
		return true;
	}

```

## OnMapImageUpdated(unknown)

```csharp
```csharp
/// <summary>
/// Called when a map image is updated.
/// </summary>
void OnMapImageUpdated()
{
    Puts("Map image has been updated.");
    // No return value, as this method does not need to return any specific data.
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void ImageUpdate(RPCMessage msg)
	{
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated", null);
		}
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is upgraded.
/// </summary>
/// <param name="oldItem">The original item being upgraded.</param>
/// <param name="newItem">The upgraded item.</param>
/// <param name="player">The player who performed the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnItemUpgrade(Item oldItem, Item newItem, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has successfully upgraded their {oldItem.info.name} to a {newItem.info.name}.");
    if (newItem.info.category == "rare")
    {
        Puts($"The upgraded item is rare! Player {player.UserIDString} will receive a bonus reward.");
        // Add code here to give the player a bonus reward
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		float num = UnityEngine.Random.Range(0f, 1f);
		if (num <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.eyes.position, player.eyes.BodyForward() * 2f);
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is deauthorized.
/// </summary>
/// <param name="turret">The AutoTurret instance that was deauthorized.</param>
/// <param name="player">The player who deauthorized the turret.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.name} has been deauthorized by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			SendNetworkUpdate();
		}
	}

```

## CanLootEntity(ResourceContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="entity">The entity being looted.</param>
/// <param name="player">The player attempting to loot the entity.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BaseEntity entity, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.baseEntityID}.");
    if (player.IsAdmin())
    {
        return null;
    }
    else
    {
        return "Not allowed: Only admins can loot this entity.";
    }
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.IsVisible(3f)]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && !player.IsDead() && !player.IsSleeping() && lootable && Interface.CallHook("CanLootEntity", this, player) == null)
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.StartLootingEntity(base.baseEntity);
			player.inventory.loot.AddContainer(container);
		}
	}

```

## CanChangeCode(CodeLock,BasePlayer,string,bool)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to change the code.
/// </summary>
/// <param name="lock">The CodeLock instance.</param>
/// <param name="player">The BasePlayer attempting to change the code.</param>
/// <param name="newCode">The new 4-digit code being proposed.</param>
/// <param name="isGuest">Whether this is a guest attempting to change the code.</param>
/// <returns>
/// Returns `null` if the player can change the code, or any non-null value to prevent them from changing it.
/// </returns>
object CanChangeCode(CodeLock lock, BasePlayer player, string newCode, bool isGuest)
{
    Puts($"Player {player.UserIDString} attempted to change the code to {newCode} as a guest: {isGuest}");
    if (newCode == "1234")
    {
        Puts($"Player {player.displayName} is trying to set the code to the default value.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (IsLocked() || text.Length != 4 || (!hasCode && flag))
		{
			return;
		}
		if (!hasCode && !flag)
		{
			SetFlag(Flags.Locked, b: true);
		}
		if (Interface.CallHook("CanChangeCode", this, rpc.player, text, flag) == null)
		{
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnLootSpawn(LootContainer)

```csharp
```csharp
/// <summary>
/// Called when loot is spawned.
/// </summary>
/// <param name="lootContainer">The LootContainer that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnLootSpawn(LootContainer lootContainer)
{
    Puts($"Loot has been spawned in container {lootContainer.containerId}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void SpawnLoot()
	{
		if (inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				Invoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

```

## IOnEnableServerConsole(ServerConsole)

```csharp
```csharp
/// <summary>
/// Called when the server console is enabled.
/// </summary>
/// <param name="console">The server console instance.</param>
/// <returns>
/// Returns `null` to allow the server console to be initialized, or any non-null value to prevent it from being initialized.
/// </returns>
object IOnEnableServerConsole(ServerConsole console)
{
    Puts("Server console enabled.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnEnable()
	{
		if (Interface.CallHook("IOnEnableServerConsole", this) == null)
		{
			console.Initialize();
			input.OnInputText += OnInputText;
			Output.OnMessage += HandleLog;
			input.ClearLine(System.Console.WindowHeight);
			for (int i = 0; i < System.Console.WindowHeight; i++)
			{
				System.Console.WriteLine(string.Empty);
			}
		}
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
Here is the method structure for `OnMeleeAttack(BasePlayer, HitInfo)`:

/// <summary>
/// Called when a melee attack is performed.
/// </summary>
/// <param name="player">The player performing the attack.</param>
/// <param name="hitInfo">Information about the hit.</param>
/// <returns>Returns true if the attack was successful, false otherwise.</returns>
bool OnMeleeAttack(BasePlayer player, HitInfo hitInfo)
{
    // Minimal code to demonstrate functionality
    Puts("OnMeleeAttack called!");
    
    // If ReturnType is void, do not include the return statement
    // In this case, we are returning a boolean value, so we will include the return statement
    
    // Determine if the attack was successful based on the hitInfo parameter
    bool success = true; // Replace with actual logic to determine success
    
    return success;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50L))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo hitInfo = Facepunch.Pool.Get<HitInfo>();
			hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
			hitInfo.Initiator = player;
			hitInfo.Weapon = this;
			hitInfo.WeaponPrefab = this;
			hitInfo.Predicted = msg.connection;
			hitInfo.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, hitInfo) != null)
			{
				return;
			}
			if (hitInfo.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.Log(hitInfo, "melee_nan");
				return;
			}
			if (ConVar.AntiHack.melee_protection > 0 && (bool)hitInfo.HitEntity)
			{
				bool flag = true;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTime + num2 + num3) * num;
				if (ConVar.AntiHack.projectile_protection >= 2)
				{
					float num5 = hitInfo.HitEntity.MaxVelocity();
					float num6 = hitInfo.HitEntity.BoundsPadding() + num4 * num5;
					float num7 = hitInfo.HitEntity.Distance(hitInfo.HitPositionWorld);
					if (num7 > num6)
					{
						string shortPrefabName2 = base.ShortPrefabName;
						string shortPrefabName3 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName2 + " on " + shortPrefabName3 + " with " + num7 + "m > " + num6 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_distance");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					float num8 = hitInfo.Initiator.MaxVelocity();
					float num9 = hitInfo.Initiator.BoundsPadding() + num4 * num8 + num * maxDistance;
					float num10 = hitInfo.Initiator.Distance(hitInfo.HitPositionWorld);
					if (num10 > num9)
					{
						string shortPrefabName4 = base.ShortPrefabName;
						string shortPrefabName5 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num10 + "m > " + num9 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_distance");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					Vector3 pointStart = hitInfo.PointStart;
					Vector3 vector = hitInfo.HitPositionWorld + hitInfo.HitNormalWorld.normalized * 0.001f;
					Vector3 position = player.eyes.position;
					Vector3 vector2 = pointStart;
					Vector3 vector3 = hitInfo.PositionOnRay(vector);
					Vector3 vector4 = vector;
					bool flag2 = GamePhysics.LineOfSight(position, vector2, vector3, vector4, 2162688);
					if (!flag2)
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
					}
					else
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_direct_los", 1, Stats.Server);
					}
					if (!flag2)
					{
						string shortPrefabName6 = base.ShortPrefabName;
						string shortPrefabName7 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat("Line of sight (", shortPrefabName6, " on ", shortPrefabName7, ") ", position, " ", vector2, " ", vector3, " ", vector4));
						player.stats.combat.Log(hitInfo, "melee_los");
						flag = false;
					}
				}
				if (!flag)
				{
					AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
					return;
				}
			}
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50L))
			{
				DoAttackShared(hitInfo);
			}
		}
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine if a world projectile can be created.
/// </summary>
/// <param name="info">The hit info.</param>
/// <param name="itemDef">The item definition.</param>
/// <returns>
/// Returns `null` to allow the creation of the world projectile, or any non-null value to prevent its creation.
/// </returns>
object CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
{
    Puts($"Checking if a world projectile can be created for {itemDef.name} at position {info.HitPositionWorld}");
    // Add custom logic here
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem == null) ? ItemManager.Create(itemDef, 1, 0uL) : recycleItem);
		BaseEntity baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		if (!info.DidHit)
		{
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			if (info.HitEntity == null)
			{
				component.isKinematic = true;
				return;
			}
			Quaternion localRotation = ((info.HitBone != 0) ? Quaternion.LookRotation(info.HitNormalLocal * -1f) : Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)));
			component.isKinematic = true;
			baseEntity.SetParent(info.HitEntity, info.HitBone);
			baseEntity.transform.localPosition = info.HitPositionLocal;
			baseEntity.transform.localRotation = localRotation;
		}
		else
		{
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## OnRecycleItem(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled.
/// </summary>
/// <param name="recycler">The recycler that is recycling the item.</param>
/// <param name="item">The item being recycled.</param>
/// <returns>
/// Returns a non-null value to override the default recycling behavior. 
/// If `null` is returned, the item is recycled as normal.
/// </returns>
object OnRecycleItem(Recycler recycler, Item item)
{
    Puts($"Item {item.info.shortname} has been recycled.");
    if (item.info.Blueprint.scrapFromRecycle > 0 && UnityEngine.Random.Range(0f, 1f) <= recycleEfficiency)
    {
        return "Scrapped: Successful recycling.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = recycleEfficiency;
		for (int i = 0; i < 6; i++)
		{
			Item slot = inventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			if (Interface.CallHook("OnRecycleItem", this, slot) != null)
			{
				if (!HasRecyclable())
				{
					StopRecycling();
				}
				return;
			}
			if (!(slot.info.Blueprint != null))
			{
				continue;
			}
			if (slot.hasCondition)
			{
				num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
			}
			int num2 = 1;
			if (slot.amount > 1)
			{
				num2 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.info.stackable * 0.1f));
			}
			if (slot.info.Blueprint.scrapFromRecycle > 0)
			{
				Item newItem = ItemManager.CreateByName("scrap", slot.info.Blueprint.scrapFromRecycle * num2, 0uL);
				MoveItemToOutput(newItem);
			}
			slot.UseItem(num2);
			foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
			{
				if (ingredient.itemDef.shortname == "scrap")
				{
					continue;
				}
				float num3 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
				int num4 = 0;
				if (num3 <= 1f)
				{
					for (int j = 0; j < num2; j++)
					{
						if (UnityEngine.Random.Range(0f, 1f) <= num)
						{
							num4++;
						}
					}
				}
				else
				{
					num4 = Mathf.CeilToInt(Mathf.Clamp(num3 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount) * (float)num2);
				}
				if (num4 <= 0)
				{
					continue;
				}
				int num5 = Mathf.CeilToInt((float)num4 / (float)ingredient.itemDef.stackable);
				for (int k = 0; k < num5; k++)
				{
					int num6 = ((num4 <= ingredient.itemDef.stackable) ? num4 : ingredient.itemDef.stackable);
					Item newItem2 = ItemManager.Create(ingredient.itemDef, num6, 0uL);
					if (!MoveItemToOutput(newItem2))
					{
						flag = true;
					}
					num4 -= num6;
					if (num4 <= 0)
					{
						break;
					}
				}
			}
			break;
		}
		if (flag || !HasRecyclable())
		{
			StopRecycling();
		}
	}

```

## OnPlayerRevive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is revived.
/// </summary>
/// <param name="reviver">The player who performed the revive.</param>
/// <param name="victim">The player being revived.</param>
/// <returns>
/// Returns `null` to allow the victim to be revived, or any non-null value to prevent them from being revived.
/// </returns>
object OnPlayerRevive(BasePlayer reviver, BasePlayer victim)
{
    Puts($"Player {reviver.UserIDString} has revived player {victim.UserIDString}.");
    if (victim.IsAdmin())
    {
        Puts($"Player {victim.displayName} is an admin and cannot be revived.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			if (player != GetOwnerPlayer() && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				player.StopWounded();
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be wounded.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="hitInfo">Information about the hit that caused this call.</param>
/// <returns>
/// Returns `true` if the player can be wounded, or `false` otherwise. 
/// If a non-boolean value is returned, it will override the default behavior.
/// </returns>
object CanBeWounded(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Checking if {player.UserIDString} can be wounded by {hitInfo.WeaponPrefab.name}.");
    if (hitInfo.WeaponPrefab.name == "Melee")
    {
        Puts($"Player {player.UserIDString} cannot be wounded by melee attacks.");
        return false;
    }
    if (hitInfo.isHeadshot)
    {
        Puts($"Player {player.UserIDString} cannot be wounded by headshots.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastWoundedTime < 60f)
		{
			return false;
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the vending broadcast toggle is changed.
/// </summary>
/// <param name="vendingMachine">The vending machine that was toggled.</param>
/// <param name="player">The player who performed the action.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending broadcast toggle changed by {player.displayName} for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="lock">The lock on the entity, which could be a key or other type of lock.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, and `false` otherwise.
/// If `null` is returned, the default behavior will be used (i.e., the player cannot use the locked entity unless they have permission).
/// </returns>
bool CanUseLockedEntity(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} attempted to use locked entity with key {lock.KeyID}");
    if (lock.IsMasterKey())
    {
        return true;
    }
    // Check if the player has permission to use the locked entity
    if (HasPermission(player, Permission.UseLockedEntity))
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the turret.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="turret">The turret doing the targeting.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts($"Checking if {player} can be targeted by {turret}.");
    if (player.IsSleeping() || !player.IsAlive() || player.IsBuildingAuthed())
    {
        return false;
    }
    object obj = Interface.CallHook("CanBeTargeted", player, turret);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // Additional checks can be added here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		List<BasePlayer> obj2 = Pool.GetList<BasePlayer>();
		Vis.Entities(GetEyePosition() + base.transform.forward * 3f, 2.5f, obj2, 131072);
		bool flag = false;
		foreach (BasePlayer item in obj2)
		{
			if (item.IsSleeping() || !item.IsAlive() || item.IsBuildingAuthed())
			{
				continue;
			}
			object obj3 = Interface.CallHook("CanBeTargeted", item, this);
			if (obj3 is bool)
			{
				Pool.FreeList(ref obj);
				Pool.FreeList(ref obj2);
				return (bool)obj3;
			}
			if (item.GetEstimatedWorldPosition().y > GetEyePosition().y + 0.5f)
			{
				continue;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1075904769);
			for (int i = 0; i < obj.Count; i++)
			{
				RaycastHit hit = obj[i];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			break;
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		return flag;
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is being accepted into the container.
/// </summary>
/// <param name="item">The item being accepted.</param>
/// <param name="targetPos">The position in the container where the item will be placed.</param>
/// <returns>
/// Returns a non-null value to override the default acceptance behavior. 
/// If `CanAcceptResult.CannotAccept` is returned, the item cannot be accepted into the container.
/// If `CanAcceptResult.CannotAcceptRightNow` is returned, the item can be accepted into the container, but there are not enough available slots to accommodate it.
/// </returns>
object CanAcceptItem(ItemContainer container, Item item, int targetPos)
{
    Puts($"Item {item.info.name} is being accepted into container {container.info.name} at position {targetPos}.");
    if (item.info.itemType == ItemType.Key && !container.info.hasLock)
    {
        Puts($"Item {item.info.name} cannot be accepted into container {container.info.name} because it does not have a lock.");
        return CanAcceptResult.CannotAccept;
    }
    object obj = Interface.CallHook("CanAcceptItem", container, item, targetPos);
    if (obj is CanAcceptResult)
    {
        return obj;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (onlyAllowedItem != null && onlyAllowedItem != item.info)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			int[] array = new int[32];
			foreach (ItemSlot availableSlot in availableSlots)
			{
				array[(int)Mathf.Log((float)availableSlot, 2f)]++;
			}
			foreach (Item item2 in itemList)
			{
				for (int i = 0; i < 32; i++)
				{
					if (((uint)item2.info.occupySlots & (uint)(1 << i)) != 0)
					{
						array[i]--;
					}
				}
			}
			for (int j = 0; j < 32; j++)
			{
				if (((uint)item.info.occupySlots & (uint)(1 << j)) != 0 && array[j] <= 0)
				{
					return CanAcceptResult.CannotAcceptRightNow;
				}
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		return CanAcceptResult.CanAccept;
	}

```

## CanPickupEntity(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if an entity can be picked up by a player.
/// </summary>
/// <param name="entity">The entity being considered for pickup.</param>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <returns>
/// Returns `true` if the entity can be picked up, or `false` otherwise. 
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanPickupEntity(BaseCombatEntity entity, BasePlayer player)
{
    Puts($"Checking if {player.UserIDString} can pick up {entity.EntityID}");
    if (entity.IsLocked)
    {
        Puts($"Entity {entity.EntityID} is locked and cannot be picked up.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return pickup.enabled && (!pickup.requireBuildingPrivilege || (player.CanBuild() && (!pickup.requireHammer || player.IsHoldingEntity<Hammer>())));
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.GetPlayerFlag(PlayerFlags.IsAdmin))
    {
        Puts($"Player {player.displayName} is an admin and will receive a special spawn reward.");
        // Reward the admin with something
    }
    else
    {
        Puts($"Player {player.displayName} is not an admin and will respawn normally.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RespawnAt(UnityEngine.Vector3 position, Quaternion rotation)
	{
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		ServerPerformance.spawns++;
		base.transform.position = position;
		base.transform.rotation = rotation;
		tickInterpolator.Reset(position);
		lastTickTime = 0f;
		StopWounded();
		StopSpectating();
		UpdateNetworkGroup();
		UpdatePlayerCollider(state: true);
		UpdatePlayerRigidbody(state: false);
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		InitializeHealth(StartHealth(), StartMaxHealth());
		inventory.GiveDefaultItems();
		SendNetworkUpdateImmediate();
		ClearEntityQueue();
		ClientRPCPlayer(null, this, "StartLoading");
		if (net != null)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", this);
		SendFullSnapshot();
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's sleeping state has ended.
/// </summary>
/// <param name="player">The player whose sleeping state has ended.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has woken up from sleep.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping())
		{
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepingPlayerList.Remove(this);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			UpdatePlayerCollider(state: true);
			UpdatePlayerRigidbody(state: true);
			Interface.CallHook("OnPlayerSleepEnded", this);
		}
	}

```

## OnAirdrop(CargoPlane,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an airdrop is performed.
/// </summary>
/// <param name="cargoPlane">The cargo plane performing the airdrop.</param>
/// <param name="dropPosition">The position where the airdrop will be dropped.</param>
/// <returns>No return behavior.</returns>
void OnAirdrop(CargoPlane cargoPlane, Vector3 dropPosition)
{
    Puts($"Airdrop performed by {cargoPlane.name} at position: {dropPosition}");
    if (Vector3.Distance(dropPosition, new Vector3(0f, 100f, 0f)) < 10f)
    {
        Puts($"Airdrop dropped too close to the base.");
        // Handle airdrop being dropped too close to the base
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		startPos.Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);
		base.transform.position = startPos;
		base.transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", this, newDropPosition);
	}

```

## OnPlayerVoice(BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a player sends voice data.
/// </summary>
/// <param name="player">The player sending the voice data.</param>
/// <param name="data">The voice data being sent.</param>
/// <returns>
/// Returns `null` to allow the voice data to be broadcasted, or any non-null value to prevent it from being broadcasted.
/// </returns>
object OnPlayerVoice(BasePlayer player, byte[] data)
{
    Puts($"Player {player.UserIDString} is sending voice data.");
    if (data.Length > 1024)
    {
        Puts($"Player {player.UserIDString} is trying to send too much voice data.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnReceivedVoice(byte[] data)
	{
		if (Interface.CallHook("OnPlayerVoice", this, data) == null && Network.Net.sv.write.Start())
		{
			Network.Net.sv.write.PacketID(Message.Type.VoiceData);
			Network.Net.sv.write.UInt32(net.ID);
			Network.Net.sv.write.BytesWithSize(data);
			Network.Net.sv.write.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f))
			{
				priority = Priority.Immediate
			});
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned.
/// </summary>
/// <param name="entity">The entity that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity {entity.EntityID} has been spawned.");
    if (entity is BasePlayer player && player.UserIDString == "admin")
    {
        Puts($"Admin player {player.displayName} has been spawned.");
        // Perform any necessary actions for the admin player
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## OnDoorClosed(Door,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a door is closed.
/// </summary>
/// <param name="door">The door that was closed.</param>
/// <param name="player">The player who closed the door.</param>
/// <returns>No return behavior.</returns>
void OnDoorClosed(BaseDoor door, BasePlayer player)
{
    Puts($"Door {door.name} has been closed by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_CloseDoor(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsOpen() && !IsBusy() && !IsLocked())
		{
			BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
			if (!(baseLock != null) || baseLock.OnTryToClose(rpc.player))
			{
				SetFlag(Flags.Open, b: false);
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnDoorClosed", this, rpc.player);
			}
		}
	}

```

## OnCupboardClearList(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the cupboard clear list is triggered.
/// </summary>
/// <param name="buildingPrivilege">The building privilege that owns the cupboard.</param>
/// <param name="player">The player who triggered the clear list action.</param>
/// <returns>
/// Returns `null` to allow the clear list action, or any non-null value to prevent it.
/// </returns>
object OnCupboardClearList(BuildingPrivilege buildingPrivilege, BasePlayer player)
{
    Puts($"Building {buildingPrivilege.GetBuilding().GetWorldName()} cupboard cleared by player {player.UserIDString}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player) && Interface.CallHook("OnCupboardClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			SendNetworkUpdate();
		}
	}

```

## OnTerrainInitialized(unknown)

```csharp
```csharp
/// <summary>
/// Called after the terrain has been initialized.
/// </summary>
void OnTerrainInitialized()
{
    Puts("Terrain initialization complete");
    
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		foreach (TerrainExtension terrainExtension in components)
		{
			terrainExtension.PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized", null);
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amountToConsume">The amount of the item to consume. Defaults to 1.</param>
/// <returns>No return behavior.</returns>
void OnItemUse(Item item, int amountToConsume)
{
    Puts($"Item {item.name} has been used.");
    if (amountToConsume > item.maxStackSize)
    {
        Puts($"Warning: Attempted to consume more than the maximum stack size ({item.maxStackSize}) of item {item.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			Interface.CallHook("OnItemUse", this, amountToConsume);
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## CanAdministerVending(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can administer a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine in question.</param>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanAdministerVending(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempting to administer vending machine {vendingMachine.name}");
    if (player.IsSuperAdmin)
    {
        return true;
    }
    else if (player.IsAdmin)
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return PlayerBehind(player);
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a vending transaction is performed.
/// </summary>
/// <param name="vendingMachine">The vending machine that performed the transaction.</param>
/// <param name="buyer">The player who bought the item.</param>
/// <param name="sellOrderId">The ID of the sell order being executed.</param>
/// <param name="numberOfTransactions">The number of transactions to perform (default is 1).</param>
/// <returns>
/// Returns a non-null value to override the default transaction behavior. 
/// If `true` is returned, the transaction will be allowed as normal.
/// If `false` is returned, the transaction will be cancelled.
/// </returns>
bool OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
{
    Puts($"Vending machine {vendingMachine.name} has performed a transaction for player {buyer.displayName}.");
    if (sellOrderId < 0 || sellOrderId > vendingMachine.sellOrders.Count)
    {
        return false;
    }
    ProtoBuf.VendingMachine.SellOrder sellOrder = vendingMachine.sellOrders[sellOrderId];
    List<Item> list = buyer.inventory.FindItemsByItemID(sellOrder.itemToSellID);
    if (sellOrder.itemToSellIsBP)
    {
        list = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
                where x.blueprintTarget == sellOrder.itemToSellID
                select x).ToList();
    }
    if (list == null || list.Count == 0)
    {
        return false;
    }
    numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
    int num = sellOrder.itemToSellAmount * numberOfTransactions;
    int num2 = list.Sum((Item x) => x.amount);
    if (num > num2)
    {
        return false;
    }
    List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
    if (sellOrder.currencyIsBP)
    {
        source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
                where x.blueprintTarget == sellOrder.currencyID
                select x).ToList();
    }
    source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
    if (source.Count == 0)
    {
        return false;
    }
    int num3 = source.Sum((Item x) => x.amount);
    int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
    if (num3 < num4)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
	{
		if (sellOrderId < 0 || sellOrderId > sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (Vector3.Distance(buyer.GetEstimatedWorldPosition(), base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> list = inventory.FindItemsByItemID(sellOrder.itemToSellID);
		if (sellOrder.itemToSellIsBP)
		{
			list = (from x in inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.itemToSellID
				select x).ToList();
		}
		if (list == null || list.Count == 0)
		{
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = list.Sum((Item x) => x.amount);
		if (num > num2)
		{
			return false;
		}
		List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
		if (source.Count == 0)
		{
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
		if (num3 < num4)
		{
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			if (!item.MoveToContainer(inventory))
			{
				item.Drop(inventory.dropPosition, Vector3.zero);
			}
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		int num7 = 0;
		foreach (Item item4 in list)
		{
			Item item2 = ((item4.amount > num) ? item4.SplitItem(num) : item4);
			num7 += item2.amount;
			buyer.GiveItem(item2, GiveItemReason.PickedUp);
			if (num7 >= num)
			{
				break;
			}
		}
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a turret targets an entity.
/// </summary>
/// <param name="turret">The AutoTurret that has targeted the entity.</param>
/// <param name="entity">The BaseCombatEntity that the turret is targeting.</param>
/// <returns>
/// Returns `null` to allow the turret to target the entity, or any non-null value to prevent the turret from targeting the entity.
/// </returns>
object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
{
    Puts($"Turret {turret.name} is now targeting {entity.displayName}.");
    if (entity is Player player && player.IsSpectator())
    {
        Puts($"Player {player.displayName} is a spectator and cannot be targeted by the turret.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((!(targ == null)) ? targetAcquiredEffect.resourcePath : targetLostEffect.resourcePath, base.transform.position, Vector3.up);
			}
			target = targ;
		}
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is rotated.
/// </summary>
/// <param name="block">The building block being rotated.</param>
/// <param name="player">The player performing the rotation.</param>
/// <returns>
/// Returns `null` to allow the structure to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnStructureRotate(BuildingBlock block, BasePlayer player)
{
    Puts($"Structure {block.name} has been rotated by player {player.UserIDString}");
    if (block.isLocked)
    {
        Puts($"Structure {block.name} is locked and cannot be rotated.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotate && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			if ((bool)currentSkin)
			{
				currentSkin.Refresh(this);
			}
			SendNetworkUpdateImmediate();
			ClientRPC(null, "RefreshSkin");
		}
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger.
/// </summary>
/// <param name="trigger">The trigger that was entered.</param>
/// <param name="entity">The entity that entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has entered trigger {trigger.name}");
}
```
```

### Source Code from the Library

```csharp

	internal virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			Interface.CallHook("OnEntityEnter", this, ent);
			entityContents.Add(ent);
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
```csharp
/// <summary>
/// Called when a player's tick is received.
/// </summary>
/// <param name="player">The player whose tick is being processed.</param>
/// <param name="tick">The player's tick data.</param>
/// <param name="wasPlayerStalled">Whether the player was stalled during this tick.</param>
/// <returns>
/// Returns a non-null value to override the default tick processing behavior. 
/// If `null` is returned, the tick is processed as normal.
/// </returns>
object OnPlayerTick(BasePlayer player, PlayerTick tick, bool wasPlayerStalled)
{
    Puts($"Processing tick for player {player.displayName}.");
    if (wasPlayerStalled)
    {
        Puts($"Player {player.displayName} was stalled during this tick.");
        // Add custom logic here to handle stalled players
    }
    else
    {
        // Add custom logic here to handle normal ticks
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null || Interface.CallHook("OnPlayerInput", this, serverInput) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if the helicopter can strafe.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanHelicopterStrafe(PatrolHelicopterAI ai)
{
    Puts($"Helicopter {ai.GetHelicopterName()} is checking if it can strafe.");
    if (ai.IsInDanger())
    {
        Puts($"Helicopter {ai.GetHelicopterName()} cannot strafe because it's in danger.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= 20f && CanInterruptState();
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
Based on the provided code snippet, I will create a method structure for `OnWeaponFired` as per the given instructions.

```csharp
/// <summary>
/// Called when a weapon is fired.
/// </summary>
/// <param name="baseProjectile">The base projectile.</param>
/// <param name="basePlayer">The player who fired the weapon.</param>
/// <param name="itemModProjectile">The item mod projectile component.</param>
/// <param name="protoBufProjectileShoot">The projectile shoot data.</param>
void OnWeaponFired(BaseProjectile baseProjectile, BasePlayer basePlayer, ItemModProjectile itemModProjectile, ProtoBuf.ProjectileShoot protoBufProjectileShoot)
{
    // Minimal code to demonstrate functionality
}
```

Please note that I have not included any return type or additional parameters as per the original method structure. If you need further assistance or modifications, please let me know!
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_missing");
			return;
		}
		ItemDefinition ammoType = primaryMagazine.ammoType;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (ammoType.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_mismatch");
			return;
		}
		if (!UsingInfiniteAmmoCheat)
		{
			primaryMagazine.contents--;
		}
		ItemModProjectile component = ammoType.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection);
		player.CleanupExpiredProjectiles();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.Log(this, "duplicate_id");
				continue;
			}
			if (!ValidateEyePos(player, projectile.startPos))
			{
				projectile.startPos = player.eyes.position;
			}
			player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, ammoType);
			CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
		}
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count());
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
		UpdateItemCondition();
		Sensation sensation = default(Sensation);
		sensation.Type = SensationType.Gunshot;
		sensation.Position = player.GetNetworkPosition();
		sensation.Radius = 100f;
		Sense.Stimulate(sensation);
		if (EACServer.playerTracker == null)
		{
			return;
		}
		using (TimeWarning.New("LogPlayerShooting"))
		{
			UnityEngine.Vector3 networkPosition = player.GetNetworkPosition();
			UnityEngine.Vector3 networkRotation = player.GetNetworkRotation();
			int weaponID = GetItem()?.info.itemid ?? 0;
			EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(player.net.connection);
			PlayerUseWeapon eventParams = default(PlayerUseWeapon);
			eventParams.Position = new EasyAntiCheat.Server.Cerberus.Vector3(networkPosition.x, networkPosition.y, networkPosition.z);
			eventParams.ViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(networkRotation.x, networkRotation.y, networkRotation.z);
			eventParams.WeaponID = weaponID;
			EACServer.playerTracker.LogPlayerUseWeapon(client, eventParams);
		}
	}

```

## OnSpinWheel(BasePlayer,SpinnerWheel)

```csharp
```csharp
/// <summary>
/// Called when a player spins the wheel.
/// </summary>
/// <param name="player">The player spinning the wheel.</param>
/// <param name="wheel">The spinner wheel being spun.</param>
/// <returns>No return behavior.</returns>
void OnSpinWheel(BasePlayer player, SpinnerWheel wheel)
{
    Puts($"Player {player.UserIDString} has spun the wheel.");
    if (wheel.IsJackpot())
    {
        Puts($"Player {player.UserIDString} hit the jackpot!");
        // Award a prize or bonus
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Spin(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && (AnyoneSpin() || rpc.player.CanBuild()))
		{
			Interface.CallHook("OnSpinWheel", rpc.player, this);
			if (!(velocity > 15f))
			{
				velocity += UnityEngine.Random.Range(4f, 7f);
			}
		}
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an entity.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntity(BasePlayer looter, BaseEntity entity)
{
    Puts($"Player {looter.UserIDString} started looting entity {entity.baseEntityID}.");
    if (entity is Chest)
    {
        Puts($"Player {looter.UserIDString} opened a chest.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if ((bool)targetEntity && targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			Assert.IsTrue(targetEntity.isServer, "Assure is server");
			PositionChecks = doPositionChecks;
			entitySource = targetEntity;
			itemSource = null;
			MarkDirty();
			Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		}
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a code is entered into the lock.
/// </summary>
/// <param name="lock">The CodeLock instance.</param>
/// <param name="player">The player who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>
/// Returns `null` to allow the code to be accepted, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnCodeEntered(CodeLock lock, BasePlayer player, string code)
{
    Puts($"Player {player.displayName} entered code '{code}' into lock {lock.name}");
    if (code == "admin123")
    {
        return "Access granted. Welcome, admin!";
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 10f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
			}
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
		}
	}

```

## OnTurretToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret's online status is toggled.
/// </summary>
/// <param name="turret">The AutoTurret instance whose online status has been toggled.</param>
/// <returns>
/// Returns `null` to allow the turret's online status to be toggled, or any non-null value to prevent the toggle.
/// If a string is returned, it will be used as a message to display when the turret's online status is toggled.
/// </returns>
object OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret.GetReference()} has been {(turret.HasFlag(Flags.On) ? "turned off" : "turned on")}.");
    if (turret.IsOffline())
    {
        return "Turret is offline.";
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != HasFlag(Flags.On) && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			booting = false;
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
			}
		}
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger.
/// </summary>
/// <param name="trigger">The trigger that the entity left.</param>
/// <param name="entity">The entity that left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.ClassName} has left trigger {trigger.EntityId}");
}
```
```

### Source Code from the Library

```csharp

	internal virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null)
		{
			Interface.CallHook("OnEntityLeave", this, ent);
			entityContents.Remove(ent);
		}
	}

```

## CanDismountEntity(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is about to be dismounted by a player.
/// </summary>
/// <param name="entity">The entity being dismounted.</param>
/// <param name="player">The player dismounting the entity.</param>
/// <returns>
/// Returns `null` to allow the entity to be dismounted, or any non-null value to prevent it from being dismounted.
/// </returns>
object CanDismountEntity(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is attempting to dismount entity {entity.EntityId}");
    if (entity.IsInWater)
    {
        Puts($"Cannot dismount entity {entity.EntityId} while it's in water");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player)
	{
		if (!(_mounted == null) && Interface.CallHook("CanDismountEntity", this, player) == null)
		{
			_mounted.DismountObject();
			Vector3 dismountPosition = GetDismountPosition(player);
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(dismountPosition);
			_mounted.eyes.NetworkUpdate(dismountAnchor.transform.rotation);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", dismountPosition);
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player starting to sleep.</param>
/// <returns>
/// Returns `null` to allow the player to start sleeping, or any non-null value to prevent them from sleeping.
/// </returns>
object OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has started sleeping.");
    if (player.GetPlayerFlag(PlayerFlags.Admin))
    {
        Puts($"Player {player.UserIDString} is an admin and cannot sleep.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping() && Interface.CallHook("OnPlayerSleep", this) == null)
		{
			EnsureDismounted();
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			if (!sleepingPlayerList.Contains(this))
			{
				sleepingPlayerList.Add(this);
			}
			CancelInvoke(InventoryUpdate);
			inventory.loot.Clear();
			inventory.crafting.CancelAll(returnItems: true);
			UpdatePlayerCollider(state: true);
			UpdatePlayerRigidbody(state: false);
		}
	}

```

## OnPlayerSpawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player spawns.
/// </summary>
/// <param name="player">The player spawning.</param>
/// <returns>
/// Returns `null` to allow the player to spawn normally, or any non-null value to override the default spawn behavior. 
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object OnPlayerSpawn(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has spawned.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is not allowed to spawn.");
        return "Blocked: Unauthorized player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SpawnNewPlayer(Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot);
		BasePlayer basePlayer = baseEntity.ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer) == null)
		{
			basePlayer.health = 0f;
			basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
			basePlayer.ResetLifeStateOnSpawn = false;
			basePlayer.limitNetworking = true;
			basePlayer.Spawn();
			basePlayer.limitNetworking = false;
			basePlayer.PlayerInit(connection);
			if (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife)
			{
				basePlayer.Respawn();
			}
			else
			{
				basePlayer.SendRespawnOptions();
			}
			DebugEx.Log(basePlayer.net.connection.ToString() + " joined [" + basePlayer.net.connection.os + "/" + basePlayer.net.connection.ownerid + "]", StackTraceLogType.None);
		}
	}

```

## OnOpenVendingShop(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player opens a vending shop.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player opening the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingShop(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has opened a vending shop with ID {vendingMachine.id}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		SendSellOrders(msg.player);
		PlayerOpenLoot(msg.player, customerPanel);
		Interface.CallHook("OnOpenVendingShop", this, msg.player);
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, DroppedItemContainer entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.GetDisplayName()}");
    if (entity.IsLocked())
    {
        Puts($"Entity {entity.GetDisplayName()} is locked and cannot be looted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if (player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null)
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.StartLootingEntity(this);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base combat entity is hurt.
/// </summary>
/// <param name="entity">The base combat entity that was hurt.</param>
/// <param name="hitInfo">Information about the hit, including the initiator and damage types.</param>
object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} has been hurt by {hitInfo.Initiator} with damage type {hitInfo.damageTypes.GetMajorityDamageType()}.");
    // You can override the default behavior here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50L))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			health = num - info.damageTypes.Total();
			SendNetworkUpdate();
			if (SingletonComponent<AiManager>.Instance != null && SingletonComponent<AiManager>.Instance.enabled && SingletonComponent<AiManager>.Instance.UseIntensity)
			{
				SingletonComponent<AiManager>.Instance.OnHit(info);
			}
			if (ConVar.Global.developer > 1)
			{
				Debug.Log(string.Concat("[Combat]".PadRight(10), base.gameObject.name, " hurt ", info.damageTypes.GetMajorityDamageType(), "/", info.damageTypes.Total(), " - ", health.ToString("0"), " health left"));
			}
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (baseCombatEntity2 != null)
			{
				baseCombatEntity2.MarkHostileTime();
			}
			if (lastDamage != DamageType.Decay)
			{
				lastAttackedTime = UnityEngine.Time.time;
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.ServerPosition - ServerPosition).normalized;
				}
			}
			if (health <= 0f)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.Log(info, num, health, "killed");
				}
				else
				{
					initiatorPlayer.stats.combat.Log(info, num, health);
				}
			}
		}
	}

```

## OnItemResearch(ResearchTable,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player researches an item.
/// </summary>
/// <param name="researchTable">The research table being used.</param>
/// <param name="item">The item being researched.</param>
/// <param name="player">The player performing the research.</param>
/// <returns>
/// Returns `null` to allow the research to proceed, or any non-null value to cancel the research.
/// </returns>
object OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is researching item {item.info.name}.");
    if (item.info.category == "restricted")
    {
        Puts($"Player {player.displayName} does not have permission to research restricted items.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", targetItem, player) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client authenticates with the server.
/// </summary>
/// <param name="connection">The connection object representing the client.</param>
/// <returns>
/// Returns `null` to allow the client to authenticate normally, or any non-null value to override the default authentication behavior. 
/// If a string is returned, the client will be kicked with the provided message as the reason.
/// </returns>
object OnClientAuth(Network.Connection connection)
{
    Puts($"Client {connection} has authenticated with the server.");
    if (connection.userid == 1234567890)
    {
        Puts($"Client {connection} has been blocked from authenticating.");
        return "Blocked: Unauthorized client.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Connection.State.Connecting;
		byte b = packet.read.UInt8();
		if (b != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String();
		packet.connection.username = packet.read.String();
		Interface.CallHook("OnClientAuth", packet.connection);
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.unread >= 4)
		{
			text = packet.read.String();
		}
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their branch is '", text, "' not '", branch, "'"), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2054)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2054), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2054)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2054), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize();
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
			}
			else
			{
				auth.OnNewConnection(packet.connection);
			}
		}
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="landmine">The landmine that was triggered.</param>
/// <param name="victim">The player who triggered the landmine.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(Landmine landmine, BasePlayer victim)
{
    Puts($"Landmine {landmine.name} triggered by player {victim.displayName}");
    if (victim.isSuperAdmin)
    {
        Puts($"Player {victim.displayName} is a super admin and cannot trigger the landmine.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## CanNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC can attack a target.
/// </summary>
/// <param name="npc">The NPC attempting to attack.</param>
/// <param name="target">The entity the NPC is trying to attack.</param>
/// <returns>
/// Returns `null` to allow the NPC to attack, or any non-null value to prevent them from attacking.
/// </returns>
object CanNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} attempting to attack {target.displayName}");
    if (target is Player player && player.IsSpectating)
    {
        Puts($"NPC {npc.name} cannot attack spectating player {player.displayName}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if (!AttackTarget || !AttackReady() || Interface.CallHook("CanNpcAttack", this, AttackTarget) != null)
		{
			return;
		}
		float magnitude = (AttackTarget.ServerPosition - ServerPosition).magnitude;
		if (!(magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(null, "Attack", AttackTarget.ServerPosition);
			}
		}
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a melee item is thrown.
/// </summary>
/// <param name="thrower">The player who threw the item.</param>
/// <param name="item">The item that was thrown.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the item is thrown as normal.
/// </returns>
object OnMeleeThrown(BasePlayer thrower, Item item)
{
    Puts($"Item {item.info.shortPrefabName} was thrown by player {thrower.displayName}.");
    if (item.info.shortPrefabName == "Sword")
    {
        Puts($"Player {thrower.displayName} threw a sword. This is not allowed.");
        return "Swords are not allowed to be thrown.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (!canThrowAsProjectile)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "not_throwable");
			return;
		}
		Item item = GetItem();
		if (item == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "item_missing");
			return;
		}
		ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (projectileShoot.projectiles.Count != 1)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "count_mismatch");
			return;
		}
		player.CleanupExpiredProjectiles();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.Log(this, "duplicate_id");
				continue;
			}
			if (!ValidateEyePos(player, projectile.startPos))
			{
				projectile.startPos = player.eyes.position;
			}
			player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, item);
			Effect effect = new Effect();
			effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
			effect.scale = 1f;
			effect.pooledString = component.projectileObject.resourcePath;
			effect.number = projectile.seed;
			EffectNetwork.Send(effect);
		}
		item.SetParent(null);
		Interface.CallHook("OnMeleeThrown", player, item);
		if (player != null)
		{
			Sensation sensation = default(Sensation);
			sensation.Type = SensationType.ThrownWeapon;
			sensation.Position = player.GetNetworkPosition();
			sensation.Radius = 50f;
			Sense.Stimulate(sensation);
		}
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when a resource is gathered from a quarry.
/// </summary>
/// <param name="quarry">The mining quarry that gathered the resource.</param>
/// <param name="item">The item that was gathered, which can be a resource such as coal or iron ore.</param>
void OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts($"Resource {item.GetDefinition().name} has been gathered from quarry {quarry.name}.");
    if (item.GetDefinition().name == "rare_ore")
    {
        Puts($"Rare ore has been found in the quarry! Adding it to the player's inventory.");
        // Add the rare ore to the player's inventory or perform some other action
    }
    else if (item.GetDefinition().name == "depleted_resource")
    {
        Puts($"The resource {item.GetDefinition().name} is depleted. The quarry will need to be refilled before it can gather more.");
        // Perform some action when the resource is depleted, such as refilling the quarry
    }
}
```
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			resource.workDone += workToAdd;
			if (!(resource.workDone < resource.workNeeded))
			{
				int num = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
				resource.workDone -= (float)num * resource.workNeeded;
				Item item = ItemManager.Create(resource.type, num, 0uL);
				Interface.CallHook("OnQuarryGather", this, item);
				if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a player buys an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine the item was purchased from.</param>
/// <param name="player">The player who made the purchase.</param>
/// <param name="itemIndex">The index of the item purchased.</param>
/// <param name="quantity">The quantity of the item purchased.</param>
/// <returns>No return behavior.</returns>
void OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer player, int itemIndex, int quantity)
{
    Puts($"Player {player.UserIDString} bought {quantity} x {itemIndex} from vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void BuyItem(RPCMessage rpc)
	{
		int num = rpc.read.Int32();
		int num2 = rpc.read.Int32();
		Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2);
		SetPendingOrder(rpc.player, num, num2);
		Invoke(CompletePendingOrder, 2.5f);
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser bonus is assigned to a player.
/// </summary>
/// <param name="dispenser">The dispenser that triggered the bonus.</param>
/// <param name="player">The player who received the bonus.</param>
/// <param name="item">The item that was given as a bonus.</param>
/// <returns>
/// Returns `null` to allow the player to receive the bonus, or any non-null value to override the default behavior.
/// If an `Item` is returned, it will be used instead of the original item.
/// </returns>
object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} received a bonus from dispenser {dispenser.displayName}.");
    if (item.def.name == "GoldenApple")
    {
        Puts($"Player {player.UserIDString} received a Golden Apple bonus.");
        return new Item(item.def, 10);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction)
	{
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			Item item = ItemManager.Create(finishBonu.itemDef, Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction)), 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## CanSeeStash(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can see the stash.
/// </summary>
/// <param name="container">The stash container.</param>
/// <param name="player">The player trying to access the stash.</param>
/// <returns>
/// Returns `null` to allow the player to see the stash, or any non-null value to prevent them from seeing it.
/// </returns>
object CanSeeStash(StashContainer container, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to access stash {container.GetID()}");
    if (player.IsAdmin())
    {
        return null;
    }
    else
    {
        return "Access denied: Not an admin";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsUnhide(RPCMessage rpc)
	{
		if (IsHidden() && Interface.CallHook("CanSeeStash", this, rpc.player) == null)
		{
			BasePlayer player = rpc.player;
			if (PlayerInRange(player))
			{
				SetHidden(isHidden: false);
			}
		}
	}

```

## OnFindBurnable(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when an oven is searching for a burnable item.
/// </summary>
/// <param name="oven">The oven searching for a burnable item.</param>
/// <returns>
/// Returns the first burnable item found in the inventory, or `null` if no burnable item is found.
/// If a non-null value other than an Item is returned from this hook, it will be ignored and the method will continue to search the inventory.
/// </returns>
Item OnFindBurnable(BaseOven oven)
{
    Puts($"Oven {oven.GetInventory().GetDisplayName()} is searching for a burnable item.");
    if (oven.GetInventory().GetItemByType(ItemType.Burnable) != null)
    {
        return oven.GetInventory().GetItemByType(ItemType.Burnable);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (inventory == null)
		{
			return null;
		}
		foreach (Item item in inventory.itemList)
		{
			ItemModBurnable component = item.info.GetComponent<ItemModBurnable>();
			if ((bool)component && (fuelType == null || item.info == fuelType))
			{
				return item;
			}
		}
		return null;
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing ground.
/// </summary>
/// <param name="entity">The BaseEntity that is missing ground.</param>
/// <returns>
/// Returns `null` to allow the entity to die normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for killing the entity.
/// </returns>
object OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} is missing ground.");
    if (entity.GetComponent<Prop>() != null)
    {
        Puts($"Entity {entity.UserIDString} has a Prop component, so it will be destroyed with a reason.");
        return "Reason: Entity was missing ground.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (Interface.CallHook("OnEntityGroundMissing", baseEntity) == null && baseEntity != null)
		{
			baseEntity.SendMessage("PreDie", SendMessageOptions.DontRequireReceiver);
			baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
		}
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is crafted.
/// </summary>
/// <param name="itemCraftTask">The task associated with the crafting process.</param>
/// <param name="owner">The player who initiated the crafting process.</param>
/// <param name="fromTempBlueprint">The blueprint used for crafting, if any.</param>
/// <returns>
/// Returns a non-null value to override the default crafting behavior. 
/// If `true` is returned, the crafting process will be allowed as normal.
/// If `false` is returned, the crafting process will be cancelled.
/// </returns>
object OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)
{
    Puts($"Player {owner.displayName} has initiated an item craft task.");
    if (itemCraftTask.blueprint.targetItem.itemid == 12345)
    {
        Puts($"Player {owner.displayName} is attempting to craft a restricted item.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null)
	{
		if (!CanCraft(bp, amount))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		CollectIngredients(bp, itemCraftTask, amount, owner);
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.owner = owner;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			return (bool)obj;
		}
		queue.Enqueue(itemCraftTask);
		if (itemCraftTask.owner != null)
		{
			itemCraftTask.owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a Bradley APC can target the given entity.
/// </summary>
/// <param name="apc">The Bradley APC attempting to target.</param>
/// <param name="entity">The entity being targeted.</param>
/// <returns>
/// Returns `true` if the Bradley APC can target the entity, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
{
    Puts($"Bradley APC {apc.transform.position} attempting to target {entity.displayName} at {entity.CenterPoint()}");
    if (entity == null || !entity.IsValid())
    {
        return true;
    }
    if (!(Vector3.Distance(entity.GetEstimatedWorldPosition(), apc.transform.position) < 1000))
    {
        return true;
    }
    object result = Interface.CallHook("CanBradleyApcTarget", apc, entity);
    if (result is bool)
    {
        return (bool)result;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.GetEstimatedWorldPosition(), base.transform.position) < viewDistance))
		{
			return false;
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			return basePlayer.IsVisible(position, CenterPoint()) || basePlayer.IsVisible(position, basePlayer.eyes.position) || basePlayer.IsVisible(position, basePlayer.transform.position);
		}
		Debug.LogWarning("Standard vis test!");
		return IsVisible(ent.CenterPoint());
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets another entity.
/// </summary>
/// <param name="npc">The NPC that is targeting.</param>
/// <param name="target">The entity being targeted.</param>
/// <returns>
/// Returns a value indicating the NPC's desire to attack the target, on a scale from 0 (no interest) to 1 (high interest). 
/// If `null` is returned, the default behavior will be used.
/// </returns>
float OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} has targeted entity {target.UserIDString}.");
    if (target == null || !target.IsValid())
    {
        return 0f;
    }
    if (target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
    {
        return 1f - npc.Stats.Tolerance;
    }
    return 0f;
}
```
```

### Source Code from the Library

```csharp

	internal float WantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("OnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		if (target == null)
		{
			return 0f;
		}
		if (CurrentBehaviour == Behaviour.Sleep)
		{
			return 0f;
		}
		if (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
		{
			return 0f;
		}
		if (target.GetType() == GetType())
		{
			return 1f - Stats.Tolerance;
		}
		return 1f;
	}

```

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating.
/// </summary>
/// <param name="player">The player starting to spectate.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} started spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to spectate with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnPlayerDie(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player dies.
/// </summary>
/// <param name="player">The player who died.</param>
/// <param name="info">Information about the hit that killed the player, if any.</param>
/// <returns>
/// Returns `null` to allow the player to die normally. If a non-null value is returned, it will override the default death behavior.
/// </returns>
object OnPlayerDie(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} has died.");
    if (info != null && info.Attacker != null)
    {
        Puts($"Player was killed by {info.Attacker.UserIDString} with a {info.Weapon}.");
        return $"Killed by {info.Attacker.UserIDString} with a {info.Weapon}.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead())
			{
				if (Belt != null && ShouldDropActiveItem())
				{
					UnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(vector.normalized * 3f);
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDie", this, info) == null)
				{
					base.Die(info);
				}
			}
		}
	}

```

## IOnRconInitialize(unknown)

```csharp
```csharp
/// <summary>
/// Called when the RCON system is initialized.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRconInitialize()
{
    Puts("RCON system initialized.");
}
```
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize", null) != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", string.Empty));
		if (Password == "password" || Password == string.Empty)
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPEndPoint ip, string id, string msg)
			{
				lock (Commands)
				{
					Command item = JsonConvert.DeserializeObject<Command>(msg);
					item.Ip = ip;
					item.ConnectionId = id;
					Commands.Enqueue(item);
				}
			};
			listenerNew.Start();
			Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			Debug.Log("RCon Started on " + Port);
			Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player attacks another entity.
/// </summary>
/// <param name="player">The player performing the attack.</param>
/// <param name="info">Information about the hit, including the target entity and damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default behavior of updating item conditions and starting a cooldown. 
/// If a non-null value is returned, it will override these behaviors.
/// </returns>
object OnPlayerAttack(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} attacked entity {info.HitEntity?.ToString()} with damage {info.Damage}.");
    if (info.HitEntity == null || info.HitEntity.IsServerOnly())
    {
        Puts($"Entity {info.HitEntity?.ToString()} is not a valid target for attack.");
        return true;
    }
    // Custom logic to handle player attacks can go here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", GetOwnerPlayer(), info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50L))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (base.isServer)
		{
			using (TimeWarning.New("ImpactEffect", 20L))
			{
				Effect.server.ImpactEffect(info);
			}
		}
		else
		{
			using (TimeWarning.New("ImpactEffect", 20L))
			{
				Effect.client.ImpactEffect(info);
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50L))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay * 0.5f);
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The storage container being used for looting.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.UserIDString} has stopped looting the entity.");
    if (container.GetContents().Count > 0)
    {
        Puts($"The storage container still contains {container.GetContents().Count} items.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the target player can be looted, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is trying to loot player {target.UserIDString}");
    if (looter == target)
    {
        return false;
    }
    object obj = Interface.CallHook("CanLootPlayer", looter, target);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If no specific rule is set, allow looting by default
    return true;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		return IsWounded() || IsSleeping();
	}

```

## OnEntityDismounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is dismounted by a player.
/// </summary>
/// <param name="entity">The entity being dismounted.</param>
/// <param name="player">The player who dismounted the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityDismounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Entity {entity.name} has been dismounted by player {player.displayName}");
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player)
	{
		if (!(_mounted == null) && Interface.CallHook("CanDismountEntity", this, player) == null)
		{
			_mounted.DismountObject();
			Vector3 dismountPosition = GetDismountPosition(player);
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(dismountPosition);
			_mounted.eyes.NetworkUpdate(dismountAnchor.transform.rotation);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", dismountPosition);
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can target a player.
/// </summary>
/// <param name="helicopter">The helicopter attempting to target the player.</param>
/// <param name="player">The player being targeted.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player, and `false` otherwise.
/// If this method is not implemented, the default behavior will be used.
/// </returns>
bool CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Helicopter {helicopter.GetReference()} attempting to target player {player.UserIDString}.");
    if (player.IsDead || player.IsInvisible)
    {
        return false;
    }
    Vector3 playerPosition = player.eyes.position;
    Vector3 helicopterPosition = helicopter.transform.position;
    float distance = Vector3.Distance(playerPosition, helicopterPosition);
    if (distance > 100f)
    {
        return false;
    }
    // Additional logic to determine if the helicopter can target the player
    // For example, check if the player is within a certain radius of the helicopter's interest zone
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1084434689) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap trigger is snapped to an object.
/// </summary>
/// <param name="trapTrigger">The trap trigger that was snapped.</param>
/// <param name="objectSnapped">The object that the trap trigger was snapped to.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trapTrigger, GameObject objectSnapped)
{
    Puts($"Trap {trapTrigger.name} snapped to object {objectSnapped.name}");
}
```
```

### Source Code from the Library

```csharp

	internal override void OnObjectAdded(GameObject obj)
	{
		Interface.CallHook("OnTrapSnapped", this, obj);
		base.OnObjectAdded(obj);
		_trap.ObjectEntered(obj);
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC wants to eat a given entity.
/// </summary>
/// <param name="npc">The NPC in question.</param>
/// <param name="entity">The entity the NPC is considering eating.</param>
/// <returns>
/// Returns `true` if the NPC wants to eat the entity, and `false` otherwise.
/// If a non-null value other than `bool` is returned, it will be used as the return value instead of this default behavior.
/// </returns>
object CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc.name} wants to eat {entity.name}");
    if (entity.HasTrait(TraitFlag.Poisoned))
    {
        Puts($"NPC {npc.name} does not want to eat {entity.name} because it is poisoned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnPlayerWound(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is wounded.
/// </summary>
/// <param name="player">The player who was wounded.</param>
/// <returns>
/// Returns `null` to allow the player to be wounded, or any non-null value to prevent them from being wounded.
/// </returns>
object OnPlayerWound(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been wounded.");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot be wounded.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartWounded()
	{
		if (!IsWounded() && Interface.CallHook("OnPlayerWound", this) == null)
		{
			stats.Add("wounded", 1);
			woundedDuration = UnityEngine.Random.Range(40f, 50f);
			woundedStartTime = UnityEngine.Time.realtimeSinceStartup;
			SetPlayerFlag(PlayerFlags.Wounded, b: true);
			SendNetworkUpdateImmediate();
			Invoke(WoundingTick, 1f);
		}
	}

```

## OnEntityMounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is mounted by a player.
/// </summary>
/// <param name="entity">The entity being mounted.</param>
/// <param name="player">The player mounting the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityMounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has mounted {entity.name}");
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && Interface.CallHook("CanMountEntity", this, player) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			player.MountObject(this);
			player.MovePosition(mountAnchor.transform.position);
			player.transform.rotation = mountAnchor.transform.rotation;
			player.ServerRotation = mountAnchor.transform.rotation;
			player.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			SetFlag(Flags.Busy, b: true);
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed in the shop.
/// </summary>
/// <param name="shopFront">The shop front where the trade was completed.</param>
/// <returns>
/// Returns `null` to allow the trade to be completed as normal, or any non-null value to override the default behavior and prevent the trade from being completed.
/// </returns>
object OnShopCompleteTrade(ShopFront shopFront)
{
    Puts($"Trade has been completed in shop {shopFront.name}.");
    if (shopFront.owner == "admin")
    {
        Puts($"Admin {shopFront.owner} is not allowed to complete trades.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			for (int num = vendorInventory.capacity - 1; num >= 0; num--)
			{
				Item slot = vendorInventory.GetSlot(num);
				Item slot2 = customerInventory.GetSlot(num);
				if ((bool)customerPlayer && slot != null)
				{
					customerPlayer.GiveItem(slot);
				}
				if ((bool)vendorPlayer && slot2 != null)
				{
					vendorPlayer.GiveItem(slot2);
				}
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine is rotated.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="player">The player who initiated the rotation.</param>
/// <returns>
/// Returns `null` to allow the vending machine to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending Machine {vendingMachine.name} has been rotated by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot rotate the vending machine");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RotateVM(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (Interface.CallHook("OnRotateVendingMachine", this, player) == null && player.CanBuild() && IsInventoryEmpty())
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnCropGather(PlantEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player gathers crops.
/// </summary>
/// <param name="plantEntity">The plant entity being gathered from.</param>
/// <param name="item">The item being gathered.</param>
/// <param name="player">The player gathering the crop.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the crop is gathered as normal.
/// </returns>
object OnCropGather(PlantEntity plantEntity, Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} has gathered {item.info.name} from {plantEntity.info.name}.");
    if (item.info.category == "Forbidden")
    {
        Puts($"Player {player.displayName} has been prevented from gathering {item.info.name}.");
        return "Forbidden: Item is not allowed to be gathered.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_PickFruit(RPCMessage msg)
	{
		if (!CanPick())
		{
			return;
		}
		harvests++;
		float num = YieldBonusScale() * (float)plantProperty.waterYieldBonus;
		int num2 = Mathf.RoundToInt((currentStage.resources + num) * (float)plantProperty.pickupAmount);
		ResetSeason();
		if (plantProperty.pickupItem.condition.enabled)
		{
			for (int i = 0; i < num2; i++)
			{
				Item item = ItemManager.Create(plantProperty.pickupItem, 1, 0uL);
				item.conditionNormalized = plantProperty.fruitCurve.Evaluate(ageFraction);
				Interface.CallHook("OnCropGather", this, item, msg.player);
				msg.player.GiveItem(item, GiveItemReason.PickedUp);
			}
		}
		else
		{
			Item item2 = ItemManager.Create(plantProperty.pickupItem, num2, 0uL);
			Interface.CallHook("OnCropGather", this, item2, msg.player);
			msg.player.GiveItem(item2, GiveItemReason.PickedUp);
		}
		if (plantProperty.pickEffect.isValid)
		{
			Effect.server.Run(plantProperty.pickEffect.resourcePath, GetEstimatedWorldPosition(), Vector3.up);
		}
		if (harvests >= plantProperty.maxHarvests)
		{
			if (plantProperty.disappearAfterHarvest)
			{
				Die();
			}
			else
			{
				BecomeState(PlantProperties.State.Dying);
			}
		}
		else
		{
			BecomeState(PlantProperties.State.Mature);
		}
	}

```

## CanUseVending(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the vending machine, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseVending(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to use vending machine {vendingMachine.name}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and can use the vending machine.");
        return true;
    }
    else if (player.HasPermission("use_vending"))
    {
        Puts($"Player {player.displayName} has permission to use the vending machine.");
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to use the vending machine.");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName = "")
	{
		object obj = Interface.CallHook("CanUseVending", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		return base.CanOpenLootPanel(player, panelName) && CanPlayerAdmin(player);
	}

```

## OnItemCraftCancelled(ItemCraftTask)

```csharp
```csharp
/// <summary>
/// Called when an item craft task is cancelled.
/// </summary>
/// <param name="task">The cancelled item craft task.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task)
{
    Puts($"Item craft task {task.taskUID} has been cancelled.");
    if (task.owner == null || !task.owner.IsConnected())
    {
        return;
    }
    task.owner.Command("note.craft_cancelled", task.taskUID, 0);
    // Additional logic can be added here to handle the cancellation of the item craft task.
}
```
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID, bool ReturnItems)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (itemCraftTask.owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask);
		itemCraftTask.owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0 && ReturnItems)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))
					{
						takenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition, itemCraftTask.owner.inventory.containerMain.dropVelocity);
						itemCraftTask.owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
		}
		return true;
	}

```

## OnExplosiveThrown(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an explosive is thrown.
/// </summary>
/// <param name="thrower">The player who threw the explosive.</param>
/// <param name="explosive">The explosive entity that was thrown.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the explosive will be handled as normal.
/// </returns>
object OnExplosiveThrown(BasePlayer thrower, BaseEntity explosive)
{
    Puts($"Explosive thrown by {thrower.displayName} at position {explosive.transform.position}.");
    if (explosive.prefab == "grenade")
    {
        // Handle grenade explosion
        return null;
    }
    else if (explosive.prefab == "molotov")
    {
        // Handle molotov cocktail explosion
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoThrow(RPCMessage msg)
	{
		if (!HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		Vector3 vector = msg.read.Vector3();
		Vector3 normalized = msg.read.Vector3().normalized;
		float num = Mathf.Clamp01(msg.read.Float());
		if (!ValidateEyePos(msg.player, vector))
		{
			vector = msg.player.eyes.position;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation((!(overrideAngle == Vector3.zero)) ? overrideAngle : (-normalized)));
		if (!(baseEntity == null))
		{
			baseEntity.creatorEntity = msg.player;
			baseEntity.SetVelocity(normalized * maxThrowVelocity * num + msg.player.estimatedVelocity * 0.5f);
			if (tumbleVelocity > 0f)
			{
				baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * tumbleVelocity);
			}
			baseEntity.Spawn();
			Interface.CallHook("OnExplosiveThrown", msg.player, baseEntity);
			StartAttackCooldown(repeatDelay);
			UseItemAmount(1);
			BasePlayer player = msg.player;
			if (player != null)
			{
				Sensation sensation = default(Sensation);
				sensation.Type = SensationType.ThrownWeapon;
				sensation.Position = player.GetNetworkPosition();
				sensation.Radius = 50f;
				Sense.Stimulate(sensation);
			}
		}
	}

```

## OnServerInitialized(unknown)

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerInitialized()
{
    Puts("Server has been successfully initialized.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void OpenConnection()
	{
		useQueryPort = ConVar.Server.queryport > 0 && ConVar.Server.queryport != ConVar.Server.port;
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			return;
		}
		StartSteamServer();
		Network.Net.sv.onMessage = OnNetworkMessage;
		Network.Net.sv.onDisconnected = OnDisconnected;
		if (!useQueryPort)
		{
			Network.Net.sv.onUnconnectedMessage = OnUnconnectedMessage;
		}
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		Interface.CallHook("OnServerInitialized", null);
	}

```

## CanVendingAcceptItem(VendingMachine,Item,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a vending machine can accept an item.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being attempted to be accepted.</param>
/// <param name="targetSlot">The slot on the vending machine where the item is being placed.</param>
/// <returns>
/// Returns `true` if the vending machine can accept the item, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior and be used as the return value.
/// </returns>
object CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)
{
    Puts($"Vending machine {vendingMachine.name} attempting to accept item {item.displayName} into slot {targetSlot}");
    if (item.isExpired)
    {
        Puts($"Item {item.displayName} is expired and cannot be accepted.");
        return false;
    }
    if (item.parent != null && item.parent == vendingMachine)
    {
        Puts($"Item {item.displayName} is already owned by vending machine {vendingMachine.name} and cannot be accepted again.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if (transactionActive)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (inventory.itemList.Contains(item))
		{
			return true;
		}
		if (ownerPlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(ownerPlayer);
	}

```

## CanStackItem(Item,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if two items can be stacked together.
/// </summary>
/// <param name="item1">The first item.</param>
/// <param name="item2">The second item.</param>
/// <returns>
/// Returns `true` if the items can be stacked, or any non-null value to override the default stacking behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the items cannot be stacked.
/// </returns>
object CanStackItem(Item item1, Item item2)
{
    Puts($"Checking if {item1.info.itemid} and {item2.info.itemid} can be stacked.");
    if (item1 == item2)
    {
        return true;
    }
    if (item1.info.stackable <= 1 || item2.info.stackable <= 1)
    {
        return null;
    }
    if (item1.info.itemid != item2.info.itemid)
    {
        return null;
    }
    if ((item1.hasCondition && item1.condition != item1.maxCondition) ||
        (item2.hasCondition && item2.condition != item2.maxCondition))
    {
        return null;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (info.stackable <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != maxCondition)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.maxCondition)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		return true;
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldHealth">The player's old health value.</param>
/// <param name="newHealth">The player's new health value.</param>
/// <returns>No return behavior.</returns>
void OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Player {player.UserIDString}'s health changed from {oldHealth} to {newHealth}");
}
```
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) == null)
		{
			base.OnHealthChanged(oldvalue, newvalue);
			metabolism.isDirty = true;
		}
	}

```

## CanHideStash(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hide their stash.
/// </summary>
/// <param name="player">The player attempting to hide their stash.</param>
/// <returns>
/// Returns `null` to allow the player to hide their stash, or any non-null value to prevent them from hiding it.
/// </returns>
object CanHideStash(BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to hide their stash.");
    if (player.IsAdmin())
    {
        return null;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", this, rpc.player) == null)
		{
			SetHidden(isHidden: true);
		}
	}

```

## CanSetBedPublic(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player tries to set their bed public or private.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being modified.</param>
/// <param name="player">The player making the change.</param>
/// <returns>
/// Returns `null` to allow the player to make the change, or any non-null value to prevent them from doing so.
/// </returns>
object CanSetBedPublic(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to set their bed public or private.");
    if (player.userID == 123456 && !IsPublic())
    {
        Puts($"Player {player.displayName} cannot make this change because they are not the owner.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsPublic() && Interface.CallHook("CanSetBedPublic", this, msg.player) == null)
		{
			SetPublic(flag);
			if (!IsPublic())
			{
				deployerUserID = msg.player.userID;
			}
			SendNetworkUpdate();
		}
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The console argument.</param>
/// <returns>
/// Returns `true` to allow the command to execute, or `false` to prevent it from executing.
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// If `null` is returned, the default behavior of allowing the command to execute will occur.
/// </returns>
object IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Executing server command: {arg.cmd.FullName}");
    if (arg.Invalid)
    {
        Puts("Invalid console argument");
        return "Invalid console argument";
    }
    // Rest of the code remains the same
}
```
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null)
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## IOnRunCommandLine(unknown)

```csharp
```csharp
/// <summary>
/// Called when the command line is run.
/// </summary>
/// <param name="args">The arguments passed to the command line.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the command line will be processed as normal.
/// </returns>
object IOnRunCommandLine(string[] args)
{
    Puts($"Command line run with arguments: {string.Join(", ", args)}");
    if (args.Contains("--debug"))
    {
        Puts("Debug mode enabled.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine", null) != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The IPlayer instance of the kicked user.</param>
/// <param name="reason">The reason for kicking the user.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(IPlayer player, string reason)
{
    Puts($"User {player.Name} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer player, string reason)
	{
		if (player.IPlayer != null)
		{
			Interface.Oxide.CallHook("OnUserKicked", player.IPlayer, reason);
		}
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned player.</param>
/// <param name="steamId">The Steam ID of the unbanned player.</param>
/// <param name="ipAddress">The IP address of the unbanned player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.Oxide.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.Oxide.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

```

## OnUserBanned(string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is banned.
/// </summary>
/// <param name="name">The username of the banned user.</param>
/// <param name="steamId">The Steam ID of the banned user.</param>
/// <param name="ipAddress">The IP address of the banned user.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string name, string steamId, string ipAddress, string reason)
{
    Puts($"User {name} with SteamID {steamId} and IP {ipAddress} has been banned: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.Oxide.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.Oxide.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

```

## OnPlayerBanned(string,ulong,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="name">The name of the banned player.</param>
/// <param name="steamId">The Steam ID of the banned player.</param>
/// <param name="ipAddress">The IP address of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string name, ulong steamId, string ipAddress, string reason)
{
    Puts($"Player {name} with SteamID {steamId} and IP {ipAddress} has been banned: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.Oxide.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.Oxide.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.Oxide.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.Oxide.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

```

