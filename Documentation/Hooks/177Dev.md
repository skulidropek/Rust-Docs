# Hook Definitions

## OnItemResearchEnd(ResearchTable,float)

```csharp
```csharp
/// <summary>
/// Called when an item research attempt ends.
/// </summary>
/// <param name="researchTable">The research table that was being used.</param>
/// <param name="successChance">The chance of the research being successful, between 0 and 1.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If a float is returned, it will be used as the new success chance.
/// </returns>
object OnItemResearchEnd(ResearchTable researchTable, float successChance)
{
    Puts($"Item research attempt ended on table {researchTable.name} with success chance {successChance}.");
    if (successChance > 0.9f)
    {
        Puts($"Item research was extremely successful on table {researchTable.name}!");
        return "EXTREMELY_SUCCESSFUL";
    }
    else if (successChance < 0.1f)
    {
        Puts($"Item research failed miserably on table {researchTable.name}. Better luck next time!");
        return "FAILED_MISERABLY";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null)
		{
			float num = UnityEngine.Random.Range(0f, 1f);
			object obj = Interface.CallHook("OnItemResearchEnd", this, num);
			if (obj is float)
			{
				num = (float)obj;
			}
			int num2 = ScrapForFullChance(targetItem);
			if (num <= GetSuccessChance(targetItem, inventory.GetSlot(1)))
			{
				int iAmount = 1;
				Item item = ItemManager.Create(targetItem.info, iAmount, 0uL);
				if (!item.MoveToContainer(inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
			else if (researchFailEffect.isValid)
			{
				Effect.server.Run(researchFailEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			if (scrapItem != null)
			{
				if (scrapItem.amount <= num2)
				{
					inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num2);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## OnDispenserGather(ResourceDispenser,BaseEntity,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser gathers an item.
/// </summary>
/// <param name="dispenser">The dispenser that gathered the item.</param>
/// <param name="entity">The entity from which the item was gathered.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the dispenser will give the item to the entity as normal.
/// </returns>
object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
{
    Puts($"Dispenser {dispenser} gathered an item from entity {entity}.");
    if (item.itemid == "GoldenApple")
    {
        Puts($"Dispenser {dispenser} found a Golden Apple!);
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float value = itemAmt.startAmount * num / num2;
		float num3 = Mathf.Clamp(value, 0f, itemAmt.amount);
		float num4 = num3 * destroyFraction * 2f;
		if (itemAmt.amount <= num3 + num4)
		{
			float num5 = (num3 + num4) / itemAmt.amount;
			num3 /= num5;
			num4 /= num5;
		}
		float amount = itemAmt.amount;
		itemAmt.amount -= Mathf.Floor(num3);
		itemAmt.amount -= Mathf.Floor(num4);
		if (num3 < 1f)
		{
			num3 = ((!(UnityEngine.Random.Range(0f, 1f) <= num3)) ? 0f : 1f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (num3 >= 1f)
		{
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, Mathf.FloorToInt(num3), 0uL);
			if (item != null)
			{
				Interface.CallHook("OnDispenserGather", this, entity, item);
				OverrideOwnership(item, attackWeapon);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnPlayerViolation(BasePlayer,AntiHackType,float)

```csharp
```csharp
/// <summary>
/// Called when a player is flagged for a violation.
/// </summary>
/// <param name="player">The player who committed the violation.</param>
/// <param name="type">The type of violation (e.g. speedhack, aimbot).</param>
/// <param name="amount">The severity of the violation.</param>
/// <returns>
/// Returns `null` to allow the player's violation level to be updated as normal.
/// If a non-null value is returned, it will override the default behavior and prevent the player's violation level from being updated.
/// </returns>
object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
{
    Puts($"Player {player.UserIDString} has been flagged for a {type} violation of {amount}.");
    if (type == AntiHackType.Speedhack && amount > 10f)
    {
        Puts($"Player {player.displayName} is suspected of using a speedhack and will be banned from the server.");
        return "Banned: Speedhack detected.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void AddViolation(BasePlayer ply, AntiHackType type, float amount)
	{
		if (Interface.CallHook("OnPlayerViolation", ply, type, amount) == null)
		{
			ply.lastViolationType = type;
			ply.lastViolationTime = UnityEngine.Time.realtimeSinceStartup;
			ply.violationLevel += amount;
			if ((ConVar.AntiHack.debuglevel >= 2 && amount > 0f) || ConVar.AntiHack.debuglevel >= 3)
			{
				LogToConsole(ply, type, "Added violation of " + amount + " in frame " + UnityEngine.Time.frameCount + " (now has " + ply.violationLevel + ")");
			}
			EnforceViolations(ply);
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed in the shop.
/// </summary>
/// <param name="shopFront">The shop front where the trade was completed.</param>
/// <returns>
/// Returns `null` to allow the trade completion, or any non-null value to prevent it.
/// If a string is returned, an error message will be displayed to the players involved in the trade.
/// </returns>
object OnShopCompleteTrade(ShopFront shopFront)
{
    Puts($"Trade completed at shop front {shopFront.name}.");
    if (shopFront.inventory.Count == 0)
    {
        Puts($"Error: Shop inventory is empty.");
        return "Error: Shop inventory is empty.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			for (int num = vendorInventory.capacity - 1; num >= 0; num--)
			{
				Item slot = vendorInventory.GetSlot(num);
				Item slot2 = customerInventory.GetSlot(num);
				if ((bool)customerPlayer && slot != null)
				{
					customerPlayer.GiveItem(slot);
				}
				if ((bool)vendorPlayer && slot2 != null)
				{
					vendorPlayer.GiveItem(slot2);
				}
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a rocket is launched.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="rocket">The launched rocket entity.</param>
object OnRocketLaunched(BasePlayer player, BaseEntity rocket)
{
    Puts($"Player {player.UserIDString} launched a rocket.");
    if (rocket != null)
    {
        // Perform any necessary actions when the rocket is launched
        return rocket;
    }
    else
    {
        // Handle the case where the rocket was not successfully created
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "magazine_empty");
			return;
		}
		primaryMagazine.contents--;
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		if (!ValidateEyePos(player, vector))
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Eye position (" + base.ShortPrefabName + ")");
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		float num = GetAimCone() + component.projectileSpread;
		if (num > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num, vector2);
		}
		float num2 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num2, 1101212417))
		{
			num2 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num2);
		if (!(baseEntity == null))
		{
			baseEntity.creatorEntity = player;
			baseEntity.SendMessage("InitializeVelocity", vector2 * 1f);
			baseEntity.Spawn();
			Interface.CallHook("OnRocketLaunched", msg.player, baseEntity);
			StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
			GetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));
		}
	}

```

## OnTurretToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret's online status is toggled.
/// </summary>
/// <param name="turret">The AutoTurret whose online status has been toggled.</param>
/// <returns>
/// Returns `null` to allow the turret's online status to be toggled, or any non-null value to prevent the toggle.
/// </returns>
object OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret.GetGlobalName()} has been {(turret.HasFlag(Flags.On) ? "turned off" : "turned on")}.");
    if (turret.IsOffline())
    {
        return "Cannot turn off an already offline turret.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != HasFlag(Flags.On) && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			booting = false;
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
			}
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped.
/// </summary>
/// <param name="item">The item being dropped.</param>
/// <param name="baseEntity">The BaseEntity representing the dropped item, or null if the item cannot be dropped.</param>
/// <returns>No return behavior.</returns>
void OnItemDropped(Item item, BaseEntity baseEntity)
{
    Puts($"Item {item.info.name} has been dropped.");
    if (baseEntity != null && baseEntity is BasePlayer)
    {
        Puts($"The item was dropped by player {((BasePlayer)baseEntity).displayName}");
    }
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		RemoveFromWorld();
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
		}
		else
		{
			Remove();
		}
		RemoveFromContainer();
		Interface.CallHook("OnItemDropped", this, baseEntity);
		return baseEntity;
	}

```

## OnServerShutdown(unknown)

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerShutdown()
{
    Puts("Server shutdown initiated.");
    // No additional logic needed for this hook, as it's primarily used to notify plugins of the shutdown.
}
```
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("OnServerShutdown", null);
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		foreach (BasePlayer basePlayer in array)
		{
			basePlayer.Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## CanSetBedPublic(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player tries to set their bed public or private.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being modified.</param>
/// <param name="player">The player making the change.</param>
/// <returns>
/// Returns `null` to allow the player to make the change, or any non-null value to prevent them from doing so.
/// </returns>
object CanSetBedPublic(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to set their bed public or private.");
    if (player.userID == 123456 && !IsPublic())
    {
        Puts($"Player {player.displayName} cannot make this change because they are not the owner.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsPublic() && Interface.CallHook("CanSetBedPublic", this, msg.player) == null)
		{
			SetPublic(flag);
			if (!IsPublic())
			{
				deployerUserID = msg.player.userID;
			}
			SendNetworkUpdate();
		}
	}

```

## CanPickupLock(BasePlayer,BaseLock)

```csharp
```csharp
/// <summary>
/// Called when a player tries to pick up a lock.
/// </summary>
/// <param name="player">The player attempting to pick up the lock.</param>
/// <param name="lock">The lock being picked up.</param>
/// <returns>
/// Returns `null` if the player can pick up the lock, or any non-null value to prevent them from picking it up.
/// </returns>
object CanPickupLock(BasePlayer player, BaseLock lock)
{
    Puts($"Player {player.UserIDString} is trying to pick up lock {lock.lockID}");
    if (lock.isLocked)
    {
        Puts($"Player {player.UserIDString} cannot pick up locked lock {lock.lockID}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_TakeLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && Interface.CallHook("CanPickupLock", rpc.player, this) == null)
		{
			Item item = ItemManager.Create(itemType, 1, skinID);
			if (item != null)
			{
				rpc.player.GiveItem(item);
			}
			Kill();
		}
	}

```

## CanPickupEntity(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pickup the entity.
/// </summary>
/// <param name="entity">The entity being picked up.</param>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or any non-null value to override the default behavior.
/// If a string is returned, the player will be notified with the provided message as the reason they cannot pick up the entity.
/// If `null` is returned, the default pickup rules apply.
/// </returns>
object CanPickupEntity(BaseCombatEntity entity, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempting to pick up {entity.DisplayName()}");
    if (entity.IsLocked())
    {
        return "Cannot pick up locked entity.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return pickup.enabled && (!pickup.requireBuildingPrivilege || (player.CanBuild() && (!pickup.requireHammer || ((bool)player.GetHeldEntity() && player.GetHeldEntity().GetComponent<Hammer>() != null))));
	}

```

## OnItemResearchStart(ResearchTable)

```csharp
```csharp
/// <summary>
/// Called when a player starts researching an item.
/// </summary>
/// <param name="researchTable">The research table being used.</param>
/// <returns>No return behavior.</returns>
void OnItemResearchStart(ResearchTable researchTable)
{
    Puts($"Player started researching {researchTable.item.name} at {researchTable.position}.");
    if (researchTable.item.amount <= 1 && !researchTable.item.IsResearchable())
    {
        Puts($"Player cannot research {researchTable.item.name} because it's not researchable or has no items to research.");
        return;
    }
    Effect.server.Run("effect/path", this, 0u, Vector3.zero, Vector3.zero);
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("OnItemResearch", targetItem, player) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearchStart", this);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item was removed.</param>
/// <param name="item">The item that was removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been removed from container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		if (onPreItemRemove != null)
		{
			onPreItemRemove(item);
		}
		itemList.Remove(item);
		item.parent = null;
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: false);
		}
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## CanEquipItem(PlayerInventory,Item)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be equipped.
/// </summary>
/// <param name="playerInventory">The player's inventory.</param>
/// <param name="item">The item to equip.</param>
/// <returns>
/// Returns `true` if the item can be equipped, or any non-null value to prevent equipping. 
/// If a string is returned, the item cannot be equipped due to a specific reason.
/// </returns>
object CanEquipItem(PlayerInventory playerInventory, Item item)
{
    Puts($"Checking if item {item.info.name} can be equipped.");
    object result = Interface.CallHook("CanEquipItem", playerInventory, item);
    if (result is bool && !(bool)result)
    {
        return "Cannot equip: Insufficient resources.";
    }
    // Additional logic to check for container restrictions and conflicts with other items
    ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
    if (component != null)
    {
        Item[] array = playerInventory.itemList.ToArray();
        foreach (Item item2 in array)
        {
            if (item2 != item)
            {
                ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
                if (component2 != null && !component.CanExistWith(component2) && !item2.MoveToContainer(playerInventory.container))
                {
                    return "Cannot equip: Conflict with other items.";
                }
            }
        }
    }
    return result;
}
```
```

### Source Code from the Library

```csharp

	private bool CanEquipItem(Item item)
	{
		object obj = Interface.CallHook("CanEquipItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
		if (component == null)
		{
			return true;
		}
		Item[] array = containerBelt.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 2f);
				}
			}
		}
		return true;
	}

```

## CanLock(CodeLock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player tries to lock the object.
/// </summary>
/// <param name="lock">The CodeLock instance.</param>
/// <param name="player">The BasePlayer attempting to lock the object.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(CodeLock lock, BasePlayer player)
{
    Puts($"Player {player.UserIDString} tried to lock the object.");
    if (lock.IsLocked())
    {
        Puts($"Object is already locked by another player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", this, rpc.player) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the gun trap.
/// </summary>
/// <param name="player">The player being checked.</param>
/// <param name="gunTrap">The gun trap doing the checking.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, GunTrap gunTrap)
{
    Puts($"Checking if {player.Name} can be targeted by {gunTrap.Name}.");
    // Custom logic to determine if the player can be targeted
    // For example:
    if (player.IsSleeping() || !player.IsAlive())
    {
        return false;
    }
    else if (player.HasPlayerFlag(BasePlayer.PlayerFlags.InBuildingPrivilege) && player.CanBuild())
    {
        return true;
    }
    else
    {
        // Call other hooks or perform additional checks here
        object result = Interface.CallHook("CanBeTargeted", player, gunTrap);
        if (result is bool)
        {
            return (bool)result;
        }
        else
        {
            return result;
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger(float offset, float radius)
	{
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		List<BasePlayer> obj2 = Pool.GetList<BasePlayer>();
		Vis.Entities(GetEyePosition() + base.transform.forward * offset, radius, obj2, 131072);
		bool flag = false;
		foreach (BasePlayer item in obj2)
		{
			if (item.IsSleeping() || !item.IsAlive() || (item.HasPlayerFlag(BasePlayer.PlayerFlags.InBuildingPrivilege) && item.CanBuild()))
			{
				continue;
			}
			object obj3 = Interface.CallHook("CanBeTargeted", item, this);
			if (obj3 is bool)
			{
				return (bool)obj3;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1075904769);
			for (int i = 0; i < obj.Count; i++)
			{
				RaycastHit hit = obj[i];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		return flag;
	}

```

## OnCollectiblePickup(Item,BasePlayer,CollectibleEntity)

```csharp
```csharp
/// <summary>
/// Called when a player picks up a collectible item.
/// </summary>
/// <param name="item">The collected item.</param>
/// <param name="player">The player who picked up the item.</param>
/// <param name="entity">The entity from which the item was picked up.</param>
/// <returns>No return behavior.</returns>
void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
{
    Puts($"Player {player.UserIDString} picked up collectible item: {item.info.name}");
    if (item.info.category == "Rare")
    {
        Puts($"Player {player.displayName} is lucky! They got a rare item.");
        // Give the player a bonus or reward
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && itemList != null)
		{
			ItemAmount[] array = itemList;
			foreach (ItemAmount itemAmount in array)
			{
				Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
				Interface.CallHook("OnCollectiblePickup", item, msg.player, this);
				msg.player.GiveItem(item, GiveItemReason.PickedUp);
			}
			itemList = null;
			if (pickupEffect.isValid)
			{
				Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
			}
			Kill();
		}
	}

```

## OnServerInitialized(unknown)

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
void OnServerInitialized()
{
    Puts("Server has been initialized.");
    // No return value, as this method does not need to return any specific data.
}
```
```

### Source Code from the Library

```csharp

	public void OpenConnection()
	{
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			return;
		}
		StartSteamServer();
		Network.Net.sv.onMessage = OnNetworkMessage;
		Network.Net.sv.onUnconnectedMessage = OnUnconnectedMessage;
		Network.Net.sv.onDisconnected = OnDisconnected;
		EACServer.DoStartup();
		InvokeRepeating("EACUpdate", 1f, 1f);
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		Interface.CallHook("OnServerInitialized", null);
	}

```

## CanAdministerVending(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can administer a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine in question.</param>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanAdministerVending(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Checking if {player.displayName} can administer {vendingMachine.name}");
    // Minimal code to demonstrate functionality
    return PlayerHasPermission(player, "administer_vending");
}
```
```

### Source Code from the Library

```csharp

	public bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return PlayerBehind(player);
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a new grade.
/// </summary>
/// <param name="structure">The structure being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="grade">The new grade of the structure.</param>
/// <returns>
/// Returns `null` if the upgrade is allowed, or any non-null value to prevent the upgrade.
/// </returns>
object OnStructureUpgrade(BaseEntity structure, BasePlayer player, BuildingGrade.Enum grade)
{
    Puts($"Structure {structure.name} has been upgraded by player {player.UserIDString} to grade {grade}.");
    if (grade == BuildingGrade.Enum.Premium && !player.HasPermission("premium.upgrades"))
    {
        Puts($"Player {player.UserIDString} does not have permission to upgrade to premium grade.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoUpgradeToGrade(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
			ConstructionGrade constructionGrade = GetGrade(@enum);
			if (!(constructionGrade == null) && CanChangeToGrade(@enum, msg.player) && CanAffordUpgrade(@enum, msg.player) && !(base.SecondsSinceAttacked < 8f) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum) == null)
			{
				PayForUpgrade(constructionGrade, msg.player);
				SetGrade(@enum);
				SetHealthToMax();
				StartBeingRotatable();
				SendNetworkUpdate();
				UpdateSkin();
				Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + @enum.ToString().ToLower() + ".prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player starting to sleep.</param>
/// <returns>
/// Returns `null` to allow the player to start sleeping, or any non-null value to prevent them from sleeping.
/// </returns>
object OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has started sleeping.");
    if (player.GetPlayerFlag(PlayerFlags.Admin))
    {
        Puts($"Player {player.UserIDString} is an admin and cannot sleep.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping() && Interface.CallHook("OnPlayerSleep", this) == null)
		{
			EnsureDismounted();
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			if (!sleepingPlayerList.Contains(this))
			{
				sleepingPlayerList.Add(this);
			}
			CancelInvoke(InventoryUpdate);
			inventory.loot.Clear();
			inventory.crafting.CancelAll(returnItems: true);
			UpdatePlayerCollider(state: true);
			UpdatePlayerRigidbody(state: false);
		}
	}

```

## OnCupboardDeauthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's authorization to access the cupboard is deauthorized.
/// </summary>
/// <param name="buildingPrivilege">The building privilege that was deauthorized.</param>
/// <param name="player">The player who had their authorization deauthorized.</param>
/// <returns>No return behavior.</returns>
void OnCupboardDeauthorize(BuildingPrivlidge buildingPrivilege, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been deauthorized from accessing the cupboard.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && CanAdministrate(rpc2.player) && Interface.CallHook("OnCupboardDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			UpdateAllPlayers();
			SendNetworkUpdate();
		}
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a combat entity is hurt.
/// </summary>
/// <param name="entity">The combat entity that was hurt.</param>
/// <param name="hitInfo">Information about the hit, including the damage type and initiator.</param>
/// <returns>
/// Returns a non-null value to override the default hurt behavior. 
/// If `null` is returned, the entity will be handled as normal.
/// </returns>
object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} was hurt by {hitInfo.Initiator} with damage type {hitInfo.damageTypes.GetMajorityDamageType()}.");
    if (hitInfo.damageTypes.GetMajorityDamageType() == "Explosive")
    {
        Puts($"Entity {entity} was critically damaged by the explosive hit.");
        return "Critical Damage: Explosive Hit";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50L))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			health = num - info.damageTypes.Total();
			SendNetworkUpdate();
			if (SingletonComponent<AiManager>.Instance != null && SingletonComponent<AiManager>.Instance.enabled && SingletonComponent<AiManager>.Instance.UseIntensity)
			{
				SingletonComponent<AiManager>.Instance.OnHit(info);
			}
			if (ConVar.Global.developer > 1)
			{
				Debug.Log(string.Concat("[Combat]".PadRight(10), base.gameObject.name, " hurt ", info.damageTypes.GetMajorityDamageType(), "/", info.damageTypes.Total(), " - ", health.ToString("0"), " health left"));
			}
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.MarkHostileTime();
			}
			if (lastDamage != DamageType.Decay)
			{
				_lastAttackedTime = UnityEngine.Time.time;
			}
			if (health <= 0f)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.Log(info, num, health, "killed");
				}
				else
				{
					initiatorPlayer.stats.combat.Log(info, num, health);
				}
			}
		}
	}

```

## IOnPlayerAttack(BaseMelee,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player attacks another entity.
/// </summary>
/// <param name="attacker">The player performing the attack.</param>
/// <param name="info">Information about the attack, including the hit entity and damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default attack behavior. If a non-null value is returned, it will override the default behavior.
/// </returns>
object IOnPlayerAttack(BaseMelee attacker, HitInfo info)
{
    Puts($"Player {attacker.UserIDString} attacked entity {info.HitEntity?.ToString()} with damage {info.Damage}.");
    if (info.HitEntity is Player target && target.IsAdmin)
    {
        Puts($"Player {target.UserIDString} is an admin and cannot be damaged.");
        return "Admins are immune to damage.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("IOnPlayerAttack", this, info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50L))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (base.isServer)
		{
			using (TimeWarning.New("ImpactEffect", 20L))
			{
				Effect.server.ImpactEffect(info);
			}
		}
		else
		{
			using (TimeWarning.New("ImpactEffect", 20L))
			{
				Effect.client.ImpactEffect(info);
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50L))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay * 0.5f);
		}
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the vending broadcast toggle is changed.
/// </summary>
/// <param name="vendingMachine">The vending machine that was toggled.</param>
/// <param name="player">The player who performed the action.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending broadcast toggle changed by {player.displayName} for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## OnDoorOpened(Door,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a door is opened.
/// </summary>
/// <param name="door">The door that was opened.</param>
/// <param name="player">The player who opened the door.</param>
/// <returns>No return behavior, this hook only notifies other scripts of the event.</returns>
void OnDoorOpened(BaseDoor door, BasePlayer player)
{
    Puts($"Door {door.name} has been opened by player {player.UserIDString}");
    if (door.name == "Secret Door")
    {
        Puts($"Player {player.displayName} has accessed a secret area.");
        // Trigger some event or notification here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_OpenDoor(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || IsOpen() || IsBusy() || IsLocked())
		{
			return;
		}
		BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
		if (baseLock != null)
		{
			if (!baseLock.OnTryToOpen(rpc.player))
			{
				return;
			}
			if (baseLock.IsLocked() && UnityEngine.Time.realtimeSinceStartup - decayResetTimeLast > 60f)
			{
				BuildingBlock buildingBlock = FindLinkedEntity<BuildingBlock>();
				if ((bool)buildingBlock)
				{
					Decay.BuildingDecayTouch(buildingBlock);
				}
				else
				{
					Decay.RadialDecayTouch(base.transform.position, 40f, 2097408);
				}
				decayResetTimeLast = UnityEngine.Time.realtimeSinceStartup;
			}
		}
		SetFlag(Flags.Open, b: true);
		SendNetworkUpdateImmediate();
		Interface.CallHook("OnDoorOpened", this, rpc.player);
	}

```

## OnReloadMagazine(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player reloads their magazine.
/// </summary>
/// <param name="player">The player reloading the magazine.</param>
/// <param name="projectile">The projectile being reloaded.</param>
/// <returns>
/// Returns `null` to allow the magazine to be reloaded, or any non-null value to prevent it from being reloaded.
/// </returns>
object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} is reloading their magazine.");
    if (projectile.ammoType == "rare")
    {
        Puts($"Player {player.displayName} cannot reload rare ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected void ReloadMagazine()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((bool)ownerPlayer && Interface.CallHook("OnReloadMagazine", ownerPlayer, this) == null)
		{
			primaryMagazine.Reload(ownerPlayer);
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret sets its target.
/// </summary>
/// <param name="turret">The helicopter turret setting the target.</param>
/// <param name="target">The entity being targeted by the helicopter turret.</param>
/// <returns>
/// Returns `null` to allow the helicopter turret to set its target, or any non-null value to prevent it from setting its target.
/// </returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts($"Helicopter Turret {turret.GetReference()} is targeting entity {target.UserIDString}.");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"Helicopter Turret {turret.GetReference()} has been prevented from targeting admin player {player.UserIDString}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## OnPlayerDie(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player dies.
/// </summary>
/// <param name="player">The player who died.</param>
/// <param name="info">Information about the hit that killed the player, if any.</param>
/// <returns>
/// Returns `null` to allow the player to die normally. If a non-null value is returned, it will override the default death behavior.
/// </returns>
object OnPlayerDie(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} has died.");
    if (info != null && info.Attacker != null)
    {
        Puts($"Player was killed by {info.Attacker.UserIDString} with a {info.Weapon}.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead() && Interface.CallHook("OnPlayerDie", this, info) == null)
			{
				if (Belt != null)
				{
					UnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(vector.normalized * 3f);
				}
				if (!WoundInsteadOfDying(info))
				{
					base.Die(info);
				}
			}
		}
	}

```

## OnPlayerBanned(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="connection">The connection of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
object OnPlayerBanned(Network.Connection connection, string reason)
{
    Puts($"Player {connection.username} has been banned with reason: {reason}");
    // You can add custom logic here to handle the ban
    return null;
}
```
```

### Source Code from the Library

```csharp

	private static void HandleClientUpdate(ClientStatusUpdate<EasyAntiCheat.Server.Hydra.Client> clientStatus)
	{
		if (!ConVar.Server.secure)
		{
			return;
		}
		using (TimeWarning.New("AntiCheatKickPlayer", 10L))
		{
			EasyAntiCheat.Server.Hydra.Client clientObject = clientStatus.ClientObject;
			Connection connection = GetConnection(clientObject);
			if (connection == null)
			{
				return;
			}
			if (clientStatus.RequiresKick)
			{
				string text = clientStatus.Message;
				if (string.IsNullOrEmpty(text))
				{
					text = clientStatus.Status.ToString();
				}
				Debug.Log("[EAC] Kicking " + connection.userid + " (" + text + ")");
				connection.authStatus = "eac";
				Network.Net.sv.Kick(connection, "EAC: " + text);
				if (clientStatus.Status == ClientStatus.ClientBanned)
				{
					connection.authStatus = "eacbanned";
					Interface.CallHook("OnPlayerBanned", connection, connection.authStatus);
					ServerUsers.Set(connection.userid, ServerUsers.UserGroup.Banned, connection.username, "EAC");
					ConsoleNetwork.BroadcastToAllClients("chat.add", 0, "<color=#fff>SERVER</color> Kicking " + connection.username + " (banned by anticheat)");
					Entity.DeleteBy(connection.userid);
				}
				easyAntiCheat.UnregisterClient(clientObject);
				client2connection.Remove(clientObject);
				userid2client.Remove(connection.userid);
				userid2status.Remove(connection.userid);
			}
			else if (clientStatus.Status == ClientStatus.ClientAuthenticatedLocal)
			{
				OnAuthenticatedLocal(connection);
				easyAntiCheat.SetClientNetworkState(clientObject, networkActive: false);
			}
			else if (clientStatus.Status == ClientStatus.ClientAuthenticatedRemote)
			{
				OnAuthenticatedRemote(connection);
			}
		}
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base player is hurt.
/// </summary>
/// <param name="basePlayer">The base player being hurt.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the base player's normal hurt logic will be executed.
/// </returns>
object IOnBasePlayerHurt(BasePlayer basePlayer, HitInfo hitInfo)
{
    Puts($"Base player {basePlayer.UserIDString} has been hurt by {hitInfo.Initiator}.");
    if (hitInfo.Initiator is BasePlayer && hitInfo.Initiator != basePlayer)
    {
        return "Player vs Player combat detected.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || IsImmortal() || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			basePlayer.Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		base.Hurt(info);
		if (EACServer.playerTracker != null && info.Initiator != null && info.Initiator is BasePlayer)
		{
			PlayerTakeDamage takeDamage = default(PlayerTakeDamage);
			BasePlayer basePlayer2 = info.Initiator.ToPlayer();
			takeDamage.VictimClient = EACServer.GetClient(userID);
			takeDamage.AttackerClient = EACServer.GetClient(basePlayer2.userID);
			takeDamage.HitBoneID = (int)info.HitBone;
			if (info.isHeadshot)
			{
				takeDamage.Flags |= PlayerTakeDamageFlags.PlayerTakeDamageFlagHeadshot;
			}
			takeDamage.WeaponID = 0;
			if (info.Weapon != null)
			{
				Item item = info.Weapon.GetItem();
				if (item != null)
				{
					takeDamage.WeaponID = item.info.itemid;
				}
			}
			UnityEngine.Vector3 position = basePlayer2.eyes.position;
			UnityEngine.Vector3 eulerAngles = basePlayer2.eyes.rotation.eulerAngles;
			UnityEngine.Vector3 position2 = eyes.position;
			UnityEngine.Vector3 eulerAngles2 = eyes.rotation.eulerAngles;
			takeDamage.AttackerPosition = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(position.x, position.y, position.z);
			takeDamage.AttackerViewAngles = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(eulerAngles.x, eulerAngles.y, eulerAngles.z);
			takeDamage.VictimPosition = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(position2.x, position2.y, position2.z);
			takeDamage.VictimViewAngles = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
			EACServer.playerTracker.LogPlayerTakeDamage(takeDamage);
		}
		metabolism.SendChangesToClient();
		if (info.PointStart != UnityEngine.Vector3.zero)
		{
			ClientRPCPlayer(null, this, "DirectionalDamage", info.PointStart, (int)info.damageTypes.GetMajorityDamageType());
		}
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be wounded.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="hitInfo">Information about the hit that caused the wounding check.</param>
/// <returns>
/// Returns `true` if the player can be wounded, or `false` otherwise. 
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeWounded(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Checking if {player.UserIDString} can be wounded by {hitInfo.WeaponPrefab.name}.");
    if (hitInfo.WeaponPrefab.name == "Melee")
    {
        Puts($"Player {player.UserIDString} cannot be wounded by melee attacks.");
        return false;
    }
    if (hitInfo.isHeadshot)
    {
        Puts($"Player {player.UserIDString} cannot be wounded by headshots.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastWoundedTime < 60f)
		{
			return false;
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnPlayerRecover(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>
/// Returns `null` to allow the player to recover, or any non-null value to prevent them from recovering.
/// </returns>
object OnPlayerRecover(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered from being wounded.");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot be wounded.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			CancelInvoke(WoundingTick);
		}
	}

```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when the stock level of a vending machine's sell order is refreshed.
/// </summary>
/// <param name="vendingMachine">The vending machine whose stock level is being refreshed.</param>
/// <param name="itemDefinition">The item definition for which the stock level is being refreshed, or null if all items are being refreshed.</param>
/// <returns>No return behavior.</returns>
void OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDefinition)
{
    Puts($"Refreshing stock level of {vendingMachine.name} for item {itemDefinition.itemid}.");
    // You can add custom logic here to refresh the stock level.
    // For example, you could update a database or call another API.
}
```
```

### Source Code from the Library

```csharp

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		foreach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (!(itemDef == null) && itemDef.itemid != sellOrder.itemToSellID)
			{
				continue;
			}
			List<Item> list = inventory.FindItemsByItemID(sellOrder.itemToSellID);
			int inStock;
			if (list != null && list.Count >= 0)
			{
				Interface.CallHook("OnRefreshVendingStock", this, itemDef);
				inStock = list.Sum((Item x) => x.amount) / sellOrder.itemToSellAmount;
			}
			else
			{
				inStock = 0;
			}
			sellOrder.inStock = inStock;
		}
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amountToConsume">The amount of the item to consume. Defaults to 1.</param>
/// <returns>No return behavior.</returns>
void OnItemUse(Item item, int amountToConsume)
{
    Puts($"Item {item.name} has been used.");
    if (amountToConsume > item.maxStackSize)
    {
        Puts($"Warning: Attempted to consume more than the maximum stack size ({item.maxStackSize}) of item {item.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			Interface.CallHook("OnItemUse", this, amountToConsume);
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## CanMoveItem(Item,PlayerInventory,uint,int,int)

```csharp
```csharp
/// <summary>
/// Called when an item is moved.
/// </summary>
/// <param name="item">The item being moved.</param>
/// <param name="playerInventory">The player's inventory.</param>
/// <param name="num">The number of items to move.</param>
/// <param name="num2">The container ID to move the item to.</param>
/// <param name="num3">The amount of items to move (optional).</param>
/// <returns>
/// Returns a non-null value to override the default movement behavior. 
/// If `null` is returned, the item will be moved as normal.
/// </returns>
object CanMoveItem(Item item, PlayerInventory playerInventory, uint num, int num2, int num3)
{
    Puts($"Attempting to move {item.info.name} from inventory to container {num2}.");
    if (item.amount <= 0)
    {
        Puts("Cannot move empty item.");
        return null;
    }
    if (num3 > item.info.stackable)
    {
        Puts("Cannot move more items than the stack limit.");
        return null;
    }
    // Add custom logic here to override the default movement behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	private void MoveItem(BaseEntity.RPCMessage msg)
	{
		uint id = msg.read.UInt32();
		uint num = msg.read.UInt32();
		int num2 = msg.read.Int8();
		int num3 = msg.read.UInt16();
		Item item = FindItemUID(id);
		if (item == null || Interface.CallHook("CanMoveItem", item, this, num, num2, num3) != null || !CanMoveItemsFrom(item.parent.entityOwner, item))
		{
			return;
		}
		if (num3 <= 0)
		{
			num3 = item.amount;
		}
		num3 = Mathf.Clamp(num3, 1, item.info.stackable);
		if (num == 0)
		{
			GiveItem(item);
			return;
		}
		ItemContainer itemContainer = FindContainer(num);
		if (itemContainer == null)
		{
			return;
		}
		ItemContainer parent = item.parent;
		if ((parent != null && parent.IsLocked()) || itemContainer.IsLocked() || itemContainer.PlayerItemInputBlocked())
		{
			return;
		}
		using (TimeWarning.New("Split"))
		{
			if (item.amount > num3)
			{
				Item item2 = item.SplitItem(num3);
				if (!item2.MoveToContainer(itemContainer, num2))
				{
					item.amount += item2.amount;
					item2.Remove();
				}
				ItemManager.DoRemoves();
				ServerUpdate(0f);
				return;
			}
		}
		if (item.MoveToContainer(itemContainer, num2))
		{
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
Based on the provided code snippet, I will create a method structure for the `OnWeaponFired` method.

```csharp
/// <summary>
/// Called when a weapon is fired.
/// </summary>
/// <param name="baseProjectile">The base projectile.</param>
/// <param name="basePlayer">The player who fired the weapon.</param>
/// <param name="itemModProjectile">The item mod projectile component.</param>
/// <param name="protoBufProjectileShoot">The projectile shoot data.</param>
void OnWeaponFired(BaseProjectile baseProjectile, BasePlayer basePlayer, ItemModProjectile itemModProjectile, ProtoBuf.ProjectileShoot protoBufProjectileShoot)
{
    // Minimal code to demonstrate functionality
}
```

Note that I've followed the provided structure and included a brief summary of the method's purpose. The parameters are also listed with their respective types.

Please let me know if you'd like me to make any changes or if this meets your requirements!
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_missing");
			return;
		}
		ItemDefinition ammoType = primaryMagazine.ammoType;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (ammoType.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_mismatch");
			return;
		}
		if (!UsingInfiniteAmmoCheat)
		{
			primaryMagazine.contents--;
		}
		ItemModProjectile component = ammoType.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection);
		player.CleanupExpiredProjectiles();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.Log(this, "duplicate_id");
			}
			else
			{
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, ammoType);
				CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
			}
		}
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count());
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
		UpdateItemCondition();
		Sensation sensation = default(Sensation);
		sensation.Type = SensationType.Gunshot;
		sensation.Position = player.GetNetworkPosition();
		sensation.Radius = 100f;
		Sense.Stimulate(sensation);
		if (EACServer.playerTracker == null)
		{
			return;
		}
		using (TimeWarning.New("LogPlayerShooting"))
		{
			UnityEngine.Vector3 networkPosition = player.GetNetworkPosition();
			UnityEngine.Vector3 networkRotation = player.GetNetworkRotation();
			int weaponID = GetItem()?.info.itemid ?? 0;
			PlayerUseWeapon useWeapon = default(PlayerUseWeapon);
			useWeapon.Client = EACServer.GetClient(player.userID);
			useWeapon.PlayerPosition = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(networkPosition.x, networkPosition.y, networkPosition.z);
			useWeapon.PlayerViewAngles = new EasyAntiCheat.Server.Hydra.Cerberus.Vector3(networkRotation.x, networkRotation.y, networkRotation.z);
			useWeapon.WeaponID = weaponID;
			EACServer.playerTracker.LogPlayerUseWeapon(useWeapon);
		}
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret authorizes a player.
/// </summary>
/// <param name="turret">The AutoTurret that authorized the player.</param>
/// <param name="player">The BasePlayer who was authorized by the turret.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent the authorization.
/// </returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"AutoTurret {turret.name} has authorized player {player.displayName}");
    if (player.UserIDString == "admin")
    {
        Puts($"AutoTurret {turret.name} has been instructed to not authorize admin players.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!IsOnline() && Interface.CallHook("OnTurretAuthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = rpc2.player.userID;
			playerNameID.username = rpc2.player.displayName;
			authorizedPlayers.Add(playerNameID);
			SendNetworkUpdate();
		}
	}

```

## OnCupboardClearList(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the cupboard clear list is triggered.
/// </summary>
/// <param name="buildingPrivilege">The building privilege that owns the cupboard.</param>
/// <param name="player">The player who triggered the clear list action.</param>
/// <returns>
/// Returns `null` to allow the clear list action, or any non-null value to prevent it.
/// </returns>
object OnCupboardClearList(BuildingPrivilege buildingPrivilege, BasePlayer player)
{
    Puts($"Player {player.UserIDString} cleared the cupboard's authorized players list.");
    if (buildingPrivilege.GetOwner() == player)
    {
        return null;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to clear the cupboard's authorized players list.");
        return true;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && Interface.CallHook("OnCupboardClearList", this, rpc.player) == null && CanAdministrate(rpc.player))
		{
			authorizedPlayers.Clear();
			UpdateAllPlayers();
			SendNetworkUpdate();
		}
	}

```

## CanAcceptItem(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is being accepted into the container.
/// </summary>
/// <param name="container">The container accepting the item.</param>
/// <param name="item">The item being accepted.</param>
/// <returns>
/// Returns a non-null value to override the default acceptance behavior. 
/// If `CanAcceptResult.CannotAccept` is returned, the item cannot be accepted.
/// If `CanAcceptResult.CannotAcceptRightNow` is returned, the item can be accepted but there are not enough available slots.
/// If `null` is returned, the item is accepted as normal.
/// </returns>
object CanAcceptItem(ItemContainer container, Item item)
{
    Puts($"Item {item.info.name} is being accepted into container {container.info.name}.");
    if (item.info.itemType == ItemType.Key && !container.HasKey())
    {
        Puts($"Item {item.info.name} cannot be accepted because the container does not have a key.");
        return CanAcceptResult.CannotAccept;
    }
    object obj = Interface.CallHook("CanAcceptItem", container, item);
    if (obj is CanAcceptResult)
    {
        return obj;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item)
	{
		if (canAcceptItem != null && !canAcceptItem(item))
		{
			return CanAcceptResult.CannotAccept;
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (onlyAllowedItem != null && onlyAllowedItem != item.info)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			int[] array = new int[32];
			foreach (ItemSlot availableSlot in availableSlots)
			{
				array[(int)Mathf.Log((float)availableSlot, 2f)]++;
			}
			foreach (Item item2 in itemList)
			{
				for (int i = 0; i < 32; i++)
				{
					if (((uint)item2.info.occupySlots & (uint)(1 << i)) != 0)
					{
						array[i]--;
					}
				}
			}
			for (int j = 0; j < 32; j++)
			{
				if (((uint)item.info.occupySlots & (uint)(1 << j)) != 0 && array[j] <= 0)
				{
					return CanAcceptResult.CannotAcceptRightNow;
				}
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		return CanAcceptResult.CanAccept;
	}

```

## InitLogging(unknown)

```csharp
```csharp
/// <summary>
/// Called to initialize logging.
/// </summary>
/// <returns>No return behavior.</returns>
void InitLogging()
{
    Puts("Logging initialized");
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging", null);
		ItemManager.Initialize();
	}

```

## OnCropGather(PlantEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player gathers crops from a plant.
/// </summary>
/// <param name="plantEntity">The plant entity being gathered from.</param>
/// <param name="item">The item being gathered (e.g. fruit, vegetables).</param>
/// <param name="player">The player gathering the crop.</param>
/// <returns>
/// Returns a non-null value to override the default gathering behavior.
/// If `null` is returned, the crop is gathered as normal.
/// </returns>
object OnCropGather(PlantEntity plantEntity, Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} has gathered {item.info.name} from plant {plantEntity.info.name}.");
    if (item.info.rarity == "Legendary")
    {
        Puts($"Player {player.displayName} has found a legendary {item.info.name}!");
        return "Legendary item found!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_PickFruit(RPCMessage msg)
	{
		if (!CanPick())
		{
			return;
		}
		harvests++;
		float num = YieldBonusScale() * (float)plantProperty.waterYieldBonus;
		int num2 = Mathf.RoundToInt((currentStage.resources + num) * (float)plantProperty.pickupAmount);
		ResetSeason();
		if (plantProperty.pickupItem.condition.enabled)
		{
			for (int i = 0; i < num2; i++)
			{
				Item item = ItemManager.Create(plantProperty.pickupItem, 1, 0uL);
				item.conditionNormalized = plantProperty.fruitCurve.Evaluate(ageFraction);
				Interface.CallHook("OnCropGather", this, item, msg.player);
				msg.player.GiveItem(item, GiveItemReason.PickedUp);
			}
		}
		else
		{
			Item item2 = ItemManager.Create(plantProperty.pickupItem, num2, 0uL);
			Interface.CallHook("OnCropGather", this, item2, msg.player);
			msg.player.GiveItem(item2, GiveItemReason.PickedUp);
		}
		if (plantProperty.pickEffect.isValid)
		{
			Effect.server.Run(plantProperty.pickEffect.resourcePath, GetEstimatedWorldPosition(), Vector3.up);
		}
		if (harvests >= plantProperty.maxHarvests)
		{
			if (plantProperty.disappearAfterHarvest)
			{
				Die();
			}
			else
			{
				BecomeState(PlantProperties.State.Dying);
			}
		}
		else
		{
			BecomeState(PlantProperties.State.Mature);
		}
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the oven is toggled on or off.
/// </summary>
/// <param name="oven">The oven being toggled.</param>
/// <param name="player">The player who toggled the oven.</param>
/// <returns>
/// Returns `null` to allow the oven to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts($"Oven {oven.name} was toggled by player {player.UserIDString}");
    if (oven.isBroken())
    {
        Puts($"Oven {oven.name} is broken and cannot be used.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag != IsOn() && Interface.CallHook("OnOvenToggle", this, msg.player) == null && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				StartCooking();
			}
			else
			{
				StopCooking();
			}
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="lockedEntity">The locked entity being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the locked entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as an error and the player will not be able to use the entity.
/// </returns>
object CanUseLockedEntity(BasePlayer player, CodeLock lockedEntity)
{
    Puts($"Player {player.UserIDString} attempted to access locked entity {lockedEntity.EntityID}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.UserIDString} has admin privileges and is allowed to use the locked entity.");
        return true;
    }
    else if (player.HasAccessToEntity(lockedEntity))
    {
        Puts($"Player {player.UserIDString} has access to the locked entity and is allowed to use it.");
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have access to the locked entity and is denied access.");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## OnItemAction(Item,string)

```csharp
Here's the code with a comment explaining what it does:

```csharp
/// <summary>
/// Called when an item is used or interacted with.
/// </summary>
/// <param name="item">The item being interacted with.</param>
/// <param name="action">The action being performed on the item (e.g. "drop", "use", etc.).</param>
/// <returns>
/// Returns a non-null value to override the default behavior for this item and action.
/// If `null` is returned, the default behavior will be used.
/// </returns>
object OnItemAction(Item item, string action)
{
    // Check if the item exists and can be interacted with
    if (item == null || Interface.CallHook("OnItemAction", item, action) != null || item.IsLocked() || !CanMoveItemsFrom(item.parent.entityOwner, item))
    {
        return null; // Default behavior will be used
    }

    // Handle the "drop" action
    if (action == "drop")
    {
        int num = item.amount;
        if (msg.read.unread >= 4)
        {
            num = msg.read.Int32();
        }
        base.baseEntity.stats.Add("item_drop", 1);
        if (num < item.amount)
        {
            item.SplitItem(num)?.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 4f + Vector3Ex.Range(-0.5f, 0.5f));
        }
        else
        {
            item.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 4f + Vector3Ex.Range(-0.5f, 0.5f));
        }
        base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
    }

    // Handle other actions (e.g. "use", etc.)
    else
    {
        item.ServerCommand(action, base.baseEntity);
        ItemManager.DoRemoves();
        ServerUpdate(0f);
    }

    return null; // Default behavior will be used if no override is provided
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		uint id = msg.read.UInt32();
		string text = msg.read.String();
		Item item = FindItemUID(id);
		if (item == null || Interface.CallHook("OnItemAction", item, text) != null || item.IsLocked() || !CanMoveItemsFrom(item.parent.entityOwner, item))
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.unread >= 4)
			{
				num = msg.read.Int32();
			}
			base.baseEntity.stats.Add("item_drop", 1);
			if (num < item.amount)
			{
				item.SplitItem(num)?.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 4f + Vector3Ex.Range(-0.5f, 0.5f));
			}
			else
			{
				item.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 4f + Vector3Ex.Range(-0.5f, 0.5f));
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnServerMessage(string,string,string,ulong)

```csharp
```csharp
/// <summary>
/// Called when a server message is broadcasted.
/// </summary>
/// <param name="message">The message being broadcasted.</param>
/// <param name="username">The username of the user who sent the message, defaults to "SERVER" if not provided.</param>
/// <param name="color">The color of the message, defaults to "#eee" if not provided.</param>
/// <param name="userid">The ID of the user who sent the message, defaults to 0 if not provided.</param>
/// <returns>
/// Returns `null` to allow the message to be broadcasted as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the message from being broadcasted.
/// </returns>
object OnServerMessage(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
{
    Puts($"Server message: {message} from {username} (ID: {userid})");
    if (userid == 1234567890uL)
    {
        Puts($"Server message from user ID {userid} has been blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", message, username, color, userid) == null)
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add", 0, "<color=" + color + ">" + username + "</color> " + message);
			ChatEntry chatEntry = default(ChatEntry);
			chatEntry.Message = message;
			chatEntry.UserId = userid;
			chatEntry.Username = username;
			chatEntry.Color = color;
			chatEntry.Time = Epoch.Current;
			ChatEntry chatEntry2 = chatEntry;
			History.Add(chatEntry2);
			RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		}
	}

```

## IOnServerUsersRemove(ulong)

```csharp
```csharp
/// <summary>
/// Called when a user is removed from the server.
/// </summary>
/// <param name="steamId">The Steam ID of the removed user.</param>
/// <returns>No return behavior.</returns>
void IOnServerUsersRemove(ulong steamId)
{
    Puts($"User with SteamID {steamId} has been removed from the server.");
}
```
```

### Source Code from the Library

```csharp

	public static void Remove(ulong uID)
	{
		Interface.CallHook("IOnServerUsersRemove", uID);
		ulong uID2 = uID;
		users.RemoveAll((User x) => x.steamid == uID2);
	}

```

## CanUseVending(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the vending machine, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseVending(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to use vending machine {vendingMachine.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.HasMoneyInAccount(vendingMachine.price))
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName = "")
	{
		object obj = Interface.CallHook("CanUseVending", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		return base.CanOpenLootPanel(player, panelName) && CanPlayerAdmin(player);
	}

```

## OnPlayerKicked(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="player">The player being kicked.</param>
/// <param name="reason">The reason for kicking the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void Kick(string reason)
	{
		if (IsConnected)
		{
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason);
		}
	}

```

## CanSeeStash(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can see the stash.
/// </summary>
/// <param name="container">The stash container.</param>
/// <param name="player">The player trying to access the stash.</param>
/// <returns>
/// Returns `null` to allow the player to see the stash, or any non-null value to prevent them from seeing it.
/// </returns>
object CanSeeStash(StashContainer container, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to access stash {container.GetID()}");
    if (player.IsAdmin())
    {
        return null;
    }
    else
    {
        return "Access denied: Only admins can see the stash.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsUnhide(RPCMessage rpc)
	{
		if (IsHidden() && Interface.CallHook("CanSeeStash", this, rpc.player) == null)
		{
			BasePlayer player = rpc.player;
			if (PlayerInRange(player))
			{
				SetHidden(isHidden: false);
			}
		}
	}

```

## OnPlayerSpawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player spawns.
/// </summary>
/// <param name="player">The player spawning.</param>
/// <returns>
/// Returns `null` to allow the player to spawn normally, or any non-null value to override the default spawn behavior. 
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object OnPlayerSpawn(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has spawned.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.UserIDString} is not allowed to spawn.");
        return "Blocked: Unauthorized user ID.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SpawnNewPlayer(Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot);
		BasePlayer basePlayer = baseEntity.ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer) == null)
		{
			basePlayer.health = 0f;
			basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
			basePlayer.ResetLifeStateOnSpawn = false;
			basePlayer.limitNetworking = true;
			basePlayer.Spawn();
			basePlayer.limitNetworking = false;
			basePlayer.PlayerInit(connection);
			if (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife)
			{
				basePlayer.Respawn();
			}
			else
			{
				basePlayer.SendRespawnOptions();
			}
			UnityEngine.Debug.Log(basePlayer.net.connection.ToString() + " joined [" + basePlayer.net.connection.os + "/" + basePlayer.net.connection.ownerid + "]");
		}
	}

```

## CanRecycle(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled.
/// </summary>
/// <param name="recycler">The recycler checking the item.</param>
/// <param name="item">The item being checked for recyclability.</param>
/// <returns>
/// Returns `true` if the item can be recycled, or `false` otherwise.
/// If a non-null value is returned, it will override the default recyclability behavior.
/// </returns>
object CanRecycle(Recycler recycler, Item item)
{
    Puts($"Checking if item {item.info.name} can be recycled by {recycler.UserIDString}");
    if (item.info.Blueprint != null && itemStackSize >= 10)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## IOnPlayerRevive(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is revived.
/// </summary>
/// <param name="medicalTool">The medical tool used to revive the player.</param>
/// <param name="player">The player being revived.</param>
/// <returns>No return behavior.</returns>
void IOnPlayerRevive(MedicalTool medicalTool, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been revived using {medicalTool.name}.");
    if (player.IsWounded())
    {
        player.health = 100;
        player.metabolism.ApplyChange(MetabolismAttribute.Type.Health, -20, 10);
    }
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			if (player != GetOwnerPlayer() && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("IOnPlayerRevive", this, player) != null)
				{
					return;
				}
				player.StopWounded();
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## OnPlayerInit(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's initialization is complete.
/// </summary>
/// <param name="player">The initialized player.</param>
object OnPlayerInit(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been initialized.");
    if (player.authLevel > 1)
    {
        Puts($"Player {player.displayName} has been flagged as a moderator.");
        return "Moderator";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PlayerInit(Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10L))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			userID = c.userid;
			UserIDString = userID.ToString();
			_displayName = StringEx.ToPrintable(c.username, 32);
			c.player = this;
			tickInterpolator.Reset(base.transform.position);
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel > 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			ClientRPCPlayer(null, this, "StartLoading");
			Interface.CallHook("OnPlayerInit", this);
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			SendGlobalSnapshot();
			SendFullSnapshot();
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is deauthorized.
/// </summary>
/// <param name="turret">The AutoTurret instance that was deauthorized.</param>
/// <param name="player">The player who deauthorized the turret.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.name} has been deauthorized by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			SendNetworkUpdate();
		}
	}

```

## OnSignUpdated(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign's content is updated.
/// </summary>
/// <param name="sign">The updated sign.</param>
/// <param name="player">The player who updated the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(Signage sign, BasePlayer player)
{
    Puts($"Sign at {sign.position} has been updated by {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void UpdateSign(RPCMessage msg)
	{
		if (!CanUpdateSign(msg.player))
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			if (textureID != 0)
			{
				FileStorage.server.Remove(textureID, FileStorage.Type.png, net.ID);
				textureID = 0u;
			}
			textureID = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
			Interface.CallHook("OnSignUpdated", this, msg.player);
			SendNetworkUpdate();
		}
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if a target can be targeted by the helicopter turret.
/// </summary>
/// <param name="potentialTarget">The potential target entity.</param>
/// <param name="turret">The helicopter turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBeTargeted(BaseCombatEntity potentialTarget, HelicopterTurret turret)
{
    Puts($"Checking if {potentialTarget.displayName} can be targeted by the helicopter turret.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
Here is the method structure for `OnMeleeAttack(BasePlayer, HitInfo)`:

/// <summary>
/// Called when a melee attack occurs.
/// </summary>
/// <param name="player">The player who performed the attack.</param>
/// <param name="hitInfo">Information about the hit.</param>
/// <returns>True if the hook was successful, false otherwise.</returns>
bool OnMeleeAttack(BasePlayer player, HitInfo hitInfo)
{
    // Minimal code to demonstrate functionality
    Puts("OnMeleeAttack called!");
    
    // Return true if the hook is successful, false otherwise
    return true;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50L))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo hitInfo = Facepunch.Pool.Get<HitInfo>();
			hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
			hitInfo.Initiator = player;
			hitInfo.Weapon = this;
			hitInfo.WeaponPrefab = this;
			hitInfo.Predicted = msg.connection;
			hitInfo.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, hitInfo) != null)
			{
				return;
			}
			if (hitInfo.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.Log(hitInfo, "melee_nan");
				return;
			}
			if (ConVar.AntiHack.melee_protection > 0 && (bool)hitInfo.HitEntity)
			{
				bool flag = true;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTime + num2 + num3) * num;
				if (ConVar.AntiHack.projectile_protection >= 2)
				{
					float num5 = hitInfo.HitEntity.MaxVelocity();
					float num6 = hitInfo.HitEntity.BoundsPadding() + num4 * num5;
					float num7 = hitInfo.HitEntity.Distance(hitInfo.HitPositionWorld);
					if (num7 > num6)
					{
						string shortPrefabName2 = base.ShortPrefabName;
						string shortPrefabName3 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName2 + " on " + shortPrefabName3 + " with " + num7 + "m > " + num6 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_distance");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					float num8 = hitInfo.Initiator.MaxVelocity();
					float num9 = hitInfo.Initiator.BoundsPadding() + num4 * num8 + num * maxDistance;
					float num10 = hitInfo.Initiator.Distance(hitInfo.HitPositionWorld);
					if (num10 > num9)
					{
						string shortPrefabName4 = base.ShortPrefabName;
						string shortPrefabName5 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num10 + "m > " + num9 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_distance");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					Vector3 pointStart = hitInfo.PointStart;
					Vector3 vector = hitInfo.HitPositionWorld + hitInfo.HitNormalWorld.normalized * 0.001f;
					Vector3 position = player.eyes.position;
					Vector3 vector2 = pointStart;
					Vector3 vector3 = hitInfo.PositionOnRay(vector);
					Vector3 vector4 = vector;
					bool flag2 = GamePhysics.LineOfSight(position, vector2, vector3, vector4, 2162688);
					if (!flag2)
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
					}
					else
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_direct_los", 1, Stats.Server);
					}
					if (!flag2)
					{
						string shortPrefabName6 = base.ShortPrefabName;
						string shortPrefabName7 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat("Line of sight (", shortPrefabName6, " on ", shortPrefabName7, ") ", position, " ", vector2, " ", vector3, " ", vector4));
						player.stats.combat.Log(hitInfo, "melee_los");
						flag = false;
					}
				}
				if (!flag)
				{
					AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
					return;
				}
			}
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50L))
			{
				DoAttackShared(hitInfo);
			}
		}
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a melee attack is thrown.
/// </summary>
/// <param name="player">The player throwing the melee attack.</param>
/// <param name="item">The item being thrown.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the melee attack is thrown as normal.
/// </returns>
object OnMeleeThrown(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} has thrown a melee attack with item {item.ShortPrefabName}.");
    if (item.info.GetComponent<ItemModProjectile>() == null)
    {
        Puts($"Item {item.ShortPrefabName} does not have the projectile mod.");
        return "Missing projectile mod.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (!canThrowAsProjectile)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "not_throwable");
			return;
		}
		Item item = GetItem();
		if (item == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "item_missing");
			return;
		}
		ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (projectileShoot.projectiles.Count != 1)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "count_mismatch");
			return;
		}
		player.CleanupExpiredProjectiles();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.Log(this, "duplicate_id");
				continue;
			}
			player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, item);
			Effect effect = new Effect();
			effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
			effect.scale = 1f;
			effect.pooledString = component.projectileObject.resourcePath;
			effect.number = projectile.seed;
			EffectNetwork.Send(effect);
		}
		item.SetParent(null);
		Interface.CallHook("OnMeleeThrown", player, item);
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after falling.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallDistance">The distance the player fell.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLand(BasePlayer player, float fallDistance)
{
    Puts($"Player {player.UserIDString} landed after falling from a height of {fallDistance} units.");
    if (fallDistance > 50f)
    {
        Puts($"Player {player.displayName} suffered severe injuries from the fall.");
        // Apply additional damage or effects here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (float.IsNaN(num) || float.IsInfinity(num))
		{
			return;
		}
		float num2 = Mathf.InverseLerp(-15f, -100f, num);
		if (num2 != 0f && Interface.CallHook("OnPlayerLand", this, num2) == null)
		{
			metabolism.bleeding.Add(num2 * 0.5f);
			float num3 = num2 * 500f;
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num2);
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that died.</param>
/// <param name="info">Information about the hit that killed the entity, if any.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity.name} has died.");
    if (info != null && info.Attacker != null)
    {
        Puts($"Entity was killed by {info.Attacker.name} with damage: {info.Damage}");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		Interface.CallHook("OnEntityDeath", this, info);
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
		}
		health = 0f;
		lifestate = LifeState.Dead;
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine admin menu is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <param name="player">The player opening the admin menu.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} opened admin menu for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			SendSellOrders(player);
			PlayerOpenLoot(player);
			ClientRPCPlayer(null, player, "CLIENT_OpenAdminMenu");
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can bypass the queue.
/// </summary>
/// <param name="connection">The player's connection.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue, or `false` otherwise.
/// If this method returns `null`, it will be treated as returning `false`.
/// </returns>
bool CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if {connection.UserIDString} can bypass queue...");
    bool result = (bool)Interface.CallHook("CanBypassQueue", connection);
    if (result)
    {
        return true;
    }
    if (DeveloperList.Contains(connection.userid))
    {
        return true;
    }
    ServerUsers.User user = ServerUsers.Get(connection.userid);
    if (user != null && user.group == ServerUsers.UserGroup.Moderator)
    {
        return true;
    }
    if (user != null && user.group == ServerUsers.UserGroup.Owner)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		return false;
	}

```

## OnSpinWheel(BasePlayer,SpinnerWheel)

```csharp
```csharp
/// <summary>
/// Called when a player spins the wheel.
/// </summary>
/// <param name="player">The player spinning the wheel.</param>
/// <param name="wheel">The spinner wheel being spun.</param>
/// <returns>No return behavior.</returns>
void OnSpinWheel(BasePlayer player, SpinnerWheel wheel)
{
    Puts($"Player {player.UserIDString} has spun the wheel.");
    if (wheel.IsMalfunctioning())
    {
        Puts($"The wheel is malfunctioning and will not award any points.");
        // Handle malfunctioning wheel logic here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Spin(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && (AnyoneSpin() || rpc.player.CanBuild()))
		{
			Interface.CallHook("OnSpinWheel", rpc.player, this);
			if (!(velocity > 15f))
			{
				velocity += UnityEngine.Random.Range(4f, 7f);
			}
		}
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The Bradley APC instance.</param>
/// <returns>
/// Returns `null` to allow the APC to initialize normally, or any non-null value to override the default initialization behavior.
/// </returns>
object OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Bradley APC initialized at position: {apc.transform.position}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## IOnServerUsersSet(ulong,ServerUsers.UserGroup,string,string)

```csharp
```csharp
/// <summary>
/// Called when a server user's information is updated.
/// </summary>
/// <param name="steamId">The Steam ID of the user.</param>
/// <param name="group">The group that the user belongs to.</param>
/// <param name="username">The username of the user.</param>
/// <param name="notes">Any additional notes about the user.</param>
/// <returns>No return behavior.</returns>
void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string username, string notes)
{
    Puts($"User {username} with SteamID {steamId} has been updated to group {group} with notes: {notes}");
}
```
```

### Source Code from the Library

```csharp

	public static void Set(ulong iUID, UserGroup group, string username, string notes)
	{
		Interface.CallHook("IOnServerUsersSet", iUID, group, username, notes);
		ulong iUID2 = iUID;
		users.RemoveAll((User x) => x.steamid == iUID2);
		User user = new User();
		user.steamid = iUID2;
		user.group = group;
		user.username = username;
		user.notes = notes;
		users.Add(user);
	}

```

## OnConsumeFuel(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The item being consumed as fuel.</param>
/// <param name="burnable">The burnable item that determines how the fuel is used.</param>
/// <returns>No return behavior.</returns>
void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel {fuel.info.name} consumed by oven {oven.info.name}");
    if (burnable.fuelAmount <= 0)
    {
        Puts($"Error: Burnable item has no fuel amount");
        return;
    }
    // Additional logic can be added here to handle the consumption of fuel
}
```
```

### Source Code from the Library

```csharp

	private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		Interface.CallHook("OnConsumeFuel", this, fuel, burnable);
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);
			if (!item.MoveToContainer(inventory))
			{
				OvenFull();
				item.Drop(inventory.dropPosition, inventory.dropVelocity);
			}
		}
		if (fuel.amount <= 1)
		{
			fuel.Remove();
			return;
		}
		fuel.amount--;
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
	}

```

## IOnRconInitialize(unknown)

```csharp
```csharp
/// <summary>
/// Called when the RCON system is initialized.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRconInitialize()
{
    Puts("RCON system initialized.");
}
```
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize", null) != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", string.Empty));
		if (Password == "password" || Password == string.Empty)
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPEndPoint ip, string id, string msg)
			{
				lock (Commands)
				{
					Command item = JsonConvert.DeserializeObject<Command>(msg);
					item.Ip = ip;
					item.ConnectionId = id;
					Commands.Enqueue(item);
				}
			};
			listenerNew.Start();
			Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			Debug.Log("RCon Started on " + Port);
			Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## OnQuarryEnabled(MiningQuarry)

```csharp
```csharp
/// <summary>
/// Called when a quarry is enabled.
/// </summary>
/// <param name="quarry">The mining quarry that has been enabled.</param>
/// <returns>No return behavior.</returns>
void OnQuarryEnabled(MiningQuarry quarry)
{
    Puts($"Quarry {quarry.name} has been enabled.");
}
```
```

### Source Code from the Library

```csharp

	private void SetOn(bool isOn)
	{
		SetFlag(Flags.On, isOn);
		engineSwitchPrefab.instance.SetFlag(Flags.On, isOn);
		SendNetworkUpdate();
		engineSwitchPrefab.instance.SendNetworkUpdate();
		if (isOn)
		{
			InvokeRepeating(ProcessResources, processRate, processRate);
			Interface.CallHook("OnQuarryEnabled", this);
		}
		else
		{
			CancelInvoke(ProcessResources);
		}
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="message">The text of the chat message.</param>
/// <param name="player">The player who sent the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be displayed, or any non-null value to prevent it from being displayed.
/// </returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Player {player.UserIDString} said: {message}");
    if (message.ToLower() == "bad word")
    {
        Puts($"Player {player.displayName} used a bad word and was muted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 0, msg);
		}
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is upgraded.
/// </summary>
/// <param name="oldItem">The original item being upgraded.</param>
/// <param name="newItem">The upgraded item.</param>
/// <param name="player">The player who performed the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnItemUpgrade(Item oldItem, Item newItem, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has successfully upgraded their {oldItem.info.name} to a {newItem.info.name}.");
    if (newItem.info.category == "rare")
    {
        Puts($"The upgraded item is rare! Player {player.UserIDString} will receive a bonus reward.");
        // Add bonus reward logic here
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		float num = UnityEngine.Random.Range(0f, 1f);
		if (num <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.eyes.position, player.eyes.BodyForward() * 2f);
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap trigger is snapped to an object.
/// </summary>
/// <param name="trapTrigger">The trap trigger that was snapped.</param>
/// <param name="objectSnapped">The object that the trap trigger was snapped to.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trapTrigger, GameObject objectSnapped)
{
    Puts($"Trap {trapTrigger.name} snapped to object {objectSnapped.name}");
}
```
```

### Source Code from the Library

```csharp

	internal override void OnObjectAdded(GameObject obj)
	{
		Interface.CallHook("OnTrapSnapped", this, obj);
		base.OnObjectAdded(obj);
		_trap.ObjectEntered(obj);
	}

```

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating.
/// </summary>
/// <param name="player">The player starting to spectate.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} started spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to spectate with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnPlayerRespawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player respawning.</param>
/// <returns>
/// Returns a non-null value to override the default respawn behavior. 
/// If a `SpawnPoint` object is returned, the player will respawn at that location and rotation.
/// If `null` is returned, the player will respawn at the default spawn point.
/// </returns>
object OnPlayerRespawn(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.IsAdmin)
    {
        SpawnPoint adminSpawn = new SpawnPoint(player.transform.position + Vector3.forward * 10, Quaternion.identity);
        return adminSpawn;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint();
		object obj = Interface.CallHook("OnPlayerRespawn", this);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
Here is the method structure for `OnResourceDepositCreated`:

```csharp
/// <summary>
/// Called when a new resource deposit is created.
/// </summary>
/// <param name="resourceDeposit">The newly created resource deposit.</param>
void OnResourceDepositCreated(ResourceDeposit resourceDeposit)
{
    Puts($"New resource deposit created at {resourceDeposit.origin}.");
}
```

Note that I've omitted the return statement since `OnResourceDepositCreated` is a void method.
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		uint seed = new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt);
		UnityEngine.Random.InitState((int)seed);
		ResourceDeposit resourceDeposit = new ResourceDeposit();
		resourceDeposit.origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20);
		float num = UnityEngine.Random.Range(0f, 1f);
		if (num < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else if (0 == 0)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
			float num2 = 0f;
			if (World.Procedural)
			{
				float num3 = ((!(TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f)) ? 0f : 1f);
				num2 = num3 * 0.25f;
			}
			else
			{
				num2 = 0.1f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num4 = 0f;
			if (World.Procedural)
			{
				float num5 = ((!(TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)) ? 0f : 1f);
				num4 = num5 * (0.25f + 0.25f * ((!TerrainMeta.TopologyMap.GetTopology(pos, 8)) ? 0f : 1f) + 0.25f * ((!TerrainMeta.TopologyMap.GetTopology(pos, 1)) ? 0f : 1f));
			}
			else
			{
				num4 = 0.1f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num4)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num6 = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
				{
					num6 += 0.25f;
				}
			}
			else
			{
				num6 += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num6)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity being killed.</param>
/// <returns>No return behavior.</returns>
void OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity.ShortName} has been killed.");
    if (entity is Player player && player.IsSpectating())
    {
        Puts($"Player {player.UserIDString} was spectating and has been killed.");
        // Handle the player's death as a spectator
    }
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
			return;
		}
		Interface.CallHook("OnEntityKill", this);
		OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
		Term(mode);
		DoEntityDestroy();
		EntityDestroy();
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is patrolling.
/// </summary>
/// <param name="apc">The Bradley APC performing the patrol.</param>
/// <returns>
/// Returns `null` to allow the APC to continue patrolling, or any non-null value to override the default patrol behavior.
/// If a string is returned, it will be used as a message to display in the console.
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC {apc.GetId()} is patrolling.");
    if (apc.GetPosition() == Vector3.zero)
    {
        Puts("Bradley APC has reached its final destination.");
        return "Bradley APC has reached its final destination.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		PathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		BasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);
		BasePathNode basePathNode = null;
		bool flag = false;
		List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			basePathNode = nodes[nodes.Count - 1];
		}
		else
		{
			basePathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) > 2f))
		{
			return;
		}
		if (closestToPoint == basePathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.transform.position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
		else
		{
			if (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].transform.position);
				}
			}
			foreach (BasePathNode item in path)
			{
				currentPath.Add(item.transform.position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
	}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can use napalm.
/// </summary>
/// <param name="helicopter">The helicopter in question.</param>
/// <returns>
/// Returns `true` if the helicopter is allowed to use napalm, and `false` otherwise.
/// If no return value is specified, returns whether 30 seconds have passed since the last time napalm was used.
/// </returns>
bool CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter can use napalm...");
    if (helicopter.IsOnFire())
    {
        Puts("Helicopter is on fire, cannot use napalm.");
        return false;
    }
    object obj = Interface.CallHook("CanHelicopterUseNapalm", helicopter);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
	}

```

## OnNpcPlayerTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC player targets a base entity.
/// </summary>
/// <param name="npcPlayer">The NPC player doing the targeting.</param>
/// <param name="targetEntity">The base entity being targeted.</param>
/// <returns>
/// Returns `true` to allow the targeting, or `false` to prevent it. 
/// If a float value is returned, it will be used as the wants-to-attack value.
/// </returns>
object OnNpcPlayerTarget(NPCPlayerApex npcPlayer, BaseEntity targetEntity)
{
    Puts($"NPC player {npcPlayer.UserIDString} has targeted entity {targetEntity.EntityId}");
    if (targetEntity == null || !targetEntity.IsValid())
    {
        return false;
    }
    if ((bool)targetEntity.GetComponent<NPCPlayer>())
    {
        return 0f;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		if (target == null)
		{
			return 0f;
		}
		object obj = Interface.CallHook("OnNpcPlayerTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
		{
			return 0f;
		}
		if ((bool)target.GetComponent<NPCPlayer>())
		{
			return 0f;
		}
		if (target.Health() <= 0f)
		{
			return 0f;
		}
		return 1f;
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford an upgrade.
/// </summary>
/// <param name="player">The player attempting the upgrade.</param>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="grade">The grade of the upgrade.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the return value.
/// </returns>
bool CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum grade)
{
    Puts($"Checking if {player.UserIDString} can afford upgrade to {buildingBlock.name} at grade {grade}");
    object obj = Interface.CallHook("CanAffordUpgrade", player, buildingBlock, grade);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // Default implementation: check if the player has enough resources
    ConstructionGrade constructionGrade = GetGrade(grade);
    foreach (ItemAmount item in constructionGrade.costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
        {
            return false;
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ConstructionGrade constructionGrade = GetGrade(iGrade);
		foreach (ItemAmount item in constructionGrade.costToBuild)
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## CanStackItem(Item,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if two items can be stacked together.
/// </summary>
/// <param name="item1">The first item.</param>
/// <param name="item2">The second item.</param>
/// <returns>
/// Returns `true` if the items can be stacked, and `false` otherwise.
/// If a non-null value is returned, it will override the default stacking behavior.
/// </returns>
bool CanStackItem(Item item1, Item item2)
{
    Puts($"Checking if {item1.info.itemName} and {item2.info.itemName} can be stacked.");
    if (item1 == item2)
    {
        return false;
    }
    if (item1.info.stackable <= 1 || item2.info.stackable <= 1)
    {
        return false;
    }
    if (item1.info.itemid != item2.info.itemid)
    {
        return false;
    }
    if (item1.hasCondition || item2.hasCondition)
    {
        return false;
    }
    if (!IsValid(item1) || !IsValid(item2))
    {
        return false;
    }
    if (IsBlueprint(item1) && blueprintTarget != item2.blueprintTarget)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (info.stackable <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition || item.hasCondition)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		return true;
	}

```

## CanDemolish(BasePlayer,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Determines whether a player can demolish the current building.
/// </summary>
/// <param name="player">The player attempting to demolish.</param>
/// <param name="buildingBlock">The block being demolished (not used in this method).</param>
/// <returns>
/// Returns `true` if the player can demolish, or `false` otherwise.
/// If a non-null value is returned from Interface.CallHook("CanDemolish"), it will override the default behavior.
/// </returns>
bool CanDemolish(BasePlayer player, BuildingBlock buildingBlock)
{
    object obj = Interface.CallHook("CanDemolish", player, this);
    if (obj != null && !(obj is bool))
    {
        Puts($"Player {player.UserIDString} cannot demolish due to custom hook result: {obj}");
        return false;
    }
    else if (obj is bool)
    {
        return (bool)obj;
    }
    return IsDemolishable() && HasDemolishPrivilege(player);
}
```
```

### Source Code from the Library

```csharp

	private bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsDemolishable() && HasDemolishPrivilege(player);
	}

```

## OnFindBurnable(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when an oven is searching for a burnable item.
/// </summary>
/// <param name="oven">The oven searching for a burnable item.</param>
/// <returns>
/// Returns the first burnable item found in the inventory, or `null` if no burnable item is found.
/// If a non-null value other than an Item is returned from this hook, it will be ignored and the method will continue to search the inventory.
/// </returns>
Item OnFindBurnable(BaseOven oven)
{
    Puts($"Oven {oven.GetInventory().GetDisplayName()} is searching for a burnable item.");
    if (oven.GetInventory().GetItemByType(ItemType.Burnable) != null)
    {
        return oven.GetInventory().GetItemByType(ItemType.Burnable);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (inventory == null)
		{
			return null;
		}
		foreach (Item item in inventory.itemList)
		{
			ItemModBurnable component = item.info.GetComponent<ItemModBurnable>();
			if ((bool)component && (fuelType == null || item.info == fuelType))
			{
				return item;
			}
		}
		return null;
	}

```

## CanLock(KeyLock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to lock the object.
/// </summary>
/// <param name="lock">The KeyLock instance.</param>
/// <param name="player">The BasePlayer attempting to lock the object.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(KeyLock lock, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to lock the object.");
    if (lock.IsLocked())
    {
        Puts($"The object is already locked by another player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Lock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", this, rpc.player) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnAirdrop(CargoPlane,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an airdrop is performed.
/// </summary>
/// <param name="cargoPlane">The cargo plane performing the airdrop.</param>
/// <param name="dropPosition">The position where the airdrop will be dropped.</param>
/// <returns>No return behavior.</returns>
void OnAirdrop(CargoPlane cargoPlane, Vector3 dropPosition)
{
    Puts($"Airdrop performed by {cargoPlane.name} at position: {dropPosition}");
    if (Vector3.Distance(dropPosition, new Vector3(0f, 100f, 0f)) < 10f)
    {
        Puts($"Airdrop dropped too close to the base.");
        // Handle airdrop being dropped too close to the base
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		startPos.Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);
		base.transform.position = startPos;
		base.transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", this, newDropPosition);
	}

```

## OnDoorClosed(Door,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a door is closed.
/// </summary>
/// <param name="door">The door that was closed.</param>
/// <param name="player">The player who closed the door.</param>
/// <returns>No return behavior.</returns>
void OnDoorClosed(BaseDoor door, BasePlayer player)
{
    Puts($"Door {door.name} has been closed by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_CloseDoor(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsOpen() && !IsBusy() && !IsLocked())
		{
			BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
			if (!(baseLock != null) || baseLock.OnTryToClose(rpc.player))
			{
				SetFlag(Flags.Open, b: false);
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnDoorClosed", this, rpc.player);
			}
		}
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret starts up.
/// </summary>
/// <param name="turret">The AutoTurret instance starting up.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally, or any non-null value to prevent it from starting up.
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"Turret {turret.name} has started up.");
    if (turret.isMalfunctioning)
    {
        Puts($"Turret {turret.name} is malfunctioning and will not start up.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
```csharp
/// <summary>
/// Called when a player's tick is received.
/// </summary>
/// <param name="player">The player whose tick is being processed.</param>
/// <param name="msg">The PlayerTick message containing the player's input and state.</param>
/// <param name="wasPlayerStalled">A boolean indicating whether the player was stalled during the previous tick.</param>
/// <returns>
/// Returns `null` to allow the default processing of the player's tick, or a non-null value to override this behavior.
/// If a string is returned, it will be used as a reason for kicking the player.
/// </returns>
object OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
{
    Puts($"Processing tick for player {player.displayName}.");
    if (msg.inputState != null)
    {
        serverInput.Flip(msg.inputState);
    }
    // Additional custom logic can be added here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## CanVendingAcceptItem(VendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if a vending machine can accept an item.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being attempted to be accepted.</param>
/// <returns>
/// Returns `true` if the vending machine can accept the item, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior and return that value instead.
/// </returns>
object CanVendingAcceptItem(VendingMachine vendingMachine, Item item)
{
    Puts($"Vending Machine {vendingMachine.name} attempting to accept item {item.displayName}");
    if (item.isExpired)
    {
        Puts($"Item {item.displayName} is expired and cannot be accepted.");
        return false;
    }
    if (item.parent == null && !inventory.itemList.Contains(item))
    {
        Puts($"Item {item.displayName} does not have a valid parent or is not in the inventory.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if (transactionActive)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (inventory.itemList.Contains(item))
		{
			return true;
		}
		if (ownerPlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(ownerPlayer);
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a code is entered into the lock.
/// </summary>
/// <param name="lock">The CodeLock instance.</param>
/// <param name="player">The player who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>
/// Returns `null` to allow the code to be accepted, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnCodeEntered(CodeLock lock, BasePlayer player, string code)
{
    Puts($"Player {player.UserID} entered code '{code}' into lock {lock}");
    if (code == "1234")
    {
        return "Access granted!";
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 10f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
			}
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
		}
	}

```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the turret.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="turret">The turret doing the targeting.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts($"Checking if {player.Name} can be targeted by {turret.name}.");
    if (player.IsSleeping() || !player.IsAlive())
    {
        return false;
    }
    object obj = Interface.CallHook("CanBeTargeted", player, turret);
    if (obj is bool)
    {
        return obj;
    }
    // Additional checks can be added here based on the specific requirements
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		List<BasePlayer> obj2 = Pool.GetList<BasePlayer>();
		Vis.Entities(GetEyePosition() + base.transform.forward * 3f, 2.5f, obj2, 131072);
		bool flag = false;
		foreach (BasePlayer item in obj2)
		{
			if (item.IsSleeping() || !item.IsAlive() || (item.HasPlayerFlag(BasePlayer.PlayerFlags.InBuildingPrivilege) && item.CanBuild()))
			{
				continue;
			}
			object obj3 = Interface.CallHook("CanBeTargeted", item, this);
			if (obj3 is bool)
			{
				return (bool)obj3;
			}
			if (item.GetEstimatedWorldPosition().y > GetEyePosition().y + 0.5f)
			{
				continue;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1075904769);
			for (int i = 0; i < obj.Count; i++)
			{
				RaycastHit hit = obj[i];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			break;
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		return flag;
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC wants to eat a given entity.
/// </summary>
/// <param name="npc">The NPC in question.</param>
/// <param name="entity">The entity the NPC is considering eating.</param>
/// <returns>
/// Returns `true` if the NPC wants to eat the entity, and `false` otherwise.
/// If a non-null value other than `bool` is returned, it will be used as the return value instead of this default behavior.
/// </returns>
object CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc.name} wants to eat {entity.name}");
    if (entity.HasTrait(TraitFlag.Poisoned))
    {
        Puts($"NPC {npc.name} does not want to eat {entity.name} because it is poisoned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
This is a C# code snippet that appears to be part of a game's projectile attack system. Here's a breakdown of the code:

**Purpose**: The code handles player projectile attacks, checking for various conditions and applying penalties if necessary.

**Main Functionality**:

1. **Initialization**: The function initializes variables related to the projectile attack.
2. **Distance Check**: It checks if the projectile has traveled too far from its origin, using a threshold value (`ConVar.AntiHack.projectile_protection`) to determine whether to apply a penalty.
3. **Speed Check**: If the projectile protection is enabled (>= 1), it checks if the projectile has traveled too fast, using another threshold value (`ConVar.AntiHack.projectile_protection`) to determine whether to apply a penalty.
4. **Line of Sight Check**: If the projectile protection is enabled (>= 3), it checks if the projectile's line of sight is blocked by an obstacle, using a function `GamePhysics.LineOfSight()` to determine whether to apply a penalty.
5. **Penalty Application**: If any of these conditions are met, the code applies a penalty to the player's attack and resets the projectile attack.
6. **Damage Calculation**: If the projectile is not penalized, it calculates the damage dealt to the target entity using the `hitInfo.ProjectilePrefab.CalculateDamage()` method.
7. **Penetration Resistance**: It checks if the target entity has penetration resistance and applies a reduction in damage accordingly.
8. **ServerProjectileHit**: The code calls the `value.itemMod.ServerProjectileHit(hitInfo)` method to update the projectile's integrity.
9. **Stats Update**: It updates various stats related to the attack, such as hit counts and indirect/direct line of sight flags.
10. **Effect and Entity Updates**: Finally, it applies an effect (`Effect.server.ImpactEffect(hitInfo)`) and updates the target entity using its `OnAttacked()` method.

**Context**: This code is likely part of a larger game system that handles player attacks, projectile behavior, and damage calculations. The specific context in which this code is deployed would depend on the overall architecture of the game.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void OnProjectileAttack(RPCMessage msg)
	{
		PlayerProjectileAttack playerProjectileAttack = PlayerProjectileAttack.Deserialize(msg.read);
		if (playerProjectileAttack == null)
		{
			return;
		}
		PlayerAttack playerAttack = playerProjectileAttack.playerAttack;
		HitInfo hitInfo = new HitInfo();
		hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
		hitInfo.Initiator = this;
		hitInfo.ProjectileID = playerAttack.projectileID;
		hitInfo.ProjectileDistance = playerProjectileAttack.hitDistance;
		hitInfo.ProjectileVelocity = playerProjectileAttack.hitVelocity;
		hitInfo.Predicted = msg.connection;
		if (hitInfo.IsNaNOrInfinity())
		{
			AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + playerAttack.projectileID + ")");
			playerProjectileAttack.ResetToPool();
			playerProjectileAttack = null;
			stats.combat.Log(hitInfo, "projectile_nan");
			return;
		}
		if (!firedProjectiles.TryGetValue(playerAttack.projectileID, out var value))
		{
			AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + playerAttack.projectileID + ")");
			playerProjectileAttack.ResetToPool();
			playerProjectileAttack = null;
			stats.combat.Log(hitInfo, "projectile_invalid");
			return;
		}
		if (value.integrity <= 0f)
		{
			AntiHack.Log(this, AntiHackType.ProjectileHack, "Integrity is zero (" + playerAttack.projectileID + ")");
			playerProjectileAttack.ResetToPool();
			playerProjectileAttack = null;
			stats.combat.Log(hitInfo, "projectile_integrity");
			return;
		}
		if (value.firedTime < UnityEngine.Time.realtimeSinceStartup - 8f)
		{
			AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + playerAttack.projectileID + ")");
			playerProjectileAttack.ResetToPool();
			playerProjectileAttack = null;
			stats.combat.Log(hitInfo, "projectile_lifetime");
			return;
		}
		hitInfo.Weapon = value.weaponSource;
		hitInfo.WeaponPrefab = value.weaponPrefab;
		hitInfo.ProjectilePrefab = value.projectilePrefab;
		hitInfo.damageProperties = value.projectilePrefab.damageProperties;
		if (ConVar.AntiHack.projectile_protection > 0 && (bool)hitInfo.HitEntity)
		{
			bool flag = true;
			float num = 1f + ConVar.AntiHack.projectile_forgiveness;
			float projectile_clientframes = ConVar.AntiHack.projectile_clientframes;
			float projectile_serverframes = ConVar.AntiHack.projectile_serverframes;
			float num2 = Mathx.Decrement(value.firedTime);
			float num3 = Mathx.Increment(UnityEngine.Time.realtimeSinceStartup);
			float num4 = num3 - num2;
			float num5 = projectile_clientframes / 60f;
			float num6 = projectile_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
			float num7 = (desyncTime + num4 + num5 + num6) * num;
			if (ConVar.AntiHack.projectile_protection >= 2)
			{
				float num8 = hitInfo.HitEntity.MaxVelocity();
				float num9 = hitInfo.HitEntity.BoundsPadding() + num7 * num8;
				float num10 = hitInfo.HitEntity.Distance2D(hitInfo.HitPositionWorld);
				if (num10 > num9)
				{
					string text = hitInfo.ProjectilePrefab.name;
					string shortPrefabName = hitInfo.HitEntity.ShortPrefabName;
					AntiHack.Log(this, AntiHackType.ProjectileHack, "Entity too far away (" + text + " on " + shortPrefabName + " with " + num10 + "m > " + num9 + "m in " + num7 + "s)");
					stats.combat.Log(hitInfo, "projectile_distance");
					flag = false;
				}
			}
			if (ConVar.AntiHack.projectile_protection >= 1)
			{
				float num11 = value.itemMod.GetMaxVelocity();
				BaseProjectile baseProjectile = hitInfo.Weapon as BaseProjectile;
				if ((bool)baseProjectile)
				{
					num11 *= baseProjectile.projectileVelocityScale;
				}
				float num12 = hitInfo.ProjectilePrefab.initialDistance + num7 * num11;
				float num13 = UnityEngine.Vector3.Distance(value.origin, hitInfo.HitPositionWorld);
				if (num13 > num12)
				{
					string text2 = hitInfo.ProjectilePrefab.name;
					string shortPrefabName2 = hitInfo.HitEntity.ShortPrefabName;
					AntiHack.Log(this, AntiHackType.ProjectileHack, "Traveled too fast (" + text2 + " on " + shortPrefabName2 + " with " + num13 + "m > " + num12 + "m in " + num7 + "s)");
					stats.combat.Log(hitInfo, "projectile_speed");
					flag = false;
				}
			}
			if (ConVar.AntiHack.projectile_protection >= 3)
			{
				UnityEngine.Vector3 pointStart = hitInfo.PointStart;
				UnityEngine.Vector3 vector = hitInfo.HitPositionWorld + hitInfo.HitNormalWorld.normalized * 0.001f;
				UnityEngine.Vector3 position = value.position;
				UnityEngine.Vector3 vector2 = pointStart;
				UnityEngine.Vector3 vector3 = hitInfo.PositionOnRay(vector);
				UnityEngine.Vector3 vector4 = vector;
				bool flag2 = GamePhysics.LineOfSight(position, vector2, vector3, vector4, 2162688);
				if (!flag2)
				{
					stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
				}
				else
				{
					stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_direct_los", 1, Stats.Server);
				}
				if (!flag2)
				{
					string text3 = hitInfo.ProjectilePrefab.name;
					string shortPrefabName3 = hitInfo.HitEntity.ShortPrefabName;
					AntiHack.Log(this, AntiHackType.ProjectileHack, string.Concat("Line of sight (", text3, " on ", shortPrefabName3, ") ", position, " ", vector2, " ", vector3, " ", vector4));
					stats.combat.Log(hitInfo, "projectile_los");
					flag = false;
				}
			}
			if (!flag)
			{
				AntiHack.AddViolation(this, AntiHackType.ProjectileHack, ConVar.AntiHack.projectile_penalty);
				playerProjectileAttack.ResetToPool();
				playerProjectileAttack = null;
				return;
			}
		}
		value.position = hitInfo.HitPositionWorld + hitInfo.ProjectileVelocity.normalized * 0.001f;
		hitInfo.ProjectilePrefab.CalculateDamage(hitInfo, value.projectileModifier, value.integrity);
		if (hitInfo.ProjectilePrefab.penetrationPower <= 0f || hitInfo.HitEntity == null)
		{
			value.integrity = 0f;
		}
		else
		{
			float num14 = hitInfo.HitEntity.PenetrationResistance(hitInfo) / hitInfo.ProjectilePrefab.penetrationPower;
			value.integrity = Mathf.Clamp01(value.integrity - num14);
		}
		value.itemMod.ServerProjectileHit(hitInfo);
		if ((bool)hitInfo.HitEntity)
		{
			stats.Add(value.itemMod.category + "_hit_" + hitInfo.HitEntity.Categorize(), 1);
		}
		if (value.integrity <= 0f && hitInfo.ProjectilePrefab.remainInWorld)
		{
			CreateWorldProjectile(hitInfo, value.itemDef, value.itemMod, hitInfo.ProjectilePrefab, value.pickupItem);
		}
		firedProjectiles[playerAttack.projectileID] = value;
		if (Interface.CallHook("OnPlayerAttack", this, hitInfo) == null)
		{
			if ((bool)hitInfo.HitEntity)
			{
				hitInfo.HitEntity.OnAttacked(hitInfo);
			}
			Effect.server.ImpactEffect(hitInfo);
			playerProjectileAttack.ResetToPool();
			playerProjectileAttack = null;
		}
	}

```

## IOnEnableServerConsole(ServerConsole)

```csharp
```csharp
/// <summary>
/// Called when the server console is enabled.
/// </summary>
/// <param name="console">The server console.</param>
/// <returns>
/// Returns `null` to allow the console to be initialized, or any non-null value to prevent it from being initialized.
/// </returns>
object IOnEnableServerConsole(ServerConsole console)
{
    Puts("Server console enabled.");
    if (console == null)
    {
        Puts("Server console is null. Skipping initialization.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnEnable()
	{
		if (!Facepunch.CommandLine.HasSwitch("-keeplogs"))
		{
			ConVar.Server.LogCreate("Log.Warning.txt");
			ConVar.Server.LogCreate("Log.Error.txt");
			ConVar.Server.LogCreate("Log.Exception.txt");
			ConVar.Server.LogCreate("Log.Log.txt");
			ConVar.Server.LogCreate("Log.Chat.txt");
			ConVar.Server.LogCreate("Log.EAC.txt");
			ConVar.Server.LogCreate("Log.Assert.txt");
		}
		if (Interface.CallHook("IOnEnableServerConsole", this) == null)
		{
			console.Initialize();
			input.OnInputText += OnInputText;
			Output.OnMessage += HandleLog;
			input.ClearLine(System.Console.WindowHeight);
			for (int i = 0; i < System.Console.WindowHeight; i++)
			{
				System.Console.WriteLine(string.Empty);
			}
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player disconnects from the server.
/// </summary>
/// <param name="player">The disconnected player.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} disconnected with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	private void OnDisconnected(string strReason, Connection connection)
	{
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		Rust.Global.SteamServer.Auth.EndSession(connection.userid);
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((bool)basePlayer)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The container from which the items were dropped.</param>
/// <returns>
/// Returns `true` to override the default drop behavior, or `false` to allow the items to be dropped normally.
/// If `null` is returned, the default drop behavior will be used.
/// </returns>
bool OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping items from container {container.GetDisplayName()}");
    if (container.GetItemCount() == 0)
    {
        Puts($"No items to drop from container {container.GetDisplayName()}");
        return true;
    }
    // Add custom logic here to override the default drop behavior
    return false;
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position, float chance = 1f)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			if (!(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				float num2 = UnityEngine.Random.Range(0f, 2f);
				item.RemoveFromContainer();
				BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
				if (baseEntity == null)
				{
					item.Remove();
				}
				else if (num2 > 0f)
				{
					baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
					baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
				}
			}
		}
	}

```

## OnCupboardAuthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is authorized to access the cupboard.
/// </summary>
/// <param name="building">The building containing the cupboard.</param>
/// <param name="player">The player being authorized.</param>
/// <returns>
/// Returns `null` to allow the player to be authorized, or any non-null value to prevent them from accessing the cupboard.
/// </returns>
object OnCupboardAuthorize(BuildingPrivlidge building, BasePlayer player)
{
    Puts($"Player {player.displayName} has been authorized to access the cupboard.");
    if (player.UserIDString == "admin")
    {
        Puts($"Player {player.displayName} is already authorized to access the cupboard.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && CanAdministrate(rpc2.player) && Interface.CallHook("OnCupboardAuthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = rpc2.player.userID;
			playerNameID.username = rpc2.player.displayName;
			authorizedPlayers.Add(playerNameID);
			UpdateAllPlayers();
			SendNetworkUpdate();
		}
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is being repaired.
/// </summary>
/// <param name="structure">The structure being repaired.</param>
/// <param name="player">The player performing the repair.</param>
/// <returns>
/// Returns `null` to allow the repair to proceed, or any non-null value to cancel the repair.
/// </returns>
object OnStructureRepair(BaseCombatEntity structure, BasePlayer player)
{
    Puts($"Structure {structure.name} is being repaired by player {player.displayName}");
    if (player.inventory.GetAmount(ItemID.None) < 1000f)
    {
        Puts($"Player {player.displayName} does not have enough resources to repair the structure.");
        return "Not enough resources.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		if (SecondsSinceAttacked <= 8f)
		{
			OnRepairFailed();
			return;
		}
		float num = MaxHealth() - health;
		float num2 = num / MaxHealth();
		if (num <= 0f || num2 <= 0f)
		{
			OnRepairFailed();
			return;
		}
		List<ItemAmount> list = RepairCost(num2);
		if (list == null)
		{
			return;
		}
		float num3 = list.Sum((ItemAmount x) => x.amount);
		if (num3 > 0f)
		{
			float a = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			a = Mathf.Min(a, 50f / num);
			if (a <= 0f)
			{
				OnRepairFailed();
				return;
			}
			int num4 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(a * item.amount);
				int num5 = player2.inventory.Take(null, item.itemid, amount);
				if (num5 > 0)
				{
					num4 += num5;
					player2.Command("note.inv", item.itemid, num5 * -1);
				}
			}
			float num6 = (float)num4 / num3;
			health += num * num6;
			SendNetworkUpdate();
		}
		else
		{
			health += num;
			SendNetworkUpdate();
		}
		if (health >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a specific entity.
/// </summary>
/// <param name="npc">The NPC that has targeted the entity.</param>
/// <param name="target">The entity that was targeted by the NPC.</param>
/// <returns>
/// Returns `true` if the NPC wants to attack the target, or any non-null value to override the default behavior.
/// If a float is returned, it represents the priority of the attack (higher values mean higher priority).
/// </returns>
object OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} has targeted entity {target.UserIDString}.");
    if (target is Player && ((Player)target).IsAdmin)
    {
        Puts($"NPC {npc.name} has been instructed to ignore admins.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("OnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallDistance">The distance the player fell.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanded(BasePlayer player, float fallDistance)
{
    Puts($"Player {player.UserIDString} has landed after falling {fallDistance} units.");
    if (fallDistance > 50f)
    {
        Puts($"Player {player.displayName} suffered severe fall damage.");
        // Apply additional effects or penalties for severe fall damage
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (float.IsNaN(num) || float.IsInfinity(num))
		{
			return;
		}
		float num2 = Mathf.InverseLerp(-15f, -100f, num);
		if (num2 != 0f && Interface.CallHook("OnPlayerLand", this, num2) == null)
		{
			metabolism.bleeding.Add(num2 * 0.5f);
			float num3 = num2 * 500f;
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num2);
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Determines whether the helicopter can strafe.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe, and `false` otherwise.
/// If a non-bool value is returned from the hook, it will be ignored and the default behavior will be used.
/// </returns>
bool CanHelicopterStrafe(PatrolHelicopterAI ai)
{
    Puts("Helicopter attempting to strafe.");
    if (ai.isLowOnFuel())
    {
        Puts("Helicopter cannot strafe due to low fuel.");
        return false;
    }
    object obj = Interface.CallHook("CanHelicopterStrafe", ai);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= 20f && CanInterruptState();
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the network should be allowed to connect to a BasePlayer.
/// </summary>
/// <param name="player">The player to check.</param>
/// <returns>
/// Returns `true` to allow the network to connect, or `false` to deny it.
/// If any other type is returned, it will be treated as `true`.
/// </returns>
bool CanNetworkTo(BasePlayer player)
{
    Puts($"Checking if network can connect to {player.UserIDString}...");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnAddVendingOffer(VendingMachine,BasePlayer,ProtoBuf.VendingMachine.SellOrder)

```csharp
```csharp
/// <summary>
/// Called when a vending offer is added.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was added to.</param>
/// <param name="player">The player who added the offer.</param>
/// <param name="sellOrder">The sell order being added.</param>
/// <returns>No return value. This method is used for hooking purposes only.</returns>
void OnAddVendingOffer(VendingMachine vendingMachine, BasePlayer player, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"Sell order {sellOrder.itemToSellID} x{sellOrder.itemToSellAmount} for {sellOrder.currencyID} x{sellOrder.currencyAmountPerItem} added by {player.displayName}");
    // You can add custom logic here to handle the addition of a vending offer
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_AddSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!CanPlayerAdmin(player))
		{
			return;
		}
		if (sellOrders.sellOrders.Count >= 7)
		{
			player.ChatMessage("Too many sell orders - remove some");
			return;
		}
		int num = msg.read.Int32();
		int value = msg.read.Int32();
		int num2 = msg.read.Int32();
		int value2 = msg.read.Int32();
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(num2);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			value2 = Mathf.Clamp(value2, 1, 10000);
			value = Mathf.Clamp(value, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = num;
			sellOrder.itemToSellAmount = value;
			sellOrder.currencyID = num2;
			sellOrder.currencyAmountPerItem = value2;
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			Interface.CallHook("OnAddVendingOffer", this, player, sellOrder);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## CanAssignBed(SleepingBag,BasePlayer,ulong)

```csharp
```csharp
/// <summary>
/// Called to check if a bed can be assigned to a player.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being considered for assignment.</param>
/// <param name="player">The player who would be using the sleeping bag.</param>
/// <param name="bedId">The ID of the bed being considered for assignment.</param>
/// <returns>
/// Returns `null` to allow the bed to be assigned, or any non-null value to prevent it from being assigned.
/// </returns>
object CanAssignBed(SleepingBag sleepingBag, BasePlayer player, ulong bedId)
{
    Puts($"Checking if bed {bedId} can be assigned to player {player.UserIDString}");
    // Check if the bed is already occupied by another player
    if (sleepingBag.IsOccupied())
    {
        return "Bed is already occupied";
    }
    // Check if the player has permission to use the bed
    if (!player.HasPermissionToUseBed(bedId))
    {
        return "Player does not have permission to use this bed";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void AssignToFriend(RPCMessage msg)
	{
		if (msg.player.CanInteract() && deployerUserID == msg.player.userID)
		{
			ulong num = msg.read.UInt64();
			if (num != 0 && Interface.CallHook("CanAssignBed", this, msg.player, num) == null)
			{
				deployerUserID = num;
				SendNetworkUpdate();
			}
		}
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an entity is built.
/// </summary>
/// <param name="planner">The planner that built the entity.</param>
/// <param name="gameObject">The GameObject of the built entity.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the entity is built as normal.
/// </returns>
object OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
{
    Puts($"Entity has been built by {planner}.");
    if (gameObject.name == "Forbidden Entity")
    {
        Puts($"Entity {gameObject.name} has been blocked from being built.");
        return "Blocked: Unauthorized entity.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())
		{
			return;
		}
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ChatMessage("Target socket is not female. (" + target.socket.socketName + ")");
				return;
			}
			if (target.construction != null && target.construction.IsOccupied(target.socket))
			{
				ownerPlayer.ChatMessage("Target socket is occupied. (" + target.socket.socketName + ")");
				return;
			}
		}
		Construction.lastPlacementError = "No Error";
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			ownerPlayer.ChatMessage("Can't place: " + Construction.lastPlacementError);
		}
		if (!(gameObject != null))
		{
			return;
		}
		Interface.CallHook("OnEntityBuilt", this, gameObject);
		Deployable deployable = GetDeployable();
		if (deployable != null)
		{
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
			if (deployable.setSocketParent && target.transformParent != null && (bool)baseEntity)
			{
				baseEntity.SetParent(target.transformParent);
				baseEntity.transform.position = target.transformParent.transform.InverseTransformPoint(baseEntity.transform.position);
			}
			if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
			{
				(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
			}
			if (deployable.copyInventoryFromItem)
			{
				StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
				if ((bool)component2)
				{
					component2.ReceiveInventoryFromItem(GetOwnerItem());
				}
			}
			ItemModDeployable modDeployable = GetModDeployable();
			if (modDeployable != null)
			{
				modDeployable.OnDeployed(baseEntity, ownerPlayer);
			}
		}
		PayForPlacement(ownerPlayer, component);
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is crafted.
/// </summary>
/// <param name="itemCraftTask">The task associated with the crafting process.</param>
/// <param name="owner">The player who initiated the crafting process.</param>
/// <param name="fromTempBlueprint">The blueprint used for crafting, if any.</param>
/// <returns>
/// Returns a non-null value to override the default crafting behavior. 
/// If `true` is returned, the crafting process will be allowed as normal.
/// If `false` is returned, the crafting process will be cancelled.
/// </returns>
object OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)
{
    Puts($"Player {owner.displayName} has initiated an item craft task.");
    if (itemCraftTask.blueprint.targetItem.itemid == 123) // Example: Cancel crafting of specific item
    {
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null)
	{
		if (!CanCraft(bp, amount))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		CollectIngredients(bp, itemCraftTask, amount, owner);
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.owner = owner;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			return (bool)obj;
		}
		queue.Enqueue(itemCraftTask);
		if (itemCraftTask.owner != null)
		{
			itemCraftTask.owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## OnExplosiveThrown(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an explosive is thrown.
/// </summary>
/// <param name="player">The player who threw the explosive.</param>
/// <param name="explosive">The explosive entity that was thrown.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the explosive was thrown successfully.
/// </returns>
object OnExplosiveThrown(BasePlayer player, BaseEntity explosive)
{
    Puts($"Player {player.UserIDString} threw an explosive.");
    if (explosivePrefab == "Grenade")
    {
        Puts($"Player {player.UserIDString} threw a grenade.");
        return null;
    }
    else
    {
        Puts($"Player {player.UserIDString} tried to throw an unknown explosive prefab: {explosivePrefab}");
        return "Error: Unknown explosive prefab.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoThrow(RPCMessage msg)
	{
		if (!HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		Vector3 vector = msg.read.Vector3();
		Vector3 normalized = msg.read.Vector3().normalized;
		float num = Mathf.Clamp01(msg.read.Float());
		if (!ValidateEyePos(msg.player, vector))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation((!(overrideAngle == Vector3.zero)) ? overrideAngle : (-normalized)));
		if (!(baseEntity == null))
		{
			baseEntity.creatorEntity = msg.player;
			baseEntity.SetVelocity(normalized * maxThrowVelocity * num);
			if (tumbleVelocity > 0f)
			{
				baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(-1f, 1f)) * tumbleVelocity);
			}
			baseEntity.Spawn();
			Interface.CallHook("OnExplosiveThrown", msg.player, baseEntity);
			StartAttackCooldown(repeatDelay);
			UseItemAmount(1);
		}
	}

```

## OnCreateWorldProjectile(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="info">The hit info of the projectile.</param>
/// <param name="itemDef">The definition of the item being used to create the projectile.</param>
/// <returns>
/// Returns `null` to allow the projectile to be created as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display when the projectile is created.
/// </returns>
object OnCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
{
    Puts($"A world projectile has been created at position {info.HitPositionWorld}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem == null) ? ItemManager.Create(itemDef, 1, 0uL) : recycleItem);
		BaseEntity baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		if (!info.DidHit)
		{
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			if (info.HitEntity == null)
			{
				component.isKinematic = true;
				return;
			}
			Quaternion rotation = ((info.HitBone != 0) ? Quaternion.LookRotation(info.HitNormalLocal * -1f) : Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)));
			component.isKinematic = true;
			baseEntity.SetParent(info.HitEntity, info.HitBone);
			baseEntity.transform.position = info.HitPositionLocal;
			baseEntity.transform.rotation = rotation;
		}
		else
		{
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="block">The building block being modified.</param>
/// <param name="grade">The new grade to be applied.</param>
/// <returns>
/// Returns `true` if the player can change the grade, or `false` otherwise.
/// </returns>
bool CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
{
    Puts($"Player {player.UserIDString} is trying to change the grade of {block.BlockName} to {grade}");
    object obj = Interface.CallHook("CanChangeGrade", player, block, grade);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If no hook returns a boolean value, default to allowing the change
    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return HasUpgradePrivilege(iGrade, player) && !IsUpgradeBlocked();
	}

```

## OnExplosiveDropped(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an explosive is dropped.
/// </summary>
/// <param name="player">The player who dropped the explosive.</param>
/// <param name="explosive">The explosive entity that was dropped.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the explosive will be handled as normal.
/// </returns>
object OnExplosiveDropped(BasePlayer player, BaseEntity explosive)
{
    Puts($"Player {player.displayName} dropped an explosive.");
    if (explosive is TimedExplosive && ((BaseEntity)player).GetDistance(explosive) < 5f)
    {
        Puts($"Player {player.displayName} was too close to the explosive.");
        return "Too Close: Player safety protocol engaged.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDrop(RPCMessage msg)
	{
		if (!HasItemAmount() || HasAttackCooldown())
		{
			return;
		}
		Vector3 vector = msg.read.Vector3();
		Vector3 normalized = msg.read.Vector3().normalized;
		if (!ValidateEyePos(msg.player, vector))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(prefabToThrow.resourcePath, vector, Quaternion.LookRotation(Vector3.up));
		if (baseEntity == null)
		{
			return;
		}
		if (UnityEngine.Physics.SphereCast(new Ray(vector, normalized), 0.05f, out var hitInfo, 1.5f, 1101212417))
		{
			Vector3 point = hitInfo.point;
			Vector3 normal = hitInfo.normal;
			BaseEntity entity = RaycastHitEx.GetEntity(hitInfo);
			if ((bool)entity && entity is StabilityEntity && baseEntity is TimedExplosive)
			{
				entity = entity.ToServer<BaseEntity>();
				TimedExplosive timedExplosive = baseEntity as TimedExplosive;
				timedExplosive.onlyDamageParent = true;
				timedExplosive.DoStick(point, normal, entity);
			}
			else
			{
				baseEntity.SetVelocity(normalized);
			}
		}
		else
		{
			baseEntity.SetVelocity(normalized);
		}
		baseEntity.creatorEntity = msg.player;
		baseEntity.Spawn();
		Interface.CallHook("OnExplosiveDropped", msg.player, baseEntity);
		StartAttackCooldown(repeatDelay);
		UseItemAmount(1);
	}

```

## OnSurveyGather(SurveyCharge,Item)

```csharp
```csharp
/// <summary>
/// Called when a survey charge is gathered.
/// </summary>
/// <param name="surveyCharge">The survey charge being gathered.</param>
/// <param name="item">The item being dropped as a result of the survey charge gathering.</param>
public void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts($"Survey charge {surveyCharge} has been gathered and an item {item} is being dropped.");
    // You can add custom logic here to handle the survey charge gathering and item dropping.
    // For example, you could modify the item's properties or spawn additional entities.
    // If you want to override the default behavior of this method, return a non-null value from your implementation.
    return;
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		base.Explode();
		if (WaterLevel.Test(base.transform.position))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);
		if (orCreate == null)
		{
			return;
		}
		Vector2i indexFrom = ResourceDepositManager.GetIndexFrom(base.transform.position);
		if (Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))
		{
			return;
		}
		Vector3 point = hitOut.point;
		Vector3 normal = hitOut.normal;
		List<SurveyCrater> obj = Pool.GetList<SurveyCrater>();
		Vis.Entities(base.transform.position, 10f, obj, 1);
		bool flag = obj.Count > 0;
		Pool.FreeList(ref obj);
		if (flag)
		{
			return;
		}
		bool flag2 = false;
		bool flag3 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag2 = true;
				if (resource.isLiquid)
				{
					flag3 = true;
				}
				for (int i = 0; i < num; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", this, item);
					float aimCone = 20f;
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, Vector3.up);
					BaseEntity baseEntity = item.Drop(base.transform.position + Vector3.up * 1f, modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation);
					baseEntity.SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
				}
			}
		}
		if (flag2)
		{
			string strPrefab = ((!flag3) ? craterPrefab.resourcePath : craterPrefab_Oil.resourcePath);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if ((bool)baseEntity2)
			{
				baseEntity2.Spawn();
			}
		}
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a player buys an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine the item was purchased from.</param>
/// <param name="player">The player who made the purchase.</param>
/// <param name="itemIndex">The index of the item purchased.</param>
/// <param name="quantity">The quantity of the item purchased.</param>
/// <returns>No return behavior.</returns>
void OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer player, int itemIndex, int quantity)
{
    Puts($"Player {player.UserIDString} bought {quantity} x {itemIndex} from vending machine {vendingMachine.VendingMachineID}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void BuyItem(RPCMessage rpc)
	{
		int num = rpc.read.Int32();
		int num2 = rpc.read.Int32();
		Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2);
		SetPendingOrder(rpc.player, num, num2);
		Invoke(CompletePendingOrder, 2.5f);
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if a target can be targeted by the auto turret.
/// </summary>
/// <param name="target">The target entity.</param>
/// <param name="autoTurret">The auto turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BaseCombatEntity target, AutoTurret autoTurret)
{
    Puts($"Checking if {target} can be targeted by {autoTurret}.");
    // Custom logic to determine if the target can be targeted
    // For example:
    if (target == null || target.IsDead())
    {
        return false;
    }
    // ...
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.GetList<RaycastHit>();
		Vector3 position = eyePos.transform.position;
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 normalized = (vector - position).normalized;
		Vector3 vector2 = Vector3.Cross(normalized, Vector3.up);
		for (int i = 0; i < 3; i++)
		{
			Vector3 vector3 = vector + vector2 * visibilityOffsets[i];
			Vector3 normalized2 = (vector3 - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized2), 0f, obj3, num * 1.1f, 1084434689);
			for (int j = 0; j < obj3.Count; j++)
			{
				RaycastHit hit = obj3[j];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == obj || entity.EqualNetID(obj)))
				{
					Facepunch.Pool.FreeList(ref obj3);
					return true;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj3);
		return false;
	}

```

## CanBuild(Planner,Construction,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to build something.
/// </summary>
/// <param name="planner">The planner object.</param>
/// <param name="construction">The construction object.</param>
/// <param name="position">The position where the building will be placed.</param>
/// <returns>
/// Returns `null` if the player is allowed to build. 
/// If a non-null value is returned, it overrides the default behavior and prevents the player from building.
/// </returns>
object CanBuild(BasePlayer planner, Construction construction, Vector3 position)
{
    Puts($"Player {planner.UserID} attempted to build at position {position}");
    if (construction == null || !planner.CanBuild())
    {
        return null;
    }
    else
    {
        // Custom logic to prevent building here...
        return "Building is blocked.";
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ChatMessage("Couldn't find Construction " + msg.blockID);
		}
		else if (!CanAffordToPlace(construction))
		{
			ownerPlayer.ChatMessage("Can't afford to place!");
		}
		else if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ChatMessage("Building is blocked!");
		}
		else
		{
			if (Interface.CallHook("CanBuild", this, construction, msg.position) != null)
			{
				return;
			}
			Construction.Target target = default(Construction.Target);
			BaseNetworkable baseNetworkable = null;
			if (msg.entity != 0)
			{
				baseNetworkable = BaseNetworkable.serverEntities.Find(msg.entity);
				if (!baseNetworkable)
				{
					ownerPlayer.ChatMessage("Couldn't find entity " + msg.entity);
					return;
				}
				target.construction = baseNetworkable.GetComponent<BuildingBlock>();
				target.transformParent = baseNetworkable.GetComponent<BaseEntity>();
				if (msg.socket != 0)
				{
					string text = StringPool.Get(msg.socket);
					if (text != string.Empty && target.transformParent != null)
					{
						target.socket = FindSocket(text, target.transformParent.prefabID);
					}
					else
					{
						ownerPlayer.ChatMessage("Invalid Socket!");
					}
				}
				else
				{
					Debug.Log("socket was 0");
				}
			}
			target.ray = msg.ray;
			target.onTerrain = msg.onterrain;
			target.position = msg.position;
			target.normal = msg.normal;
			target.rotation = msg.rotation;
			target.player = ownerPlayer;
			target.valid = true;
			Deployable deployable = GetDeployable();
			if ((bool)deployable && deployable.placeEffect.isValid)
			{
				if ((bool)baseNetworkable && msg.socket != 0)
				{
					Effect.server.Run(deployable.placeEffect.resourcePath, baseNetworkable.transform.TransformPoint(target.socket.worldPosition), baseNetworkable.transform.up);
				}
				else
				{
					Effect.server.Run(deployable.placeEffect.resourcePath, msg.position, msg.normal);
				}
			}
			DoBuild(target, construction);
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned.
/// </summary>
/// <param name="entity">The entity that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity {entity.ClassName} has been spawned.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player picks up an item.
/// </summary>
/// <param name="item">The item being picked up.</param>
/// <param name="player">The player picking up the item.</param>
/// <returns>
/// Returns `null` to allow the player to pick up the item, or any non-null value to prevent them from picking it up.
/// </returns>
object OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} picked up item: {item.displayName}");
    if (item.isLocked)
    {
        Puts($"Player {player.UserIDString} tried to pick up locked item: {item.displayName}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && item != null && allowPickup && Interface.CallHook("OnItemPickup", item, msg.player) == null)
		{
			ClientRPC(null, "PickupSound");
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can target a player.
/// </summary>
/// <param name="helicopter">The helicopter attempting to target the player.</param>
/// <param name="player">The player being targeted.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player, and `false` otherwise.
/// If this method is not implemented or returns a non-boolean value, the default behavior will be used.
/// </returns>
bool CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Helicopter {helicopter.GetReference()} attempting to target player {player.UserIDString}.");
    if (player.IsDead || player.IsInvisible)
    {
        return false;
    }
    // Additional logic can be added here to determine if the helicopter can target the player
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1084434689) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## OnPlayerConnected(Network.Message)

```csharp
```csharp
/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="packet">The message packet containing information about the connected player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(Network.Message packet)
{
    Puts($"Player {packet.connection.info["name"]} has connected to the server.");
    if (packet.connection.info["ip"] == "192.168.1.1")
    {
        Puts($"Player {packet.connection.info["name"]} with IP {packet.connection.info["ip"]} has been blocked from joining.");
        return;
    }
    // Additional logic can be added here to handle the player connection
}
```
```

### Source Code from the Library

```csharp

	private void ClientReady(Message packet)
	{
		using ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read);
		foreach (ClientReady.ClientInfo item in clientReady.clientInfo)
		{
			packet.connection.info.Set(item.name, item.value);
		}
		connectionQueue.JoinedGame(packet.connection);
		Interface.CallHook("OnPlayerConnected", packet);
		using (TimeWarning.New("ClientReady"))
		{
			using (TimeWarning.New("SpawnPlayerSleeping"))
			{
				if (SpawnPlayerSleeping(packet.connection))
				{
					return;
				}
			}
			using (TimeWarning.New("SpawnNewPlayer"))
			{
				SpawnNewPlayer(packet.connection);
			}
		}
	}

```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine is rotated.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="player">The player who initiated the rotation.</param>
/// <returns>
/// Returns `null` to allow the vending machine to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending Machine {vendingMachine.name} has been rotated by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot rotate the vending machine");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RotateVM(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (Interface.CallHook("OnRotateVendingMachine", this, player) == null && player.CanBuild() && IsInventoryEmpty())
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## CanChangeCode(CodeLock,BasePlayer,string,bool)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to change the code.
/// </summary>
/// <param name="lock">The CodeLock instance.</param>
/// <param name="player">The BasePlayer attempting to change the code.</param>
/// <param name="newCode">The new 4-digit code being proposed.</param>
/// <param name="isGuest">Whether this is a guest attempting to change the code.</param>
/// <returns>
/// Returns `null` if the player can change the code, or any non-null value to prevent them from changing it.
/// </returns>
object CanChangeCode(CodeLock lock, BasePlayer player, string newCode, bool isGuest)
{
    Puts($"Player {player.UserIDString} attempted to change the code to {newCode} as a guest: {isGuest}");
    if (newCode == "1234")
    {
        Puts($"Player {player.displayName} tried to set the code to the default value.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (IsLocked() || text.Length != 4 || (!hasCode && flag))
		{
			return;
		}
		if (!hasCode && !flag)
		{
			SetFlag(Flags.Locked, b: true);
		}
		if (Interface.CallHook("CanChangeCode", this, rpc.player, text, flag) == null)
		{
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## CanUnlock(KeyLock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock the object.
/// </summary>
/// <param name="lock">The KeyLock instance.</param>
/// <param name="player">The BasePlayer attempting to unlock the lock.</param>
/// <returns>
/// Returns `null` to allow the player to unlock the lock, or any non-null value to prevent them from unlocking it.
/// </returns>
object CanUnlock(KeyLock lock, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is attempting to unlock {lock.name}");
    if (player.IsAdmin())
    {
        return null;
    }
    else
    {
        return "Access denied: Only admins can unlock this lock";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", this, rpc.player) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The storage container being used for looting.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.UserIDString} has finished looting the entity.");
    if (container.GetItemCount() == 0)
    {
        Puts($"The storage container is now empty.");
        // Optional: Remove or reset the container
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a hammer hits an entity.
/// </summary>
/// <param name="owner">The player who wielded the hammer.</param>
/// <param name="info">Information about the hit, including the entity and damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default behavior of repairing the entity. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnHammerHit(BasePlayer owner, HitInfo info)
{
    Puts($"Player {owner.UserIDString} hit an entity with their hammer.");
    if (info.HitEntity is BaseBuilding)
    {
        Puts($"The entity hit was a building.");
        return "Building cannot be repaired.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			if (ownerPlayer != null && base.isServer)
			{
				using (TimeWarning.New("DoRepair", 50L))
				{
					baseCombatEntity.DoRepair(ownerPlayer);
				}
			}
		}
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing ground.
/// </summary>
/// <param name="entity">The BaseEntity that is missing ground.</param>
/// <returns>
/// Returns `null` to allow the entity to die normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for killing the entity.
/// </returns>
object OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity.EntityID} is missing ground.");
    if (entity.EntityID == 12345)
    {
        Puts($"Entity {entity.EntityID} has been blocked from dying.");
        return "Blocked: Entity ID not allowed to die.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (Interface.CallHook("OnEntityGroundMissing", baseEntity) == null && baseEntity != null)
		{
			baseEntity.SendMessage("PreDie", SendMessageOptions.DontRequireReceiver);
			baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
		}
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldHealth">The player's old health value.</param>
/// <param name="newHealth">The player's new health value.</param>
/// <returns>No return behavior.</returns>
void OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Player {player.UserIDString} health changed from {oldHealth} to {newHealth}");
}
```
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) == null)
		{
			base.OnHealthChanged(oldvalue, newvalue);
			metabolism.isDirty = true;
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client authenticates with the server.
/// </summary>
/// <param name="connection">The client connection.</param>
/// <returns>
/// Returns `null` to allow the client to authenticate normally, or any non-null value to override the default authentication behavior. 
/// If a string is returned, the client will be kicked with the provided message as the reason.
/// </returns>
object OnClientAuth(Network.Connection connection)
{
    Puts($"Client {connection} has authenticated with the server.");
    if (connection.userid == 1234567890)
    {
        Puts($"Client {connection} has been blocked from authenticating.");
        return "Blocked: Unauthorized client.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Connection.State.Connecting;
		byte b = packet.read.UInt8();
		if (b != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String();
		packet.connection.username = packet.read.String();
		Interface.CallHook("OnClientAuth", packet.connection);
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.unread >= 4)
		{
			text = packet.read.String();
		}
		if (branch != string.Empty && branch != text)
		{
			UnityEngine.Debug.Log(string.Concat("Kicking ", packet.connection, " - their branch is '", text, "' not '", branch, "'"));
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2013)
		{
			UnityEngine.Debug.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2013));
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2013)
		{
			UnityEngine.Debug.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2013));
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize();
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
			}
			else
			{
				auth.OnNewConnection(packet.connection);
			}
		}
	}

```

## IOnStructureDemolish(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is demolished.
/// </summary>
/// <param name="structure">The structure being demolished.</param>
/// <param name="player">The player demolishing the structure.</param>
/// <returns>
/// Returns `null` to allow the demolition, or any non-null value to prevent it.
/// </returns>
object IOnStructureDemolish(BuildingBlock structure, BasePlayer player)
{
    Puts($"Structure {structure.name} has been demolished by player {player.displayName}");
    if (structure.isImportant)
    {
        Puts($"Important structure {structure.name} cannot be demolished.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("IOnStructureDemolish", this, msg.player) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## IOnLootPlayer(PlayerLoot,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is being looted.
/// </summary>
/// <param name="looter">The entity doing the looting.</param>
/// <param name="player">The player being looted.</param>
/// <returns>No return behavior.</returns>
void IOnLootPlayer(PlayerLoot looter, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is being looted by {looter.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingPlayer(BasePlayer player)
	{
		Clear();
		if ((bool)player && (bool)player.inventory)
		{
			AddContainer(player.inventory.containerWear);
			AddContainer(player.inventory.containerMain);
			AddContainer(player.inventory.containerBelt);
			PositionChecks = true;
			entitySource = player;
			itemSource = null;
			MarkDirty();
			Interface.CallHook("IOnLootPlayer", this, player);
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be targeted for helicopter strafing.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <param name="target">The BasePlayer target.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanHelicopterStrafeTarget(PatrolHelicopterAI ai, BasePlayer target)
{
    Puts($"Checking if {target.UserIDString} can be targeted for helicopter strafing.");
    if (target.IsAdmin())
    {
        return true;
    }
    BuildingPrivlidge buildingPrivilege = target.GetBuildingPrivilege();
    if (buildingPrivilege != null && buildingPrivilege.AnyAuthed())
    {
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidStrafeTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ply.CanBuild())
		{
			return true;
		}
		BuildingPrivlidge buildingPrivilege = ply.GetBuildingPrivilege();
		if (buildingPrivilege == null || !buildingPrivilege.AnyAuthed())
		{
			return true;
		}
		return false;
	}

```

## OnItemDeployed(Deployer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is deployed onto a base entity.
/// </summary>
/// <param name="deployer">The deployable item that was used to deploy the entity.</param>
/// <param name="baseEntity">The base entity that the item was deployed onto.</param>
void OnItemDeployed(Deployable deployer, BaseEntity baseEntity)
{
    Puts($"Item {deployer.name} has been deployed onto {baseEntity.displayName}.");
    if (baseEntity is BaseBuilding building && building.GetSlot(deployer.slot) != null)
    {
        Puts($"Slot {deployer.slot} on {building.displayName} already occupied by another item.");
        return;
    }
    // Additional logic can be added here to handle the deployment of the item.
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || !ownerPlayer.CanBuild())
		{
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			TransformEx.Identity(baseEntity2.gameObject);
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OnDeployed(baseEntity);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity);
		UseItemAmount(1);
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that was locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.name} has been locked by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## CanUnlock(CodeLock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player tries to unlock the code lock.
/// </summary>
/// <param name="codeLock">The code lock being unlocked.</param>
/// <param name="player">The player attempting to unlock the code lock.</param>
/// <returns>
/// Returns `null` to allow the player to unlock the code lock, or any non-null value to prevent them from unlocking it.
/// </returns>
object CanUnlock(CodeLock codeLock, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to unlock the code lock.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is not allowed to unlock the code lock.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", this, rpc.player) == null)
		{
			if (whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectUnlocked.resourcePath);
				SetFlag(Flags.Locked, b: false);
				SendNetworkUpdate();
			}
			else
			{
				ClientRPCPlayer(null, rpc.player, "EnterUnlockCode");
			}
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="signage">The signage being updated (not used in this implementation).</param>
/// <returns>
/// Returns `true` if the player is allowed to update the sign, or `false` otherwise.
/// </returns>
bool CanUpdateSign(BasePlayer player, Signage signage)
{
    Puts($"Checking if {player.UserIDString} can update a sign");
    object obj = Interface.CallHook("CanUpdateSign", player, signage);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If no hook returns a boolean value, default to allowing admins and developers
    if (player.IsAdmin || player.IsDeveloper)
    {
        Puts($"Allowing {player.UserIDString} to update the sign due to admin privileges");
        return true;
    }
    // Check if the player has build permissions
    if (!player.CanBuild())
    {
        Puts($"Denying {player.UserIDString} permission to update the sign due to lack of build permissions");
        return false;
    }
    // If the sign is locked, only allow the owner to update it
    if (IsLocked())
    {
        Puts($"Allowing {player.UserIDString} to update the sign because they are the owner");
        return player.userID == base.OwnerID;
    }
    // Default to allowing updates
    Puts($"Allowing {player.UserIDString} to update the sign");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player's looting session ends.
/// </summary>
/// <param name="playerLoot">The PlayerLoot object associated with the ended looting session.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot playerLoot)
{
    Puts($"Player {playerLoot.Player.UserIDString} has finished looting.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		containers.Clear();
		entitySource = null;
		itemSource = null;
	}

```

## OnDeleteVendingOffer(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending offer is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the offer was deleted.</param>
/// <param name="player">The player who deleted the offer, if applicable.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending offer deleted on {vendingMachine.GetPositionString()} by {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				sellOrders.sellOrders.RemoveAt(num);
			}
			Interface.CallHook("OnDeleteVendingOffer", this, player);
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the mailbox, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Player {player.UserIDString} attempting to access mailbox {mailbox.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and will receive a special spawn reward.");
        // Add custom logic for admin spawn rewards
    }
    else
    {
        Puts($"Player {player.displayName} is not an admin and will receive the standard spawn items.");
        // Add custom logic for standard spawn items
    }
}
```
```

### Source Code from the Library

```csharp

	public void RespawnAt(UnityEngine.Vector3 position, Quaternion rotation)
	{
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.HasBuildingPrivilege, b: false);
		SetPlayerFlag(PlayerFlags.InBuildingPrivilege, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		ServerPerformance.spawns++;
		base.transform.position = position;
		base.transform.rotation = rotation;
		tickInterpolator.Reset(position);
		lastTickTime = 0f;
		StopWounded();
		StopSpectating();
		UpdateNetworkGroup();
		UpdatePlayerCollider(state: true);
		UpdatePlayerRigidbody(state: false);
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		InitializeHealth(StartHealth(), StartMaxHealth());
		inventory.GiveDefaultItems();
		SendNetworkUpdateImmediate();
		ClearEntityQueue();
		ClientRPCPlayer(null, this, "StartLoading");
		Networkable networkable = net;
		Interface.CallHook("OnPlayerRespawned", this);
		if (networkable != null)
		{
			EACServer.OnStartLoading(net.connection);
		}
		SendFullSnapshot();
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a healing item is used on a player.
/// </summary>
/// <param name="medicalTool">The medical tool being used.</param>
/// <param name="player">The player receiving the healing effect.</param>
/// <returns>
/// Returns `null` to allow the healing effect to be applied, or any non-null value to prevent the healing effect from being applied.
/// </returns>
object OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)
{
    Puts($"Medical tool {medicalTool.name} used on player {player.displayName}");
    if (player.IsWounded() && !player.HasBandage())
    {
        Puts($"Player {player.displayName} is wounded and has no bandages.");
        return "Cannot heal without a bandage.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			if (player != GetOwnerPlayer() && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("IOnPlayerRevive", this, player) != null)
				{
					return;
				}
				player.StopWounded();
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## OnItemRepair(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to repair an item.
/// </summary>
/// <param name="player">The player attempting to repair the item.</param>
/// <param name="item">The item being repaired.</param>
/// <returns>
/// Returns `null` if the repair is allowed, or a non-null value to override the default behavior and prevent the repair.
/// </returns>
object OnItemRepair(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is attempting to repair item {item.info.shortname}.");
    // Add custom logic here to determine if the repair should be allowed or not
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RepairItem(RPCMessage msg)
	{
		Item slot = inventory.GetSlot(0);
		if (slot == null)
		{
			return;
		}
		ItemDefinition info = slot.info;
		ItemBlueprint component = info.GetComponent<ItemBlueprint>();
		if (!component || !info.condition.repairable || slot.condition == slot.maxCondition)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (Interface.CallHook("OnItemRepair", player, slot) != null)
		{
			return;
		}
		float num = RepairCostFraction(slot);
		bool flag = false;
		List<ItemAmount> obj = GetRepairCostList(component);
		foreach (ItemAmount item in obj)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				int num2 = Mathf.CeilToInt(item.amount * num);
				if (num2 > amount)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Facepunch.Pool.Free(ref obj);
			return;
		}
		foreach (ItemAmount item2 in obj)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
			}
		}
		Facepunch.Pool.Free(ref obj);
		slot.DoRepair(maxConditionLostOnRepair);
		if (ConVar.Global.developer > 0)
		{
			Debug.Log("Item repaired! condition : " + slot.condition + "/" + slot.maxCondition);
		}
		Effect.server.Run("assets/bundled/prefabs/fx/repairbench/itemrepair.prefab", this, 0u, Vector3.zero, Vector3.zero);
	}

```

## IOnLootItem(PlayerLoot,Item)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an item.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void IOnLootItem(PlayerLooter looter, Item item)
{
    Puts($"Player {looter.UserIDString} started looting item: {item.displayName}");
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			MarkDirty();
			Interface.CallHook("IOnLootItem", this, item);
		}
	}

```

## OnRecycleItem(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled.
/// </summary>
/// <param name="recycler">The recycler that is recycling the item.</param>
/// <param name="item">The item being recycled.</param>
/// <returns>
/// Returns a non-null value to override the default recycling behavior. 
/// If `null` is returned, the item is recycled as normal.
/// </returns>
object OnRecycleItem(Recycler recycler, Item item)
{
    Puts($"Item {item.info.name} has been recycled by {recycler.GetType().Name}.");
    if (item.info.Blueprint == null || item.amount <= 0)
    {
        return null;
    }
    // Add custom recycling logic here
    // For example:
    if (item.info.Blueprint.scrapFromRecycle > 0 && UnityEngine.Random.Range(0f, 1f) < 0.5f)
    {
        Item scrapItem = ItemManager.CreateByName("scrap", item.amount * recycler.recycleEfficiency, 0uL);
        return scrapItem;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = recycleEfficiency;
		for (int i = 0; i < 6; i++)
		{
			Item slot = inventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			if (Interface.CallHook("OnRecycleItem", this, slot) != null)
			{
				if (!HasRecyclable())
				{
					StopRecycling();
				}
				return;
			}
			if (!(slot.info.Blueprint != null))
			{
				continue;
			}
			if (slot.hasCondition)
			{
				num = Mathf.Clamp01(num * slot.conditionNormalized * slot.maxConditionNormalized);
			}
			int num2 = 1;
			if (slot.amount > 1)
			{
				num2 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.info.stackable * 0.1f));
			}
			if (slot.info.Blueprint.scrapFromRecycle > 0)
			{
				Item newItem = ItemManager.CreateByName("scrap", slot.info.Blueprint.scrapFromRecycle * num2, 0uL);
				MoveItemToOutput(newItem);
			}
			slot.UseItem(num2);
			foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
			{
				float num3 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
				int num4 = 0;
				if (num3 <= 1f)
				{
					for (int j = 0; j < num2; j++)
					{
						if (UnityEngine.Random.Range(0f, 1f) <= num)
						{
							num4++;
						}
					}
				}
				else
				{
					num4 = Mathf.CeilToInt(Mathf.Clamp(num3 * num * UnityEngine.Random.Range(1f, 1f), 1f, ingredient.amount) * (float)num2);
				}
				if (num4 <= 0)
				{
					continue;
				}
				int num5 = Mathf.CeilToInt((float)num4 / (float)ingredient.itemDef.stackable);
				for (int k = 0; k < num5; k++)
				{
					int num6 = ((num4 <= ingredient.itemDef.stackable) ? num4 : ingredient.itemDef.stackable);
					Item newItem2 = ItemManager.Create(ingredient.itemDef, num6, 0uL);
					if (!MoveItemToOutput(newItem2))
					{
						flag = true;
					}
					num4 -= num6;
					if (num4 <= 0)
					{
						break;
					}
				}
			}
			break;
		}
		if (flag || !HasRecyclable())
		{
			StopRecycling();
		}
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger.
/// </summary>
/// <param name="trigger">The trigger that the entity left.</param>
/// <param name="entity">The entity that left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.ClassName} has left trigger {trigger.EntityId}");
}
```
```

### Source Code from the Library

```csharp

	internal virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null)
		{
			Interface.CallHook("OnEntityLeave", this, ent);
			entityContents.Remove(ent);
		}
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="lock">The lock on the entity, which could be a key or other type of lock.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, and `false` otherwise.
/// If `null` is returned, the default behavior will be used (i.e., the player cannot use the locked entity unless they have permission).
/// </returns>
bool CanUseLockedEntity(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} attempted to use locked entity with key {lock.KeyID}");
    if (lock.IsMasterKey())
    {
        return true;
    }
    // Check if the player has permission to use the locked entity
    if (HasPermission(player, Permission.UseLockedEntity))
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## OnTick(unknown)

```csharp
```csharp
/// <summary>
/// Called every tick.
/// </summary>
void OnTick()
{
    Puts("Server is ticking...");
    // Minimal code to demonstrate functionality
}
```

Note: Since the return type of `OnTick` is unknown, I've assumed it's a void method. If it returns something else, please provide more context or information about what `OnTick` should return.
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		if (Rust.Global.SteamServer != null)
		{
			Interface.CallHook("OnTick", null);
			Rust.Global.SteamServer.Update();
		}
		RCon.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container that the item was added to.</param>
/// <param name="item">The item that was added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been added to container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## OnTerrainInitialized(unknown)

```csharp
```csharp
/// <summary>
/// Called after the terrain has been initialized.
/// </summary>
void OnTerrainInitialized()
{
    Puts("Terrain initialization complete");
    
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		foreach (TerrainExtension terrainExtension in components)
		{
			terrainExtension.PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized", null);
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's sleeping state has ended.
/// </summary>
/// <param name="player">The player whose sleeping state has ended.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has woken up from sleep.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping())
		{
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepingPlayerList.Remove(this);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			UpdatePlayerCollider(state: true);
			UpdatePlayerRigidbody(state: true);
			Interface.CallHook("OnPlayerSleepEnded", this);
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable quantity of an item.
/// </summary>
/// <param name="item">The item being checked.</param>
/// <returns>
/// Returns the maximum stackable quantity, or any non-null value to override the default behavior. 
/// If `null` is returned, the default maximum stackable quantity will be used.
/// </returns>
object OnMaxStackable(Item item)
{
    Puts($"Checking max stackable for item {item.name}");
    if (item.category == "Rare")
    {
        Puts($"Item {item.name} has a custom max stackable of 10.");
        return 10;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## CanWearItem(PlayerInventory,Item)

```csharp
```csharp
/// <summary>
/// Called to check if an item can be worn.
/// </summary>
/// <param name="playerInventory">The player's inventory.</param>
/// <param name="item">The item to wear.</param>
/// <returns>
/// Returns `true` if the item can be worn, or any non-null value to override the default behavior. 
/// If a string is returned, the item cannot be worn and the provided message will be displayed as the reason.
/// </returns>
object CanWearItem(PlayerInventory playerInventory, Item item)
{
    Puts($"Checking if item {item.info.name} can be worn.");
    if (item.info.name == "Forbidden Item")
    {
        Puts($"Item {item.info.name} cannot be worn due to its forbidden nature.");
        return "Cannot wear: Forbidden item.";
    }
    // Additional checks or logic can go here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanWearItem(Item item)
	{
		ItemModWearable component = item.info.GetComponent<ItemModWearable>();
		if (component == null)
		{
			return false;
		}
		object obj = Interface.CallHook("CanWearItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Item[] array = containerWear.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModWearable component2 = item2.info.GetComponent<ItemModWearable>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 2f);
				}
			}
		}
		return true;
	}

```

## IOnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a new user connects to the server.
/// </summary>
/// <param name="connection">The connection object for the new user.</param>
/// <returns>
/// Returns `null` to allow the user to connect as normal. 
/// If a non-null value is returned, it will override the default approval behavior and kick the user with the provided message.
/// </returns>
object IOnUserApprove(Connection connection)
{
    Puts($"New connection from {connection.username} with SteamID {connection.userid}");
    if (connection.token == null || connection.token.Length < 32)
    {
        Reject(connection, "Invalid Token");
        return true;
    }
    if (connection.userid == 0)
    {
        Reject(connection, "Invalid SteamID");
        return true;
    }
    if (connection.protocol != 2013)
    {
        if (!DeveloperList.Contains(connection.userid))
        {
            Reject(connection, "Incompatible Version");
            return true;
        }
        Debug.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)");
    }
    if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
    {
        Reject(connection, "You are banned from this server");
        return true;
    }
    object result = Interface.CallHook("OnUserApprove", connection);
    if (result != null)
    {
        return result;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2013)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			Debug.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)");
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			Reject(connection, "You are banned from this server");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			Debug.Log(connection.ToString() + " has auth level 1");
			connection.authLevel = 1;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			Debug.Log(connection.ToString() + " has auth level 2");
			connection.authLevel = 2;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			Debug.Log(connection.ToString() + " is a developer");
			connection.authLevel = 1;
		}
		if (IsConnected(connection.userid))
		{
			Reject(connection, "You are already connected!");
		}
		else if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser bonus is assigned to a player.
/// </summary>
/// <param name="dispenser">The dispenser that triggered the bonus.</param>
/// <param name="player">The player who received the bonus.</param>
/// <param name="item">The item that was given as a bonus.</param>
/// <returns>
/// Returns `null` to allow the player to receive the bonus, or any non-null value to override the default behavior.
/// If an `Item` is returned, it will be used instead of the original item.
/// </returns>
object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} received a bonus from dispenser {dispenser.displayName}.");
    if (item.name == "Golden Coin")
    {
        Puts($"Player {player.UserIDString} was given a rare Golden Coin as a bonus!");
        return new Item(item.def, 2, 0uL);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction)
	{
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			Item item = ItemManager.Create(finishBonu.itemDef, Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction)), 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnRconConnection(System.Net.IPEndPoint)

```csharp
```csharp
/// <summary>
/// Called when an RCON connection is established.
/// </summary>
/// <param name="endpoint">The IP endpoint of the connecting client.</param>
/// <returns>
/// Returns a non-null value to override the default behavior and close the socket. 
/// If `null` is returned, the RCON connection will be processed as normal.
/// </returns>
object OnRconConnection(System.Net.IPEndPoint endpoint)
{
    Puts($"RCON connection from {endpoint} established.");
    if (endpoint.Address.ToString() == "192.168.1.1")
    {
        Puts($"Ignoring RCON connection from {endpoint} - banned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", iPEndPoint) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger.
/// </summary>
/// <param name="trigger">The trigger that was entered.</param>
/// <param name="entity">The entity that entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has entered trigger {trigger.name}");
}
```
```

### Source Code from the Library

```csharp

	internal virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			Interface.CallHook("OnEntityEnter", this, ent);
			entityContents.Add(ent);
		}
	}

```

## OnItemCraftCancelled(ItemCraftTask)

```csharp
```csharp
/// <summary>
/// Called when an item craft task is cancelled.
/// </summary>
/// <param name="task">The cancelled item craft task.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task)
{
    Puts($"Item craft task {task.taskUID} has been cancelled.");
    if (task.owner == null || !task.owner.IsConnected())
    {
        return;
    }
    task.owner.Command("note.craft_cancelled", task.taskUID, 0);
    // Additional logic can be added here to handle the cancellation of the item craft task.
}
```
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID, bool ReturnItems)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (itemCraftTask.owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask);
		itemCraftTask.owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0 && ReturnItems)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))
					{
						takenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition, itemCraftTask.owner.inventory.containerMain.dropVelocity);
						itemCraftTask.owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
		}
		return true;
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret is shutting down.
/// </summary>
/// <param name="turret">The AutoTurret instance being shut down.</param>
/// <returns>
/// Returns `null` to allow the turret to shut down normally, or any non-null value to prevent it from shutting down.
/// </returns>
object OnTurretShutdown(AutoTurret turret)
{
    Puts($"Turret {turret.GetReference().ToString()} is shutting down.");
    if (turret.GetReference() == "Turret 1")
    {
        Puts($"Turret {turret.GetReference()} has been overridden from shutting down.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if (!IsOffline() && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the recycler is toggled on or off.
/// </summary>
/// <param name="recycler">The recycler being toggled.</param>
/// <param name="player">The player who toggled the recycler.</param>
/// <returns>
/// Returns `null` to allow the recycler to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts($"Recycler {recycler.name} has been toggled by player {player.UserIDString}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot toggle the recycler.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag != IsOn() && (!flag || HasRecyclable()) && Interface.CallHook("OnRecyclerToggle", this, msg.player) == null)
		{
			if (flag)
			{
				StartRecycling();
			}
			else
			{
				StopRecycling();
			}
		}
	}

```

## OnPlayerChat(ConsoleSystem.Arg)

```csharp
Here is the method structure for `OnPlayerChat(ConsoleSystem.Arg)`:

```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="arg">The console argument containing the chat message.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. 
/// If a string is returned, the player will be kicked with the provided message as the reason. 
/// If `null` is returned, the chat message is processed normally.
/// </returns>
object OnPlayerChat(ConsoleSystem.Arg arg)
{
    // Minimal code to demonstrate functionality
    Puts("OnPlayerChat called!");
    
    // Rest of the method implementation...
}
```

Note that I've kept the return type as `object` since it's not explicitly specified in the original code. If you know the correct return type, please let me know and I'll update the method structure accordingly.
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!basePlayer || basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper)
		{
			if (basePlayer.NextChatTime == 0f)
			{
				basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup - 30f;
			}
			if (basePlayer.NextChatTime > UnityEngine.Time.realtimeSinceStartup)
			{
				basePlayer.NextChatTime += 2f;
				float num = basePlayer.NextChatTime - UnityEngine.Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(basePlayer.net.connection, "chat.add", 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					basePlayer.Kick("Chatting too fast");
				}
				return;
			}
		}
		string text = arg.GetString(0, "text").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0 || text.StartsWith("/") || text.StartsWith("\\") || (text.Contains("<") && (StringEx.Contains(text, "<size", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<color", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<material", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<quad", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<b>", CompareOptions.IgnoreCase) || StringEx.Contains(text, "<i>", CompareOptions.IgnoreCase))) || Interface.CallHook("OnPlayerChat", arg) != null)
		{
			return;
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured(ConsoleColor.DarkYellow, basePlayer.displayName + ": ", ConsoleColor.DarkGreen, text);
			Server.Log("Log.Chat.txt", $"{basePlayer.ToString()}: {text}\n");
			Debug.Log($"[CHAT] {basePlayer.ToString()} : {text}");
		}
		string text2 = "#5af";
		if (basePlayer.IsAdmin)
		{
			text2 = "#af5";
		}
		if (basePlayer.IsDeveloper)
		{
			text2 = "#fa5";
		}
		string displayName = basePlayer.displayName;
		displayName = displayName.Replace('<', '[').Replace('>', ']');
		basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup + 1.5f;
		ChatEntry chatEntry = default(ChatEntry);
		chatEntry.Message = text;
		chatEntry.UserId = basePlayer.userID;
		chatEntry.Username = basePlayer.displayName;
		chatEntry.Color = text2;
		chatEntry.Time = Epoch.Current;
		ChatEntry chatEntry2 = chatEntry;
		History.Add(chatEntry2);
		RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		if (Server.globalchat)
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add2", basePlayer.userID, text, displayName, text2, 1f);
			arg.ReplyWith(string.Empty);
			return;
		}
		float num2 = 2500f;
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			float sqrMagnitude = (activePlayer.transform.position - basePlayer.transform.position).sqrMagnitude;
			if (!(sqrMagnitude > num2))
			{
				ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", basePlayer.userID, text, displayName, text2, Mathf.Clamp01(num2 - sqrMagnitude + 0.2f));
			}
		}
		arg.ReplyWith(string.Empty);
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player ends spectating.
/// </summary>
/// <param name="player">The player ending spectation.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to end spectating normally. 
/// If any non-null value is returned, it will override the default behavior and prevent the player from ending spectation.
/// </returns>
object OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} ended spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to end spectation with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## IOnLootEntity(PlayerLoot,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an entity.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>No return behavior.</returns>
void IOnLootEntity(PlayerLoot looter, BaseEntity entity)
{
    Puts($"Player {looter.UserIDString} started looting entity {entity.EntityID}.");
    if (entity is TreasureChest)
    {
        Puts($"Player {looter.UserIDString} found a treasure chest!);
    }
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if ((bool)targetEntity && targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			Assert.IsTrue(targetEntity.isServer, "Assure is server");
			PositionChecks = doPositionChecks;
			entitySource = targetEntity;
			itemSource = null;
			MarkDirty();
			Interface.CallHook("IOnLootEntity", this, targetEntity);
		}
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed.
/// </summary>
/// <param name="trap">The bear trap being armed.</param>
/// <param name="player">The player who triggered the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to be armed, or any non-null value to prevent it from arming.
/// </returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Bear trap {trap.name} has been armed by player {player.displayName}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot arm the bear trap.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## OnItemSplit(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is being split into smaller quantities.
/// </summary>
/// <param name="item">The item being split.</param>
/// <param name="splitAmount">The amount to split the item by.</param>
/// <returns>
/// Returns a new `Item` object if the split should be overridden, or `null` if the original behavior should occur.
/// </returns>
object OnItemSplit(Item item, int splitAmount)
{
    Puts($"Item {item.info.itemid} is being split into {splitAmount} units.");
    if (splitAmount == 1)
    {
        Puts($"Item {item.info.itemid} cannot be split further.");
        return null;
    }
    // Custom logic to override the default splitting behavior
    Item newSplit = item.SplitInto(splitAmount);
    return newSplit;
}
```
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		MarkDirty();
		return item;
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when a condition is lost.
/// </summary>
/// <param name="item">The item losing the condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>
/// Returns `null` to allow the condition to be lost, or any non-null value to prevent the condition from being lost.
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Item {item.info.shortname} is losing {amount} condition.");
    if (amount > 0.5f)
    {
        Puts($"Item {item.info.shortname} has exceeded the maximum allowed condition loss of 0.5f.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && Interface.CallHook("IOnLoseCondition", this, amount) == null && !Debugging.disablecondition)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## IOnStructureImmediateDemolish(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is immediately demolished.
/// </summary>
/// <param name="structure">The structure being demolished.</param>
/// <param name="player">The player who initiated the demolition.</param>
/// <returns>
/// Returns `null` to allow the structure to be demolished, or any non-null value to prevent it from being demolished.
/// </returns>
object IOnStructureImmediateDemolish(BaseBuildingBlock structure, BasePlayer player)
{
    Puts($"Structure {structure.GetGlobalIndex()} has been immediately demolished by player {player.UserIDString}.");
    if (player.IsAdmin && structure.OwnerID == player.UserID)
    {
        Puts($"Player {player.UserIDString} is allowed to demolish their own structure.");
        return null;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void DoImmediateDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && msg.player.IsAdmin && Interface.CallHook("IOnStructureImmediateDemolish", this, msg.player) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to disarm a trap.
/// </summary>
/// <param name="landmine">The landmine being disarmed.</param>
/// <param name="player">The player attempting to disarm the landmine.</param>
/// <returns>
/// Returns `null` to allow the player to disarm the landmine, or any non-null value to prevent them from disarming it.
/// </returns>
object OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to disarm landmine at position {landmine.Position}");
    if (player.HasFlag(Flags.Admin))
    {
        Puts($"Player {player.displayName} is an admin and can't be prevented from disarming the landmine.");
        return null;
    }
    return "You don't have permission to disarm this landmine.";
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if (rpc.player.net.ID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			int num = UnityEngine.Random.Range(0, 100);
			if (num < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## CanNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC can attack a target.
/// </summary>
/// <param name="npc">The NPC attempting to attack.</param>
/// <param name="target">The entity the NPC is trying to attack.</param>
/// <returns>
/// Returns `null` to allow the NPC to attack, or any non-null value to prevent them from attacking.
/// </returns>
object CanNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} attempting to attack {target.displayName}");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"NPC {npc.name} cannot attack admin player {player.displayName}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if ((bool)AttackTarget && AttackReady() && Interface.CallHook("CanNpcAttack", this, AttackTarget) == null)
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(null, "Attack", AttackTarget.ServerPosition);
			}
		}
	}

```

## OnReloadWeapon(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player starts reloading their weapon.
/// </summary>
/// <param name="player">The player starting to reload.</param>
/// <param name="projectile">The projectile being reloaded, if applicable.</param>
/// <returns>
/// Returns `null` to allow the player to start reloading, or any non-null value to prevent them from reloading.
/// </returns>
object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} started reloading their weapon.");
    if (projectile != null && projectile.ammoType == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to reload restricted ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnReloadWeapon", player, this) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			StartReloadCooldown(reloadTime);
		}
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a vending transaction is performed.
/// </summary>
/// <param name="vendingMachine">The vending machine performing the transaction.</param>
/// <param name="buyer">The player buying from the vending machine.</param>
/// <param name="sellOrderId">The ID of the sell order being executed.</param>
/// <param name="numberOfTransactions">The number of transactions to perform (default is 1).</param>
/// <returns>
/// Returns a non-null value to override the default transaction behavior. 
/// If `true` is returned, the transaction will be allowed as normal.
/// If `false` is returned, the transaction will be blocked.
/// </returns>
object OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
{
    Puts($"Vending machine {vendingMachine.name} has been used by player {buyer.displayName} to purchase item with ID {sellOrderId}.");
    if (sellOrderId == 5)
    {
        Puts($"Transaction blocked: Item with ID {sellOrderId} is out of stock.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
	{
		if (sellOrderId < 0 || sellOrderId > sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (Vector3.Distance(buyer.GetEstimatedWorldPosition(), base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> list = inventory.FindItemsByItemID(sellOrder.itemToSellID);
		if (list == null || list.Count == 0)
		{
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = list.Sum((Item x) => x.amount);
		if (num > num2)
		{
			return false;
		}
		List<Item> list2 = buyer.inventory.FindItemIDs(sellOrder.currencyID);
		if (list2.Count == 0)
		{
			return false;
		}
		int num3 = list2.Sum((Item x) => x.amount);
		int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
		if (num3 < num4)
		{
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in list2)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			if (!item.MoveToContainer(inventory))
			{
				item.Drop(inventory.dropPosition, Vector3.zero);
			}
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		int num7 = 0;
		foreach (Item item4 in list)
		{
			Item item2 = ((item4.amount > num) ? item4.SplitItem(num) : item4);
			num7 += item2.amount;
			buyer.GiveItem(item2, GiveItemReason.PickedUp);
			if (num7 >= num)
			{
				break;
			}
		}
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## OnPlayerWound(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is wounded.
/// </summary>
/// <param name="player">The player who was wounded.</param>
/// <returns>
/// Returns `null` to allow the player to be wounded, or any non-null value to prevent them from being wounded.
/// </returns>
object OnPlayerWound(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been wounded.");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot be wounded.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartWounded()
	{
		if (!IsWounded() && Interface.CallHook("OnPlayerWound", this) == null)
		{
			stats.Add("wounded", 1);
			woundedDuration = UnityEngine.Random.Range(40f, 50f);
			woundedStartTime = UnityEngine.Time.realtimeSinceStartup;
			SetPlayerFlag(PlayerFlags.Wounded, b: true);
			SendNetworkUpdateImmediate();
			Invoke(WoundingTick, 1f);
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="lootableCorpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts($"Player {player.UserIDString} stopped looting {lootableCorpse.DisplayName}");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a turret targets an entity.
/// </summary>
/// <param name="turret">The AutoTurret that has targeted the entity.</param>
/// <param name="entity">The BaseCombatEntity that is being targeted by the turret.</param>
/// <returns>
/// Returns `null` to allow the turret to target the entity, or any non-null value to prevent the turret from targeting the entity.
/// </returns>
object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
{
    Puts($"Turret {turret.name} has targeted entity {entity.displayName}.");
    if (entity is Player player && player.IsSpectator())
    {
        Puts($"Player {player.displayName} is a spectator and cannot be targeted by the turret.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((!(targ == null)) ? targetAcquiredEffect.resourcePath : targetLostEffect.resourcePath, base.transform.position, Vector3.up);
			}
			target = targ;
		}
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when a resource is gathered from a quarry.
/// </summary>
/// <param name="quarry">The mining quarry that gathered the resource.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>No return behavior.</returns>
void OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts($"Resource {item.GetDisplayName()} gathered from quarry {quarry.GetName()}.");
    if (item.GetStackSize() > 10)
    {
        Puts($"Warning: Large quantity of resources ({item.GetStackSize()}) gathered from quarry {quarry.GetName()}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			resource.workDone += workToAdd;
			if (!(resource.workDone < resource.workNeeded))
			{
				int num = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
				resource.workDone -= (float)num * resource.workNeeded;
				Item item = ItemManager.Create(resource.type, num, 0uL);
				Interface.CallHook("OnQuarryGather", this, item);
				if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a BasePlayer is attacked.
/// </summary>
/// <param name="attacker">The player who initiated the attack.</param>
/// <param name="info">Information about the attack, including the hit bone and damage type.</param>
void IOnBasePlayerAttacked(BasePlayer attacker, HitInfo info)
{
    Puts($"Player {base.playerId} was attacked by {attacker.playerId}");
    
    // Check if any wearable items on the player's inventory protect the hit area
    float health_old = base.health;
    if (base.isServer && info.boneArea != (HitArea)(-1))
    {
        List<Item> obj = Facepunch.Pool.GetList<Item>();
        obj.AddRange(inventory.containerWear.itemList);
        for (int i = 0; i < obj.Count; i++)
        {
            Item item = obj[i];
            if (item != null)
            {
                ItemModWearable component = item.info.GetComponent<ItemModWearable>();
                if (!(component == null) && component.ProtectsArea(info.boneArea))
                {
                    item.OnAttacked(info);
                }
            }
        }
        Facepunch.Pool.FreeList(ref obj);
    }

    // Check if the player is wounded or dead
    if (base.isServer && base.health <= 0)
    {
        CheckDeathCondition(info);
    }

    // Broadcast signals for flinching and headshots
    string text = StringPool.Get(info.HitBone);
    UnityEngine.Vector3 normalized = (info.PointEnd - info.PointStart).normalized;
    bool flag = UnityEngine.Vector3.Dot(normalized, eyes.BodyForward()) > 0.4f;
    if (info.isHeadshot)
    {
        if (flag)
        {
            SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
        }
        else
        {
            SignalBroadcast(Signal.Flinch_Head, string.Empty);
        }
    }
    else if (flag)
    {
        SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
    }
    else if (text == "spine" || text == "spine2")
    {
        SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
    }
    else
    {
        SignalBroadcast(Signal.Flinch_Chest, string.Empty);
    }

    // Log combat stats
    if (stats != null)
    {
        if (IsWounded())
        {
            stats.combat.Log(info, health_old, base.health, "wounded");
        }
        else if (IsDead())
        {
            stats.combat.Log(info, health_old, base.health, "killed");
        }
        else
        {
            stats.combat.Log(info, health_old, base.health);
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float health_old = base.health;
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.GetList<Item>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortal())
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				Effect effect = new Effect();
				effect.Init(Effect.Type.Generic, base.transform.position, base.transform.forward);
				effect.pooledString = "assets/bundled/prefabs/fx/takedamage_hit.prefab";
				EffectNetwork.Send(effect, net.connection);
			}
			string text = StringPool.Get(info.HitBone);
			UnityEngine.Vector3 normalized = (info.PointEnd - info.PointStart).normalized;
			bool flag = UnityEngine.Vector3.Dot(normalized, eyes.BodyForward()) > 0.4f;
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (!(initiatorPlayer != null)) ? null : initiatorPlayer.net.connection);
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1);
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.Log(info, health_old, base.health, "wounded");
			}
			else if (IsDead())
			{
				stats.combat.Log(info, health_old, base.health, "killed");
			}
			else
			{
				stats.combat.Log(info, health_old, base.health);
			}
		}
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is rotated.
/// </summary>
/// <param name="block">The building block being rotated.</param>
/// <param name="player">The player performing the rotation.</param>
/// <returns>
/// Returns `null` to allow the structure to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnStructureRotate(BuildingBlock block, BasePlayer player)
{
    Puts($"Structure {block.name} has been rotated by player {player.UserIDString}");
    if (block.name == "Forbidden Structure")
    {
        Puts($"Player {player.displayName} is not allowed to rotate the structure {block.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotate && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			if ((bool)currentSkin)
			{
				currentSkin.Refresh(this);
			}
			SendNetworkUpdateImmediate();
			ClientRPC(null, "RefreshSkin");
		}
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <param name="target">The object that entered the trap's trigger area.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(BearTrap trap, GameObject target)
{
    Puts($"Trap triggered by {target.name} at position: {target.transform.position}");
    if (target.CompareTag("Player"))
    {
        Puts($"Player detected in trap area. Preventing trap trigger.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is finished.
/// </summary>
/// <param name="task">The ItemCraftTask that was completed.</param>
/// <param name="item">The crafted item.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If null, the item will be added to the player's inventory as normal.
/// </returns>
object OnItemCraftFinished(ItemCraftTask task, Item item)
{
    Puts($"Item crafting task {task.taskUID} has been completed.");
    if (item.info.itemid == 12345)
    {
        Puts($"Item with ID {item.info.itemid} has been flagged for special handling.");
        return "Special handling required.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong num = 0uL;
		Facepunch.Steamworks.Inventory.Definition definition = Rust.Global.SteamServer.Inventory.FindDefinition(task.skinID);
		if (definition != null)
		{
			num = definition.GetProperty<ulong>("workshopdownload");
		}
		if (num == 0)
		{
			num = (ulong)task.skinID;
		}
		Item item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, num);
		item.amount = task.blueprint.amountToCreate;
		if (item.hasCondition && task.conditionScale != 1f)
		{
			item.maxCondition *= task.conditionScale;
			item.condition = item.maxCondition;
		}
		item.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num2 = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int amount = takenItem.amount;
					int num3 = Mathf.Min(amount, num2);
					takenItem.UseItem(num2);
					num2 -= num3;
				}
				if (num2 > 0)
				{
				}
			}
		}
		Facepunch.Rust.Analytics.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		task.owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item);
		item.instanceData = task.instanceData;
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			task.owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		if (task.owner.inventory.GiveItem(item))
		{
			task.owner.Command("note.inv", item.info.itemid, item.amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		task.owner.Command("note.inv", item.info.itemid, item.amount);
		task.owner.Command("note.inv", item.info.itemid, -item.amount);
		item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="landmine">The landmine that was triggered.</param>
/// <param name="victim">The player who triggered the landmine.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(Landmine landmine, BasePlayer victim)
{
    Puts($"Landmine {landmine.name} triggered by player {victim.displayName}");
    if (victim.isSuperAdmin)
    {
        Puts($"Player {victim.displayName} is a super admin and cannot trigger the landmine.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## OnLiftUse(Lift,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player uses a lift.
/// </summary>
/// <param name="lift">The lift being used.</param>
/// <param name="player">The player using the lift.</param>
/// <returns>
/// Returns `null` to allow the player to use the lift, or any non-null value to prevent them from using it.
/// </returns>
object OnLiftUse(Lift lift, BasePlayer player)
{
    Puts($"Player {player.UserIDString} used the lift at position: {lift.transform.position}");
    if (lift.isBroken)
    {
        Puts($"The lift at position: {lift.transform.position} is currently broken.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_UseLift(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && Interface.CallHook("OnLiftUse", this, rpc.player) == null)
		{
			MoveUp();
		}
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a craft can be performed.
/// </summary>
/// <param name="itemCrafter">The item crafter attempting the craft.</param>
/// <param name="bp">The blueprint for the item being crafted.</param>
/// <param name="amount">The amount of items being crafted.</param>
/// <returns>
/// Returns `true` if the craft can be performed, or any non-null value to prevent the craft from happening.
/// If a string is returned, it will be used as an error message for the player attempting the craft.
/// </returns>
object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
{
    Puts($"Attempting to craft {bp.name} x{amount}");
    if (bp.ingredients.Any(ingredient => ingredient.amount > 9000))
    {
        Puts($"Cannot craft {bp.name} due to excessive material requirements");
        return "Insufficient materials";
    }
    object result = Interface.CallHook("CanCraft", itemCrafter, bp, amount);
    if (result is string)
    {
        Puts($"Crafting of {bp.name} prevented: {result}");
        return result;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1)
	{
		if (amount < 1 || amount > 9000)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## OnItemResearch(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts researching an item.
/// </summary>
/// <param name="item">The item being researched.</param>
/// <param name="player">The player performing the research.</param>
/// <returns>
/// Returns `null` to allow the research to proceed, or any non-null value to cancel the research.
/// </returns>
object OnItemResearch(Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} started researching item: {item.info.name}");
    if (item.info.category == "Forbidden")
    {
        Puts($"Player {player.displayName} is not allowed to research forbidden items.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("OnItemResearch", targetItem, player) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearchStart", this);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## IOnDisableServerConsole(unknown)

```csharp
```csharp
/// <summary>
/// Called when the server console is disabled.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnDisableServerConsole()
{
    Puts("Server console has been disabled.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	private void OnDisable()
	{
		if (Interface.CallHook("IOnDisableServerConsole", null) == null)
		{
			Output.OnMessage -= HandleLog;
			input.OnInputText -= OnInputText;
			console.Shutdown();
		}
	}

```

## CanHideStash(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hide their stash.
/// </summary>
/// <param name="player">The player attempting to hide their stash.</param>
/// <returns>
/// Returns `null` to allow the player to hide their stash, or any non-null value to prevent them from hiding it.
/// </returns>
object CanHideStash(BasePlayer player)
{
    Puts($"Player {player.UserIDString} is trying to hide their stash.");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can hide their stash.");
        return null;
    }
    return "You don't have permission to hide your stash.";
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", this, rpc.player) == null)
		{
			SetHidden(isHidden: true);
		}
	}

```

## OnRunPlayerMetabolism(PlayerMetabolism,BaseCombatEntity,float)

```csharp
Here is the method structure for `OnRunPlayerMetabolism`:

/// <summary>
/// This method handles player metabolism, updating various health-related values.
/// </summary>
/// <param name="playerMetabolism">The player's metabolism data.</param>
/// <param name="ownerEntity">The entity owning the player's metabolism.</param>
/// <param name="delta">A time delta value.</param>
/// <returns>None</returns>

void OnRunPlayerMetabolism(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)
{
    // Minimal code to demonstrate functionality
    Puts("OnRunPlayerMetabolism called");

    // Rest of the method implementation...
}
```

### Source Code from the Library

```csharp

	protected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
	{
		if (Interface.CallHook("OnRunPlayerMetabolism", this, ownerEntity, delta) != null)
		{
			return;
		}
		float currentTemperature = owner.currentTemperature;
		float fTarget = owner.currentComfort;
		float num = currentTemperature;
		num -= DeltaWet() * 34f;
		float num2 = Mathf.Clamp(owner.baseProtection.amounts[18] * 1.5f, -1f, 1f);
		float num3 = num2;
		float num4 = Mathf.InverseLerp(20f, -50f, currentTemperature);
		float num5 = Mathf.InverseLerp(20f, 30f, currentTemperature);
		num += num4 * 70f * num3;
		num += num5 * 10f * Mathf.Abs(num3);
		num += heartrate.value * 5f;
		temperature.MoveTowards(num, delta * 5f);
		if (temperature.value >= 40f)
		{
			fTarget = 0f;
		}
		comfort.MoveTowards(fTarget, delta / 5f);
		float num6 = 0.6f + 0.4f * comfort.value;
		if (calories.value > 100f && owner.healthFraction < num6 && radiation_poison.Fraction() < 0.25f && owner.SecondsSinceAttacked > 10f && !SignificantBleeding() && temperature.value >= 10f && hydration.value > 40f)
		{
			float num7 = Mathf.InverseLerp(calories.min, calories.max, calories.value);
			float num8 = 5f;
			float num9 = num8 * owner.MaxHealth() * 0.8f / 600f;
			num9 += num9 * num7 * 0.5f;
			float num10 = num9 / num8;
			num10 += num10 * comfort.value * 6f;
			ownerEntity.Heal(num10 * delta);
			calories.Subtract(num9 * delta);
			hydration.Subtract(num9 * delta * 0.2f);
		}
		float num11 = owner.estimatedSpeed2D / owner.GetMaxSpeed() * 0.75f;
		float fTarget2 = Mathf.Clamp(0.05f + num11, 0f, 1f);
		heartrate.MoveTowards(fTarget2, delta * 0.1f);
		float num12 = heartrate.Fraction() * 0.375f;
		calories.MoveTowards(0f, delta * num12);
		float num13 = 1f / 120f;
		num13 += Mathf.InverseLerp(40f, 60f, temperature.value) * (1f / 12f);
		num13 += heartrate.value * (1f / 15f);
		hydration.MoveTowards(0f, delta * num13);
		bool b = hydration.Fraction() <= 0f || radiation_poison.value >= 100f;
		owner.SetPlayerFlag(BasePlayer.PlayerFlags.NoSprint, b);
		if (temperature.value > 40f)
		{
			hydration.Add(Mathf.InverseLerp(40f, 200f, temperature.value) * delta * -1f);
		}
		if (temperature.value < 10f)
		{
			float num14 = Mathf.InverseLerp(20f, -100f, temperature.value);
			heartrate.MoveTowards(Mathf.Lerp(0.2f, 1f, num14), delta * 2f * num14);
		}
		float num15 = owner.WaterFactor();
		if (num15 > 0.85f)
		{
			oxygen.MoveTowards(0f, delta * 0.1f);
		}
		else
		{
			oxygen.MoveTowards(1f, delta * 1f);
		}
		float f = 0f;
		float f2 = 0f;
		if (owner.IsOutside(owner.eyes.position))
		{
			f = Climate.GetRain(owner.eyes.position) * 0.6f;
			f2 = Climate.GetSnow(owner.eyes.position) * 0.2f;
		}
		wetness.value = Mathf.Max(wetness.value, num15);
		wetness.MoveTowards(Mathx.Max(wetness.value, f, f2), delta * 0.05f);
		if (num15 < wetness.value)
		{
			wetness.MoveTowards(0f, delta * 0.2f * Mathf.InverseLerp(0f, 100f, currentTemperature));
		}
		poison.MoveTowards(0f, delta * (5f / 9f));
		if (wetness.Fraction() > 0.4f && owner.estimatedSpeed > 0.25f && radiation_level.Fraction() == 0f)
		{
			radiation_poison.Subtract(radiation_poison.value * 0.2f * wetness.Fraction() * delta * 0.2f);
		}
		if (ConVar.Server.radiation)
		{
			radiation_level.value = owner.radiationLevel;
			if (radiation_level.value > 0f)
			{
				radiation_poison.Add(radiation_level.value * delta);
			}
		}
		if (pending_health.value > 0f)
		{
			float num16 = Mathf.Min(2f * delta, pending_health.value);
			ownerEntity.Heal(num16);
			if (ownerEntity.healthFraction == 1f)
			{
				pending_health.value = 0f;
			}
			else
			{
				pending_health.Subtract(num16);
			}
		}
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is hunting.
/// </summary>
/// <param name="bradleyApc">The Bradley APC instance.</param>
/// <returns>
/// Returns a non-null value to override the default hunting behavior. 
/// If `null` is returned, the Bradley APC will continue with its normal hunting routine.
/// </returns>
object OnBradleyApcHunt(BradleyAPC bradleyApc)
{
    Puts($"The Bradley APC {bradleyApc.GetId()} has started hunting.");
    if (bradleyApc.GetCurrentTarget().GetDistance() > 100f)
    {
        Puts($"The Bradley APC {bradleyApc.GetId()} is too far away from its target to engage.");
        return "Too Far Away";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			BasePathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			BasePathNode basePathNode = null;
			List<BasePathNode> nearNodes = Facepunch.Pool.GetList<BasePathNode>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<BasePathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (BasePathNode item2 in nearNodes)
			{
				Stack<BasePathNode> path = new Stack<BasePathNode>();
				if (targetInfo.entity.IsVisible(item2.transform.position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					basePathNode = item2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].transform.position);
					}
				}
				foreach (BasePathNode item3 in stack)
				{
					currentPath.Add(item3.transform.position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = basePathNode.transform.position;
			}
			Facepunch.Pool.FreeList(ref nearNodes);
			Facepunch.Pool.FreeList(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the target player can be looted, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is trying to loot player {target.UserIDString}");
    if (looter == target)
    {
        return false;
    }
    object result = Interface.CallHook("CanLootPlayer", looter, target);
    if (result is bool)
    {
        return result;
    }
    // If a non-bool value is returned, it will override the default behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		return IsWounded() || IsSleeping();
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a Bradley APC can target the given entity.
/// </summary>
/// <param name="bradley">The Bradley APC.</param>
/// <param name="entity">The entity to check.</param>
/// <returns>
/// Returns `true` if the Bradley APC can target the entity, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBradleyApcTarget(BradleyAPC bradley, BaseEntity entity)
{
    Puts($"Checking if Bradley APC {bradley.GetDisplayName()} can target {entity.GetDisplayName()}");
    if (entity == null || !entity.IsValid())
    {
        return true;
    }
    object result = Interface.CallHook("CanBradleyApcTarget", bradley, entity);
    if (result is bool)
    {
        return result;
    }
    // If the entity is a player, check their visibility
    if (entity is BasePlayer)
    {
        BasePlayer player = entity as BasePlayer;
        Vector3 position = bradley.MainTurretPosition();
        return player.IsVisible(position, CenterPoint()) || player.IsVisible(position, player.EyesPosition) || player.IsVisible(position, player.Position);
    }
    // Otherwise, use the standard visibility test
    return IsVisible(entity.CenterPoint());
}
```
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.GetEstimatedWorldPosition(), base.transform.position) < viewDistance))
		{
			return false;
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			return basePlayer.IsVisible(position, CenterPoint()) || basePlayer.IsVisible(position, basePlayer.eyes.position) || basePlayer.IsVisible(position, basePlayer.transform.position);
		}
		Debug.LogWarning("Standard vis test!");
		return IsVisible(ent.CenterPoint());
	}

```

## OnMapImageUpdated(unknown)

```csharp
```csharp
/// <summary>
/// Called when a map image is updated.
/// </summary>
void OnMapImageUpdated()
{
    Puts("Map image has been updated.");
    // No return value, as this method does not need to return any specific data.
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void ImageUpdate(RPCMessage msg)
	{
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated", null);
		}
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
```csharp
/// <summary>
/// Called to determine if two dropped items can be combined.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>
/// Returns `null` to allow the combination, or any non-null value to prevent it.
/// </returns>
object CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts($"Checking if items {item1.item.info.name} and {item2.item.info.name} can be combined.");
    if (item1.item.info.stackable == 1 || item2.item.info.stackable == 1)
    {
        Puts($"Combination prevented: One of the items is not stackable.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item != null && di.item != null && Interface.CallHook("CanCombineDroppedItem", this, di) == null && item.info.stackable > 1 && !(di.item.info != item.info) && (!di.item.IsBlueprint() || di.item.blueprintTarget == item.blueprintTarget))
		{
			int num = di.item.amount + item.amount;
			if (num <= item.info.stackable && num != 0)
			{
				di.DestroyItem();
				di.Kill();
				item.amount = num;
				item.MarkDirty();
				Invoke(IdleDestroy, GetDespawnDuration());
				Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnOpenVendingShop(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player opens a vending shop.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player opening the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingShop(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has opened a vending shop with ID {vendingMachine.id}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		SendSellOrders(msg.player);
		PlayerOpenLoot(msg.player, customerPanel);
		Interface.CallHook("OnOpenVendingShop", this, msg.player);
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The console argument.</param>
/// <returns>
/// Returns `true` to allow the command to execute, or `false` to prevent it from executing.
/// If a non-null value other than `bool` is returned, it will be used as the reason for preventing the command from executing.
/// </returns>
object IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Executing server command: {arg.cmd.FullName}");
    if (arg.Invalid)
    {
        return "Invalid argument";
    }
    // You can add custom logic here to prevent or modify the command execution
    return null;
}
```
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null)
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## IOnRunCommandLine(unknown)

```csharp
```csharp
/// <summary>
/// Called when the command line is run.
/// </summary>
/// <param name="args">The arguments passed to the command line.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the command line will be processed as normal.
/// </returns>
object IOnRunCommandLine(string[] args)
{
    Puts($"Command line run with arguments: {string.Join(", ", args)}");
    if (args.Contains("--debug"))
    {
        Puts("Debug mode enabled.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine", null) != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The IPlayer instance of the kicked user.</param>
/// <param name="reason">The reason for kicking the user.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(IPlayer player, string reason)
{
    Puts($"User {player.Name} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer player, string reason)
	{
		if (player.IPlayer != null)
		{
			Interface.Oxide.CallHook("OnUserKicked", player.IPlayer, reason);
		}
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned player.</param>
/// <param name="steamId">The Steam ID of the unbanned player.</param>
/// <param name="ipAddress">The IP address of the unbanned player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.Oxide.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.Oxide.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

```

## OnUserBanned(string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is banned.
/// </summary>
/// <param name="name">The username of the banned user.</param>
/// <param name="steamId">The Steam ID of the banned user.</param>
/// <param name="ipAddress">The IP address of the banned user.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string name, string steamId, string ipAddress, string reason)
{
    Puts($"User {name} with SteamID {steamId} and IP {ipAddress} has been banned: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.Oxide.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.Oxide.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

```

## OnPlayerBanned(string,ulong,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="name">The name of the banned player.</param>
/// <param name="steamId">The Steam ID of the banned player.</param>
/// <param name="ipAddress">The IP address of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string name, ulong steamId, string ipAddress, string reason)
{
    Puts($"Player {name} with SteamID {steamId} and IP {ipAddress} has been banned: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.Oxide.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.Oxide.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.Oxide.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.Oxide.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

```

