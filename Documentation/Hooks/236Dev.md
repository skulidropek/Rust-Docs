# Hook Definitions

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating another player or entity.
/// </summary>
/// <param name="player">The player who is starting to spectate.</param>
/// <param name="filter">The filter used to determine what the player is spectating.</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.displayName} is attempting to spectate with filter: {filter}.");
    
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to spectate with filter: {filter}.");
        return "You cannot spectate this target.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnFuelConsumed(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The fuel item being consumed.</param>
/// <param name="burnable">The burnable item associated with the fuel consumption.</param>
/// <returns>No return behavior.</returns>
void OnFuelConsumed(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel consumed in oven: {oven.net.ID}, Fuel Item: {fuel.info.displayName.english}, Amount: {fuel.amount}");

    if (fuel.info.shortname == "wood")
    {
        Puts("Wood fuel is being consumed.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= 1)
		{
			fuel.Remove();
			return;
		}
		fuel.amount--;
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## OnNpcConversationStart(NPCTalking,BasePlayer,ConversationData)

```csharp
```csharp
/// <summary>
/// Called when a player starts a conversation with an NPC.
/// </summary>
/// <param name="npc">The NPC that the player is conversing with.</param>
/// <param name="player">The player who is starting the conversation.</param>
/// <param name="conversationData">The data related to the conversation being initiated.</param>
/// <returns>
/// Returns `null` to allow the conversation to proceed, or any non-null value to prevent the conversation from starting.
/// </returns>
object OnNpcConversationStart(NPCTalking npc, BasePlayer player, ConversationData conversationData)
{
    Puts($"Player {player.displayName} has started a conversation with NPC: {npc.name}.");

    if (player.HasItem("forbidden_item"))
    {
        Puts($"Player {player.displayName} is not allowed to converse with NPC: {npc.name} due to forbidden items.");
        return "You cannot talk to this NPC while carrying forbidden items.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void Server_BeginTalking(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		CleanupConversingPlayers();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor != null)
		{
			if (conversingPlayers.Contains(player))
			{
				OnConversationEnded(player);
			}
			if (Interface.CallHook("OnNpcConversationStart", this, player, conversationFor) == null)
			{
				conversingPlayers.Add(player);
				UpdateFlags();
				ClientRPCPlayer(null, player, "Client_StartConversation", GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech());
			}
		}
	}

```

## OnCrateHack(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate starts being hacked.
/// </summary>
/// <param name="crate">The hackable locked crate that is being hacked.</param>
/// <returns>No return behavior.</returns>
void OnCrateHack(HackableLockedCrate crate)
{
    Puts($"Hacking started on crate ID: {crate.net.ID} by player {crate.OwnerID}.");
}
```
```

### Source Code from the Library

```csharp

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", this);
		BroadcastEntityMessage("HackingStarted", 20f, 256);
		SetFlag(Flags.Reserved1, b: true);
		InvokeRepeating(HackProgress, 1f, 1f);
		ClientRPC(null, "UpdateHackProgress", 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

```

## CanAffordToPlace(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Determines if a player can afford to place a construction using a planner.
/// </summary>
/// <param name="player">The player attempting to place the construction.</param>
/// <param name="planner">The planner being used for the construction.</param>
/// <param name="construction">The construction being placed.</param>
/// <returns>
/// Returns `true` if the player can afford to place the construction, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can afford the placement.
/// </returns>
bool? CanAffordToPlace(BasePlayer player, Planner planner, Construction construction)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to place a {construction.fullName} using a planner.");

    if (construction.fullName == "foundation.stone")
    {
        Puts($"Player {player.displayName} is not allowed to place a stone foundation.");
        return false;
    }

    object obj = Interface.CallHook("CanAffordToPlace", player, planner, construction);
    if (obj is bool)
    {
        return (bool)obj;
    }

    foreach (ItemAmount item in construction.defaultGrade.costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemDef.itemid) < item.amount)
        {
            return false;
        }
    }

    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordToPlace(Construction component)
	{
		if (isTypeDeployable)
		{
			return true;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return false;
		}
		object obj = Interface.CallHook("CanAffordToPlace", ownerPlayer, this, component);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount item in component.defaultGrade.costToBuild)
		{
			if ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnItemUnlock(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is unlocked.
/// </summary>
/// <param name="item">The item that has been unlocked.</param>
/// <returns>No return behavior.</returns>
void OnItemUnlock(Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) has been unlocked.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## CanUseHelicopter(BasePlayer,CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a helicopter.
/// </summary>
/// <param name="player">The player attempting to use the helicopter.</param>
/// <param name="helicopter">The helicopter that the player is trying to use.</param>
/// <returns>
/// Returns `null` to allow the player to use the helicopter, or any non-null value to prevent usage.
/// </returns>
object CanUseHelicopter(BasePlayer player, CH47HelicopterAIController helicopter)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use the helicopter.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot use the helicopter while dead.");
        return "You cannot use the helicopter while dead.";
    }

    if (player.inventory.armorAmount < 10)
    {
        Puts($"Player {player.displayName} does not have enough armor to use the helicopter.");
        return "You need more armor to use the helicopter.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", player, this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

```

## OnNpcTarget(HumanNPC,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC identifies a player as a target.
/// </summary>
/// <param name="npc">The NPC that is targeting the player.</param>
/// <param name="player">The player being targeted by the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the player, or any non-null value to prevent the targeting.
/// </returns>
object OnNpcTarget(HumanNPC npc, BasePlayer player)
{
    Puts($"NPC {npc.name} is attempting to target player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInSafeZone())
    {
        Puts($"Targeting prevented: Player {player.displayName} is in a safe zone.");
        return true; // Prevent targeting
    }

    return null; // Allow targeting
}
```
```

### Source Code from the Library

```csharp

	public void UpdateTargets(float delta)
	{
		UpdateMemory();
		int num = -1;
		float num2 = -1f;
		Vector3 position = base.transform.position;
		for (int i = 0; i < myMemory.All.Count; i++)
		{
			SimpleAIMemory.SeenInfo seenInfo = myMemory.All[i];
			if (seenInfo.Entity == null)
			{
				continue;
			}
			float num3 = 0f;
			float value = Vector3.Distance(seenInfo.Entity.transform.position, position);
			if (!seenInfo.Entity.IsNpc && !(seenInfo.Entity.Health() <= 0f))
			{
				num3 += 1f - Mathf.InverseLerp(10f, sightRange, value);
				float value2 = Vector3.Dot((seenInfo.Entity.transform.position - eyes.position).normalized, eyes.BodyForward());
				num3 += Mathf.InverseLerp(visionCone, 1f, value2);
				float value3 = seenInfo.Timestamp - UnityEngine.Time.realtimeSinceStartup;
				num3 += 1f - Mathf.InverseLerp(0f, 3f, value3);
				if (num3 > num2)
				{
					num = i;
					num2 = num3;
				}
			}
		}
		if (num != -1)
		{
			SimpleAIMemory.SeenInfo seenInfo2 = myMemory.All[num];
			if (seenInfo2.Entity != null && seenInfo2.Entity is BasePlayer)
			{
				BasePlayer component = seenInfo2.Entity.GetComponent<BasePlayer>();
				if (Interface.CallHook("OnNpcTarget", this, component) == null)
				{
					currentTarget = component;
					currentTargetLOS = IsVisibleToUs(component);
				}
			}
		}
		else
		{
			currentTarget = null;
			currentTargetLOS = false;
		}
	}

```

## OnDemoRecordingStopped(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when demo recording is stopped for a player.
/// </summary>
/// <param name="filename">The filename of the recorded demo.</param>
/// <param name="player">The player whose demo recording has stopped.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStopped(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped for player {player.displayName} (ID: {player.UserIDString}). Filename: {filename}");
}
```
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a code is entered into a code lock.
/// </summary>
/// <param name="codeLock">The code lock being accessed.</param>
/// <param name="player">The player who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>
/// Returns a non-null value to prevent the default unlock behavior. 
/// If `null` is returned, the code will be processed normally.
/// </returns>
object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
{
    Puts($"Player {player.displayName} entered code: {code} on CodeLock ID: {codeLock.net.ID}");

    if (code == "1234")
    {
        Puts("Access granted with the default code.");
        return null; // Allow the default behavior
    }

    Puts("Access denied: Invalid code.");
    return "Invalid code entered."; // Prevent default behavior
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 10f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
			}
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
		}
	}

```

## OnSignalBroadcast(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a signal is broadcasted from a server entity.
/// </summary>
/// <param name="entity">The entity that is broadcasting the signal.</param>
/// <returns>Returns `null` to allow the signal broadcast, or any non-null value to prevent it.</returns>
object OnSignalBroadcast(BaseEntity entity)
{
    Puts($"Signal broadcast initiated from entity: {entity.net.ID} ({entity.ShortPrefabName})");
    
    // Example condition to block the signal broadcast
    if (entity.IsDestroyed)
    {
        Puts($"Broadcast from destroyed entity {entity.net.ID} is blocked.");
        return true; // Prevent the broadcast
    }
    
    return null; // Allow the broadcast
}
```
```

### Source Code from the Library

```csharp

	public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", this) == null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers)
			{
				method = SendMethod.Unreliable,
				priority = Priority.Immediate
			}, sourceConnection, "SignalFromServerEx", (int)signal, arg);
		}
	}

```

## CanUnlock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a key lock.
/// </summary>
/// <param name="player">The player attempting to unlock the key lock.</param>
/// <param name="keyLock">The key lock that is being unlocked.</param>
/// <returns>
/// Returns `null` to allow the unlocking, or any non-null value to prevent the unlocking action.
/// </returns>
object CanUnlock(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to unlock a key lock.");

    if (player.inventory.GetAmount("key") < 1)
    {
        Puts($"Player {player.displayName} does not have a key to unlock the lock.");
        return "You need a key to unlock this.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnEntityDestroy(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the CH47 helicopter AI controller is destroyed.
/// </summary>
/// <param name="helicopter">The helicopter AI controller that is being destroyed.</param>
/// <returns>No return behavior.</returns>
void OnEntityDestroy(CH47HelicopterAIController helicopter)
{
    Puts($"CH47 Helicopter (ID: {helicopter.net.ID}) has been destroyed.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

```

## OnExperimentEnded(Workbench)

```csharp
```csharp
/// <summary>
/// Called when an experiment at the workbench has completed.
/// </summary>
/// <param name="workbench">The workbench where the experiment was conducted.</param>
/// <returns>No return behavior.</returns>
void OnExperimentEnded(Workbench workbench)
{
    Puts($"Experiment completed at Workbench ID: {workbench.net.ID}.");
    
    if (workbench.pendingBlueprint == null)
    {
        Puts("No pending blueprint to finalize after the experiment.");
        return;
    }

    Puts($"Pending blueprint ID: {workbench.pendingBlueprint.itemid} has been successfully processed.");
}
```
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnNpcEquipWeapon(ScientistNPC,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon.
/// </summary>
/// <param name="npc">The NPC that is equipping the weapon.</param>
/// <param name="item">The item being equipped by the NPC.</param>
/// <returns>
/// Returns a non-null value to prevent the NPC from equipping the weapon. 
/// If `null` is returned, the NPC will proceed to equip the weapon as normal.
/// </returns>
object OnNpcEquipWeapon(ScientistNPC npc, Item item)
{
    Puts($"NPC {npc.displayName} is attempting to equip weapon: {item.info.displayName.english}.");

    if (item.info.shortname == "weapon.semiauto")
    {
        Puts($"NPC {npc.displayName} is not allowed to equip a semi-automatic weapon.");
        return true; // Prevent equipping
    }

    return null; // Allow equipping
}
```
```

### Source Code from the Library

```csharp

	public override void EquipWeapon()
	{
		base.EquipWeapon();
		HeldEntity heldEntity = GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		Item item = heldEntity.GetItem();
		if (item == null || item.contents == null || Interface.CallHook("OnNpcEquipWeapon", this, item) != null)
		{
			return;
		}
		if (UnityEngine.Random.Range(0, 3) == 0)
		{
			Item item2 = ItemManager.CreateByName("weapon.mod.flashlight", 1, 0uL);
			if (!item2.MoveToContainer(item.contents))
			{
				item2.Remove();
				return;
			}
			lightsOn = false;
			InvokeRandomized(base.LightCheck, 0f, 30f, 5f);
			LightCheck();
		}
		else
		{
			Item item3 = ItemManager.CreateByName("weapon.mod.lasersight", 1, 0uL);
			if (!item3.MoveToContainer(item.contents))
			{
				item3.Remove();
			}
			LightToggle();
			lightsOn = true;
		}
	}

```

## OnQuarryConsumeFuel(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when the mining quarry consumes fuel.
/// </summary>
/// <param name="quarry">The mining quarry that is consuming fuel.</param>
/// <param name="fuelItem">The item being used as fuel.</param>
/// <returns>
/// Returns the fuel item if it has been modified or replaced; otherwise, returns `null` to indicate the default behavior.
/// </returns>
object OnQuarryConsumeFuel(MiningQuarry quarry, Item fuelItem)
{
    Puts($"Mining Quarry {quarry.net.ID} is consuming fuel: {fuelItem.info.displayName.english} (Amount: {fuelItem.amount})");

    // Example condition to modify the fuel item
    if (fuelItem.info.shortname == "lowgradefuel" && fuelItem.amount > 5)
    {
        Puts("Reducing fuel amount by 1 for special processing.");
        fuelItem.amount -= 1; // Modify the fuel item
    }

    return fuelItem; // Return the modified fuel item
}
```
```

### Source Code from the Library

```csharp

	public bool FuelCheck()
	{
		Item item = fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemsByItemName("lowgradefuel");
		if (item != null && item.amount >= 1)
		{
			object obj = Interface.CallHook("OnQuarryConsumeFuel", this, item);
			if (obj is Item)
			{
				item = (Item)obj;
			}
			item.UseItem();
			return true;
		}
		return false;
	}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an admin opens the vending machine interface.
/// </summary>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <param name="adminPlayer">The player who is opening the vending machine as an admin.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer adminPlayer)
{
    Puts($"Admin {adminPlayer.displayName} opened the vending machine: {vendingMachine.net.ID}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			SendSellOrders(player);
			PlayerOpenLoot(player);
			ClientRPCPlayer(null, player, "CLIENT_OpenAdminMenu");
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a turret acquires or loses a target.
/// </summary>
/// <param name="turret">The turret that is acquiring or losing a target.</param>
/// <param name="target">The target entity that the turret is focusing on.</param>
/// <returns>No return behavior.</returns>
void OnTurretTarget(AutoTurret turret, BaseCombatEntity target)
{
    Puts($"Turret {turret.net.ID} is targeting {target?.net.ID ?? "none"}.");
    
    if (target != null)
    {
        Puts($"Turret {turret.net.ID} has acquired target {target.net.ID}.");
    }
    else
    {
        Puts($"Turret {turret.net.ID} has lost its target.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);
				MarkDirtyForceUpdateOutputs();
				nextShotTime += 0.1f;
			}
			target = targ;
		}
	}

```

## OnEntityActiveCheck(BaseEntity,BasePlayer,uint,string)

```csharp
```csharp
/// <summary>
/// Called to check if a player can interact with a specific entity based on activity conditions.
/// </summary>
/// <param name="entity">The entity being checked for activity.</param>
/// <param name="player">The player attempting to interact with the entity.</param>
/// <param name="id">A unique identifier for the check.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <returns>
/// Returns `true` if the player can interact with the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine the interaction validity.
/// </returns>
bool? OnEntityActiveCheck(BaseEntity entity, BasePlayer player, uint id, string debugName)
{
    Puts($"Checking activity for Player {player.displayName} on Entity {entity?.name} (ID: {entity?.net.ID}) with debug name: {debugName}");

    if (entity == null || player == null)
    {
        Puts("Entity or Player is null, cannot proceed with the check.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityActiveCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				Item activeItem = player.GetActiveItem();
				if (activeItem == null)
				{
					return false;
				}
				if (activeItem.GetHeldEntity() != ent)
				{
					return false;
				}
				return true;
			}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Determines whether the helicopter can use napalm.
/// </summary>
/// <param name="helicopter">The helicopter instance checking for napalm usage.</param>
/// <returns>
/// Returns `true` if the helicopter can use napalm, or `false` if it cannot.
/// If the method returns `null`, the default cooldown logic will be applied.
/// </returns>
bool? CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter {helicopter.net.ID} can use napalm.");
    
    if (helicopter.lastNapalmTime + 30f > UnityEngine.Time.realtimeSinceStartup)
    {
        Puts($"Helicopter {helicopter.net.ID} is on cooldown for napalm usage.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
	}

```

## OnCorpsePopulate(NPCMurderer,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called to populate an NPC's corpse with loot after it has been created.
/// </summary>
/// <param name="murderer">The NPC that killed the player.</param>
/// <param name="corpse">The corpse of the NPC player.</param>
/// <returns>
/// Returns a <c>BaseCorpse</c> object if the corpse is modified; otherwise, returns <c>null</c> to use the default behavior.
/// </returns>
BaseCorpse OnCorpsePopulate(NPCMurderer murderer, NPCPlayerCorpse corpse)
{
    Puts($"Populating corpse of {corpse.playerName} (SteamID: {corpse.playerSteamID}) killed by {murderer.displayName}.");

    // Example modification: Add a special item to the corpse if the murderer has a specific flag
    if (murderer.HasFlag(NPCFlags.SpecialLoot))
    {
        Puts($"Adding special loot to the corpse of {corpse.playerName}.");
        // Logic to add special loot
    }

    return null; // Return null to allow default loot population behavior
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse()
	{
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse("assets/prefabs/npc/murderer/murderer_corpse.prefab") as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				for (int i = 0; i < inventory.containerWear.itemList.Count; i++)
				{
					Item item = inventory.containerWear.itemList[i];
					if (item != null && item.info.shortname == "gloweyes")
					{
						inventory.containerWear.Remove(item);
						break;
					}
				}
				nPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				nPCPlayerCorpse.playerName = base.displayName;
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				nPCPlayerCorpse.TakeChildren(this);
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int j = 0; j < containers.Length; j++)
				{
					containers[j].Clear();
				}
				if (LootSpawnSlots.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int j = 0; j < lootSpawnSlots.Length; j++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[j];
						for (int k = 0; k < lootSpawnSlot.numberToSpawn; k++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnReloadMagazine(BasePlayer,BaseProjectile,int)

```csharp
```csharp
/// <summary>
/// Called when a player reloads the magazine of a projectile weapon.
/// </summary>
/// <param name="player">The player reloading the magazine.</param>
/// <param name="projectile">The projectile weapon being reloaded.</param>
/// <param name="desiredAmount">The amount of ammunition the player wishes to reload.</param>
/// <returns>
/// Returns `null` to allow the reload to proceed, or any non-null value to prevent the reload.
/// </returns>
object OnReloadMagazine(BasePlayer player, BaseProjectile projectile, int desiredAmount)
{
    Puts($"Player {player.displayName} is attempting to reload the magazine of {projectile.info.displayName.english} with desired amount: {desiredAmount}.");

    if (desiredAmount > 10)
    {
        Puts($"Player {player.displayName} cannot reload more than 10 rounds at once.");
        return "Cannot reload more than 10 rounds at once.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	protected void ReloadMagazine(int desiredAmount = -1)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((bool)ownerPlayer && Interface.CallHook("OnReloadMagazine", ownerPlayer, this, desiredAmount) == null)
		{
			primaryMagazine.Reload(ownerPlayer, desiredAmount);
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnExcavatorMiningToggled(ExcavatorArm)

```csharp
```csharp
/// <summary>
/// Called when the mining state of the excavator is toggled.
/// </summary>
/// <param name="excavator">The excavator arm that is being toggled for mining.</param>
/// <returns>No return behavior.</returns>
void OnExcavatorMiningToggled(ExcavatorArm excavator)
{
    Puts($"Excavator {excavator.net.ID} mining state toggled. Current state: {(excavator.HasFlag(Flags.On) ? "Mining" : "Stopped")}");
}
```
```

### Source Code from the Library

```csharp

	public void BeginMining()
	{
		if (IsPowered())
		{
			SetFlag(Flags.On, b: true);
			InvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);
			ExcavatorServerEffects.SetMining(isMining: true);
			Facepunch.Rust.Analytics.ExcavatorStarted();
			excavatorStartTime = GetNetworkTime();
			Interface.CallHook("OnExcavatorMiningToggled", this);
		}
	}

```

## OnHorseLead(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to lead a horse.
/// </summary>
/// <param name="horse">The horse being led.</param>
/// <param name="player">The player attempting to lead the horse.</param>
/// <returns>
/// Returns `null` to allow the leading action, or any non-null value to prevent the action.
/// </returns>
object OnHorseLead(BaseRidableAnimal horse, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to lead horse ID: {horse.net.ID}.");

    if (player.IsInCombat)
    {
        Puts($"Player {player.displayName} cannot lead the horse while in combat.");
        return "You cannot lead a horse while in combat.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Lead(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && !HasDriver() && !IsForSale())
		{
			bool num = IsLeading();
			bool flag = msg.read.Bit();
			if (num != flag && Interface.CallHook("OnHorseLead", this, player) == null)
			{
				SetLeading(flag ? player : null);
				LeadingChanged();
			}
		}
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base combat entity is hurt.
/// </summary>
/// <param name="entity">The base combat entity that is being hurt.</param>
/// <param name="hitInfo">Information about the hit, including damage and the attacker.</param>
/// <returns>
/// Returns a non-null value to prevent further processing of the hurt event. 
/// If `null` is returned, the default damage handling will proceed.
/// </returns>
object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.gameObject.name} is being hurt by {hitInfo.Initiator?.gameObject.name} with damage: {hitInfo.damageTypes.Total()}");

    if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Explosive)
    {
        Puts($"Explosive damage detected on {entity.gameObject.name}. Applying special rules.");
        return true; // Prevent further processing for explosive damage
    }

    return null; // Allow default processing to continue
}
```
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			if (!(this is BasePlayer))
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
			DebugHurt(info);
			health = num - info.damageTypes.Total();
			SendNetworkUpdate();
			if (ConVar.Global.developer > 1)
			{
				Debug.Log(string.Concat("[Combat]".PadRight(10), base.gameObject.name, " hurt ", info.damageTypes.GetMajorityDamageType(), "/", info.damageTypes.Total(), " - ", health.ToString("0"), " health left"));
			}
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (markAttackerHostile && baseCombatEntity2 != null && baseCombatEntity2 != this)
			{
				baseCombatEntity2.MarkHostileFor();
			}
			if (lastDamage.IsConsideredAnAttack())
			{
				lastAttackedTime = UnityEngine.Time.time;
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;
				}
			}
			if (diesAtZeroHealth && Health() <= 0f)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.Log(info, num, health, "killed");
				}
				else
				{
					initiatorPlayer.stats.combat.Log(info, num, health);
				}
			}
		}
	}

```

## OnNpcTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a specific entity.
/// </summary>
/// <param name="npc">The NPC that is targeting the entity.</param>
/// <param name="target">The entity being targeted by the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC to proceed with targeting, or any non-null value to prevent the targeting action.
/// </returns>
object OnNpcTarget(NPCPlayerApex npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is attempting to target {target?.ShortPrefabName ?? "an unknown entity"}.");

    if (target is BasePlayer player && player.IsInvisible())
    {
        Puts($"Targeting prevented: {player.displayName} is invisible.");
        return true; // Prevent targeting
    }

    return null; // Allow targeting
}
```
```

### Source Code from the Library

```csharp

	public Memory.SeenInfo UpdateTargetMemory(BaseEntity target, float dmg, Vector3 lastKnownPosition, out Memory.ExtendedInfo extendedInfo)
	{
		if (target == null || Interface.CallHook("OnNpcTarget", this, target) != null)
		{
			extendedInfo = default(Memory.ExtendedInfo);
			return default(Memory.SeenInfo);
		}
		Vector3 dir;
		float dot;
		if (base.isMounted)
		{
			BestMountedPlayerDirection.Evaluate(this, lastKnownPosition, out dir, out dot);
		}
		else
		{
			BestPlayerDirection.Evaluate(this, lastKnownPosition, out dir, out dot);
		}
		BestPlayerDistance.Evaluate(this, lastKnownPosition, out var distanceSqr, out var _);
		BasePlayer basePlayer = target.ToPlayer();
		int standing;
		int crouched;
		byte b = (byte)((!basePlayer) ? 1 : ((!base.isMounted) ? BestLineOfSight.Evaluate(this, basePlayer, out standing, out crouched) : BestMountedLineOfSight.Evaluate(this, basePlayer)));
		SetFact(Facts.HasLineOfSight, b);
		return AiContext.Memory.Update(target, lastKnownPosition, dmg, dir, dot, distanceSqr, b, lastAttacker == target, lastAttackedTime, out extendedInfo);
	}

```

## OnAddVendingOffer(VendingMachine,ProtoBuf.VendingMachine.SellOrder)

```csharp
```csharp
/// <summary>
/// Called when a new vending offer is added to the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine where the offer is being added.</param>
/// <param name="sellOrder">The details of the sell order being added.</param>
/// <returns>No return behavior.</returns>
void OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"New vending offer added: Sell {sellOrder.itemToSellAmount} of item ID {sellOrder.itemToSellID} " +
         $"for {sellOrder.currencyAmountPerItem} of currency ID {sellOrder.currencyID}.");

    if (sellOrder.currencyIsBP)
    {
        Puts("This offer uses blueprint currency.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = itemToSellID;
			sellOrder.itemToSellAmount = itemToSellAmount;
			sellOrder.currencyID = currencyToUseID;
			sellOrder.currencyAmountPerItem = currencyAmount;
			sellOrder.currencyIsBP = bpState == 3 || bpState == 2;
			sellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", this, sellOrder);
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## OnHelicopterRetire(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called when the patrol helicopter is set to retire.
/// </summary>
/// <param name="helicopter">The patrol helicopter that is retiring.</param>
/// <returns>
/// Returns `null` to allow the helicopter to retire, or any non-null value to prevent the retirement.
/// </returns>
object OnHelicopterRetire(PatrolHelicopterAI helicopter)
{
    Puts($"Patrol Helicopter ID: {helicopter.net.ID} is attempting to retire.");
    
    // Example condition to prevent retirement
    if (helicopter.IsUnderAttack())
    {
        Puts($"Patrol Helicopter ID: {helicopter.net.ID} cannot retire while under attack.");
        return "Cannot retire while under attack.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Retire()
	{
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", this) == null)
		{
			isRetiring = true;
			Invoke(DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 newPos = Vector3Ex.Range(-1f, 1f);
			newPos.y = 0f;
			newPos.Normalize();
			newPos *= x * 20f;
			newPos.y = y;
			ExitCurrentState();
			State_Move_Enter(newPos);
		}
	}

```

## OnMapImageUpdated()

```csharp
```csharp
/// <summary>
/// Called when a map image is updated by a player.
/// </summary>
/// <returns>No return behavior.</returns>
void OnMapImageUpdated()
{
    Puts("A map image has been updated.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void ImageUpdate(RPCMessage msg)
	{
		if (msg.player == null || UnityEngine.Time.realtimeSinceStartup - msg.player.lastSignUpdate < ConVar.AntiHack.signpause)
		{
			return;
		}
		msg.player.lastSignUpdate = UnityEngine.Time.realtimeSinceStartup;
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}

```

## IOnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets another entity, either a player or another NPC.
/// </summary>
/// <param name="npc">The NPC that is targeting another entity.</param>
/// <param name="target">The entity being targeted, which can be a player or another NPC.</param>
/// <returns>
/// Returns `null` to allow the default targeting behavior, or a non-null value to override it.
/// </returns>
object IOnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is targeting {target?.displayName ?? "an unknown entity"}.");
    
    if (target is BasePlayer player && player.IsInStealthMode)
    {
        Puts($"NPC {npc.displayName} cannot target {player.displayName} because they are in stealth mode.");
        return true; // Prevent targeting
    }

    return null; // Allow default behavior
}
```
```

### Source Code from the Library

```csharp

	private void AggroClosestEnemy()
	{
		float num = float.MaxValue;
		BasePlayer basePlayer = null;
		BaseNpc baseNpc = null;
		AiContext.AIAgent.AttackTarget = null;
		Vector3 vector = Vector3.zero;
		float num2 = 0f;
		float num3 = 0f;
		foreach (BasePlayer player in AiContext.Players)
		{
			if (player.IsDead() || player.IsDestroyed || (blockTargetingThisEnemy != null && player.net != null && blockTargetingThisEnemy.net != null && player.net.ID == blockTargetingThisEnemy.net.ID) || player.currentSafeLevel > 0f)
			{
				continue;
			}
			Vector3 vector2 = player.ServerPosition - ServerPosition;
			float sqrMagnitude = vector2.sqrMagnitude;
			num2 += Mathf.Min(Mathf.Sqrt(sqrMagnitude), Stats.VisionRange) / Stats.VisionRange;
			if (sqrMagnitude < num)
			{
				num = sqrMagnitude;
				basePlayer = player;
				baseNpc = null;
				vector = vector2;
				if (num <= AttackRange)
				{
					break;
				}
			}
		}
		if (num > AttackRange)
		{
			foreach (BaseNpc npc in AiContext.Npcs)
			{
				if (npc.IsDead() || npc.IsDestroyed || Stats.Family == npc.Stats.Family)
				{
					continue;
				}
				Vector3 vector3 = npc.ServerPosition - ServerPosition;
				float sqrMagnitude2 = vector3.sqrMagnitude;
				num3 += Mathf.Min(Mathf.Sqrt(sqrMagnitude2), Stats.VisionRange) / Stats.VisionRange;
				if (sqrMagnitude2 < num)
				{
					num = sqrMagnitude2;
					baseNpc = npc;
					basePlayer = null;
					vector = vector3;
					if (num < AttackRange)
					{
						break;
					}
				}
			}
		}
		if (num > AttackRange)
		{
			if (AiContext.PlayersBehindUs.Count > 0)
			{
				basePlayer = AiContext.PlayersBehindUs[0];
				baseNpc = null;
			}
			else if (AiContext.NpcsBehindUs.Count > 0)
			{
				basePlayer = null;
				baseNpc = AiContext.NpcsBehindUs[0];
			}
		}
		if (AiContext.EnemyPlayer == null || AiContext.EnemyPlayer.IsDestroyed || AiContext.EnemyPlayer.IsDead() || num2 > AiContext.LastEnemyPlayerScore + DecisionMomentumPlayerTarget())
		{
			AiContext.EnemyPlayer = basePlayer;
			AiContext.LastEnemyPlayerScore = num2;
			playerTargetDecisionStartTime = UnityEngine.Time.time;
		}
		else if (basePlayer == null && DecisionMomentumPlayerTarget() < 0.01f)
		{
			AiContext.EnemyPlayer = basePlayer;
			AiContext.LastEnemyPlayerScore = 0f;
			playerTargetDecisionStartTime = 0f;
		}
		if (AiContext.EnemyNpc == null || AiContext.EnemyNpc.IsDestroyed || AiContext.EnemyNpc.IsDead() || num3 > AiContext.LastEnemyNpcScore + DecisionMomentumAnimalTarget())
		{
			AiContext.EnemyNpc = baseNpc;
			AiContext.LastEnemyNpcScore = num3;
			animalTargetDecisionStartTime = UnityEngine.Time.time;
		}
		else if (baseNpc == null && DecisionMomentumAnimalTarget() < 0.01f)
		{
			AiContext.EnemyNpc = baseNpc;
			AiContext.LastEnemyNpcScore = 0f;
			animalTargetDecisionStartTime = 0f;
		}
		if (basePlayer != null || baseNpc != null)
		{
			SetFact(Facts.HasEnemy, 1);
			if (basePlayer != null)
			{
				AiContext.AIAgent.AttackTarget = basePlayer;
			}
			else
			{
				AiContext.AIAgent.AttackTarget = baseNpc;
			}
			float magnitude = vector.magnitude;
			if (Interface.CallHook("IOnNpcTarget", this, AiContext.AIAgent.AttackTarget) == null)
			{
				EnemyRangeEnum enemyRangeEnum = ToEnemyRangeEnum(magnitude);
				AfraidRangeEnum value = ToAfraidRangeEnum(magnitude);
				SetFact(Facts.EnemyRange, (byte)enemyRangeEnum);
				SetFact(Facts.AfraidRange, (byte)value);
				TryAggro(enemyRangeEnum);
			}
		}
		else
		{
			SetFact(Facts.HasEnemy, 0);
			SetFact(Facts.EnemyRange, 3);
			SetFact(Facts.AfraidRange, 1);
		}
	}

```

## OnSignLocked(PhotoFrame,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that is being locked.</param>
/// <param name="player">The player who is locking the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(PhotoFrame sign, BasePlayer player)
{
    Puts($"Sign locked by player {player.displayName} (ID: {player.UserIDString}). Sign ID: {sign.net.ID}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the looter can loot the target player; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if looting is allowed.
/// </returns>
bool CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.displayName} is attempting to loot {target.displayName}.");

    if (target.IsSleeping())
    {
        Puts($"{target.displayName} is sleeping and can be looted.");
        return true;
    }

    if (target.IsWounded())
    {
        Puts($"{target.displayName} is wounded and can be looted.");
        return true;
    }

    Puts($"{target.displayName} is not in a looting state.");
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		if (!IsWounded())
		{
			return IsSleeping();
		}
		return true;
	}

```

## CanLootEntity(BasePlayer,BaseRidableAnimal)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity that is being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, BaseRidableAnimal entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot entity: {entity.name}.");

    if (entity.IsDead())
    {
        Puts($"Entity {entity.name} is dead and cannot be looted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## OnWorldPrefabSpawned(UnityEngine.GameObject,string)

```csharp
```csharp
/// <summary>
/// Called when a prefab is spawned in the world.
/// </summary>
/// <param name="spawnedObject">The GameObject that was spawned.</param>
/// <param name="category">The category of the prefab that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnWorldPrefabSpawned(UnityEngine.GameObject spawnedObject, string category)
{
    Puts($"Prefab of category '{category}' has been spawned: {spawnedObject.name} at position {spawnedObject.transform.position}.");
    
    if (category == "enemy")
    {
        Puts("An enemy prefab has been spawned! Prepare for battle!");
    }
}
```
```

### Source Code from the Library

```csharp

	private static void Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		if ((bool)prefab.Object)
		{
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject gameObject = prefab.Spawn(position, rotation, scale);
			if ((bool)gameObject)
			{
				Interface.CallHook("OnWorldPrefabSpawned", gameObject, category);
				GameObjectEx.SetHierarchyGroup(gameObject, category);
			}
		}
	}

```

## OnHelicopterAttacked(CH47HelicopterAIController,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when the helicopter is attacked.
/// </summary>
/// <param name="helicopter">The helicopter that is being attacked.</param>
/// <param name="hitInfo">Information about the hit, including damage and source.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterAttacked(CH47HelicopterAIController helicopter, HitInfo hitInfo)
{
    Puts($"Helicopter {helicopter.net.ID} was attacked with damage: {hitInfo.damageTypes.Total()} from {hitInfo.Initiator?.displayName ?? "unknown source"}.");
    
    if (hitInfo.damageTypes.Total() > 50)
    {
        Puts("The attack was significant, initiating defensive maneuvers.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttacked", this, info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved7, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

```

## OnInputUpdate(IOEntity,int,int)

```csharp
```csharp
/// <summary>
/// Called when the input state of an IOEntity is updated.
/// </summary>
/// <param name="inputAmount">The amount of input received.</param>
/// <param name="inputSlot">The specific input slot that received the input.</param>
/// <returns>No return behavior.</returns>
void OnInputUpdate(IOEntity entity, int inputAmount, int inputSlot)
{
    Puts($"Input updated for entity {entity.net.ID}: Amount = {inputAmount}, Slot = {inputSlot}");
    
    if (inputAmount < 0)
    {
        Puts("Received negative input amount, ignoring update.");
        return;
    }
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public virtual void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (Interface.CallHook("OnInputUpdate", this, inputAmount, inputSlot) != null)
		{
			return;
		}
		if (inputs[inputSlot].type != ioType)
		{
			IOStateChanged(inputAmount, inputSlot);
			return;
		}
		UpdateHasPower(inputAmount, inputSlot);
		lastEnergy = currentEnergy;
		currentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);
		int passthroughAmount = GetPassthroughAmount();
		bool flag = lastPassthroughEnergy != passthroughAmount;
		lastPassthroughEnergy = passthroughAmount;
		if (currentEnergy != lastEnergy || flag)
		{
			IOStateChanged(inputAmount, inputSlot);
			ensureOutputsUpdated = true;
		}
		_processQueue.Enqueue(this);
	}

```

## OnPayForUpgrade(BasePlayer,BuildingBlock,ConstructionGrade)

```csharp
```csharp
/// <summary>
/// Called when a player pays for an upgrade to a building block.
/// </summary>
/// <param name="player">The player who is paying for the upgrade.</param>
/// <param name="block">The building block being upgraded.</param>
/// <param name="grade">The construction grade to which the block is being upgraded.</param>
/// <returns>No return behavior.</returns>
void OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade grade)
{
    Puts($"Player {player.displayName} is paying for an upgrade to {block.name} with grade {grade.name}.");
    
    if (player.inventory.GetAmount(grade.costToBuild[0].itemid) < grade.costToBuild[0].amount)
    {
        Puts($"Player {player.displayName} does not have enough resources to upgrade.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
	{
		if (Interface.CallHook("OnPayForUpgrade", player, this, g) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in g.costToBuild)
		{
			player.inventory.Take(list, item.itemid, (int)item.amount);
			player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether a patrol helicopter can target a specific player.
/// </summary>
/// <param name="helicopter">The patrol helicopter attempting to target the player.</param>
/// <param name="player">The player being targeted.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine targeting capability.
/// </returns>
bool? CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Helicopter {helicopter.net.ID} is checking if it can target player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInvisible())
    {
        Puts($"Player {player.displayName} is invisible and cannot be targeted.");
        return false;
    }

    if (TOD_Sky.Instance.IsNight && Vector3.Distance(player.eyes.position, helicopter.transform.position) > 40f)
    {
        Puts($"It's night and player {player.displayName} is too far away to be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldHealth">The player's health before the change.</param>
/// <param name="newHealth">The player's health after the change.</param>
/// <returns>No return behavior.</returns>
void OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Player {player.displayName} health changed from {oldHealth} to {newHealth}.");

    if (newHealth < oldHealth)
    {
        Puts($"Player {player.displayName} took damage: {oldHealth - newHealth}.");
    }
    else
    {
        Puts($"Player {player.displayName} healed: {newHealth - oldHealth}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) != null)
		{
			return;
		}
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer)
		{
			if (oldvalue > newvalue)
			{
				LifeStoryHurt(oldvalue - newvalue);
			}
			else
			{
				LifeStoryHeal(newvalue - oldvalue);
			}
			metabolism.isDirty = true;
		}
	}

```

## OnDemoRecordingStart(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is about to start for a player.
/// </summary>
/// <param name="filePath">The file path where the demo will be saved.</param>
/// <param name="player">The player who is starting the demo recording.</param>
/// <returns>
/// Returns `null` to allow the demo recording to start, or any non-null value to prevent it from starting.
/// </returns>
object OnDemoRecordingStart(string filePath, BasePlayer player)
{
    Puts($"Demo recording for player {player.displayName} will be saved to: {filePath}");
    
    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and cannot start demo recordings.");
        return "Demo recording is disabled in creative mode.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is being repaired by a player.
/// </summary>
/// <param name="structure">The structure that is being repaired.</param>
/// <param name="player">The player attempting to repair the structure.</param>
/// <returns>No return behavior.</returns>
void OnStructureRepair(BaseCombatEntity structure, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to repair structure: {structure.ShortPrefabName}.");

    if (structure.Health() >= structure.MaxHealth())
    {
        Puts($"Repair attempt by {player.displayName} failed: Structure is already at full health.");
    }
    else
    {
        Puts($"Repair attempt by {player.displayName} is valid for structure: {structure.ShortPrefabName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		float num = 30f;
		if (SecondsSinceAttacked <= num)
		{
			OnRepairFailed(player2, $"Unable to repair: Recently damaged. Repairable in: {num - SecondsSinceAttacked:N0}s.");
			return;
		}
		float num2 = MaxHealth() - Health();
		float num3 = num2 / MaxHealth();
		if (num2 <= 0f || num3 <= 0f)
		{
			OnRepairFailed(player2, "Unable to repair: Not damaged.");
			return;
		}
		List<ItemAmount> list = RepairCost(num3);
		if (list == null)
		{
			return;
		}
		float num4 = list.Sum((ItemAmount x) => x.amount);
		if (num4 > 0f)
		{
			float a = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			a = Mathf.Min(a, 50f / num2);
			if (a <= 0f)
			{
				OnRepairFailed(player2, "Unable to repair: Insufficient resources.");
				return;
			}
			int num5 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(a * item.amount);
				int num6 = player2.inventory.Take(null, item.itemid, amount);
				if (num6 > 0)
				{
					num5 += num6;
					player2.Command("note.inv", item.itemid, num6 * -1);
				}
			}
			float num7 = (float)num5 / num4;
			health += num2 * num7;
			SendNetworkUpdate();
		}
		else
		{
			health += num2;
			SendNetworkUpdate();
		}
		if (Health() >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines if a player is a valid target for the helicopter to strafe.
/// </summary>
/// <param name="helicopter">The helicopter attempting to strafe.</param>
/// <param name="player">The player being evaluated as a target.</param>
/// <returns>
/// Returns `true` if the player is a valid strafe target; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine the validity.
/// </returns>
bool? CanHelicopterStrafeTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Evaluating strafe target: Player {player.displayName} (ID: {player.UserIDString}) for Helicopter ID: {helicopter.net.ID}");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidStrafeTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return !ply.IsNearEnemyBase();
	}

```

## CanLootEntity(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a storage container.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="container">The storage container being looted.</param>
/// <returns>
/// Returns `true` if the player is allowed to loot the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot {container.name}.");

    if (container.IsLocked())
    {
        Puts($"Loot attempt failed: {container.name} is locked.");
        return false;
    }

    if (container.onlyOneUser && container.IsOpen())
    {
        Puts($"Loot attempt failed: {container.name} is currently in use.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (IsLocked())
		{
			player.ShowToast(1, LockedMessage);
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ShowToast(1, InUseMessage);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = panelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			AddContainers(player.inventory.loot);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## CanRecycle(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled at a recycler.
/// </summary>
/// <param name="recycler">The recycler attempting to recycle the item.</param>
/// <param name="item">The item being checked for recyclability.</param>
/// <returns>
/// Returns `true` if the item can be recycled, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the item can be recycled.
/// </returns>
bool? CanRecycle(Recycler recycler, Item item)
{
    Puts($"Checking recyclability for item: {item.info.displayName.english} (ID: {item.info.itemid}) at recycler: {recycler.name}.");

    if (item.info.shortname == "wood")
    {
        Puts("Wood can always be recycled.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## OnTeamPromote(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is promoted to team leader within their team.
/// </summary>
/// <param name="team">The team to which the player belongs.</param>
/// <param name="newLeader">The player being promoted to team leader.</param>
/// <returns>
/// Returns `null` to allow the promotion, or any non-null value to prevent the promotion.
/// </returns>
object OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer newLeader)
{
    Puts($"Player {newLeader.displayName} has been promoted to team leader of team ID: {team.teamID}.");
    
    if (newLeader.IsBannedFromLeadership())
    {
        Puts($"Player {newLeader.displayName} is banned from being a team leader.");
        return "You are banned from being a team leader.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void promote(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);
		if (!(lookingAtPlayer == null) && !lookingAtPlayer.IsDead() && !(lookingAtPlayer == basePlayer) && lookingAtPlayer.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = Instance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == basePlayer.userID && Interface.CallHook("OnTeamPromote", playerTeam, lookingAtPlayer) == null)
			{
				playerTeam.SetTeamLeader(lookingAtPlayer.userID);
			}
		}
	}

```

## OnCollectiblePickup(Item,BasePlayer,CollectibleEntity)

```csharp
```csharp
/// <summary>
/// Called when a collectible item is picked up by a player.
/// </summary>
/// <param name="item">The item that is being picked up.</param>
/// <param name="player">The player who is picking up the item.</param>
/// <param name="collectible">The collectible entity from which the item is being picked up.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being picked up. 
/// If `null` is returned, the item will be given to the player as normal.
/// </returns>
object OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity collectible)
{
    Puts($"Player {player.displayName} is attempting to pick up {item.info.displayName.english} from {collectible.gameObject.name}.");

    if (item.info.shortname == "forbidden.item")
    {
        Puts($"Player {player.displayName} is not allowed to pick up {item.info.displayName.english}.");
        return "You cannot pick up this item.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoPickup(BasePlayer reciever)
	{
		if (itemList == null)
		{
			return;
		}
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
			if (item == null)
			{
				continue;
			}
			if ((bool)reciever)
			{
				if (Interface.CallHook("OnCollectiblePickup", item, reciever, this) != null)
				{
					return;
				}
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
		}
		Kill();
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an object is detected by the trap trigger.
/// </summary>
/// <param name="trap">The trap that has been triggered.</param>
/// <param name="triggeredObject">The object that has entered the trap's trigger area.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trap, UnityEngine.GameObject triggeredObject)
{
    Puts($"Trap {trap.gameObject.name} has snapped! Object: {triggeredObject.name} entered the trap.");
}
```
```

### Source Code from the Library

```csharp

	public override void OnObjectAdded(GameObject obj)
	{
		Interface.CallHook("OnTrapSnapped", this, obj);
		base.OnObjectAdded(obj);
		_trap.ObjectEntered(obj);
	}

```

## OnBookmarkInput(ComputerStation,BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player provides input to a computer station's bookmark feature.
/// </summary>
/// <param name="station">The computer station receiving the input.</param>
/// <param name="player">The player providing the input.</param>
/// <param name="inputState">The state of the input provided by the player.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkInput(ComputerStation station, BasePlayer player, InputState inputState)
{
    Puts($"Player {player.displayName} provided input to the bookmark feature on station {station.net.ID}.");
    
    if (inputState.IsPressed(InputButton.Bookmark))
    {
        Puts($"Player {player.displayName} pressed the bookmark button.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (currentlyControllingEnt.IsValid(serverside: true) && Interface.CallHook("OnBookmarkInput", this, player, inputState) == null)
		{
			currentlyControllingEnt.Get(serverside: true).GetComponent<IRemoteControllable>().UserInput(inputState, player);
		}
	}

```

## OnItemSkinChange(int,Item,RepairBench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player changes the skin of an item at a repair bench.
/// </summary>
/// <param name="skinId">The ID of the skin being applied.</param>
/// <param name="item">The item whose skin is being changed.</param>
/// <param name="repairBench">The repair bench where the skin change is taking place.</param>
/// <param name="player">The player attempting to change the skin.</param>
/// <returns>
/// Returns a non-null value to prevent the skin change, or `null` to allow it.
/// </returns>
object OnItemSkinChange(int skinId, Item item, RepairBench repairBench, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to change skin of {item.info.displayName.english} to skin ID {skinId}.");

    if (skinId == 12345) // Example of a restricted skin ID
    {
        Puts($"Skin ID {skinId} is restricted for player {player.displayName}.");
        return "You cannot use this skin.";
    }

    return null; // Allow the skin change
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ChangeSkin(RPCMessage msg)
	{
		if (UnityEngine.Time.realtimeSinceStartup < nextSkinChangeTime)
		{
			return;
		}
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || Interface.CallHook("OnItemSkinChange", num, slot, this, msg.player) != null)
		{
			return;
		}
		bool flag = false;
		if (num != 0 && !flag && !player.blueprints.CheckSkinOwnership(num, player.userID))
		{
			debugprint("RepairBench.ChangeSkin player does not have item :" + num + ":");
			return;
		}
		ulong Skin = ItemDefinition.FindSkin(slot.info.itemid, num);
		if (Skin == slot.skin && slot.info.isRedirectOf == null)
		{
			debugprint("RepairBench.ChangeSkin cannot apply same skin twice : " + Skin + ": " + slot.skin);
			return;
		}
		nextSkinChangeTime = UnityEngine.Time.realtimeSinceStartup + 0.75f;
		ItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		if (slot.info.isRedirectOf != null)
		{
			Skin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, num);
			skin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		}
		ItemSkin itemSkin = ((skin.id == 0) ? null : (skin.invItem as ItemSkin));
		if ((bool)itemSkin && (itemSkin.Redirect != null || slot.info.isRedirectOf != null))
		{
			ItemDefinition template = itemSkin.Redirect;
			bool flag2 = false;
			if (itemSkin.Redirect == null && slot.info.isRedirectOf != null)
			{
				template = slot.info.isRedirectOf;
				flag2 = num != 0;
			}
			float condition = slot.condition;
			float maxCondition = slot.maxCondition;
			slot.Remove();
			ItemManager.DoRemoves();
			Item item = ItemManager.Create(template, 1, 0uL);
			item.MoveToContainer(base.inventory, 0, allowStack: false);
			item.maxCondition = maxCondition;
			item.condition = condition;
			if (flag2)
			{
				ApplySkinToItem(item, Skin);
			}
		}
		else if (!itemSkin && slot.info.isRedirectOf != null)
		{
			ItemDefinition isRedirectOf = slot.info.isRedirectOf;
			float condition2 = slot.condition;
			float maxCondition2 = slot.maxCondition;
			slot.Remove();
			ItemManager.DoRemoves();
			Item item2 = ItemManager.Create(isRedirectOf, 1, Skin);
			item2.MoveToContainer(base.inventory, 0, allowStack: false);
			item2.maxCondition = maxCondition2;
			item2.condition = condition2;
		}
		else
		{
			ApplySkinToItem(slot, Skin);
		}
		if (skinchangeEffect.isValid)
		{
			Effect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);
		}
	}

```

## OnLootSpawn(LootContainer)

```csharp
```csharp
/// <summary>
/// Called when loot is spawned in a loot container.
/// </summary>
/// <param name="container">The loot container where the loot is being spawned.</param>
/// <returns>No return behavior.</returns>
void OnLootSpawn(LootContainer container)
{
    Puts($"Loot is being spawned in container: {container.gameObject.name} (ID: {container.net.ID})");
    
    // Example condition to prevent spawning loot in certain containers
    if (container.IsLocked)
    {
        Puts($"Loot spawn prevented: Container {container.gameObject.name} is locked.");
        return;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				Invoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

```

## OnPlayerAssist(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player assists another player who is wounded.
/// </summary>
/// <param name="assistedPlayer">The player who is being assisted.</param>
/// <param name="assistingPlayer">The player who is providing assistance.</param>
/// <returns>No return behavior.</returns>
void OnPlayerAssist(BasePlayer assistedPlayer, BasePlayer assistingPlayer)
{
    Puts($"Player {assistingPlayer.displayName} is assisting wounded player {assistedPlayer.displayName}.");
    
    if (assistedPlayer.IsWounded())
    {
        Puts($"Player {assistedPlayer.displayName} has been successfully assisted.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Assist(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerAssist", this, msg.player) == null)
		{
			StopWounded(msg.player);
			msg.player.stats.Add("wounded_assisted", 1, (Stats)5);
			stats.Add("wounded_healed", 1);
		}
	}

```

## IOnServerInitialized()

```csharp
```csharp
/// <summary>
/// Called when the server has been initialized and is ready to accept connections.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnServerInitialized()
{
    Puts("Server has been initialized and is ready for connections.");
    // Additional initialization logic can be added here.
}
```
```

### Source Code from the Library

```csharp

	public void OpenConnection()
	{
		useQueryPort = ConVar.Server.queryport > 0 && ConVar.Server.queryport != ConVar.Server.port;
		if (!useQueryPort && !Network.Net.sv.AllowPassthroughMessages)
		{
			ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
			useQueryPort = true;
		}
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		StartSteamServer();
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			CloseConnection();
			return;
		}
		Network.Net.sv.callbackHandler = this;
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		EACServer.DoStartup();
		InvokeRepeating("EACUpdate", 1f, 1f);
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
		Interface.CallHook("IOnServerInitialized");
	}

```

## OnSupplyDropLanded(SupplyDrop)

```csharp
```csharp
/// <summary>
/// Called when a supply drop has landed in the game world.
/// </summary>
/// <param name="supplyDrop">The supply drop that has landed.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropLanded(SupplyDrop supplyDrop)
{
    Puts($"Supply drop landed at position: {supplyDrop.transform.position}.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	private void OnCollisionEnter(Collision collision)
	{
		if (((1 << collision.collider.gameObject.layer) & 0x40A10111) > 0)
		{
			RemoveParachute();
			MakeLootable();
		}
		Interface.CallHook("OnSupplyDropLanded", this);
	}

```

## OnOvenCooked(BaseOven,Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item has finished cooking in the oven.
/// </summary>
/// <param name="oven">The oven that cooked the item.</param>
/// <param name="item">The item that was cooked.</param>
/// <param name="entity">The entity associated with the cooking process.</param>
/// <returns>No return behavior.</returns>
void OnOvenCooked(BaseOven oven, Item item, BaseEntity entity)
{
    Puts($"Item {item.info.displayName.english} has been cooked in oven ID: {oven.net.ID} by entity: {entity?.gameObject.name ?? "Unknown"}.");

    if (item.info.shortname == "food.cooked.chicken")
    {
        Puts("Cooked chicken is ready to serve!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null)
		{
			StopCooking();
			return;
		}
		base.inventory.OnCycle(0.5f);
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		ItemModBurnable component = item.info.GetComponent<ItemModBurnable>();
		item.fuel -= 0.5f * (cookingTemperature / 200f);
		if (!item.HasFlag(Item.Flag.OnFire))
		{
			item.SetFlag(Item.Flag.OnFire, b: true);
			item.MarkDirty();
		}
		if (item.fuel <= 0f)
		{
			ConsumeFuel(item, component);
		}
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnConstructionPlace(BaseEntity,Construction,Construction.Target,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a construction is placed by a player.
/// </summary>
/// <param name="entity">The entity being placed.</param>
/// <param name="construction">The construction component being used.</param>
/// <param name="placement">The target placement location for the construction.</param>
/// <param name="player">The player who is placing the construction.</param>
/// <returns>
/// Returns the GameObject of the placed construction if successful; otherwise, returns `null`.
/// If the method returns a non-null value, the placement is allowed; if it returns `null`, the placement is canceled.
/// </returns>
GameObject OnConstructionPlace(BaseEntity entity, Construction construction, Construction.Target placement, BasePlayer player)
{
    Puts($"Player {player.displayName} is placing a construction at {placement.position}.");

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can place constructions freely.");
        return entity.gameObject; // Allow placement
    }

    if (construction.fullName == "foundation.stone")
    {
        Puts($"Player {player.displayName} is not allowed to place a stone foundation.");
        return null; // Disallow placement
    }

    return entity.gameObject; // Allow placement
}
```
```

### Source Code from the Library

```csharp

	public GameObject DoPlacement(Construction.Target placement, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		BaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);
		if (!baseEntity)
		{
			return null;
		}
		float num = 1f;
		float num2 = 0f;
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			baseEntity.skinID = ownerItem.skin;
			if (ownerItem.hasCondition)
			{
				num = ownerItem.conditionNormalized;
			}
		}
		PoolableEx.AwakeFromInstantiate(baseEntity.gameObject);
		BuildingBlock buildingBlock = baseEntity as BuildingBlock;
		if ((bool)buildingBlock)
		{
			buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
			if (!buildingBlock.blockDefinition)
			{
				Debug.LogError("Placing a building block that has no block definition!");
				return null;
			}
			buildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);
			num2 = buildingBlock.currentGrade.maxHealth;
		}
		BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
		if ((bool)baseCombatEntity)
		{
			num2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);
			baseCombatEntity.ResetLifeStateOnSpawn = false;
			baseCombatEntity.InitializeHealth(num2 * num, num2);
		}
		if (Interface.CallHook("OnConstructionPlace", baseEntity, component, placement, ownerPlayer) != null)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.KillMessage();
			}
			else
			{
				GameManager.Destroy(baseEntity);
			}
			return null;
		}
		baseEntity.gameObject.SendMessage("SetDeployedBy", ownerPlayer, SendMessageOptions.DontRequireReceiver);
		baseEntity.OwnerID = ownerPlayer.userID;
		baseEntity.Spawn();
		if ((bool)buildingBlock)
		{
			Effect.server.Run("assets/bundled/prefabs/fx/build/frame_place.prefab", baseEntity, 0u, Vector3.zero, Vector3.zero);
		}
		StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
		if ((bool)stabilityEntity)
		{
			stabilityEntity.UpdateSurroundingEntities();
		}
		return baseEntity.gameObject;
	}

```

## OnLootEntityEnd(BasePlayer,ContainerIOEntity)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="container">The container entity that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ContainerIOEntity container)
{
    Puts($"Player {player.displayName} has stopped looting the container: {container.name}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Determines whether a potential target can be targeted by the helicopter turret.
/// </summary>
/// <param name="target">The potential target entity.</param>
/// <param name="turret">The helicopter turret attempting to target the entity.</param>
/// <returns>
/// Returns `true` if the target can be engaged; otherwise, returns `false`.
/// If the method returns `null`, the default targeting logic will be applied.
/// </returns>
bool? CanBeTargeted(BaseCombatEntity target, HelicopterTurret turret)
{
    Puts($"Checking if target {target.displayName} can be engaged by turret {turret.net.ID}.");

    if (target is Player player && player.IsInvisible())
    {
        Puts($"Target {player.displayName} is invisible and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## OnTeamUpdated(ulong,ProtoBuf.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's team information is updated.
/// </summary>
/// <param name="teamId">The ID of the team being updated.</param>
/// <param name="teamData">The updated team data containing members and other information.</param>
/// <param name="player">The player whose team is being updated.</param>
/// <returns>
/// Returns `null` to allow the default team update behavior, or a non-null value to override it.
/// </returns>
object OnTeamUpdated(ulong teamId, ProtoBuf.PlayerTeam teamData, BasePlayer player)
{
    Puts($"Team update for Team ID: {teamId} by Player: {player.displayName} (ID: {player.UserIDString})");

    if (teamData.members.Count > 5)
    {
        Puts($"Team {teamId} has exceeded the maximum member limit.");
        return "Team member limit exceeded.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TeamUpdate()
	{
		if (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)
		{
			return;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindTeam(currentTeam);
		if (playerTeam == null)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		using PlayerTeam playerTeam2 = Facepunch.Pool.Get<PlayerTeam>();
		playerTeam2.teamLeader = playerTeam.teamLeader;
		playerTeam2.teamID = playerTeam.teamID;
		playerTeam2.teamName = playerTeam.teamName;
		playerTeam2.members = Facepunch.Pool.GetList<PlayerTeam.TeamMember>();
		playerTeam2.teamLifetime = playerTeam.teamLifetime;
		foreach (ulong member in playerTeam.members)
		{
			BasePlayer basePlayer = RelationshipManager.FindByID(member);
			PlayerTeam.TeamMember teamMember = Facepunch.Pool.Get<PlayerTeam.TeamMember>();
			teamMember.displayName = ((basePlayer != null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
			teamMember.healthFraction = ((basePlayer != null) ? basePlayer.healthFraction : 0f);
			teamMember.position = ((basePlayer != null) ? basePlayer.transform.position : UnityEngine.Vector3.zero);
			teamMember.online = basePlayer != null && !basePlayer.IsSleeping();
			if ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) && basePlayer != null)
			{
				if ((bool)basePlayer.GetHeldEntity() && basePlayer.GetHeldEntity().IsInstrument())
				{
					num++;
				}
				if (basePlayer.isMounted)
				{
					if (basePlayer.GetMounted().IsInstrument())
					{
						num++;
					}
					if (basePlayer.GetMounted().IsSummerDlcVehicle)
					{
						num2++;
					}
				}
				if (num >= 4 && !sentInstrumentTeamAchievement)
				{
					GiveAchievement("TEAM_INSTRUMENTS");
					sentInstrumentTeamAchievement = true;
				}
				if (num2 >= 4)
				{
					GiveAchievement("SUMMER_INFLATABLE");
					sentSummerTeamAchievement = true;
				}
			}
			teamMember.userID = member;
			playerTeam2.members.Add(teamMember);
		}
		teamLeaderBuffer = FindByID(playerTeam.teamLeader);
		if (teamLeaderBuffer != null)
		{
			playerTeam2.mapNote = teamLeaderBuffer.ServerCurrentMapNote;
		}
		if (Interface.CallHook("OnTeamUpdated", currentTeam, playerTeam2, this) == null)
		{
			ClientRPCPlayer(null, this, "CLIENT_ReceiveTeamInfo", playerTeam2);
			playerTeam2.mapNote = null;
		}
	}

```

## OnRconConnection(System.Net.IPAddress)

```csharp
```csharp
/// <summary>
/// Called when a new RCON connection is established.
/// </summary>
/// <param name="ipAddress">The IP address of the connecting client.</param>
/// <returns>
/// Returns a non-null value to reject the connection, or `null` to allow the connection to proceed.
/// </returns>
object OnRconConnection(System.Net.IPAddress ipAddress)
{
    Puts($"RCON connection attempt from IP: {ipAddress}");

    if (ipAddress.ToString() == "192.168.0.100")
    {
        Puts($"RCON connection from {ipAddress} is not allowed.");
        return "Connection rejected: Unauthorized IP address.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", iPEndPoint.Address) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnWireConnect(BasePlayer,IOEntity,int,IOEntity,int)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to connect two IO entities with wires.
/// </summary>
/// <param name="player">The player making the connection.</param>
/// <param name="inputEntity">The IO entity receiving the input connection.</param>
/// <param name="inputSlot">The input slot index on the receiving entity.</param>
/// <param name="outputEntity">The IO entity providing the output connection.</param>
/// <param name="outputSlot">The output slot index on the providing entity.</param>
/// <returns>
/// Returns `null` to allow the connection, or any non-null value to prevent the connection.
/// </returns>
object OnWireConnect(BasePlayer player, IOEntity inputEntity, int inputSlot, IOEntity outputEntity, int outputSlot)
{
    Puts($"Player {player.displayName} is attempting to connect {inputEntity.name} (Input Slot: {inputSlot}) to {outputEntity.name} (Output Slot: {outputSlot}).");

    if (!player.HasPermission("wire.connect"))
    {
        Puts($"Player {player.displayName} does not have permission to connect wires.");
        return "You do not have permission to connect wires.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void MakeConnection(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		uint uid = msg.read.UInt32();
		int num = msg.read.Int32();
		uint uid2 = msg.read.UInt32();
		int num2 = msg.read.Int32();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		IOEntity iOEntity = ((baseNetworkable == null) ? null : baseNetworkable.GetComponent<IOEntity>());
		if (iOEntity == null)
		{
			return;
		}
		BaseNetworkable baseNetworkable2 = BaseNetworkable.serverEntities.Find(uid2);
		IOEntity iOEntity2 = ((baseNetworkable2 == null) ? null : baseNetworkable2.GetComponent<IOEntity>());
		if (!(iOEntity2 == null) && !(Vector3.Distance(baseNetworkable2.transform.position, baseNetworkable.transform.position) > maxWireLength) && num < iOEntity.inputs.Length && num2 < iOEntity2.outputs.Length && !(iOEntity.inputs[num].connectedTo.Get() != null) && !(iOEntity2.outputs[num2].connectedTo.Get() != null) && (!iOEntity.inputs[num].rootConnectionsOnly || iOEntity2.IsRootEntity()) && CanModifyEntity(player, iOEntity) && CanModifyEntity(player, iOEntity2))
		{
			if (Interface.CallHook("OnWireConnect", msg.player, iOEntity, num, iOEntity2, num2) != null)
			{
				iOEntity2.outputs[num2].linePoints = null;
				return;
			}
			iOEntity.inputs[num].connectedTo.Set(iOEntity2);
			iOEntity.inputs[num].connectedToSlot = num2;
			iOEntity.inputs[num].connectedTo.Init();
			iOEntity2.outputs[num2].connectedTo.Set(iOEntity);
			iOEntity2.outputs[num2].connectedToSlot = num;
			iOEntity2.outputs[num2].connectedTo.Init();
			iOEntity2.MarkDirtyForceUpdateOutputs();
			iOEntity2.SendNetworkUpdate();
			iOEntity.SendNetworkUpdate();
			iOEntity2.SendChangedToRoot(forceUpdate: true);
		}
	}

```

## OnEntityTakeDamage(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit, including damage type and amount.</param>
/// <returns>
/// Returns a non-null value to prevent the damage from being applied. 
/// If `null` is returned, the damage will be processed as normal.
/// </returns>
object OnEntityTakeDamage(ResourceEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.net.ID} is taking damage: {hitInfo.damageTypes.Total()} from {hitInfo.Initiator?.ToString() ?? "unknown source"}.");

    if (entity.health < 50f)
    {
        Puts($"Entity {entity.net.ID} is critically damaged and cannot take more damage.");
        return true; // Prevent further damage
    }

    return null; // Allow damage to proceed
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", this, info) != null)
		{
			return;
		}
		if (resourceDispenser != null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if ((bool)baseProtection)
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnKilled(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

```

## OnOutputUpdate(IOEntity)

```csharp
```csharp
/// <summary>
/// Called when the outputs of an IOEntity are updated.
/// </summary>
/// <param name="entity">The IOEntity whose outputs are being updated.</param>
/// <returns>No return behavior.</returns>
void OnOutputUpdate(IOEntity entity)
{
    Puts($"Output update triggered for IOEntity: {entity.name} (ID: {entity.net.ID})");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public virtual void UpdateOutputs()
	{
		if (Interface.CallHook("OnOutputUpdate", this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		ensureOutputsUpdated = false;
		using (TimeWarning.New("ProcessIOOutputs"))
		{
			for (int i = 0; i < outputs.Length; i++)
			{
				IOSlot iOSlot = outputs[i];
				bool flag = true;
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if (!(iOEntity != null))
				{
					continue;
				}
				if (ioType == IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)
				{
					using (TimeWarning.New("FluidOutputProcessing"))
					{
						if (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))
						{
							flag = false;
						}
					}
				}
				int passthroughAmount = GetPassthroughAmount(i);
				iOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);
			}
		}
	}

```

## OnExcavatorResourceSet(ExcavatorArm,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the resource target for an excavator is set by a player.
/// </summary>
/// <param name="excavator">The excavator arm that is being set up.</param>
/// <param name="resourceType">The type of resource being targeted (e.g., HQM, Sulfur, Stone, Metal).</param>
/// <param name="player">The player who is setting the resource target.</param>
/// <returns>No return behavior.</returns>
void OnExcavatorResourceSet(ExcavatorArm excavator, string resourceType, BasePlayer player)
{
    Puts($"Player {player.displayName} has set the excavator to target resource: {resourceType}.");
    
    if (resourceType == "HQM")
    {
        Puts("High Quality Metal is now the target resource.");
    }
    else if (resourceType == "Sulfur")
    {
        Puts("Sulfur is now the target resource.");
    }
    else if (resourceType == "Stone")
    {
        Puts("Stone is now the target resource.");
    }
    else if (resourceType == "Metal")
    {
        Puts("Metal is now the target resource.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SetResourceTarget(RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnExcavatorResourceSet", this, text, msg.player) == null)
		{
			switch (text)
			{
			case "HQM":
				resourceMiningIndex = 0;
				break;
			case "Sulfur":
				resourceMiningIndex = 1;
				break;
			case "Stone":
				resourceMiningIndex = 2;
				break;
			case "Metal":
				resourceMiningIndex = 3;
				break;
			}
			if (!IsOn())
			{
				BeginMining();
			}
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The item container from which items are being dropped.</param>
/// <returns>No return behavior.</returns>
void OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping items from container ID: {container.uid}, containing {container.itemList.Count} items.");
    
    if (container.itemList.Count == 0)
    {
        Puts("No items to drop from the container.");
        return;
    }

    foreach (var item in container.itemList)
    {
        Puts($"Item {item.info.displayName.english} is being dropped.");
    }
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position, float chance = 1f)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			if (!(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				float num2 = UnityEngine.Random.Range(0f, 2f);
				item.RemoveFromContainer();
				BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
				if (baseEntity == null)
				{
					item.Remove();
				}
				else if (num2 > 0f)
				{
					baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
					baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
				}
			}
		}
	}

```

## OnGrowableGathered(GrowableEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a growable entity is gathered by a player.
/// </summary>
/// <param name="growable">The growable entity that was gathered.</param>
/// <param name="item">The item that was produced from the gathering.</param>
/// <param name="player">The player who gathered the item.</param>
/// <returns>No return behavior.</returns>
void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} gathered {item.amount} of {item.info.displayName.english} from {growable.name}.");
    
    if (item.amount > 10)
    {
        Puts($"Player {player.displayName} has gathered a large amount of {item.info.displayName.english}!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void GiveFruit(BasePlayer player, int amount, bool applyCondition)
	{
		Item item = ItemManager.Create(Properties.pickupItem, amount, 0uL);
		if (applyCondition)
		{
			item.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);
		}
		if (player != null)
		{
			Interface.CallHook("OnGrowableGathered", this, item, player);
			player.GiveItem(item, GiveItemReason.PickedUp);
		}
		else
		{
			item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
		}
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player can use the mailbox; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can use the mailbox.
/// </returns>
bool? CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use the mailbox.");

    if (player.IsBannedFromMailboxes)
    {
        Puts($"Player {player.displayName} is banned from using mailboxes.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine is rotated by a player.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="player">The player who is rotating the vending machine.</param>
/// <returns>No return behavior.</returns>
void OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending machine at {vendingMachine.transform.position} rotated by player {player.displayName} (ID: {player.UserIDString}).");
    
    if (!player.CanBuild())
    {
        Puts($"Player {player.displayName} does not have permission to build.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RotateVM(RPCMessage msg)
	{
		if (Interface.CallHook("OnRotateVendingMachine", this, msg.player) == null && CanRotate())
		{
			UpdateEmptyFlag();
			if (msg.player.CanBuild() && IsInventoryEmpty())
			{
				base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
				SendNetworkUpdate();
			}
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting a lootable entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="corpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse corpse)
{
    Puts($"Player {player.displayName} has stopped looting the corpse.");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanMoveItem(Item,PlayerInventory,uint,int,int)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be moved from one inventory to another.
/// </summary>
/// <param name="item">The item being moved.</param>
/// <param name="inventory">The player's inventory attempting to move the item.</param>
/// <param name="targetContainerId">The ID of the target container where the item is being moved.</param>
/// <param name="position">The position in the target container.</param>
/// <param name="amount">The amount of the item to move.</param>
/// <returns>
/// Returns `null` to allow the item to be moved, or any non-null value to prevent the move operation.
/// </returns>
object CanMoveItem(Item item, PlayerInventory inventory, uint targetContainerId, int position, int amount)
{
    Puts($"Attempting to move item {item.info.displayName.english} (ID: {item.uid}) to container {targetContainerId}.");

    if (item.info.shortname == "forbidden.item")
    {
        Puts($"Item {item.info.displayName.english} cannot be moved.");
        return "You cannot move this item.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	private void MoveItem(BaseEntity.RPCMessage msg)
	{
		uint num = msg.read.UInt32();
		uint num2 = msg.read.UInt32();
		int num3 = msg.read.Int8();
		int num4 = (int)msg.read.UInt32();
		Item item = FindItemUID(num);
		if (item == null)
		{
			msg.player.ChatMessage("Invalid item (" + num + ")");
		}
		else
		{
			if (Interface.CallHook("CanMoveItem", item, this, num2, num3, num4) != null)
			{
				return;
			}
			if (!CanMoveItemsFrom(item.parent.entityOwner, item))
			{
				msg.player.ChatMessage("Cannot move item!");
				return;
			}
			if (num4 <= 0)
			{
				num4 = item.amount;
			}
			num4 = Mathf.Clamp(num4, 1, item.MaxStackable());
			if (msg.player.GetActiveItem() == item)
			{
				msg.player.UpdateActiveItem(0u);
			}
			if (num2 == 0)
			{
				if (!GiveItem(item))
				{
					msg.player.ChatMessage("GiveItem failed!");
				}
				return;
			}
			ItemContainer itemContainer = FindContainer(num2);
			if (itemContainer == null)
			{
				msg.player.ChatMessage("Invalid container (" + num2 + ")");
				return;
			}
			ItemContainer parent = item.parent;
			if ((parent != null && parent.IsLocked()) || itemContainer.IsLocked())
			{
				msg.player.ChatMessage("Container is locked!");
				return;
			}
			if (itemContainer.PlayerItemInputBlocked())
			{
				msg.player.ChatMessage("Container does not accept player items!");
				return;
			}
			using (TimeWarning.New("Split"))
			{
				if (item.amount > num4)
				{
					int split_Amount = num4;
					if (itemContainer.maxStackSize > 0)
					{
						split_Amount = Mathf.Min(num4, itemContainer.maxStackSize);
					}
					Item item2 = item.SplitItem(split_Amount);
					if (!item2.MoveToContainer(itemContainer, num3))
					{
						item.amount += item2.amount;
						item2.Remove();
					}
					ItemManager.DoRemoves();
					ServerUpdate(0f);
					return;
				}
			}
			if (item.MoveToContainer(itemContainer, num3))
			{
				ItemManager.DoRemoves();
				ServerUpdate(0f);
			}
		}
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a landmine trap is disarmed by a player.
/// </summary>
/// <param name="landmine">The landmine trap that is being disarmed.</param>
/// <param name="disarmingPlayer">The player who is attempting to disarm the trap.</param>
/// <returns>No return behavior.</returns>
void OnTrapDisarm(Landmine landmine, BasePlayer disarmingPlayer)
{
    Puts($"Player {disarmingPlayer.displayName} has disarmed a landmine trap.");
    
    if (disarmingPlayer.IsAdmin)
    {
        Puts($"Admin {disarmingPlayer.displayName} disarmed the trap without consequences.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if (rpc.player.net.ID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			if (UnityEngine.Random.Range(0, 100) < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## OnEntityDistanceCheck(BaseEntity,BasePlayer,uint,string,float)

```csharp
```csharp
/// <summary>
/// Called to check if a player is within a specified distance from an entity.
/// </summary>
/// <param name="entity">The entity to check the distance from.</param>
/// <param name="player">The player whose distance from the entity is being checked.</param>
/// <param name="id">An identifier for the distance check operation.</param>
/// <param name="debugName">A name for debugging purposes.</param>
/// <param name="maximumDistance">The maximum allowable distance from the entity.</param>
/// <returns>
/// Returns `true` if the player is within the maximum distance from the entity; otherwise, returns `false`.
/// If the method returns `null`, the default distance check logic will be used.
/// </returns>
bool? OnEntityDistanceCheck(BaseEntity entity, BasePlayer player, uint id, string debugName, float maximumDistance)
{
    Puts($"Checking distance for Player {player.displayName} (ID: {player.UserIDString}) from Entity {entity?.name} with ID: {id}.");

    if (maximumDistance < 0)
    {
        Puts("Maximum distance cannot be negative.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityDistanceCheck", ent, player, id, debugName, maximumDistance);
				if (obj is bool)
				{
					return (bool)obj;
				}
				return ent.Distance(player.eyes.position) <= maximumDistance;
			}

```

## OnTurretRotate(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an auto turret rotates, typically in response to player interaction.
/// </summary>
/// <param name="turret">The auto turret that is rotating.</param>
/// <param name="player">The player who triggered the turret rotation.</param>
/// <returns>
/// Returns `null` to allow the turret to rotate, or any non-null value to prevent the rotation.
/// </returns>
object OnTurretRotate(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.net.ID} is rotating due to player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone; turret rotation is blocked.");
        return "Turret rotation is not allowed in safe zones.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void FlipAim(RPCMessage rpc)
	{
		if (!IsOnline() && IsAuthed(rpc.player) && !booting && Interface.CallHook("OnTurretRotate", this, rpc.player) == null)
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnEntityMarkHostile(BaseCombatEntity,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile for a specified duration.
/// </summary>
/// <param name="entity">The entity that is being marked as hostile.</param>
/// <param name="duration">The duration in seconds for which the entity is marked hostile.</param>
/// <returns>No return behavior.</returns>
void OnEntityMarkHostile(BaseCombatEntity entity, float duration)
{
    Puts($"Entity {entity.net.ID} marked as hostile for {duration} seconds.");
    
    if (duration > 120f)
    {
        Puts($"Warning: Entity {entity.net.ID} is marked hostile for an unusually long duration.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			float b = UnityEngine.Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, b);
		}
	}

```

## OnPlayerRevive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is revived by another player.
/// </summary>
/// <param name="reviver">The player who is reviving another player.</param>
/// <param name="target">The player being revived.</param>
/// <returns>
/// Returns `null` to allow the revival process to continue, or any non-null value to prevent the revival.
/// </returns>
object OnPlayerRevive(BasePlayer reviver, BasePlayer target)
{
    Puts($"Player {reviver.displayName} is attempting to revive {target.displayName}.");

    if (target.health < 50)
    {
        Puts($"Revival failed: {target.displayName} has too low health.");
        return "Revival failed: Health too low.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (player != ownerPlayer && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				player.StopWounded(ownerPlayer);
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## OnPlayerKicked(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="connection">The connection of the player being kicked.</param>
/// <param name="reason">The reason for the kick.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(Network.Connection connection, string reason)
{
    Puts($"Player {connection.username} (ID: {connection.userid}) has been kicked. Reason: {reason}");
    
    if (reason.Contains("EAC"))
    {
        Puts($"Player {connection.username} was kicked due to anti-cheat violation.");
    }
}
```
```

### Source Code from the Library

```csharp

	private static void HandleClientUpdate(ClientStatusUpdate<EasyAntiCheat.Server.Hydra.Client> clientStatus)
	{
		using (TimeWarning.New("AntiCheatKickPlayer", 10))
		{
			EasyAntiCheat.Server.Hydra.Client client = clientStatus.Client;
			Connection connection = GetConnection(client);
			if (connection == null)
			{
				Debug.LogError("EAC status update for invalid client: " + client.ClientID);
			}
			else
			{
				if (ShouldIgnore(connection))
				{
					return;
				}
				if (clientStatus.RequiresKick)
				{
					string text = clientStatus.Message;
					if (string.IsNullOrEmpty(text))
					{
						text = clientStatus.Status.ToString();
					}
					Debug.Log($"[EAC] Kicking {connection.userid} / {connection.username} ({text})");
					connection.authStatus = "eac";
					Network.Net.sv.Kick(connection, "EAC: " + text);
					Interface.CallHook("OnPlayerKicked", connection, text);
					if (clientStatus.IsBanned(out var timeBanExpires))
					{
						connection.authStatus = "eacbanned";
						object[] args = new object[3]
						{
							2,
							0,
							"<color=#fff>SERVER</color> Kicking " + connection.username + " (banned by anticheat)"
						};
						Interface.CallHook("OnPlayerBanned", connection, text);
						ConsoleNetwork.BroadcastToAllClients("chat.add", args);
						if (!timeBanExpires.HasValue)
						{
							Entity.DeleteBy(connection.userid);
						}
					}
					easyAntiCheat.UnregisterClient(client);
					client2connection.Remove(client);
					connection2client.Remove(connection);
					connection2status.Remove(connection);
				}
				else if (clientStatus.Status == ClientStatus.ClientAuthenticatedLocal)
				{
					OnAuthenticatedLocal(connection);
					easyAntiCheat.SetClientNetworkState(client, networkActive: false);
				}
				else if (clientStatus.Status == ClientStatus.ClientAuthenticatedRemote)
				{
					OnAuthenticatedRemote(connection);
				}
			}
		}
	}

```

## OnNpcRadioChatter(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC plays radio chatter.
/// </summary>
/// <param name="npc">The NPC that is playing the radio chatter.</param>
/// <returns>
/// Returns `null` to allow the radio chatter to play, or any non-null value to prevent it from playing.
/// </returns>
object OnNpcRadioChatter(ScientistNPC npc)
{
    Puts($"NPC {npc.displayName} is attempting to play radio chatter.");
    
    // Example condition to prevent chatter
    if (npc.IsInCombat)
    {
        Puts($"NPC {npc.displayName} is in combat and cannot play radio chatter.");
        return true; // Prevents chatter
    }
    
    return null; // Allows chatter
}
```
```

### Source Code from the Library

```csharp

	public void PlayRadioChatter()
	{
		if (RadioChatterEffects.Length != 0)
		{
			if (base.IsDestroyed || base.transform == null)
			{
				CancelInvoke(PlayRadioChatter);
			}
			else if (Interface.CallHook("OnNpcRadioChatter", this) == null)
			{
				Effect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				QueueRadioChatter();
			}
		}
	}

```

## OnAmmoUnload(BaseProjectile,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player unloads ammo from a projectile weapon.
/// </summary>
/// <param name="projectile">The projectile weapon from which ammo is being unloaded.</param>
/// <param name="item">The item representing the ammo being unloaded.</param>
/// <param name="player">The player performing the unload action.</param>
/// <returns>
/// Returns a non-null value to prevent the ammo from being unloaded. 
/// If `null` is returned, the ammo unload proceeds as normal.
/// </returns>
object OnAmmoUnload(BaseProjectile projectile, Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to unload ammo from {projectile.info.displayName.english}.");

    if (projectile.primaryMagazine.contents == 0)
    {
        Puts($"No ammo to unload from {projectile.info.displayName.english}.");
        return "No ammo to unload.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UnloadAmmo(Item item, BasePlayer player)
	{
		BaseProjectile component = item.GetHeldEntity().GetComponent<BaseProjectile>();
		if (!component.canUnloadAmmo || Interface.CallHook("OnAmmoUnload", component, item, player) != null || !component)
		{
			return;
		}
		int contents = component.primaryMagazine.contents;
		if (contents > 0)
		{
			component.primaryMagazine.contents = 0;
			SendNetworkUpdateImmediate();
			Item item2 = ItemManager.Create(component.primaryMagazine.ammoType, contents, 0uL);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
		}
	}

```

## OnPlayerRecovered(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from a wounded state.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecovered(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has recovered from being wounded.");
    
    // Additional logic can be added here, such as notifying other players or updating stats.
}
```
```

### Source Code from the Library

```csharp

	private void WoundingTick()
	{
		using (TimeWarning.New("WoundingTick"))
		{
			if (IsDead())
			{
				return;
			}
			if (secondsSinceWoundedStarted >= woundedDuration)
			{
				if (UnityEngine.Random.Range(0, 100) < 20)
				{
					RecoverFromWounded();
					Interface.CallHook("OnPlayerRecovered", this);
				}
				else
				{
					Die();
				}
			}
			else
			{
				Invoke(WoundingTick, 1f);
			}
		}
	}

```

## OnEntityControl(RemoteControlEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an entity can be controlled by a player or system.
/// </summary>
/// <param name="entity">The entity that is being controlled.</param>
/// <returns>
/// Returns `true` if the entity can be controlled; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine control permissions.
/// </returns>
bool? OnEntityControl(RemoteControlEntity entity)
{
    Puts($"Attempting to control entity: {entity.net.ID} of type {entity.GetType().Name}.");

    if (entity.IsLocked)
    {
        Puts($"Entity {entity.net.ID} is locked and cannot be controlled.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl()
	{
		object obj = Interface.CallHook("OnEntityControl", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnNetworkGroupEntered(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network group is entered by a networkable entity.
/// </summary>
/// <param name="entity">The networkable entity that entered the group.</param>
/// <param name="group">The network visibility group that was entered.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupEntered(BaseNetworkable entity, Network.Visibility.Group group)
{
    Puts($"Entity {entity.net.ID} has entered the network group: {group.name}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", this, group);
	}

```

## OnSleepingBagDestroy(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is about to be destroyed.
/// </summary>
/// <param name="sleepingBag">The sleeping bag that is being destroyed.</param>
/// <param name="player">The player attempting to destroy the sleeping bag.</param>
/// <returns>
/// Returns a non-null value to prevent the destruction of the sleeping bag. 
/// If `null` is returned, the sleeping bag will be destroyed as normal.
/// </returns>
object OnSleepingBagDestroy(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to destroy sleeping bag owned by {sleepingBag.deployerUserID}.");
    
    if (sleepingBag.canBePublic)
    {
        Puts($"Sleeping bag {sleepingBag.net.ID} is public and cannot be destroyed.");
        return "This sleeping bag is public and cannot be destroyed.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(BasePlayer player, uint sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, player) != null)
		{
			return false;
		}
		if (sleepingBag2.canBePublic)
		{
			sleepingBag2.SetPublic(isPublic: true);
			sleepingBag2.deployerUserID = 0uL;
		}
		else
		{
			sleepingBag2.Kill();
		}
		player.SendRespawnOptions();
		Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, player);
		return true;
	}

```

## CanStackItem(Item,Item)

```csharp
```csharp
/// <summary>
/// Determines whether two items can be stacked together in the inventory.
/// </summary>
/// <param name="item">The item to check for stacking compatibility.</param>
/// <returns>
/// Returns `true` if the items can be stacked; otherwise, returns `false`. 
/// If the method returns `null`, the default stacking logic will be applied.
/// </returns>
bool? CanStackItem(Item item)
{
    Puts($"Checking if item {this.info.displayName.english} can stack with {item.info.displayName.english}.");

    if (item.info.itemid != this.info.itemid)
    {
        Puts("Items have different IDs and cannot stack.");
        return false;
    }

    if (item.skin != this.skin)
    {
        Puts("Items have different skins and cannot stack.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (info.stackable <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != item.info.condition.max)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.info.condition.max)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		if (item.skin != skin)
		{
			return false;
		}
		if (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			int num2 = ((instanceData != null) ? instanceData.dataInt : (-1));
			if (num != num2)
			{
				return false;
			}
		}
		return true;
	}

```

## OnDieselEngineToggled(DieselEngine)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled off.
/// </summary>
/// <param name="engine">The diesel engine that has been toggled.</param>
/// <returns>No return behavior.</returns>
void OnDieselEngineToggled(DieselEngine engine)
{
    Puts($"Diesel engine {engine.net.ID} has been toggled off.");
}
```
```

### Source Code from the Library

```csharp

	public void EngineOff()
	{
		SetFlag(Flags.On, b: false);
		BroadcastEntityMessage("DieselEngineOff");
		Interface.CallHook("OnDieselEngineToggled", this);
	}

```

## OnLootEntityEnd(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The dropped item container that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, DroppedItemContainer container)
{
    Puts($"Player {player.displayName} has stopped looting the container with ID: {container.net.ID}.");
    
    if (container.inventory != null && container.inventory.itemList.Count > 0)
    {
        Puts($"Container still has items: {container.inventory.itemList.Count} items remaining.");
    }
    else
    {
        Puts("Container is empty and will be removed.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		if (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)
		{
			Kill();
			return;
		}
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
```csharp
/// <summary>
/// Called to determine if two dropped items can be combined into one.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>
/// Returns `true` if the items can be combined, or `false` if they cannot. 
/// If the method returns `null`, the default game logic will determine if the items can be combined.
/// </returns>
object CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts($"Checking if items {item1.item.info.displayName.english} and {item2.item.info.displayName.english} can be combined.");

    if (item1.item.info.stackable <= 1 || item2.item.info.stackable <= 1)
    {
        Puts("One of the items is not stackable.");
        return false;
    }

    if (item1.item.info != item2.item.info)
    {
        Puts("Items have different types and cannot be combined.");
        return false;
    }

    return null; // Allow default logic to determine if they can be combined
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || item.info.stackable <= 1 || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null && di.item.info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
			int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			if (num != num2)
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.info.stackable && num3 != 0)
		{
			di.DestroyItem();
			di.Kill();
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
		}
	}

```

## OnDefaultItemsReceived(PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when default items are given to a player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory receiving the default items.</param>
/// <returns>No return behavior.</returns>
void OnDefaultItemsReceived(PlayerInventory inventory)
{
    Puts($"Default items have been received by player with ID: {inventory.OwnerID}.");
}
```
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		ulong skin = 0uL;
		int infoInt = base.baseEntity.GetInfoInt("client.rockskin", 0);
		if (infoInt > 0 && base.baseEntity.blueprints.steamInventory.HasItem(infoInt))
		{
			IPlayerItemDefinition itemDefinition = PlatformService.Instance.GetItemDefinition(infoInt);
			if (itemDefinition != null)
			{
				skin = itemDefinition.WorkshopDownload;
			}
		}
		GiveItem(ItemManager.CreateByName("rock", 1, skin), containerBelt);
		GiveItem(ItemManager.CreateByName("torch", 1, 0uL), containerBelt);
		if (IsBirthday())
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas())
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
	}

```

## IOnPlayerCommand(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player issues a command in the chat.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The command that was issued by the player.</param>
/// <returns>
/// Returns `false` if the command is not valid or if the player is muted or banned. 
/// If the command is valid, it returns `true` or allows further processing based on hooks.
/// </returns>
bool IOnPlayerCommand(BasePlayer player, string command)
{
    Puts($"Player {player.displayName} issued command: {command}");

    if (command.StartsWith("/"))
    {
        Puts($"Command {command} is being processed.");
        // Further command processing logic can be added here
        return true;
    }

    return false;
}
```
```

### Source Code from the Library

```csharp

	internal static bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)
	{
		if (!player)
		{
			player = null;
		}
		if (!enabled)
		{
			return false;
		}
		if (player != null && player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return false;
		}
		ServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;
		if (userGroup == ServerUsers.UserGroup.Banned)
		{
			return false;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0)
		{
			return false;
		}
		if (text.StartsWith("/") || text.StartsWith("\\"))
		{
			Interface.CallHook("IOnPlayerCommand", player, message);
			return false;
		}
		text = text.EscapeRichText();
		object obj = Interface.CallHook("IOnPlayerChat", userId, username, text, targetChannel, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured(ConsoleColor.DarkYellow, string.Concat("[", targetChannel, "] ", username, ": "), ConsoleColor.DarkGreen, text);
			string text2 = player?.ToString() ?? $"{username}[{userId}]";
			if (targetChannel == ChatChannel.Team)
			{
				DebugEx.Log("[TEAM CHAT] " + text2 + " : " + text);
			}
			else
			{
				DebugEx.Log("[CHAT] " + text2 + " : " + text);
			}
		}
		bool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;
		bool num = ((player != null) ? player.IsDeveloper : DeveloperList.Contains(userId));
		string text3 = "#5af";
		if (flag)
		{
			text3 = "#af5";
		}
		if (num)
		{
			text3 = "#fa5";
		}
		string text4 = username.EscapeRichText();
		ChatEntry chatEntry = default(ChatEntry);
		chatEntry.Channel = targetChannel;
		chatEntry.Message = text;
		chatEntry.UserId = ((player != null) ? player.UserIDString : userId.ToString());
		chatEntry.Username = username;
		chatEntry.Color = text3;
		chatEntry.Time = Epoch.Current;
		ChatEntry chatEntry2 = chatEntry;
		History.Add(chatEntry2);
		RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		switch (targetChannel)
		{
		case ChatChannel.Global:
			if (Server.globalchat)
			{
				ConsoleNetwork.BroadcastToAllClients("chat.add2", 0, userId, text, text4, text3, 1f);
				return true;
			}
			break;
		case ChatChannel.Team:
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindPlayersTeam(userId);
			if (playerTeam == null)
			{
				return false;
			}
			List<Network.Connection> onlineMemberConnections = playerTeam.GetOnlineMemberConnections();
			if (onlineMemberConnections != null)
			{
				ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add2", 1, userId, text, text4, text3, 1f);
			}
			playerTeam.BroadcastTeamChat(userId, text4, text, text3);
			return true;
		}
		}
		if (player != null)
		{
			float num2 = 2500f;
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				float sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;
				if (!(sqrMagnitude > num2))
				{
					ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", 0, userId, text, text4, text3, Mathf.Clamp01(num2 - sqrMagnitude + 0.2f));
				}
			}
			return true;
		}
		return false;
	}

```

## IOnNpcTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine the NPC's desire to attack a given target.
/// </summary>
/// <param name="npc">The NPC that is evaluating the target.</param>
/// <param name="target">The target entity that may be attacked.</param>
/// <returns>
/// Returns a float representing the NPC's desire to attack the target. 
/// A value of `0` means the NPC does not want to attack, while a value of `1` indicates a strong desire to attack.
/// If the method returns `null`, the default logic will be used to determine the attack desire.
/// </returns>
float? IOnNpcTarget(NPCPlayerApex npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is evaluating target: {target?.ShortPrefabName ?? "null"}");

    if (target is PlayerEntity)
    {
        Puts($"NPC {npc.displayName} has identified a player as a target.");
        return 1f; // Strong desire to attack players
    }

    return null; // Use default logic
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		if (target == null)
		{
			return 0f;
		}
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
		{
			return 0f;
		}
		if (target.GetType() == GetType())
		{
			return 0f;
		}
		if (target.Health() <= 0f)
		{
			return 0f;
		}
		return 1f;
	}

```

## OnTurretModeToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the turret mode is toggled on or off.
/// </summary>
/// <param name="turret">The turret whose mode is being toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretModeToggle(AutoTurret turret)
{
    Puts($"Turret {turret.net.ID} mode toggled. Current mode: {(turret.PeacekeeperMode() ? "Peacekeeper" : "Standard")}");
}
```
```

### Source Code from the Library

```csharp

	public void SetPeacekeepermode(bool isOn)
	{
		if (PeacekeeperMode() != isOn)
		{
			SetFlag(Flags.Reserved1, isOn);
			Effect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnTurretModeToggle", this);
		}
	}

```

## OnEntityLeave(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the comfort trigger area.
/// </summary>
/// <param name="entity">The entity that has left the trigger area.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity?.name} has left the comfort trigger area.");
    if (entity is BasePlayer player)
    {
        Puts($"Player {player.displayName} has exited the comfort zone.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityLeave(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			_players.Remove(basePlayer);
		}
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is patrolling its designated path.
/// </summary>
/// <param name="apc">The Bradley APC that is currently patrolling.</param>
/// <returns>
/// Returns `null` to allow the APC to continue its patrol. 
/// If a non-null value is returned, it will interrupt the patrol behavior.
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC (ID: {apc.net.ID}) is currently patrolling.");
    
    // Example condition to stop the patrol
    if (apc.IsUnderAttack())
    {
        Puts("Bradley APC is under attack and will stop patrolling.");
        return true; // Stop the patrol
    }
    
    return null; // Continue patrolling
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		PathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		BasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);
		BasePathNode basePathNode = null;
		bool flag = false;
		List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			basePathNode = nodes[nodes.Count - 1];
		}
		else
		{
			basePathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) > 2f))
		{
			return;
		}
		if (closestToPoint == basePathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.transform.position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
		else
		{
			if (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].transform.position);
				}
			}
			foreach (BasePathNode item in path)
			{
				currentPath.Add(item.transform.position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
	}

```

## OnItemScrap(ResearchTable,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is scrapped for research purposes.
/// </summary>
/// <param name="researchTable">The research table where the item is being scrapped.</param>
/// <param name="item">The item being scrapped.</param>
/// <returns>
/// Returns the amount of scrap received from scrapping the item. 
/// If the method returns a non-null integer, that value will be used instead of the default calculation.
/// </returns>
int OnItemScrap(ResearchTable researchTable, Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) is being scrapped at the research table.");

    if (item.info.shortname == "special.item")
    {
        Puts("Special item scrapped for double scrap!");
        return 1000; // Special case for a specific item
    }

    return 0; // Default return if no specific case is matched
}
```
```

### Source Code from the Library

```csharp

	public int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnItemScrap", this, item);
		if (obj is int)
		{
			return (int)obj;
		}
		int result = 0;
		if (item.info.rarity == Rarity.Common)
		{
			result = 20;
		}
		if (item.info.rarity == Rarity.Uncommon)
		{
			result = 75;
		}
		if (item.info.rarity == Rarity.Rare)
		{
			result = 125;
		}
		if (item.info.rarity == Rarity.VeryRare || item.info.rarity == Rarity.None)
		{
			result = 500;
		}
		return result;
	}

```

## OnPlayerRecover(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from a wounded state.
/// </summary>
/// <param name="player">The player who is recovering.</param>
/// <param name="source">The player who initiated the recovery, if applicable.</param>
/// <returns>
/// Returns a non-null value to prevent the recovery process, or `null` to allow it.
/// </returns>
object OnPlayerRecover(BasePlayer player, BasePlayer source)
{
    Puts($"Player {player.displayName} is attempting to recover from being wounded. Source: {source?.displayName ?? "None"}");

    if (player.health < 50)
    {
        Puts($"Player {player.displayName} cannot recover due to low health.");
        return "Health too low to recover.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopWounded(BasePlayer source = null)
	{
		if (IsDead() || Interface.CallHook("OnPlayerRecover", this, source) != null)
		{
			return;
		}
		RecoverFromWounded();
		CancelInvoke(WoundingTick);
		if (EACServer.playerTracker == null || net.connection == null || !(source != null) || source.net.connection == null)
		{
			return;
		}
		using (TimeWarning.New("playerTracker.LogPlayerRevive"))
		{
			EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
			EasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(source.net.connection);
			EACServer.playerTracker.LogPlayerRevive(client, client2);
		}
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player finishes sleeping.
/// </summary>
/// <param name="player">The player who has ended their sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has woken up from sleep.");
    
    // Additional logic can be added here, such as notifying other players or updating game state.
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (!IsSleeping())
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.Sleeping, b: false);
		sleepStartTime = -1f;
		sleepingPlayerList.Remove(this);
		CancelInvoke(ScheduledDeath);
		InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
		if (RelationshipManager.TeamsEnabled())
		{
			InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
		}
		EnablePlayerCollider();
		AddPlayerRigidbody();
		EnableServerFall(wantsOn: false);
		if (HasParent())
		{
			SetParent(null, worldPositionStays: true);
			ForceUpdateTriggers();
		}
		inventory.containerMain.OnChanged();
		inventory.containerBelt.OnChanged();
		inventory.containerWear.OnChanged();
		Interface.CallHook("OnPlayerSleepEnded", this);
		if (EACServer.playerTracker == null || net.connection == null)
		{
			return;
		}
		using (TimeWarning.New("playerTracker.LogPlayerSpawn"))
		{
			EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
			EACServer.playerTracker.LogPlayerSpawn(client, 0, 0);
		}
	}

```

## OnEntityDeath(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a resource entity is killed.
/// </summary>
/// <param name="entity">The resource entity that has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(ResourceEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.name} has been killed. Hit information: {hitInfo.damageTypes.GetTotal()} damage.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnKilled(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", this, info);
		Kill();
	}

```

## OnNpcStopMoving(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC stops moving.
/// </summary>
/// <param name="npc">The NPC that has stopped moving.</param>
/// <returns>No return behavior.</returns>
void OnNpcStopMoving(NPCPlayerApex npc)
{
    Puts($"NPC {npc.displayName} has stopped moving at position: {npc.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public void StopMoving()
	{
		if (Interface.CallHook("OnNpcStopMoving", this) == null)
		{
			IsStopped = true;
			finalDestination = GetPosition();
		}
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when a mining quarry gathers resources.
/// </summary>
/// <param name="quarry">The mining quarry that is gathering resources.</param>
/// <param name="item">The item that has been gathered by the quarry.</param>
/// <returns>No return behavior.</returns>
void OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts($"Mining Quarry at {quarry.transform.position} has gathered {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "stone")
    {
        Puts("Stone has been gathered, ensure proper storage!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			resource.workDone += workToAdd;
			if (!(resource.workDone < resource.workNeeded))
			{
				int num = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
				resource.workDone -= (float)num * resource.workNeeded;
				Item item = ItemManager.Create(resource.type, num, 0uL);
				if (Interface.CallHook("OnQuarryGather", this, item) != null)
				{
					item.Remove();
				}
				else if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
	}

```

## OnVehicleModuleSelect(Item,ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is selected by a player.
/// </summary>
/// <param name="item">The vehicle item that represents the module being selected.</param>
/// <param name="garage">The modular car garage that contains the vehicle.</param>
/// <param name="player">The player who selected the vehicle module.</param>
/// <returns>
/// Returns a non-null value to prevent the selection action, or `null` to allow it.
/// </returns>
object OnVehicleModuleSelect(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.displayName} selected module: {item.info.displayName.english} from garage: {garage.net.ID}.");

    if (item.info.shortname == "engine")
    {
        Puts($"Player {player.displayName} cannot select the engine module.");
        return "You cannot select the engine module.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		uint itemUID = msg.read.UInt32();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result) && result is VehicleModuleStorage vehicleModuleStorage)
		{
			IItemContainerEntity container = vehicleModuleStorage.GetContainer();
			if (!ObjectEx.IsUnityNull(container))
			{
				player.inventory.loot.AddContainer(container.inventory);
				flag = true;
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## CanLootEntity(BasePlayer,ContainerIOEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity that is being looted.</param>
/// <returns>
/// Returns `true` if the player is allowed to loot the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, ContainerIOEntity entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot entity: {entity.name}.");

    if (entity.IsLocked())
    {
        Puts($"Entity {entity.name} is locked and cannot be looted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (needsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = lootPanelName;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnEntityFromOwnerCheck(BaseEntity,BasePlayer,uint,string)

```csharp
```csharp
/// <summary>
/// Called to check if a player is the owner of a specific entity.
/// </summary>
/// <param name="entityId">The unique identifier of the entity.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <param name="entity">The entity being checked.</param>
/// <param name="player">The player attempting to access the entity.</param>
/// <returns>
/// Returns `true` if the player is the owner of the entity, `false` if not, 
/// or `null` if the default ownership logic should be applied.
/// </returns>
bool? OnEntityFromOwnerCheck(uint entityId, string debugName, BaseEntity entity, BasePlayer player)
{
    Puts($"Checking ownership for Entity ID: {entityId}, Debug Name: {debugName}, Player: {player.displayName}");

    if (entity == null || player == null)
    {
        Puts("Entity or Player is null, returning false.");
        return false;
    }

    if (entity.net.ID == player.net.ID)
    {
        Puts($"Player {player.displayName} is the owner of the entity.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityFromOwnerCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				return true;
			}

```

## OnEntityMarkHostile(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player entity is marked as hostile for a specified duration.
/// </summary>
/// <param name="player">The player entity being marked as hostile.</param>
/// <param name="duration">The duration in seconds for which the player is marked hostile.</param>
/// <returns>No return behavior.</returns>
void OnEntityMarkHostile(BasePlayer player, float duration)
{
    Puts($"Player {player.displayName} has been marked hostile for {duration} seconds.");
    
    if (duration > 120f)
    {
        Puts($"Warning: Player {player.displayName} is marked hostile for an unusually long duration.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			double currentTimestamp = TimeEx.currentTimestamp;
			double val = currentTimestamp + (double)duration;
			State.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);
			DirtyPlayerState();
			double num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);
			ClientRPCPlayer(null, this, "SetHostileLength", (float)num);
		}
	}

```

## OnMapMarkerRemove(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player removes a map marker from their map.
/// </summary>
/// <param name="player">The player who is removing the map marker.</param>
/// <param name="mapNote">The map note that is being removed.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkerRemove(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has removed a map marker: {mapNote.title}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void Server_RemovePointOfInterest(RPCMessage msg)
	{
		if (ServerCurrentMapNote != null && Interface.CallHook("OnMapMarkerRemove", this, ServerCurrentMapNote) == null)
		{
			ServerCurrentMapNote.Dispose();
			ServerCurrentMapNote = null;
			DirtyPlayerState();
			TeamUpdate();
		}
	}

```

## OnSendModelState(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the model state of a player needs to be sent to clients.
/// </summary>
/// <param name="player">The player whose model state is being sent.</param>
/// <returns>No return behavior.</returns>
void OnSendModelState(BasePlayer player)
{
    Puts($"Sending model state for player: {player.displayName} (ID: {player.UserIDString})");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	private void SendModelState()
	{
		if (!wantsSendModelState || nextModelStateUpdate > UnityEngine.Time.time)
		{
			return;
		}
		wantsSendModelState = false;
		nextModelStateUpdate = UnityEngine.Time.time + 0.1f;
		if (!IsDead() && !IsSpectating())
		{
			modelState.sleeping = IsSleeping();
			modelState.mounted = isMounted;
			modelState.relaxed = IsRelaxed();
			modelState.onPhone = HasActiveTelephone;
			if (!base.limitNetworking && Interface.CallHook("OnSendModelState", this) == null)
			{
				ClientRPC(null, "OnModelState", modelState);
			}
		}
	}

```

## CanVendingAcceptItem(VendingMachine,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether a vending machine can accept a specific item for a given slot.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being offered to the vending machine.</param>
/// <param name="targetSlot">The slot in the vending machine where the item is to be placed.</param>
/// <returns>
/// Returns `true` if the item can be accepted, `false` if it cannot, 
/// or `null` if the default acceptance logic should be applied.
/// </returns>
bool? CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)
{
    Puts($"Checking if vending machine can accept item: {item.info.displayName.english} (ID: {item.info.itemid}) for slot {targetSlot}.");

    if (item.info.itemid == 12345) // Example item ID that is not accepted
    {
        Puts("This item is not accepted by the vending machine.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if (transactionActive)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (base.inventory.itemList.Contains(item))
		{
			return true;
		}
		if (ownerPlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(ownerPlayer);
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container to which the item is being added.</param>
/// <param name="item">The item that is being added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) has been added to container {container.name}.");
    
    if (item.info.itemid == 12345) // Example item ID for a special item
    {
        Puts("A special item has been added to the container!");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## CanLock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can lock a code lock.
/// </summary>
/// <param name="player">The player attempting to lock the code lock.</param>
/// <param name="codeLock">The code lock being locked.</param>
/// <returns>
/// Returns `null` to allow the locking action, or any non-null value to prevent it.
/// </returns>
object CanLock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to lock the code lock.");

    if (player.IsBannedFromLocking)
    {
        Puts($"Player {player.displayName} is banned from locking.");
        return "You are not allowed to lock this.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", rpc.player, this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnCrateDropped(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate is dropped in the game world.
/// </summary>
/// <param name="crate">The hackable locked crate that has been dropped.</param>
/// <returns>No return behavior.</returns>
void OnCrateDropped(HackableLockedCrate crate)
{
    Puts($"A hackable locked crate has been dropped at position: {crate.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", this);
	}

```

## OnSendCommand(Network.Connection,string,object[])

```csharp
```csharp
/// <summary>
/// Called when a command is sent to a client.
/// </summary>
/// <param name="connection">The connection of the client receiving the command.</param>
/// <param name="command">The command being sent to the client.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>No return behavior.</returns>
void OnSendCommand(Network.Connection connection, string command, object[] args)
{
    Puts($"Command '{command}' sent to client with connection ID: {connection.userid}.");
    
    if (command == "kick")
    {
        Puts($"Warning: A kick command was sent to connection ID: {connection.userid}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(Connection cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected())
		{
			Interface.CallHook("OnSendCommand", cn, strCommand, args);
			Network.Net.sv.write.Start();
			Network.Net.sv.write.PacketID(Message.Type.ConsoleCommand);
			Network.Net.sv.write.String(ConsoleSystem.BuildCommand(strCommand, args));
			Network.Net.sv.write.Send(new SendInfo(cn));
		}
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
```csharp
/// <summary>
/// Determines whether a specified combat entity can be targeted by an auto turret.
/// </summary>
/// <param name="target">The combat entity that is being checked for targeting.</param>
/// <param name="turret">The auto turret attempting to target the entity.</param>
/// <returns>
/// Returns `true` if the entity can be targeted; otherwise, returns `false`. 
/// If the method returns `null`, the default targeting logic will be applied.
/// </returns>
bool? CanBeTargeted(BaseCombatEntity target, AutoTurret turret)
{
    Puts($"Checking if {target.displayName} can be targeted by turret {turret.net.ID}.");

    if (target.IsDead())
    {
        Puts($"Target {target.displayName} is dead and cannot be targeted.");
        return false;
    }

    if (target.IsInSafeZone())
    {
        Puts($"Target {target.displayName} is in a safe zone and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.GetList<RaycastHit>();
		Vector3 position = eyePos.transform.position;
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);
		for (int i = 0; (float)i < (CheckPeekers() ? 3f : 1f); i++)
		{
			Vector3 normalized = (vector + vector2 * visibilityOffsets[i] - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);
			for (int j = 0; j < obj3.Count; j++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);
				if ((!(entity != null) || !entity.isClient) && (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) && (!(entity != null) || !entity.EqualNetID(this)))
				{
					if (entity != null && (entity == obj || entity.EqualNetID(obj)))
					{
						Facepunch.Pool.FreeList(ref obj3);
						peekIndex = i;
						return true;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj3);
		return false;
	}

```

## OnReloadWeapon(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player starts reloading a weapon.
/// </summary>
/// <param name="player">The player who is reloading the weapon.</param>
/// <param name="projectile">The projectile being reloaded.</param>
/// <returns>
/// Returns `null` to allow the reload to proceed, or any non-null value to prevent the reload action.
/// </returns>
object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to reload the weapon: {projectile.info.displayName.english}.");

    if (player.inventory.GetAmount(projectile.primaryMagazine.ammoType.itemid) <= 0)
    {
        Puts($"Player {player.displayName} cannot reload because they have no ammo.");
        return "No ammo available for reload.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnReloadWeapon", player, this) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			fractionalInsertCounter = 0;
			primaryMagazine.SwitchAmmoTypesIfNeeded(player);
			StartReloadCooldown(GetReloadDuration());
		}
	}

```

## IOnNpcSenseClose(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses entities in close range.
/// </summary>
/// <param name="npc">The NPC that is sensing nearby entities.</param>
/// <returns>
/// Returns a non-null value to prevent the default sensing behavior. 
/// If `null` is returned, the NPC will proceed to find entities in close range.
/// </returns>
object IOnNpcSenseClose(NPCPlayerApex npc)
{
    Puts($"NPC {npc.displayName} is sensing nearby entities.");
    
    // Example condition to prevent sensing
    if (npc.IsInStealthMode)
    {
        Puts($"NPC {npc.displayName} is in stealth mode and cannot sense nearby entities.");
        return true; // Prevents further processing
    }
    
    return null; // Allows the default behavior
}
```
```

### Source Code from the Library

```csharp

	private void _FindEntitiesInCloseRange()
	{
		if (Interface.CallHook("IOnNpcSenseClose", this) != null)
		{
			return;
		}
		EntityQueryResultCount = Query.Server.GetInSphere(base.transform.position, Stats.CloseRange, EntityQueryResults, delegate(BaseEntity entity)
		{
			if (entity == null || !entity.isServer || entity.IsDestroyed)
			{
				return false;
			}
			return (entity is BaseNpc || entity is TimedExplosive) ? true : false;
		});
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base player is attacked.
/// </summary>
/// <param name="attacker">The player or entity that initiated the attack.</param>
/// <param name="hitInfo">Information about the hit, including damage and hit location.</param>
/// <returns>
/// Returns a non-null value to prevent further processing of the attack. 
/// If `null` is returned, the default attack handling will proceed.
/// </returns>
object IOnBasePlayerAttacked(BasePlayer attacker, HitInfo hitInfo)
{
    Puts($"Player {attacker.displayName} attacked {this.displayName} with damage type: {hitInfo.damageTypes.GetTotal()}.");

    if (attacker.IsInCreativeMode)
    {
        Puts($"Attack from {attacker.displayName} is ignored due to creative mode.");
        return true; // Prevents the attack from affecting the player
    }

    return null; // Allow the default processing of the attack
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float health_old = base.health;
		if (InSafeZone() && !IsHostile() && info.Initiator != null && info.Initiator != this)
		{
			info.damageTypes.ScaleAll(0f);
		}
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.GetList<Item>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortal())
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			if (isMounted)
			{
				GetMounted().MounteeTookDamage(this, info);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				Effect effect = new Effect();
				effect.Init(Effect.Type.Generic, base.transform.position, base.transform.forward);
				effect.pooledString = "assets/bundled/prefabs/fx/takedamage_hit.prefab";
				EffectNetwork.Send(effect, net.connection);
			}
			string text = StringPool.Get(info.HitBone);
			bool flag = UnityEngine.Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) > 0.4f;
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer && !info.damageTypes.IsMeleeType())
			{
				initiatorPlayer.LifeStoryShotHit(info.Weapon);
			}
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1, (Stats)5);
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.Log(info, health_old, base.health, "wounded");
			}
			else if (IsDead())
			{
				stats.combat.Log(info, health_old, base.health, "killed");
			}
			else
			{
				stats.combat.Log(info, health_old, base.health);
			}
		}
	}

```

## OnFlameThrowerBurn(FlameThrower,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a flame thrower burns an entity.
/// </summary>
/// <param name="flameThrower">The flame thrower that is causing the burn.</param>
/// <param name="target">The entity that is being burned.</param>
/// <returns>No return behavior.</returns>
void OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity target)
{
    Puts($"FlameThrower {flameThrower.net.ID} is burning entity {target.net.ID} ({target.ShortPrefabName}).");

    if (target is BasePlayer player)
    {
        Puts($"Warning: Player {player.displayName} is being burned by the flame thrower!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void FlameTick()
	{
		float num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;
		lastFlameTick = UnityEngine.Time.realtimeSinceStartup;
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		ReduceAmmo(num);
		SendNetworkUpdate();
		Ray ray = ownerPlayer.eyes.BodyRay();
		Vector3 origin = ray.origin;
		RaycastHit hitInfo;
		bool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);
		if (!num2)
		{
			hitInfo.point = origin + ray.direction * flameRange;
		}
		float num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);
		float amount = damagePerSec[0].amount;
		damagePerSec[0].amount = amount * num * num3;
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, 2279681, useLineOfSight: true);
		damagePerSec[0].amount = amount;
		if (num2 && UnityEngine.Time.realtimeSinceStartup >= nextFlameTime && hitInfo.distance > 1.1f)
		{
			nextFlameTime = UnityEngine.Time.realtimeSinceStartup + 0.45f;
			Vector3 point = hitInfo.point;
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, point - ray.direction * 0.25f);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnFlameThrowerBurn", this, baseEntity);
				baseEntity.creatorEntity = ownerPlayer;
				baseEntity.Spawn();
			}
		}
		if (ammo == 0)
		{
			SetFlameState(wantsOn: false);
		}
		GetOwnerItem()?.LoseCondition(num);
	}

```

## OnSamSiteTarget(SamSite,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when the SAM site detects a potential target.
/// </summary>
/// <param name="samSite">The SAM site that is scanning for targets.</param>
/// <param name="target">The potential target detected by the SAM site.</param>
/// <returns>
/// Returns `null` to allow the SAM site to engage the target, or any non-null value to prevent engagement.
/// </returns>
object OnSamSiteTarget(SamSite samSite, BaseCombatEntity target)
{
    Puts($"SAM Site {samSite.net.ID} detected target: {target.displayName} (ID: {target.net.ID})");

    if (target is BaseVehicle vehicle && vehicle.InSafeZone())
    {
        Puts($"Target {target.displayName} is in a safe zone. Engagement prevented.");
        return true; // Prevent engagement
    }

    return null; // Allow engagement
}
```
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (Time.time > lastTargetVisibleTime + 3f)
		{
			currentTarget = null;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<BaseCombatEntity> obj = Pool.GetList<BaseCombatEntity>();
		Vis.Entities(eyePoint.transform.position, scanRadius, obj, 32768, QueryTriggerInteraction.Ignore);
		BaseCombatEntity baseCombatEntity = null;
		foreach (BaseCombatEntity item in obj)
		{
			if (!item.isClient && !(EntityCenterPoint(item).y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, scanRadius * 2f) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				BaseVehicle component = item.GetComponent<BaseVehicle>();
				if ((staticRespawn || !(component != null) || !component.InSafeZone()) && (alltarget || (bool)item.GetComponent<HotAirBalloon>() || (bool)item.GetComponent<MiniCopter>()))
				{
					baseCombatEntity = item;
				}
			}
		}
		if (baseCombatEntity != null && currentTarget != baseCombatEntity)
		{
			lockOnTime = Time.time + 0.5f;
		}
		currentTarget = baseCombatEntity;
		if (currentTarget != null)
		{
			lastTargetVisibleTime = Time.time;
		}
		Pool.FreeList(ref obj);
		if (currentTarget == null)
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity, such as a corpse.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="lootableCorpse">The lootable entity being accessed.</param>
/// <returns>
/// Returns `true` if the player can loot the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot a corpse.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot loot while dead.");
        return false;
    }

    if (lootableCorpse.IsLooted())
    {
        Puts($"The corpse has already been looted by another player.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if ((bool)player && player.CanInteract() && CanLoot() && containers != null && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			SetFlag(Flags.Open, b: true);
			ItemContainer[] array = containers;
			foreach (ItemContainer container in array)
			{
				player.inventory.loot.AddContainer(container);
			}
			player.inventory.loot.SendImmediate();
			ClientRPCPlayer(null, player, "RPC_ClientLootCorpse");
			SendNetworkUpdate();
		}
	}

```

## OnTeamUpdate(ulong,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's team is updated.
/// </summary>
/// <param name="oldTeam">The player's previous team ID.</param>
/// <param name="newTeam">The player's new team ID.</param>
/// <param name="player">The player whose team is being updated.</param>
/// <returns>No return behavior.</returns>
void OnTeamUpdate(ulong oldTeam, ulong newTeam, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) updated team from {oldTeam} to {newTeam}.");
    
    if (newTeam == 0)
    {
        Puts($"Player {player.displayName} has left the team.");
    }
    else
    {
        Puts($"Player {player.displayName} has joined team {newTeam}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateTeam(ulong newTeam)
	{
		if (Interface.CallHook("OnTeamUpdate", currentTeam, newTeam, this) == null)
		{
			currentTeam = newTeam;
			SendNetworkUpdate();
			if (RelationshipManager.Instance.FindTeam(newTeam) == null)
			{
				ClearTeam();
			}
			else
			{
				TeamUpdate();
			}
		}
	}

```

## IOnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player successfully connects to the server.
/// </summary>
/// <param name="player">The player who has connected.</param>
/// <returns>No return behavior.</returns>
void IOnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has connected to the server.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has connected. Checking anti-hack settings...");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PlayerInit(Network.Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			bots.Remove(this);
			userID = c.userid;
			UserIDString = userID.ToString();
			displayName = c.username;
			c.player = this;
			currentTeam = RelationshipManager.Instance.FindPlayersTeam(userID)?.teamID ?? 0;
			SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(userID, displayName);
			tickInterpolator.Reset(base.transform.position);
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			InvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			ClientRPCPlayer(null, this, "StartLoading");
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			Interface.CallHook("IOnPlayerConnected", this);
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
			}
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable amount for an item.
/// </summary>
/// <param name="item">The item for which the maximum stackable amount is being queried.</param>
/// <returns>
/// Returns the maximum stackable amount for the item. If a non-null integer is returned, it overrides the default stackable amount.
/// </returns>
int OnMaxStackable(Item item)
{
    Puts($"Calculating max stackable for item: {item.info.displayName.english} (ID: {item.info.itemid})");

    if (item.info.itemid == 12345) // Example item ID for a special case
    {
        Puts("This item has a custom max stackable limit.");
        return 5; // Custom limit for this specific item
    }

    return item.info.stackable; // Default behavior
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## OnDemoRecordingStarted(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording has started for a player.
/// </summary>
/// <param name="filePath">The file path where the demo is being recorded.</param>
/// <param name="player">The player who started the demo recording.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStarted(string filePath, BasePlayer player)
{
    Puts($"Demo recording started for player {player.displayName} at {filePath}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has started a demo recording.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a healing item is used on a player.
/// </summary>
/// <param name="healingItem">The medical tool being used.</param>
/// <param name="targetPlayer">The player receiving the healing effects.</param>
/// <returns>
/// Returns a non-null value to prevent the healing effects from being applied. 
/// If `null` is returned, the healing effects will be applied as normal.
/// </returns>
object OnHealingItemUse(MedicalTool healingItem, BasePlayer targetPlayer)
{
    Puts($"Healing item {healingItem.name} used on player {targetPlayer.displayName} (ID: {targetPlayer.UserIDString}).");

    if (targetPlayer.health < 20)
    {
        Puts($"Player {targetPlayer.displayName} is too injured to receive healing.");
        return "Player is too injured to heal.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			if (player != ownerPlayer && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				player.StopWounded(ownerPlayer);
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## OnBoatPathGenerate()

```csharp
```csharp
/// <summary>
/// Called to generate a patrol path for boats in the ocean.
/// </summary>
/// <returns>
/// Returns a list of <c>Vector3</c> points representing the generated patrol path.
/// If the hook returns a non-null value, that value will be used as the patrol path.
/// </returns>
List<Vector3> OnBoatPathGenerate()
{
    Puts("Generating ocean patrol path for boats.");
    return null; // Allow the default path generation logic to proceed.
}
```
```

### Source Code from the Library

```csharp

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * (float)Math.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float y = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num5 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num5 * ((float)Math.PI / 180f)) * num4, y, Mathf.Cos(num5 * ((float)Math.PI / 180f)) * num4));
		}
		float num6 = 4f;
		float num7 = 200f;
		bool flag = true;
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 vector = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 b = list[index2];
				Vector3 b2 = list[index];
				Vector3 origin = vector;
				Vector3 normalized = (Vector3.zero - vector).normalized;
				Vector3 vector2 = vector + normalized * num6;
				if (Vector3.Distance(vector2, b) > num7 || Vector3.Distance(vector2, b2) > num7)
				{
					continue;
				}
				bool flag2 = true;
				int num8 = 16;
				for (int l = 0; l < num8; l++)
				{
					float num9 = (float)l / (float)num8 * 360f;
					Vector3 normalized2 = new Vector3(Mathf.Sin(num9 * ((float)Math.PI / 180f)), y, Mathf.Cos(num9 * ((float)Math.PI / 180f))).normalized;
					Vector3 vector3 = vector2 + normalized2 * 1f;
					GetWaterDepth(vector3);
					Vector3 direction = normalized;
					if (vector3 != Vector3.zero)
					{
						direction = (vector3 - vector2).normalized;
					}
					if (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1218511105))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = vector2;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning("Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log("Generated ocean patrol path with node count: " + list.Count);
		return list;
	}

```

## CanUseWires(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use wires in the game.
/// </summary>
/// <param name="player">The player attempting to use wires.</param>
/// <returns>
/// Returns `true` if the player can use wires; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the player can use wires.
/// </returns>
bool? CanUseWires(BasePlayer player)
{
    Puts($"Checking wire usage for player: {player.displayName} (ID: {player.UserIDString})");

    if (!player.CanBuild())
    {
        Puts($"Player {player.displayName} cannot build and thus cannot use wires.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool CanPlayerUseWires(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseWires", player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		List<Collider> obj2 = Facepunch.Pool.GetList<Collider>();
		GamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);
		bool result = obj2.All((Collider collider) => collider.gameObject.CompareTag("IgnoreWireCheck"));
		Facepunch.Pool.FreeList(ref obj2);
		return result;
	}

```

## OnSwitchAmmo(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player switches the ammunition type for their projectile weapon.
/// </summary>
/// <param name="player">The player who is switching the ammo.</param>
/// <param name="projectile">The projectile weapon for which the ammo is being switched.</param>
/// <returns>
/// Returns `null` to allow the ammo switch, or any non-null value to prevent the switch.
/// </returns>
object OnSwitchAmmo(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.displayName} is attempting to switch ammo for {projectile.info.displayName.english}.");

    if (projectile.primaryMagazine.ammoType.itemid == 123) // Example ammo ID
    {
        Puts($"Player {player.displayName} cannot switch from the current ammo type.");
        return "Cannot switch from the current ammo type.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnSwitchAmmo", ownerPlayer, this) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				primaryMagazine.contents = 0;
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger area.
/// </summary>
/// <param name="entity">The entity that has entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(BaseEntity entity)
{
    Puts($"Entity {entity?.name} has entered the trigger area.");

    if (entityContents == null)
    {
        entityContents = new HashSet<BaseEntity>();
    }

    if (entity != null)
    {
        Puts($"Processing entry for entity: {entity.name}");
        entityContents.Add(entity);
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			if (Interface.CallHook("OnEntityEnter", this, ent) == null)
			{
				entityContents.Add(ent);
			}
		}
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to authorize themselves on an auto turret.
/// </summary>
/// <param name="turret">The auto turret being authorized.</param>
/// <param name="player">The player attempting to authorize themselves.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent it.
/// </returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to authorize on turret {turret.net.ID}.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and is authorized automatically.");
        return null; // Allow authorization for admins
    }

    return "You are not allowed to authorize on this turret."; // Prevent authorization for non-admins
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!IsOnline() && rpc2.player.CanBuild() && Interface.CallHook("OnTurretAuthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = rpc2.player.userID;
			playerNameID.username = rpc2.player.displayName;
			authorizedPlayers.Add(playerNameID);
			SendNetworkUpdate();
		}
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity that has been killed.</param>
/// <returns>
/// Returns a non-null value to prevent the entity from being destroyed. 
/// If `null` is returned, the entity will be destroyed as normal.
/// </returns>
object OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity.net.ID} has been killed.");
    
    if (entity is BaseAnimal)
    {
        Puts($"Animal entity {entity.net.ID} cannot be killed at this time.");
        return true; // Prevents the entity from being killed
    }
    
    return null; // Allows the entity to be killed
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
		}
		else if (Interface.CallHook("OnEntityKill", this) == null)
		{
			OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Determines whether a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="buildingBlock">The building block whose grade is being changed.</param>
/// <param name="newGrade">The new grade to which the building block is being changed.</param>
/// <returns>
/// Returns `true` if the player can change the grade, `false` if they cannot, 
/// or `null` if the default game logic should be used to determine the outcome.
/// </returns>
bool? CanChangeGrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum newGrade)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to change grade to {newGrade} for {buildingBlock.name}.");

    if (newGrade == BuildingGrade.Enum.Stone)
    {
        Puts($"Player {player.displayName} is not allowed to change to Stone grade.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasUpgradePrivilege(iGrade, player))
		{
			return !IsUpgradeBlocked();
		}
		return false;
	}

```

## OnOpenVendingShop(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player opens a vending shop.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player who is opening the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingShop(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.displayName} has opened the vending shop at {vendingMachine.transform.position}.");
    
    if (vendingMachine.IsInUse)
    {
        Puts($"Vending shop is currently in use by another player.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player))
		{
			SendSellOrders(msg.player);
			PlayerOpenLoot(msg.player, customerPanel);
			Interface.CallHook("OnOpenVendingShop", this, msg.player);
		}
	}

```

## OnClothingItemChanged(PlayerInventory,Item,bool)

```csharp
```csharp
/// <summary>
/// Called when a clothing item is added or removed from a player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory where the clothing item change occurred.</param>
/// <param name="item">The clothing item that was added or removed.</param>
/// <param name="bAdded">Indicates whether the item was added (<c>true</c>) or removed (<c>false</c>).</param>
/// <returns>No return behavior.</returns>
void OnClothingItemChanged(PlayerInventory inventory, Item item, bool bAdded)
{
    Puts($"Clothing item '{item.info.displayName.english}' has been " + (bAdded ? "added" : "removed") + " from inventory.");
}
```
```

### Source Code from the Library

```csharp

	private void OnClothingChanged(Item item, bool bAdded)
	{
		base.baseEntity.SV_ClothingChanged();
		ItemManager.DoRemoves();
		ServerUpdate(0f);
		Interface.CallHook("OnClothingItemChanged", this, item, bAdded);
	}

```

## OnDispenserGather(ResourceDispenser,BaseEntity,Item)

```csharp
```csharp
/// <summary>
/// Called when a resource dispenser gathers resources from an entity.
/// </summary>
/// <param name="dispenser">The resource dispenser that is gathering resources.</param>
/// <param name="entity">The entity from which resources are being gathered.</param>
/// <param name="item">The item that is being gathered.</param>
/// <returns>No return behavior.</returns>
void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
{
    Puts($"Resource gathered from {entity?.name ?? "unknown entity"} by dispenser {dispenser?.name ?? "unknown dispenser"}: {item.info.displayName.english}.");
    
    if (item.info.shortname == "wood")
    {
        Puts("Wood has been gathered! Make sure to use it wisely.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float num3 = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		float num4 = num3 * destroyFraction * 2f;
		if (itemAmt.amount <= num3 + num4)
		{
			float num5 = (num3 + num4) / itemAmt.amount;
			num3 /= num5;
			num4 /= num5;
		}
		itemAmt.amount -= Mathf.Floor(num3);
		itemAmt.amount -= Mathf.Floor(num4);
		if (num3 < 1f)
		{
			num3 = ((UnityEngine.Random.Range(0f, 1f) <= num3) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (num3 >= 1f)
		{
			int num6 = CalculateGatherBonus(entity, itemAmt, num3);
			int iAmount = Mathf.FloorToInt(num3) + num6;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (item != null && Interface.CallHook("OnDispenserGather", this, entity, item) == null)
			{
				OverrideOwnership(item, attackWeapon);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a dropped item container.
/// </summary>
/// <param name="player">The player attempting to loot the container.</param>
/// <param name="container">The dropped item container being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the container, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the container.
/// </returns>
bool? CanLootEntity(BasePlayer player, DroppedItemContainer container)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot a container.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot loot while dead.");
        return false;
    }

    if (container.IsLocked())
    {
        Puts($"Container is locked. Player {player.displayName} cannot loot.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player can network to this entity.
/// </summary>
/// <param name="entity">The networkable entity.</param>
/// <param name="player">The player attempting to connect to the entity.</param>
/// <returns>
/// Returns `true` if the player can network to the entity; otherwise, returns `false`.
/// If the method returns `null`, the default networking logic will be applied.
/// </returns>
bool? CanNetworkTo(BaseNetworkable entity, BasePlayer player)
{
    Puts($"Checking network access for Player {player.displayName} to Entity ID: {entity.net.ID}");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can network to any entity.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (net.group == null)
		{
			return true;
		}
		return player.net.subscriber.IsSubscribed(net.group);
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a recycler is toggled on or off by a player.
/// </summary>
/// <param name="recycler">The recycler that is being toggled.</param>
/// <param name="player">The player who toggled the recycler.</param>
/// <returns>
/// Returns `null` to allow the toggle action, or any non-null value to prevent it.
/// </returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts($"Player {player.displayName} toggled the recycler (ID: {recycler.net.ID}).");

    if (player.inventory.GetAmount("recyclable.item") < 1)
    {
        Puts($"Player {player.displayName} does not have any recyclable items.");
        return "You need recyclable items to use the recycler.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || msg.player == null || Interface.CallHook("OnRecyclerToggle", this, msg.player) != null || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

```

## CanEntityBeHostile(BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the specified combat entity can be considered hostile.
/// </summary>
/// <param name="entity">The combat entity to check for hostility.</param>
/// <returns>
/// Returns `true` if the entity is considered hostile; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine hostility.
/// </returns>
bool? CanEntityBeHostile(BaseCombatEntity entity)
{
    Puts($"Checking hostility for entity ID: {entity.net.ID}, Type: {entity.GetType().Name}");

    if (entity is Animal)
    {
        Puts($"Entity {entity.net.ID} is an animal and is not hostile.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnPlayerStudyBlueprint(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player studies a blueprint item.
/// </summary>
/// <param name="player">The player studying the blueprint.</param>
/// <param name="item">The blueprint item being studied.</param>
/// <returns>
/// Returns a non-null value to prevent the default study behavior. 
/// If `null` is returned, the blueprint will be studied as normal.
/// </returns>
object OnPlayerStudyBlueprint(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is studying blueprint: {item.info.displayName.english} (ID: {item.info.itemid})");

    if (item.info.itemid == 12345) // Example item ID for a restricted blueprint
    {
        Puts($"Player {player.displayName} is not allowed to study this blueprint.");
        return "You cannot study this blueprint.";
    }

    return null; // Allow the default behavior
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (item.GetOwnerPlayer() != player)
		{
			bool flag = false;
			foreach (ItemContainer container in player.inventory.loot.containers)
			{
				if (item.GetRootContainer() == container)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (!(command == "study") || !item.IsBlueprint())
		{
			return;
		}
		ItemDefinition blueprintTargetDef = item.blueprintTargetDef;
		ItemBlueprint blueprint = blueprintTargetDef.Blueprint;
		bool flag2 = player.blueprints.IsUnlocked(blueprintTargetDef);
		if (flag2 && blueprint != null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				if (!player.blueprints.IsUnlocked(additionalUnlock))
				{
					flag2 = false;
				}
			}
		}
		if (flag2 || Interface.CallHook("OnPlayerStudyBlueprint", player, item) != null)
		{
			return;
		}
		Item item2 = item;
		if (item.amount > 1)
		{
			item2 = item.SplitItem(1);
		}
		item2.UseItem();
		player.blueprints.Unlock(blueprintTargetDef);
		if (blueprint != null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock2 in blueprint.additionalUnlocks)
			{
				player.blueprints.Unlock(additionalUnlock2);
			}
		}
		if (studyEffect.isValid)
		{
			Effect.server.Run(studyEffect.resourcePath, player, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
	}

```

## OnFlameExplosion(FlameExplosive,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a flame explosive detonates, creating additional entities.
/// </summary>
/// <param name="explosive">The flame explosive that triggered the explosion.</param>
/// <param name="entity">The entity created as a result of the explosion.</param>
/// <returns>No return behavior.</returns>
void OnFlameExplosion(FlameExplosive explosive, BaseEntity entity)
{
    Puts($"Flame explosive {explosive.net.ID} has detonated, creating entity {entity.net.ID}.");
    
    if (entity is Fireball)
    {
        Puts("A fireball has been created from the explosion!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Explode(Vector3 surfaceNormal)
	{
		if (!base.isServer)
		{
			return;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, base.transform.position);
			if ((bool)baseEntity)
			{
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle, surfaceNormal);
				baseEntity.transform.SetPositionAndRotation(base.transform.position, Quaternion.LookRotation(modifiedAimConeDirection));
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFlameExplosion", this, baseEntity);
				baseEntity.Spawn();
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(minVelocity, maxVelocity));
			}
		}
		base.Explode();
	}

```

## OnSensorDetect(HBHFSensor,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sensor detects a player entity.
/// </summary>
/// <param name="sensor">The sensor that detected the player.</param>
/// <param name="player">The player that was detected by the sensor.</param>
/// <returns>
/// Returns `null` to allow the default detection behavior, or any non-null value to override it.
/// </returns>
object OnSensorDetect(HBHFSensor sensor, BasePlayer player)
{
    Puts($"Sensor {sensor.net.ID} detected player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInvisible())
    {
        Puts($"Player {player.displayName} is invisible and will not be counted.");
        return true; // Prevents counting this player
    }

    return null; // Allow default behavior
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePassthroughAmount()
	{
		if (base.isClient)
		{
			return;
		}
		int num = detectedPlayers;
		detectedPlayers = 0;
		if (myTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in myTrigger.entityContents)
			{
				if (entityContent == null || !entityContent.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f))
				{
					continue;
				}
				BasePlayer component = entityContent.GetComponent<BasePlayer>();
				if (Interface.CallHook("OnSensorDetect", this, component) == null)
				{
					bool flag = component.CanBuild();
					if ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && component != null && component.IsAlive() && !component.IsSleeping() && component.isServer)
					{
						detectedPlayers++;
					}
				}
			}
		}
		if (num != detectedPlayers && IsPowered())
		{
			MarkDirty();
			if (detectedPlayers > num)
			{
				Effect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);
			}
			else if (detectedPlayers < num)
			{
				Effect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnOvenCook(BaseOven,Item)

```csharp
```csharp
/// <summary>
/// Called when an oven is cooking an item.
/// </summary>
/// <param name="oven">The oven that is performing the cooking.</param>
/// <param name="item">The item being cooked in the oven.</param>
/// <returns>No return behavior.</returns>
void OnOvenCook(BaseOven oven, Item item)
{
    Puts($"Oven {oven.net.ID} is cooking item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "raw.meat")
    {
        Puts("Cooking raw meat! Ensure proper cooking time.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null)
		{
			StopCooking();
			return;
		}
		base.inventory.OnCycle(0.5f);
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		ItemModBurnable component = item.info.GetComponent<ItemModBurnable>();
		item.fuel -= 0.5f * (cookingTemperature / 200f);
		if (!item.HasFlag(Item.Flag.OnFire))
		{
			item.SetFlag(Item.Flag.OnFire, b: true);
			item.MarkDirty();
		}
		if (item.fuel <= 0f)
		{
			ConsumeFuel(item, component);
		}
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## CanDeployItem(BasePlayer,Deployer,uint)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can deploy a specific item.
/// </summary>
/// <param name="player">The player attempting to deploy the item.</param>
/// <param name="deployer">The deployable item being placed.</param>
/// <param name="slotId">The slot ID where the item is being deployed.</param>
/// <returns>
/// Returns `true` if the player can deploy the item, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the item can be deployed.
/// </returns>
bool? CanDeployItem(BasePlayer player, Deployable deployer, uint slotId)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to deploy item in slot {slotId}.");

    if (slotId == 1)
    {
        Puts($"Player {player.displayName} cannot deploy items in slot 1.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDeploy(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Deployable deployable = GetDeployable();
		if (deployable == null)
		{
			return;
		}
		Ray ray = msg.read.Ray();
		uint num = msg.read.UInt32();
		if (Interface.CallHook("CanDeployItem", msg.player, this, num) == null)
		{
			if (deployable.toSlot)
			{
				DoDeploy_Slot(deployable, ray, num);
			}
			else
			{
				DoDeploy_Regular(deployable, ray);
			}
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Determines whether the patrol helicopter can perform a strafe maneuver.
/// </summary>
/// <param name="helicopter">The patrol helicopter AI instance checking for strafe capability.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe, `false` if it cannot, 
/// or `null` if the default game logic should be used to determine strafe capability.
/// </returns>
bool? CanHelicopterStrafe(PatrolHelicopterAI helicopter)
{
    Puts($"Checking strafe capability for Helicopter ID: {helicopter.net.ID} at time: {UnityEngine.Time.realtimeSinceStartup}.");

    if (helicopter.lastStrafeTime < UnityEngine.Time.realtimeSinceStartup - 20f)
    {
        Puts("Helicopter is ready to strafe.");
        return true;
    }

    Puts("Helicopter cannot strafe yet.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= 20f)
		{
			return CanInterruptState();
		}
		return false;
	}

```

## OnHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter drops a supply crate.
/// </summary>
/// <param name="helicopter">The helicopter that is dropping the crate.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.net.ID} has dropped a crate at position: {helicopter.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

```

## OnItemResearch(ResearchTable,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is researched at the research table.
/// </summary>
/// <param name="researchTable">The research table where the item is being researched.</param>
/// <param name="item">The item that is being researched.</param>
/// <param name="player">The player who is performing the research.</param>
/// <returns>No return behavior.</returns>
void OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} is researching item: {item.info.displayName.english} at {researchTable.name}.");

    if (item.info.shortname == "blueprint")
    {
        Puts($"Player {player.displayName} has researched a blueprint!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnCargoShipEgress(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when the cargo ship begins the egress process.
/// </summary>
/// <param name="cargoShip">The cargo ship that is starting to egress.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipEgress(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip.net.ID} is starting to egress.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	public void StartEgress()
	{
		if (!egressing && Interface.CallHook("OnCargoShipEgress", this) == null)
		{
			egressing = true;
			CancelInvoke(PlayHorn);
			radiation.SetActive(value: true);
			SetFlag(Flags.Reserved8, b: true);
			InvokeRepeating(UpdateRadiation, 10f, 1f);
			Invoke(DelayedDestroy, 60f * egress_duration_minutes);
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
```csharp
/// <summary>
/// Determines whether a player can be targeted by a gun trap.
/// </summary>
/// <param name="player">The player being checked for targeting.</param>
/// <param name="trap">The gun trap that is attempting to target the player.</param>
/// <returns>
/// Returns `true` if the player can be targeted by the gun trap; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the player can be targeted.
/// </returns>
bool? CanBeTargeted(BasePlayer player, GunTrap trap)
{
    Puts($"Checking if player {player.displayName} (ID: {player.UserIDString}) can be targeted by the gun trap.");

    if (player.IsBuildingAuthed())
    {
        Puts($"Player {player.displayName} is authorized to build and cannot be targeted.");
        return false;
    }

    if (player.IsSleeping())
    {
        Puts($"Player {player.displayName} is sleeping and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = item.GetComponent<BasePlayer>();
				if (component.IsSleeping() || !component.IsAlive() || component.IsBuildingAuthed())
				{
					continue;
				}
				object obj2 = Interface.CallHook("CanBeTargeted", component, this);
				if (obj2 is bool)
				{
					Pool.FreeList(ref obj);
					return (bool)obj2;
				}
				obj.Clear();
				GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
				for (int i = 0; i < obj.Count; i++)
				{
					BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
					if (entity != null && (entity == this || entity.EqualNetID(this)))
					{
						flag = true;
						break;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeList(ref obj);
		return flag;
	}

```

## CanSamSiteShoot(SamSite)

```csharp
```csharp
/// <summary>
/// Called to determine if the SAM site can shoot at a target.
/// </summary>
/// <param name="samSite">The SAM site attempting to shoot.</param>
/// <returns>
/// Returns `null` to allow the SAM site to shoot, or any non-null value to prevent it from shooting.
/// </returns>
object CanSamSiteShoot(SamSite samSite)
{
    Puts($"SAM Site {samSite.net.ID} is checking if it can shoot.");
    
    if (!samSite.IsPowered())
    {
        Puts("SAM Site is not powered and cannot shoot.");
        return "Not powered.";
    }

    if (samSite.IsDead())
    {
        Puts("SAM Site is dead and cannot shoot.");
        return "Site is dead.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void WeaponTick()
	{
		if (IsDead() || Time.time < lockOnTime || Time.time < nextBurstTime)
		{
			return;
		}
		if (!IsPowered())
		{
			firedCount = 0;
			return;
		}
		if (firedCount >= 6)
		{
			nextBurstTime = Time.time + 5f;
			firedCount = 0;
			return;
		}
		EnsureReloaded();
		if (HasAmmo() && Interface.CallHook("CanSamSiteShoot", this) == null)
		{
			if (!staticRespawn && ammoItem != null)
			{
				ammoItem.UseItem();
			}
			firedCount++;
			FireProjectile(tubes[currentTubeIndex].position, currentAimDir, currentTarget);
			Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
			currentTubeIndex++;
			if (currentTubeIndex >= tubes.Length)
			{
				currentTubeIndex = 0;
			}
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Determines whether a player can bypass the connection queue.
/// </summary>
/// <param name="connection">The network connection of the player attempting to bypass the queue.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue, `false` if they cannot, 
/// or `null` if the default queue logic should be applied.
/// </returns>
bool? CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if connection {connection.userid} can bypass the queue.");

    if (connection.userid == 123456789) // Example for a specific user ID
    {
        Puts($"Connection {connection.userid} is a special case and can bypass the queue.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user == null || user.group != ServerUsers.UserGroup.Moderator)
		{
			if (user != null)
			{
				return user.group == ServerUsers.UserGroup.Owner;
			}
			return false;
		}
		return true;
	}

```

## OnNpcConversationRespond(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
```csharp
/// <summary>
/// Called when a player responds to an NPC conversation.
/// </summary>
/// <param name="npc">The NPC that the player is conversing with.</param>
/// <param name="player">The player responding to the conversation.</param>
/// <param name="conversation">The conversation data associated with the interaction.</param>
/// <param name="responseNode">The specific response node that the player has selected.</param>
/// <returns>No return behavior.</returns>
void OnNpcConversationRespond(NPCTalking npc, BasePlayer player, ConversationData conversation, ConversationData.ResponseNode responseNode)
{
    Puts($"Player {player.displayName} responded to NPC {npc.name} with response: {responseNode.text}");

    if (responseNode.text.Contains("goodbye"))
    {
        Puts($"Player {player.displayName} is ending the conversation with NPC {npc.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode != null && Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) == null)
		{
			if (responseNode.conditions.Length != 0)
			{
				UpdateFlags();
			}
			bool flag = responseNode.PassesConditions(player, this);
			if (flag && !string.IsNullOrEmpty(responseNode.actionString))
			{
				OnConversationAction(player, responseNode.actionString);
			}
			int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
			if (speechNodeIndex == -1)
			{
				ForceEndConversation(player);
				return;
			}
			ForceSpeechNode(player, speechNodeIndex);
			Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
		}
	}

```

## OnEventTrigger(TriggeredEventPrefab)

```csharp
```csharp
/// <summary>
/// Called when an event is triggered, allowing for custom behavior before the event executes.
/// </summary>
/// <param name="eventPrefab">The prefab associated with the triggered event.</param>
/// <returns>No return behavior.</returns>
void OnEventTrigger(TriggeredEventPrefab eventPrefab)
{
    Puts($"Event triggered for prefab: {eventPrefab.resourcePath}");
    // Additional custom logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	private void RunEvent()
	{
		if (Interface.CallHook("OnEventTrigger", this) == null)
		{
			Debug.Log("[event] " + targetPrefab.resourcePath);
			BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.SendMessage("TriggeredEventSpawn", SendMessageOptions.DontRequireReceiver);
				baseEntity.Spawn();
			}
		}
	}

```

## OnFuelConsume(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by an oven or similar device.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The fuel item being consumed.</param>
/// <param name="burnable">The burnable item modifier associated with the fuel.</param>
/// <returns>No return behavior.</returns>
void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel consumed: {fuel.info.displayName.english} in oven ID: {oven.net.ID}.");

    if (fuel.info.shortname == "wood")
    {
        Puts("Wood is being consumed as fuel.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= 1)
		{
			fuel.Remove();
			return;
		}
		fuel.amount--;
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## CanPickupEntity(BasePlayer,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether a player can pick up a specific entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can pick up the entity.
/// </returns>
bool? CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to pick up entity: {entity.name}.");

    if (entity is SomeSpecificEntity)
    {
        Puts($"Player {player.displayName} cannot pick up this specific entity.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (pickup.enabled)
		{
			if (!pickup.requireBuildingPrivilege || player.CanBuild())
			{
				if (pickup.requireHammer)
				{
					return player.IsHoldingEntity<Hammer>();
				}
				return true;
			}
			return false;
		}
		return false;
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to buy an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the item is being purchased.</param>
/// <param name="buyer">The player attempting to buy the item.</param>
/// <param name="itemId">The ID of the item being purchased.</param>
/// <param name="amount">The amount of the item being purchased.</param>
/// <returns>
/// Returns `null` to allow the purchase to proceed, or any non-null value to prevent the purchase.
/// </returns>
object OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer buyer, int itemId, int amount)
{
    Puts($"Player {buyer.displayName} is attempting to buy {amount} of item ID {itemId} from vending machine {vendingMachine.net.ID}.");

    if (amount > 10)
    {
        Puts($"Purchase denied: {buyer.displayName} tried to buy too many items at once.");
        return "You cannot buy more than 10 items at a time.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void BuyItem(RPCMessage rpc)
	{
		if (OccupiedCheck(rpc.player))
		{
			int num = rpc.read.Int32();
			int num2 = rpc.read.Int32();
			if (IsVending())
			{
				rpc.player.ShowToast(1, WaitForVendingMessage);
			}
			else if (Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2) == null)
			{
				SetPendingOrder(rpc.player, num, num2);
				Invoke(CompletePendingOrder, GetBuyDuration());
			}
		}
	}

```

## OnFindBurnable(BaseOven)

```csharp
```csharp
/// <summary>
/// Called to find a burnable item in the oven's inventory.
/// </summary>
/// <param name="oven">The oven instance searching for burnable items.</param>
/// <returns>
/// Returns an <c>Item</c> if a burnable item is found; otherwise, returns <c>null</c>.
/// If the method returns a non-null value, it overrides the default item search logic.
/// </returns>
Item OnFindBurnable(BaseOven oven)
{
    Puts($"Searching for burnable items in oven ID: {oven.net.ID}.");
    
    // Example condition to block a specific item
    if (oven.inventory != null && oven.inventory.itemList.Any(i => i.info.shortname == "wood"))
    {
        Puts("Wood is not allowed as a burnable item.");
        return null;
    }

    return null; // Allow default logic to proceed if no specific conditions are met
}
```
```

### Source Code from the Library

```csharp

	public Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (base.inventory == null)
		{
			return null;
		}
		foreach (Item item in base.inventory.itemList)
		{
			if ((bool)item.info.GetComponent<ItemModBurnable>() && (fuelType == null || item.info == fuelType))
			{
				return item;
			}
		}
		return null;
	}

```

## OnVehicleModuleDeselected(ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is deselected by a player in the garage.
/// </summary>
/// <param name="garage">The garage where the vehicle module is located.</param>
/// <param name="player">The player who deselected the vehicle module.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModuleDeselected(ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.displayName} has deselected a module in the garage: {garage.name}.");
    
    if (player.inventory.loot.IsLooting())
    {
        Puts($"Player {player.displayName} is currently looting.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DeselectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.inventory.loot.IsLooting() && !(player.inventory.loot.entitySource != this))
		{
			if (player.inventory.loot.RemoveContainerAt(3))
			{
				player.inventory.loot.SendImmediate();
			}
			Interface.CallHook("OnVehicleModuleDeselected", this, player);
		}
	}

```

## OnTurretClearList(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the authorized player list of a turret is cleared.
/// </summary>
/// <param name="turret">The turret whose authorized player list is being cleared.</param>
/// <param name="player">The player who initiated the clear action.</param>
/// <returns>No return behavior.</returns>
void OnTurretClearList(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.net.ID} authorized player list cleared by {player.displayName} (ID: {player.UserIDString}).");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			SendNetworkUpdate();
		}
	}

```

## OnTeamCreated(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a new team is created by a player.
/// </summary>
/// <param name="player">The player who created the team.</param>
/// <param name="team">The team that was created.</param>
/// <returns>No return behavior.</returns>
void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
{
    Puts($"Team created by player {player.displayName} (ID: {player.UserIDString}). Team ID: {team.teamID}.");
    
    if (team.playerCount > 1)
    {
        Puts($"Team {team.teamID} has {team.playerCount} members.");
    }
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = Instance.CreateTeam();
			playerTeam.teamLeader = basePlayer.userID;
			playerTeam.AddPlayer(basePlayer);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## IOnUpdateServerInformation()

```csharp
```csharp
/// <summary>
/// Called to update the server information sent to the Steam server.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnUpdateServerInformation()
{
    Puts("Updating server information for Steam server.");
    // Additional logic can be added here if needed for custom behavior.
}
```
```

### Source Code from the Library

```csharp

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		using (TimeWarning.New("UpdateServerInformation"))
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.Name;
			string text = "stok";
			if (Restarting)
			{
				text = "strst";
			}
			string text2 = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text3 = $"gm{GamemodeName()}";
			string text4 = (ConVar.Server.pve ? ",pve" : string.Empty);
			SteamServer.GameTags = $"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},v{2271}{text4},h{AssemblyHash},{text},{text2},{text3}";
			Interface.CallHook("IOnUpdateServerInformation");
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = ConVar.Server.description.SplitToChunks(100).ToArray();
				Interface.CallHook("IOnUpdateServerDescription");
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			SteamServer.SetKey("world.seed", World.Seed.ToString());
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("logoimage", ConVar.Server.logoimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("gmd", GamemodeDesc());
			SteamServer.SetKey("gmu", GamemodeUrl());
			SteamServer.SetKey("uptime", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is initiated.
/// </summary>
/// <param name="task">The crafting task that is being created.</param>
/// <param name="owner">The player who is crafting the item.</param>
/// <param name="fromTempBlueprint">The temporary blueprint used for crafting, if any.</param>
/// <returns>
/// Returns `true` if the crafting can proceed, or `false` if it cannot. 
/// If the method returns `null`, the default crafting logic will be applied.
/// </returns>
object OnItemCraft(ItemCraftTask task, BasePlayer owner, Item fromTempBlueprint)
{
    Puts($"Player {owner.displayName} is crafting {task.blueprint.targetItem.shortname} (Amount: {task.amount}).");

    if (task.amount > 5)
    {
        Puts($"Player {owner.displayName} is attempting to craft too many items at once.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)
	{
		if (!CanCraft(bp, amount, free))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		if (!free)
		{
			CollectIngredients(bp, itemCraftTask, amount, owner);
		}
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.owner = owner;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			if (itemCraftTask.instanceData != null)
			{
				fromTempBlueprint.instanceData = itemCraftTask.instanceData;
			}
			return (bool)obj;
		}
		queue.AddLast(itemCraftTask);
		if (itemCraftTask.owner != null)
		{
			itemCraftTask.owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## OnTerrainInitialized()

```csharp
```csharp
/// <summary>
/// Called when the terrain has been initialized and all components are set up.
/// </summary>
/// <returns>No return behavior.</returns>
void OnTerrainInitialized()
{
    Puts("Terrain has been successfully initialized and all components are set up.");
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

```

## OnDieselEngineToggle(BasePlayer,DieselEngine)

```csharp
```csharp
/// <summary>
/// Called when a player toggles the state of a diesel engine.
/// </summary>
/// <param name="player">The player who is toggling the engine.</param>
/// <param name="engine">The diesel engine being toggled.</param>
/// <returns>Returns a non-null value to prevent the engine from toggling; otherwise, returns null to allow the action.</returns>
object OnDieselEngineToggle(BasePlayer player, DieselEngine engine)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) toggled the diesel engine.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has full control over the engine.");
        return null; // Allow the toggle
    }

    Puts($"Player {player.displayName} is not allowed to toggle the engine.");
    return "You do not have permission to toggle this engine."; // Prevent the toggle
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnDieselEngineToggle", msg.player, this) != null)
		{
			return;
		}
		if (msg.read.Bit())
		{
			if (GetFuelAmount() > 0)
			{
				EngineOn();
			}
		}
		else
		{
			EngineOff();
		}
	}

```

## CanDismountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can dismount from an entity.
/// </summary>
/// <param name="player">The player attempting to dismount.</param>
/// <param name="mountable">The mountable entity the player is currently on.</param>
/// <returns>
/// Returns `null` to allow the dismount, or any non-null value to prevent the dismount.
/// </returns>
object CanDismountEntity(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to dismount from {mountable.gameObject.name}.");

    if (player.IsInCombat)
    {
        Puts($"Player {player.displayName} cannot dismount while in combat.");
        return "Cannot dismount while in combat.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			_mounted.DismountObject();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			SetFlag(Flags.Busy, b: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
		}
		else
		{
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPCPlayer(null, player, "ForcePositionToParentOffset", baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				Interface.CallHook("OnEntityDismounted", this, player);
				player.ClientRPCPlayer(null, player, "ForcePositionTo", res);
			}
			OnPlayerDismounted(player);
		}
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The instance of the Bradley APC being initialized.</param>
/// <returns>No return behavior.</returns>
void OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Initializing Bradley APC with ID: {apc.net.ID} at position: {apc.transform.position}");
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## OnMapMarkerAdd(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player adds a new map marker.
/// </summary>
/// <param name="player">The player who is adding the map marker.</param>
/// <param name="mapNote">The map note being added.</param>
/// <returns>
/// Returns `null` to allow the addition of the map marker, or any non-null value to prevent it.
/// </returns>
object OnMapMarkerAdd(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.displayName} is adding a map marker at position: {mapNote.position} with note: {mapNote.note}.");

    if (mapNote.note.Contains("forbidden"))
    {
        Puts($"Player {player.displayName} attempted to add a forbidden marker.");
        return "You cannot add this type of marker.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 9L;
			ServerCurrentMapNote?.Dispose();
			ServerCurrentMapNote = MapNote.Deserialize(msg.read);
			DirtyPlayerState();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, ServerCurrentMapNote);
		}
	}

```

## CanMountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can mount a specific entity.
/// </summary>
/// <param name="player">The player attempting to mount the entity.</param>
/// <param name="mountable">The mountable entity that the player wants to mount.</param>
/// <returns>
/// Returns `true` if the player can mount the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can mount the entity.
/// </returns>
bool? CanMountEntity(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to mount the entity: {mountable.GetType().Name}.");

    if (player.IsInCombat)
    {
        Puts($"Player {player.displayName} cannot mount while in combat.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			TriggerParent triggerParent = player.FindTrigger<TriggerParent>();
			if ((bool)triggerParent)
			{
				triggerParent.OnTriggerExit(player.GetComponent<Collider>());
			}
			player.MountObject(this);
			player.MovePosition(mountAnchor.transform.position);
			player.transform.rotation = mountAnchor.transform.rotation;
			player.ServerRotation = mountAnchor.transform.rotation;
			player.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			SetFlag(Flags.Busy, b: true);
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnEngineStarted(MotorRowboat,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the engine of the motorized rowboat is started.
/// </summary>
/// <param name="rowboat">The motorized rowboat whose engine is being started.</param>
/// <param name="driver">The player who is driving the rowboat.</param>
/// <returns>No return behavior.</returns>
void OnEngineStarted(MotorRowboat rowboat, BasePlayer driver)
{
    Puts($"Engine started for rowboat driven by {driver.displayName} (ID: {driver.UserIDString}).");
    
    if (driver.IsInSafeZone())
    {
        Puts($"Warning: {driver.displayName} is trying to start the engine in a safe zone.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.Reserved1, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
		}
	}

```

## OnNpcGiveSoldItem(NPCVendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC vending machine gives a sold item to a player.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that is selling the item.</param>
/// <param name="soldItem">The item that is being sold.</param>
/// <param name="buyer">The player who is buying the item.</param>
/// <returns>No return behavior.</returns>
void OnNpcGiveSoldItem(NPCVendingMachine vendingMachine, Item soldItem, BasePlayer buyer)
{
    Puts($"NPC Vending Machine {vendingMachine.net.ID} is giving item {soldItem.info.displayName.english} to player {buyer.displayName}.");
    
    if (soldItem.info.shortname == "special.item")
    {
        Puts($"Player {buyer.displayName} has received a special item!");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnNpcGiveSoldItem", this, soldItem, buyer) == null)
		{
			base.GiveSoldItem(soldItem, buyer);
		}
	}

```

## OnItemLock(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is locked or unlocked.
/// </summary>
/// <param name="item">The item that is being locked or unlocked.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being locked or unlocked. 
/// If `null` is returned, the item will be locked or unlocked as requested.
/// </returns>
object OnItemLock(Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.net.ID}) is being locked.");
    if (item.amount > 10)
    {
        Puts($"Item {item.info.displayName.english} cannot be locked because it has more than 10 units.");
        return "Cannot lock items with more than 10 units.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## OnTeamRejectInvite(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a player rejects an invitation to join a team.
/// </summary>
/// <param name="player">The player who rejected the team invite.</param>
/// <param name="team">The team from which the invite was rejected.</param>
/// <returns>
/// Returns `null` to allow the rejection to proceed, or any non-null value to prevent the rejection.
/// </returns>
object OnTeamRejectInvite(BasePlayer player, RelationshipManager.PlayerTeam team)
{
    Puts($"Player {player.displayName} has rejected the invite to join team {team.TeamName}.");
    
    if (team.TeamName == "VIPs")
    {
        Puts($"Player {player.displayName} cannot reject invites from VIP teams.");
        return "You cannot reject invites from VIP teams.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void rejectinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = Instance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamRejectInvite", basePlayer, playerTeam) == null)
			{
				playerTeam.RejectInvite(basePlayer);
			}
		}
	}

```

## OnVehicleLockableCheck(ModularCarLock)

```csharp
```csharp
/// <summary>
/// Called to check if a vehicle can have a lock applied to it.
/// </summary>
/// <param name="vehicle">The vehicle being checked for lockability.</param>
/// <returns>
/// Returns `true` if the vehicle can have a lock, `false` if it cannot, 
/// or `null` to allow the default game logic to determine the lockability.
/// </returns>
bool? OnVehicleLockableCheck(ModularCarLock vehicle)
{
    Puts($"Checking lockability for vehicle ID: {vehicle.net.ID}, Owner: {vehicle.owner?.displayName ?? "None"}");

    if (vehicle.owner == null || vehicle.owner.IsDead())
    {
        Puts("Vehicle cannot have a lock because the owner is dead or not present.");
        return false;
    }

    return null; // Allow default logic to determine if the vehicle can have a lock.
}
```
```

### Source Code from the Library

```csharp

	public bool CanHaveALock()
	{
		object obj = Interface.CallHook("OnVehicleLockableCheck", this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		if (!owner.IsDead())
		{
			return owner.HasDriverMountPoints();
		}
		return false;
	}

```

## OnVehicleModuleMove(BaseVehicleModule,BaseModularVehicle,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is moved by a player.
/// </summary>
/// <param name="module">The vehicle module being moved.</param>
/// <param name="vehicle">The vehicle that contains the module.</param>
/// <param name="player">The player attempting to move the module.</param>
/// <returns>
/// Returns `true` if the module can be moved, or `false` if it cannot. 
/// If the method returns `null`, the default game logic will determine if the module can be moved.
/// </returns>
object OnVehicleModuleMove(BaseVehicleModule module, BaseModularVehicle vehicle, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to move module {module.moduleName} from vehicle {vehicle.net.ID}.");

    if (module.IsLocked)
    {
        Puts($"Module {module.moduleName} is locked and cannot be moved.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		BaseVehicleModule moduleForItem = GetModuleForItem(item);
		if (moduleForItem != null)
		{
			object obj = Interface.CallHook("OnVehicleModuleMove", moduleForItem, this, player);
			if (obj != null)
			{
				if (!(obj is bool))
				{
					return false;
				}
				return (bool)obj;
			}
			return moduleForItem.CanBeMovedNow();
		}
		return true;
	}

```

## CanNetworkTo(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether this player can network to another player.
/// </summary>
/// <param name="sourcePlayer">The player attempting to network.</param>
/// <param name="targetPlayer">The player to which the networking is being checked.</param>
/// <returns>
/// Returns `true` if the source player can network to the target player; otherwise, returns `false`.
/// If the method returns `null`, the default networking logic will be applied.
/// </returns>
bool? CanNetworkTo(BasePlayer sourcePlayer, BasePlayer targetPlayer)
{
    Puts($"Checking network capability from {sourcePlayer.displayName} to {targetPlayer.displayName}.");

    if (sourcePlayer.IsIncapacitated())
    {
        Puts($"{sourcePlayer.displayName} cannot network while incapacitated.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsSpectating() && player != this && !player.net.connection.info.GetBool("global.specnet"))
		{
			return false;
		}
		return base.ShouldNetworkTo(player);
	}

```

## OnBonusItemDrop(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is dropped for a player after an action.
/// </summary>
/// <param name="item">The bonus item that is being dropped.</param>
/// <param name="player">The player who is receiving the bonus item.</param>
/// <returns>No return behavior.</returns>
void OnBonusItemDrop(Item item, BasePlayer player)
{
    Puts($"Bonus item {item.info.displayName.english} dropped for player {player.displayName} (ID: {player.UserIDString}).");
    
    if (item.info.shortname == "scrap")
    {
        Puts($"Player {player.displayName} received bonus scrap!");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity());
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnFireBallDamage(FireBall,BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a fireball inflicts damage on a target entity.
/// </summary>
/// <param name="fireball">The fireball that is causing the damage.</param>
/// <param name="target">The target entity that is being damaged.</param>
/// <param name="hitInfo">Information about the hit, including damage type and position.</param>
/// <returns>No return behavior.</returns>
void OnFireBallDamage(FireBall fireball, BaseCombatEntity target, HitInfo hitInfo)
{
    Puts($"Fireball damage inflicted on {target.displayName} (ID: {target.net.ID}) at position {hitInfo.HitPositionWorld}.");

    if (target is BasePlayer player)
    {
        Puts($"Player {player.displayName} is taking fire damage!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoRadialDamage()
	{
		List<Collider> obj = Pool.GetList<Collider>();
		Vector3 position = base.transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Colliders(position, radius, obj, AttackLayers);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = ((creatorEntity == null) ? GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);
		hitInfo.PointStart = base.transform.position;
		foreach (Collider item in obj)
		{
			if (item.isTrigger && (item.gameObject.layer == 29 || item.gameObject.layer == 18))
			{
				continue;
			}
			BaseCombatEntity baseCombatEntity = GameObjectEx.ToBaseEntity(item.gameObject) as BaseCombatEntity;
			if (!(baseCombatEntity == null) && baseCombatEntity.isServer && baseCombatEntity.IsAlive() && (!ignoreNPC || !baseCombatEntity.IsNpc) && baseCombatEntity.IsVisible(position))
			{
				if (baseCombatEntity is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", baseCombatEntity, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = baseCombatEntity.transform.position;
				hitInfo.HitPositionWorld = baseCombatEntity.transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", this, baseCombatEntity, hitInfo);
				baseCombatEntity.OnAttacked(hitInfo);
			}
		}
		Pool.FreeList(ref obj);
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player performs a melee attack.
/// </summary>
/// <param name="player">The player initiating the melee attack.</param>
/// <param name="hitInfo">Information about the hit, including the target and damage details.</param>
/// <returns>No return behavior.</returns>
void OnMeleeAttack(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} initiated a melee attack on {hitInfo.HitEntity?.ShortPrefabName ?? "nothing"}.");

    if (hitInfo.IsNaNOrInfinity())
    {
        Puts("Attack contains invalid hit information (NaN or Infinity).");
        return;
    }

    // Additional logic can be added here for handling melee attack consequences
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo hitInfo = Facepunch.Pool.Get<HitInfo>();
			hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
			hitInfo.Initiator = player;
			hitInfo.Weapon = this;
			hitInfo.WeaponPrefab = this;
			hitInfo.Predicted = msg.connection;
			hitInfo.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, hitInfo) != null)
			{
				return;
			}
			if (hitInfo.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.Log(hitInfo, "melee_nan");
				return;
			}
			if (ConVar.AntiHack.melee_protection > 0 && (bool)hitInfo.HitEntity)
			{
				bool flag = true;
				BasePlayer basePlayer = hitInfo.HitEntity as BasePlayer;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTime + num2 + num3) * num;
				int layerMask = (ConVar.AntiHack.melee_terraincheck ? 10551296 : 2162688);
				if ((bool)basePlayer && hitInfo.boneArea == (HitArea)(-1))
				{
					string shortPrefabName2 = base.ShortPrefabName;
					string shortPrefabName3 = hitInfo.HitEntity.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.MeleeHack, "Bone is invalid  (" + shortPrefabName2 + " on " + shortPrefabName3 + " bone " + hitInfo.HitBone + ")");
					player.stats.combat.Log(hitInfo, "melee_bone");
					flag = false;
				}
				if (ConVar.AntiHack.projectile_protection >= 2)
				{
					float num5 = hitInfo.HitEntity.MaxVelocity() + hitInfo.HitEntity.GetParentVelocity().magnitude;
					float num6 = hitInfo.HitEntity.BoundsPadding() + num4 * num5;
					float num7 = hitInfo.HitEntity.Distance(hitInfo.HitPositionWorld);
					if (num7 > num6)
					{
						string shortPrefabName4 = base.ShortPrefabName;
						string shortPrefabName5 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num7 + "m > " + num6 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_target");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					float num8 = hitInfo.Initiator.MaxVelocity() + hitInfo.Initiator.GetParentVelocity().magnitude;
					float num9 = hitInfo.Initiator.BoundsPadding() + num4 * num8 + num * maxDistance;
					float num10 = hitInfo.Initiator.Distance(hitInfo.HitPositionWorld);
					if (num10 > num9)
					{
						string shortPrefabName6 = base.ShortPrefabName;
						string shortPrefabName7 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName6 + " on " + shortPrefabName7 + " with " + num10 + "m > " + num9 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_initiator");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					Vector3 pointStart = hitInfo.PointStart;
					Vector3 vector = hitInfo.HitPositionWorld + hitInfo.HitNormalWorld.normalized * 0.001f;
					Vector3 center = player.eyes.center;
					Vector3 position = player.eyes.position;
					Vector3 vector2 = pointStart;
					Vector3 vector3 = hitInfo.PositionOnRay(vector);
					Vector3 vector4 = vector;
					bool num11 = GamePhysics.LineOfSight(center, position, vector2, vector3, vector4, layerMask);
					if (!num11)
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
					}
					else
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_direct_los", 1, Stats.Server);
					}
					if (!num11)
					{
						string shortPrefabName8 = base.ShortPrefabName;
						string shortPrefabName9 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat("Line of sight (", shortPrefabName8, " on ", shortPrefabName9, ") ", center, " ", position, " ", vector2, " ", vector3, " ", vector4));
						player.stats.combat.Log(hitInfo, "melee_los");
						flag = false;
					}
					if ((bool)basePlayer)
					{
						Vector3 vector5 = hitInfo.HitPositionWorld + hitInfo.HitNormalWorld.normalized * 0.001f;
						Vector3 position2 = basePlayer.eyes.position;
						Vector3 vector6 = basePlayer.CenterPoint();
						if (!GamePhysics.LineOfSight(vector5, position2, layerMask) && !GamePhysics.LineOfSight(vector5, vector6, layerMask))
						{
							string shortPrefabName10 = base.ShortPrefabName;
							string shortPrefabName11 = hitInfo.HitEntity.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat("Line of sight (", shortPrefabName10, " on ", shortPrefabName11, ") ", vector5, " ", position2, " or ", vector5, " ", vector6));
							player.stats.combat.Log(hitInfo, "melee_los");
							flag = false;
						}
					}
				}
				if (!flag)
				{
					AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
					return;
				}
			}
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50))
			{
				DoAttackShared(hitInfo);
			}
		}
	}

```

## OnActiveItemChange(BasePlayer,Item,uint)

```csharp
```csharp
/// <summary>
/// Called when a player's active item changes.
/// </summary>
/// <param name="player">The player whose active item is changing.</param>
/// <param name="previousItem">The item that was previously active.</param>
/// <param name="newItemID">The ID of the new active item.</param>
/// <returns>No return behavior.</returns>
void OnActiveItemChange(BasePlayer player, Item previousItem, uint newItemID)
{
    Puts($"Player {player.displayName} changed active item from {previousItem?.info.displayName.english ?? "none"} to item ID: {newItemID}.");
    
    if (newItemID == 0)
    {
        Puts($"Player {player.displayName} has unequipped their active item.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(uint itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = 0u;
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = 0u;
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = 0u;
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnTeamLeave(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player leaves a team.
/// </summary>
/// <param name="team">The team that the player is leaving.</param>
/// <param name="player">The player who is leaving the team.</param>
/// <returns>
/// Returns `null` to allow the player to leave the team, or any non-null value to prevent the action.
/// </returns>
object OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has left the team {team.TeamID}.");
    
    if (player.IsBannedFromTeams)
    {
        Puts($"Player {player.displayName} is banned from leaving teams.");
        return "You are banned from leaving teams.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void leaveteam(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam != 0L)
		{
			PlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);
			if (playerTeam != null && Interface.CallHook("OnTeamLeave", playerTeam, basePlayer) == null)
			{
				playerTeam.RemovePlayer(basePlayer.userID);
				basePlayer.ClearTeam();
			}
		}
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player is hurt by an attack.
/// </summary>
/// <param name="player">The player who is being hurt.</param>
/// <param name="hitInfo">Information about the hit, including damage types and initiator.</param>
/// <returns>
/// Returns a non-null value to prevent further processing of the hurt event. 
/// If `null` is returned, the default hurt logic will proceed.
/// </returns>
object IOnBasePlayerHurt(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} is being hurt by {hitInfo.InitiatorPlayer?.displayName ?? "unknown"} with damage: {hitInfo.damageTypes.Total()}.");

    if (hitInfo.damageTypes.Total() > 50f)
    {
        Puts($"Critical hit detected on {player.displayName}!");
    }

    return null; // Allow default processing to continue
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || (IsImmortal() && info.damageTypes.Total() >= 0f) || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		if (info.damageTypes.Has(DamageType.Fun_Water))
		{
			bool flag = true;
			Item activeItem = GetActiveItem();
			if (activeItem != null && (activeItem.info.shortname == "gun.water" || activeItem.info.shortname == "pistol.water"))
			{
				float value = metabolism.wetness.value;
				metabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);
				bool flag2 = metabolism.wetness.value >= ConVar.Server.funWaterDamageThreshold;
				flag = !flag2;
				if (info.InitiatorPlayer != null)
				{
					if (flag2 && value < ConVar.Server.funWaterDamageThreshold)
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_SOAKED");
					}
					if (metabolism.radiation_level.Fraction() > 0.2f && !string.IsNullOrEmpty("SUMMER_RADICAL"))
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_RADICAL");
					}
				}
			}
			if (flag)
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
		}
		if (info.damageTypes.Get(DamageType.Drowned) > 5f && drownEffect.isValid)
		{
			Effect.server.Run(drownEffect.resourcePath, this, StringPool.Get("head"), UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);
		}
		if (modifiers != null)
		{
			if (info.damageTypes.Has(DamageType.Radiation))
			{
				info.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));
			}
			if (info.damageTypes.Has(DamageType.RadiationExposure))
			{
				info.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));
			}
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((bool)initiatorPlayer && initiatorPlayer != this)
		{
			if (initiatorPlayer.InSafeZone() || InSafeZone())
			{
				initiatorPlayer.MarkHostileFor(1800f);
			}
			if (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(DamageType.Explosion) > 0f)
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);
			}
		}
		base.Hurt(info);
		if (EACServer.playerTracker != null && info.Initiator != null && info.Initiator is BasePlayer)
		{
			BasePlayer basePlayer = info.Initiator.ToPlayer();
			if (net.connection != null && basePlayer.net.connection != null)
			{
				EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
				EasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(basePlayer.net.connection);
				PlayerTakeDamage eventParams = default(PlayerTakeDamage);
				eventParams.DamageTaken = (int)info.damageTypes.Total();
				eventParams.HitBoneID = (int)info.HitBone;
				eventParams.WeaponID = 0;
				eventParams.DamageFlags = (info.isHeadshot ? PlayerTakeDamageFlags.PlayerTakeDamageCriticalHit : PlayerTakeDamageFlags.PlayerTakeDamageNormalHit);
				if (info.Weapon != null)
				{
					Item item = info.Weapon.GetItem();
					if (item != null)
					{
						eventParams.WeaponID = item.info.itemid;
					}
				}
				UnityEngine.Vector3 position = basePlayer.eyes.position;
				UnityEngine.Quaternion rotation = basePlayer.eyes.rotation;
				UnityEngine.Vector3 position2 = eyes.position;
				UnityEngine.Quaternion rotation2 = eyes.rotation;
				eventParams.AttackerPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position.x, position.y, position.z);
				eventParams.AttackerViewRotation = new EasyAntiCheat.Server.Cerberus.Quaternion(rotation.w, rotation.x, rotation.y, rotation.z);
				eventParams.VictimPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position2.x, position2.y, position2.z);
				eventParams.VictimViewRotation = new EasyAntiCheat.Server.Cerberus.Quaternion(rotation2.w, rotation2.x, rotation2.y, rotation2.z);
				EACServer.playerTracker.LogPlayerTakeDamage(client, client2, eventParams);
			}
		}
		metabolism.SendChangesToClient();
		if (info.PointStart != UnityEngine.Vector3.zero && info.damageTypes.Total() >= 0f)
		{
			ClientRPCPlayer(null, this, "DirectionalDamage", info.PointStart, (int)info.damageTypes.GetMajorityDamageType());
		}
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves a trigger area.
/// </summary>
/// <param name="entity">The entity that has left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.displayName} (ID: {entity.net.ID}) has left the trigger area: {trigger.name}.");

    if (entityContents != null)
    {
        Puts($"Removing entity {entity.displayName} from contents.");
        entityContents.Remove(entity);
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			entityContents.Remove(ent);
		}
	}

```

## OnVehicleModulesAssign(ModularCar,Rust.Modular.ItemModVehicleModule[])

```csharp
```csharp
/// <summary>
/// Called when vehicle modules are assigned to a modular car.
/// </summary>
/// <param name="car">The modular car to which the modules are being assigned.</param>
/// <param name="modules">An array of vehicle modules being assigned to the car.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModulesAssign(ModularCar car, Rust.Modular.ItemModVehicleModule[] modules)
{
    Puts($"Assigning modules to vehicle: {car.net.ID} with {modules.Length} modules.");

    foreach (var module in modules)
    {
        if (module != null)
        {
            Puts($"Module {module.shortname} is being assigned to vehicle {car.net.ID}.");
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", this, modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				itemModVehicleModule.doNonUserSpawn = true;
				Item item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);
				float num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", this, modularCarPresetConfig.socketItemDefs);
	}

```

## IOnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to approve a user's connection to the server.
/// </summary>
/// <param name="connection">The network connection of the user attempting to connect.</param>
/// <returns>
/// Returns a non-null value to reject the connection with a message. 
/// If `null` is returned, the connection is approved and the user is allowed to proceed.
/// </returns>
object IOnUserApprove(Network.Connection connection)
{
    Puts($"User {connection.userid} is attempting to connect with token: {connection.token}.");

    if (connection.token == "special_token")
    {
        Puts($"User {connection.userid} has a special token and is approved.");
        return null; // Approve the connection
    }

    Puts($"User {connection.userid} does not have a special token and will be rejected.");
    return "You need a special token to connect.";
}
```
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0L)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2271)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)");
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			ServerUsers.User user = ServerUsers.Get(connection.userid);
			string text = user?.notes ?? "no reason given";
			string text2 = ((user != null && user.expiry > 0) ? (" for " + (user.expiry - Epoch.Current).FormatSecondsLong()) : "");
			Reject(connection, "You are banned from this server" + text2 + " (" + text + ")");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log(connection.ToString() + " has auth level 1");
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log(connection.ToString() + " has auth level 2");
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log(connection.ToString() + " is a developer");
			connection.authLevel = 3u;
		}
		if (IsConnected(connection.userid))
		{
			Reject(connection, "You are already connected!");
		}
		else if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used, allowing for custom behavior before consumption.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amount">The amount of the item to consume.</param>
/// <returns>No return behavior.</returns>
void OnItemUse(Item item, int amount)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) is being used. Amount to consume: {amount}.");

    if (item.info.shortname == "healthkit")
    {
        Puts("Health kit used! Restoring health.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", this, amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## OnLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player loots another player.
/// </summary>
/// <param name="looter">The player who is looting.</param>
/// <param name="target">The player being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"{looter.displayName} is looting {target.displayName}'s inventory.");
    
    if (target.IsDead())
    {
        Puts($"{target.displayName} has been successfully looted.");
    }
    else
    {
        Puts($"{target.displayName} is still alive and cannot be looted.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_LootPlayer(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))
		{
			player.inventory.loot.AddContainer(inventory.containerMain);
			player.inventory.loot.AddContainer(inventory.containerWear);
			player.inventory.loot.AddContainer(inventory.containerBelt);
			Interface.CallHook("OnLootPlayer", this, player);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "player_corpse");
		}
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when an auto turret is shutting down.
/// </summary>
/// <param name="turret">The auto turret that is shutting down.</param>
/// <returns>No return behavior.</returns>
void OnTurretShutdown(AutoTurret turret)
{
    Puts($"Auto turret {turret.net.ID} is shutting down.");
    if (turret.IsOffline())
    {
        Puts($"Turret {turret.net.ID} is already offline.");
    }
    else
    {
        Puts($"Turret {turret.net.ID} is transitioning to offline mode.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if ((!IsOffline() || booting) && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			CancelInvoke(SetOnline);
			booting = false;
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## OnSurveyGather(SurveyCharge,Item)

```csharp
```csharp
/// <summary>
/// Called when resources are gathered from a survey charge explosion.
/// </summary>
/// <param name="surveyCharge">The survey charge that triggered the gathering.</param>
/// <param name="item">The item that was gathered as a result of the survey.</param>
/// <returns>No return behavior.</returns>
void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts($"Survey charge at {surveyCharge.transform.position} gathered item: {item.info.displayName.english} (ID: {item.info.itemid})");
    
    if (item.info.shortname == "scrap")
    {
        Puts("Scrap has been gathered from the survey charge!");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		base.Explode();
		if (WaterLevel.Test(base.transform.position, waves: true, this))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))
		{
			return;
		}
		Vector3 point = hitOut.point;
		_ = hitOut.normal;
		List<SurveyCrater> obj = Pool.GetList<SurveyCrater>();
		Vis.Entities(base.transform.position, 10f, obj, 1);
		bool num = obj.Count > 0;
		Pool.FreeList(ref obj);
		if (num)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag = true;
				if (resource.isLiquid)
				{
					flag2 = true;
				}
				for (int i = 0; i < num2; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", this, item);
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);
					item.Drop(base.transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
				}
			}
		}
		if (flag)
		{
			string strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);
			BaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if ((bool)baseEntity)
			{
				baseEntity.Spawn();
			}
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player disconnects from the server.
/// </summary>
/// <param name="player">The player who has disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has disconnected. Reason: {reason}");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void OnDisconnected(string strReason, Network.Connection connection)
	{
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		PlatformService.Instance.EndPlayerSession(connection.userid);
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((bool)basePlayer)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
	}

```

## OnItemCraftCancelled(ItemCraftTask)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is cancelled.
/// </summary>
/// <param name="task">The item crafting task that was cancelled.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task)
{
    Puts($"Crafting task {task.taskUID} has been cancelled for item: {task.blueprint.targetItem.shortname}.");
    
    if (task.takenItems != null && task.takenItems.Count > 0)
    {
        foreach (Item takenItem in task.takenItems)
        {
            if (takenItem != null)
            {
                Puts($"Item {takenItem.info.displayName.english} was taken for crafting and is now being returned.");
            }
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID, bool ReturnItems)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (itemCraftTask.owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask);
		itemCraftTask.owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0 && ReturnItems)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))
					{
						takenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition + UnityEngine.Random.value * Vector3.down + UnityEngine.Random.insideUnitSphere, itemCraftTask.owner.inventory.containerMain.dropVelocity);
						itemCraftTask.owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
		}
		return true;
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player toggles the vending machine's broadcast setting.
/// </summary>
/// <param name="vendingMachine">The vending machine whose broadcast setting is being toggled.</param>
/// <param name="player">The player who toggled the broadcast setting.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) toggled the broadcast for vending machine {vendingMachine.net.ID}.");
    
    if (vendingMachine.HasFlag(Flags.Reserved4))
    {
        Puts("Broadcast is now enabled.");
    }
    else
    {
        Puts("Broadcast is now disabled.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has respawned at position: {player.transform.position}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void RespawnAt(UnityEngine.Vector3 position, UnityEngine.Quaternion rotation)
	{
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		ServerPerformance.spawns++;
		SetParent(null, worldPositionStays: true);
		base.transform.SetPositionAndRotation(position, rotation);
		tickInterpolator.Reset(position);
		lastTickTime = 0f;
		StopWounded();
		StopSpectating();
		UpdateNetworkGroup();
		EnablePlayerCollider();
		RemovePlayerRigidbody();
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		if (modifiers != null)
		{
			modifiers.RemoveAll();
		}
		InitializeHealth(StartHealth(), StartMaxHealth());
		inventory.GiveDefaultItems();
		SendNetworkUpdateImmediate();
		ClientRPCPlayer(null, this, "StartLoading");
		if (net != null)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", this);
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is in hunt mode to determine its behavior.
/// </summary>
/// <param name="apc">The Bradley APC that is hunting.</param>
/// <returns>
/// Returns a non-null value to override the default hunting behavior. 
/// If `null` is returned, the APC will proceed with its normal hunting logic.
/// </returns>
object OnBradleyApcHunt(BradleyAPC apc)
{
    Puts($"Bradley APC (ID: {apc.net.ID}) is attempting to hunt for targets.");
    
    // Example condition to prevent hunting
    if (apc.IsUnderAttack)
    {
        Puts("Bradley APC is under attack and will not hunt.");
        return true; // Prevents normal hunting behavior
    }

    return null; // Allows normal hunting behavior to continue
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			BasePathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			BasePathNode basePathNode = null;
			List<BasePathNode> nearNodes = Facepunch.Pool.GetList<BasePathNode>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<BasePathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (BasePathNode item2 in nearNodes)
			{
				Stack<BasePathNode> path = new Stack<BasePathNode>();
				if (targetInfo.entity.IsVisible(item2.transform.position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					basePathNode = item2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].transform.position);
					}
				}
				foreach (BasePathNode item3 in stack)
				{
					currentPath.Add(item3.transform.position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = basePathNode.transform.position;
			}
			Facepunch.Pool.FreeList(ref nearNodes);
			Facepunch.Pool.FreeList(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## OnMapMarkersClear(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player clears their map markers.
/// </summary>
/// <param name="player">The player who is clearing the map markers.</param>
/// <param name="mapNote">The map note that is being cleared.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkersClear(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has cleared their map markers.");
    
    if (mapNote != null)
    {
        Puts($"Cleared map note: {mapNote.note}");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, ServerCurrentMapNote) == null)
		{
			ServerCurrentDeathNote?.Dispose();
			ServerCurrentDeathNote = null;
			ServerCurrentMapNote?.Dispose();
			ServerCurrentMapNote = null;
			DirtyPlayerState();
			TeamUpdate();
			Interface.CallHook("OnMapMarkersCleared", this, ServerCurrentMapNote);
		}
	}

```

## OnPlayerWantsMount(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player expresses a desire to mount a mountable entity.
/// </summary>
/// <param name="player">The player who wants to mount the entity.</param>
/// <param name="mountable">The mountable entity the player wants to interact with.</param>
/// <returns>No return behavior.</returns>
void OnPlayerWantsMount(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) wants to mount {mountable.gameObject.name}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_WantsMount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (DirectlyMountable() && Interface.CallHook("OnPlayerWantsMount", player, this) == null)
		{
			AttemptMount(player);
		}
	}

```

## OnNpcResume(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC resumes its normal behavior after being paused.
/// </summary>
/// <param name="npc">The NPC that is resuming its behavior.</param>
/// <returns>No return behavior.</returns>
void OnNpcResume(NPCPlayerApex npc)
{
    Puts($"NPC {npc.displayName} (ID: {npc.net.ID}) has resumed its normal behavior.");
    
    if (!npc.IsMounted)
    {
        Puts($"NPC {npc.displayName} is not mounted and will attempt to navigate.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Resume()
	{
		if (base.isMounted)
		{
			if (utilityAiComponent == null)
			{
				utilityAiComponent = Entity.GetComponent<UtilityAIComponent>();
			}
			if (utilityAiComponent != null)
			{
				utilityAiComponent.enabled = true;
				utilityAiComponent.Resume();
			}
			SendNetworkUpdateImmediate();
			return;
		}
		if (!GetNavAgent.isOnNavMesh)
		{
			if (Interface.CallHook("OnNpcResume", this) == null)
			{
				StartCoroutine(TryForceToNavmesh());
			}
			return;
		}
		GetNavAgent.enabled = true;
		StoppingDistance = 1f;
		if (utilityAiComponent == null)
		{
			utilityAiComponent = Entity.GetComponent<UtilityAIComponent>();
		}
		if (utilityAiComponent != null)
		{
			utilityAiComponent.enabled = true;
			utilityAiComponent.Resume();
		}
		InvokeRandomized(RadioChatter, RadioEffectRepeatRange.x, RadioEffectRepeatRange.x, RadioEffectRepeatRange.y - RadioEffectRepeatRange.x);
	}

```

## CanHackCrate(BasePlayer,HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hack a locked crate.
/// </summary>
/// <param name="player">The player attempting to hack the crate.</param>
/// <param name="crate">The hackable locked crate being targeted.</param>
/// <returns>
/// Returns `true` if the player can hack the crate, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can hack the crate.
/// </returns>
bool? CanHackCrate(BasePlayer player, HackableLockedCrate crate)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to hack a crate.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot hack a crate while in a safe zone.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", msg.player, this) == null)
		{
			StartHacking();
		}
	}

```

## OnTurretToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the state of an auto turret is toggled online or offline.
/// </summary>
/// <param name="turret">The auto turret whose state is being toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret.net.ID} is now {(turret.HasFlag(Flags.On) ? "online" : "offline")}.");
    
    if (turret.HasFlag(Flags.On))
    {
        Puts($"Turret {turret.net.ID} is active and ready to engage targets.");
    }
    else
    {
        Puts($"Turret {turret.net.ID} has been deactivated and will not engage.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != HasFlag(Flags.On) && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			booting = false;
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
			}
		}
	}

```

## OnPlayerInput(BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player provides input during their tick update.
/// </summary>
/// <param name="player">The player providing the input.</param>
/// <param name="inputState">The current state of the player's input.</param>
/// <returns>No return behavior.</returns>
void OnPlayerInput(BasePlayer player, InputState inputState)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) input received: {inputState.ToString()}");

    if (inputState.IsPressed(BUTTON.FIRE_PRIMARY))
    {
        Puts($"Player {player.displayName} is firing their primary weapon.");
    }
    else if (inputState.IsPressed(BUTTON.JUMP))
    {
        Puts($"Player {player.displayName} jumped.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## OnEntityMounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player mounts an entity.
/// </summary>
/// <param name="mountable">The mountable entity being used.</param>
/// <param name="player">The player who is mounting the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityMounted(BaseMountable mountable, BasePlayer player)
{
    Puts($"Player {player.displayName} has mounted {mountable.gameObject.name}.");
    
    if (mountable is Vehicle)
    {
        Puts($"Player {player.displayName} is now driving the vehicle.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			TriggerParent triggerParent = player.FindTrigger<TriggerParent>();
			if ((bool)triggerParent)
			{
				triggerParent.OnTriggerExit(player.GetComponent<Collider>());
			}
			player.MountObject(this);
			player.MovePosition(mountAnchor.transform.position);
			player.transform.rotation = mountAnchor.transform.rotation;
			player.ServerRotation = mountAnchor.transform.rotation;
			player.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			SetFlag(Flags.Busy, b: true);
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that has been locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.net.ID} has been locked by player {player.displayName} (ID: {player.UserIDString}).");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} locked the sign, bypassing any restrictions.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## OnCorpsePopulate(HumanNPC,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called to populate an NPC player's corpse with loot after it has been created.
/// </summary>
/// <param name="npc">The NPC that has died and whose corpse is being populated.</param>
/// <param name="corpse">The NPCPlayerCorpse that is being populated with loot.</param>
/// <returns>
/// Returns a <c>BaseCorpse</c> if the hook modifies the corpse; otherwise, returns <c>null</c> to use the default population logic.
/// </returns>
BaseCorpse OnCorpsePopulate(HumanNPC npc, NPCPlayerCorpse corpse)
{
    Puts($"Populating corpse for NPC: {npc.displayName} (ID: {npc.userID})");

    if (npc.IsElite)
    {
        Puts("This NPC is elite, adding special loot.");
        // Add special loot logic here
    }

    return null; // Allow default loot population to occur
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse()
	{
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse("assets/prefabs/npc/scientist/scientist_corpse.prefab") as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				nPCPlayerCorpse.playerName = base.displayName;
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				nPCPlayerCorpse.TakeChildren(this);
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
				if (LootSpawnSlots.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int i = 0; i < lootSpawnSlots.Length; i++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
						for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## CanUpdateSign(BasePlayer,PhotoFrame)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update the sign associated with this object.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="photoFrame">The photo frame object associated with the sign.</param>
/// <returns>
/// Returns `true` if the player can update the sign; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can update the sign.
/// </returns>
bool? CanUpdateSign(BasePlayer player, PhotoFrame photoFrame)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to update a sign.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can update the sign.");
        return true;
    }

    if (photoFrame.IsLocked() && player.userID != photoFrame.OwnerID)
    {
        Puts($"Player {player.displayName} cannot update the sign because it is locked.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## CanHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Determines whether the helicopter can drop a supply crate.
/// </summary>
/// <param name="helicopter">The helicopter attempting to drop a crate.</param>
/// <returns>
/// Returns `true` if the helicopter can drop a crate; otherwise, returns `false`.
/// If the method returns `null`, the default logic will be used to determine if a crate can be dropped.
/// </returns>
bool? CanHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter ID: {helicopter.net.ID} is checking if it can drop a crate.");
    
    if (helicopter.numCrates <= 0)
    {
        Puts("No crates available for dropping.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the oven is toggled on or off by a player.
/// </summary>
/// <param name="oven">The oven that is being toggled.</param>
/// <param name="player">The player who is toggling the oven.</param>
/// <returns>No return behavior.</returns>
void OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts($"Player {player.displayName} toggled the oven (ID: {oven.net.ID}). Current state: {(oven.IsOn() ? "On" : "Off")}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnOvenToggle", this, msg.player) == null && flag != IsOn() && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				StartCooking();
			}
			else
			{
				StopCooking();
			}
		}
	}

```

## OnExplosiveDud(DudTimedExplosive)

```csharp
```csharp
/// <summary>
/// Called when a timed explosive becomes a dud instead of detonating.
/// </summary>
/// <param name="dud">The dud timed explosive that failed to detonate.</param>
/// <returns>
/// Returns a non-null value to override the default dud behavior. If `null` is returned, the explosive will behave as normal.
/// </returns>
object OnExplosiveDud(DudTimedExplosive dud)
{
    Puts($"Explosive {dud.net.ID} has become a dud and will not detonate.");
    // Additional logic can be added here if needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		if (creatorEntity != null && creatorEntity.IsNpc)
		{
			base.Explode();
		}
		else if (UnityEngine.Random.Range(0f, 1f) < dudChance && Interface.CallHook("OnExplosiveDud", this) == null)
		{
			BecomeDud();
		}
		else
		{
			base.Explode();
		}
	}

```

## OnGiveSoldItem(VendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is given to a player from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine dispensing the item.</param>
/// <param name="soldItem">The item being sold.</param>
/// <param name="buyer">The player purchasing the item.</param>
/// <returns>No return behavior.</returns>
void OnGiveSoldItem(VendingMachine vendingMachine, Item soldItem, BasePlayer buyer)
{
    Puts($"Item {soldItem.info.displayName.english} given to {buyer.displayName} from vending machine.");
    
    if (soldItem.info.shortname == "water.bottle")
    {
        Puts($"{buyer.displayName} received a water bottle!");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", this, soldItem, buyer) == null)
		{
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

```

## OnCorpsePopulate(Scientist,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called to populate the corpse of a scientist NPC with loot or other items.
/// </summary>
/// <param name="scientist">The scientist NPC whose corpse is being populated.</param>
/// <param name="corpse">The NPCPlayerCorpse instance representing the scientist's corpse.</param>
/// <returns>
/// Returns a <c>BaseCorpse</c> instance if the population is modified; otherwise, returns <c>null</c> to use the default loot population logic.
/// </returns>
BaseCorpse OnCorpsePopulate(Scientist scientist, NPCPlayerCorpse corpse)
{
    Puts($"Populating corpse for scientist {scientist.displayName} (ID: {scientist.userID}).");

    // Example modification: Add a special item to the corpse
    if (scientist.HasSpecialLoot)
    {
        Puts("Adding special loot to the scientist's corpse.");
        // Add special loot logic here
    }

    return null; // Return null to allow default behavior
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse()
	{
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse("assets/prefabs/npc/scientist/scientist_corpse.prefab") as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				nPCPlayerCorpse.playerName = LootPanelName;
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				nPCPlayerCorpse.TakeChildren(this);
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
				if (LootSpawnSlots.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int i = 0; i < lootSpawnSlots.Length; i++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
						for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnPlayerCorpseSpawned(BasePlayer,PlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player's corpse is spawned in the game world.
/// </summary>
/// <param name="player">The player whose corpse is being spawned.</param>
/// <param name="corpse">The corpse object that has been created.</param>
/// <returns>No return behavior.</returns>
void OnPlayerCorpseSpawned(BasePlayer player, PlayerCorpse corpse)
{
    Puts($"Corpse spawned for player {player.displayName} (ID: {player.UserIDString}).");

    if (corpse != null)
    {
        Puts($"Corpse contains items: {corpse.inventory.itemList.Count} items.");
    }
    else
    {
        Puts($"No corpse was created for player {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse()
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			PlayerCorpse playerCorpse = DropCorpse("assets/prefabs/player/player_corpse.prefab") as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				playerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				playerCorpse.playerName = displayName;
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
	}

```

## CanTakeCutting(BasePlayer,GrowableEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can take a cutting from a growable entity.
/// </summary>
/// <param name="player">The player attempting to take a cutting.</param>
/// <param name="growable">The growable entity from which the cutting is being taken.</param>
/// <returns>
/// Returns `null` to allow the player to take a cutting, or any non-null value to prevent the action.
/// </returns>
object CanTakeCutting(BasePlayer player, GrowableEntity growable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to take a cutting from {growable.displayName}.");

    if (player.inventory.GetAmount("scissors") < 1)
    {
        Puts($"Player {player.displayName} does not have scissors to take a cutting.");
        return "You need scissors to take a cutting.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TakeClones(BasePlayer player)
	{
		if (player == null || !CanClone() || Interface.CallHook("CanTakeCutting", player, this) != null)
		{
			return;
		}
		int num = Properties.BaseCloneCount + Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;
		if (num > 0)
		{
			Item item = ItemManager.Create(Properties.CloneItem, num, 0uL);
			GrowableGeneEncoding.EncodeGenesToItem(this, item);
			player.GiveItem(item, GiveItemReason.PickedUp);
			if (Properties.pickEffect.isValid)
			{
				Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
			}
			Die();
		}
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the NPC can eat the specified entity.
/// </summary>
/// <param name="npc">The NPC attempting to eat.</param>
/// <param name="entity">The entity that may be eaten.</param>
/// <returns>
/// Returns `true` if the NPC can eat the entity, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the NPC can eat the entity.
/// </returns>
bool? CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc.displayName} is evaluating whether to eat {entity.displayName}.");

    if (!entity.HasTrait(TraitFlag.Food))
    {
        Puts($"{entity.displayName} is not food.");
        return false;
    }

    if (entity.HasTrait(TraitFlag.Alive))
    {
        Puts($"{entity.displayName} is alive and cannot be eaten.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnBookmarkDelete(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a bookmark is deleted from a computer station.
/// </summary>
/// <param name="station">The computer station from which the bookmark is being deleted.</param>
/// <param name="player">The player who is deleting the bookmark.</param>
/// <param name="bookmarkId">The identifier of the bookmark being deleted.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkDelete(ComputerStation station, BasePlayer player, string bookmarkId)
{
    Puts($"Bookmark '{bookmarkId}' deleted by player {player.displayName} (ID: {player.UserIDString}) from station {station.net.ID}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DeleteBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (IsValidIdentifier(text) && controlBookmarks.ContainsKey(text) && Interface.CallHook("OnBookmarkDelete", this, player, text) == null)
		{
			uint num = controlBookmarks[text];
			controlBookmarks.Remove(text);
			SendControlBookmarks(player);
			if (num == currentlyControllingEnt.uid)
			{
				currentlyControllingEnt.Set(null);
				SendNetworkUpdate();
			}
		}
	}

```

## OnExperimentEnd(Workbench)

```csharp
```csharp
/// <summary>
/// Called when an experiment at the workbench has completed.
/// </summary>
/// <param name="workbench">The workbench where the experiment was conducted.</param>
/// <returns>No return behavior.</returns>
void OnExperimentEnd(Workbench workbench)
{
    Puts($"Experiment completed at Workbench ID: {workbench.net.ID}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after a fall, allowing for custom handling of landing effects.
/// </summary>
/// <param name="player">The player who has landed.</param>
/// <param name="fallVelocity">The velocity at which the player landed.</param>
/// <returns>
/// Returns `null` to allow the default fall damage behavior, or any non-null value to override it.
/// </returns>
object OnPlayerLand(BasePlayer player, float fallVelocity)
{
    Puts($"Player {player.displayName} landed with a velocity of {fallVelocity} m/s.");

    if (fallVelocity > -50f)
    {
        Puts($"Player {player.displayName} landed safely.");
        return null; // Allow normal behavior
    }

    Puts($"Player {player.displayName} landed hard and may take damage.");
    return true; // Prevent default behavior if needed
}
```
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned in the game world.
/// </summary>
/// <param name="entity">The entity that has been spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity {entity.net.ID} of type {entity.GetType().Name} has been spawned.");
    
    if (entity is BaseEntity baseEntity)
    {
        Puts($"Entity {baseEntity.displayName} has been initialized with ID: {baseEntity.net.ID}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a combat entity dies.
/// </summary>
/// <param name="entity">The combat entity that has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death, if available.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.gameObject.name} has died. Cause: {hitInfo?.damageTypes?.ToString() ?? "Unknown"}");
    
    if (hitInfo != null && hitInfo.Initiator != null)
    {
        Puts($"Killed by: {hitInfo.Initiator.displayName}");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
		}
		health = 0f;
		lifestate = LifeState.Dead;
		Interface.CallHook("OnEntityDeath", this, info);
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## CanResearchItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can research a specific item.
/// </summary>
/// <param name="player">The player attempting to research the item.</param>
/// <param name="item">The item that the player wants to research.</param>
/// <returns>
/// Returns `true` if the player can research the item, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the item can be researched.
/// </returns>
bool? CanResearchItem(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to research item: {item.info.displayName.english}.");

    if (item.info.shortname == "blueprint")
    {
        Puts($"Player {player.displayName} cannot research blueprints.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnTeamAcceptInvite(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player accepts an invite to join a team.
/// </summary>
/// <param name="team">The team that the player is invited to join.</param>
/// <param name="player">The player who accepted the invite.</param>
/// <returns>
/// Returns `null` to allow the player to join the team, or any non-null value to prevent the action.
/// </returns>
object OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.displayName} has accepted an invite to join team {team.TeamName}.");
    
    if (team.IsFull())
    {
        Puts($"Player {player.displayName} cannot join team {team.TeamName} because it is full.");
        return "Team is full.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void acceptinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = Instance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamAcceptInvite", playerTeam, basePlayer) == null)
			{
				playerTeam.AcceptInvite(basePlayer);
			}
		}
	}

```

## OnBonusItemDropped(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is dropped for a player after crafting or other actions.
/// </summary>
/// <param name="item">The bonus item that has been dropped.</param>
/// <param name="player">The player who receives the bonus item.</param>
/// <returns>No return behavior.</returns>
void OnBonusItemDropped(Item item, BasePlayer player)
{
    Puts($"Bonus item {item.info.displayName.english} has been dropped for player {player.displayName} (ID: {player.UserIDString}).");

    if (item.info.shortname == "scrap")
    {
        Puts($"Player {player.displayName} received bonus scrap!");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity());
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player hits an entity with a hammer.
/// </summary>
/// <param name="player">The player who performed the hammer hit.</param>
/// <param name="hitInfo">Information about the hit, including the target entity and damage details.</param>
/// <returns>No return behavior.</returns>
void OnHammerHit(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} hit an entity with a hammer. Target: {hitInfo.HitEntity?.ShortPrefabName ?? "None"}");

    if (hitInfo.HitEntity is BaseCombatEntity entity)
    {
        Puts($"Entity {entity.ShortPrefabName} was hit for repair.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null && ownerPlayer != null && base.isServer)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			using (TimeWarning.New("DoRepair", 50))
			{
				baseCombatEntity.DoRepair(ownerPlayer);
			}
		}
		info.DoDecals = false;
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## OnBuildingPrivilege(BaseEntity,OBB)

```csharp
```csharp
/// <summary>
/// Called to retrieve the building privilege associated with a given bounding box.
/// </summary>
/// <param name="entity">The entity requesting the building privilege.</param>
/// <param name="obb">The oriented bounding box to check for building privileges.</param>
/// <returns>
/// Returns a <c>BuildingPrivlidge</c> object if a privilege is found; otherwise, returns <c>null</c>.
/// If the method returns a non-null value, it overrides the default privilege retrieval logic.
/// </returns>
BuildingPrivlidge OnBuildingPrivilege(BaseEntity entity, OBB obb)
{
    Puts($"Checking building privilege for entity: {entity?.name} with OBB at position: {obb.position}.");

    // Example condition to restrict building privileges
    if (obb.position.y < 0)
    {
        Puts("Building privilege denied: Position is below ground level.");
        return null;
    }

    return null; // Allow default behavior if no specific privilege is found
}
```
```

### Source Code from the Library

```csharp

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
	{
		object obj = Interface.CallHook("OnBuildingPrivilege", this, obb);
		if (obj is BuildingPrivlidge)
		{
			return (BuildingPrivlidge)obj;
		}
		BuildingBlock other = null;
		BuildingPrivlidge result = null;
		List<BuildingBlock> obj2 = Facepunch.Pool.GetList<BuildingBlock>();
		Vis.Entities(obb.position, 16f + obb.extents.magnitude, obj2, 2097152);
		for (int i = 0; i < obj2.Count; i++)
		{
			BuildingBlock buildingBlock = obj2[i];
			if (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) > 16f)
			{
				continue;
			}
			BuildingManager.Building building = buildingBlock.GetBuilding();
			if (building != null)
			{
				BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
				if (!(dominatingBuildingPrivilege == null))
				{
					other = buildingBlock;
					result = dominatingBuildingPrivilege;
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		return result;
	}

```

## OnEngineStart(ModularCar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to start the engine of a modular car.
/// </summary>
/// <param name="car">The modular car whose engine is being started.</param>
/// <param name="player">The player attempting to start the engine.</param>
/// <returns>
/// Returns a non-null value to prevent the engine from starting. 
/// If `null` is returned, the engine will proceed to start as normal.
/// </returns>
object OnEngineStart(ModularCar car, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to start the engine of car ID: {car.net.ID}.");
    
    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can start the engine.");
        return null; // Allow engine to start
    }

    Puts($"Player {player.displayName} is not allowed to start the engine.");
    return true; // Prevent engine from starting
}
```
```

### Source Code from the Library

```csharp

	public void TryStartEngines(BasePlayer player)
	{
		if (!IsDead() && CurEngineState == EngineState.Off && player.net != null)
		{
			if (!CanRunEngines())
			{
				bool arg = !HasAnyWorkingEngines() || waterlogged;
				ClientRPC(null, "EngineStartFailed", arg);
			}
			else if (Interface.CallHook("OnEngineStart", this, player) == null)
			{
				CancelEngineStart();
				SetFlag(Flags.Reserved1, b: true);
				SetFlag(Flags.On, b: false);
				Invoke(FinishStartingEngine, carSettings.engineStartupTime);
			}
		}
	}

```

## OnPlayerDeath(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player dies in the game.
/// </summary>
/// <param name="player">The player who has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death.</param>
/// <returns>
/// Returns `null` to allow the default death behavior, or any non-null value to override it.
/// </returns>
object OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has died due to {hitInfo.damageTypes.GetMajorityDamageType()}.");
    
    if (hitInfo.Initiator is BasePlayer killer)
    {
        Puts($"Player {player.displayName} was killed by {killer.displayName}.");
    }

    return null; // Allow default death behavior
}
```
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead())
			{
				if (Belt != null && ShouldDropActiveItem())
				{
					UnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + vector.normalized * 3f);
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDeath", this, info) == null)
				{
					base.Die(info);
				}
			}
		}
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an entity.
/// </summary>
/// <param name="player">The player who is looting the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntity(BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has started looting entity: {entity.name} (ID: {entity.net.ID}).");
    
    if (entity is LootableObject)
    {
        Puts($"Entity {entity.name} is lootable.");
    }
    else
    {
        Puts($"Entity {entity.name} is not lootable.");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!targetEntity)
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		MarkDirty();
		return true;
	}

```

## OnReactiveTargetReset(ReactiveTarget)

```csharp
```csharp
/// <summary>
/// Called when a reactive target is reset after being knocked down.
/// </summary>
/// <param name="target">The reactive target that is being reset.</param>
/// <returns>No return behavior.</returns>
void OnReactiveTargetReset(ReactiveTarget target)
{
    Puts($"Reactive target {target.net.ID} has been reset.");
}
```
```

### Source Code from the Library

```csharp

	public void ResetTarget()
	{
		if (IsKnockedDown() && CanToggle())
		{
			CancelInvoke(ResetTarget);
			SetFlag(Flags.On, b: true);
			knockdownHealth = 100f;
			SendPowerBurst();
			Interface.CallHook("OnReactiveTargetReset", this);
		}
	}

```

## OnTeamInvite(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player invites another player to join their team.
/// </summary>
/// <param name="inviter">The player who is sending the team invite.</param>
/// <param name="invitee">The player being invited to join the team.</param>
/// <returns>
/// Returns `null` to allow the invite to proceed, or any non-null value to prevent the invite.
/// </returns>
object OnTeamInvite(BasePlayer inviter, BasePlayer invitee)
{
    Puts($"Player {inviter.displayName} (ID: {inviter.UserIDString}) invited {invitee.displayName} (ID: {invitee.UserIDString}) to join their team.");
    
    if (invitee.IsBannedFromTeams)
    {
        Puts($"Player {invitee.displayName} is banned from joining teams.");
        return "You are banned from joining teams.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void sendinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		PlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), out var hitInfo, 5f, 1218652417, QueryTriggerInteraction.Ignore))
		{
			return;
		}
		BaseEntity entity = RaycastHitEx.GetEntity(hitInfo);
		if ((bool)entity)
		{
			BasePlayer component = entity.GetComponent<BasePlayer>();
			if ((bool)component && component != basePlayer && !component.IsNpc && component.currentTeam == 0L && Interface.CallHook("OnTeamInvite", basePlayer, component) == null)
			{
				playerTeam.SendInvite(component);
			}
		}
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after a fall, allowing for custom handling of landing effects.
/// </summary>
/// <param name="player">The player who has landed.</param>
/// <param name="fallVelocity">The velocity at which the player landed.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanded(BasePlayer player, float fallVelocity)
{
    Puts($"Player {player.displayName} landed with a velocity of {fallVelocity} m/s.");

    if (fallVelocity > 50f)
    {
        Puts($"Player {player.displayName} experienced a hard landing!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnPlayerSetInfo(Network.Connection,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player sets their information, such as username or other attributes.
/// </summary>
/// <param name="connection">The network connection of the player setting the information.</param>
/// <param name="key">The key representing the type of information being set.</param>
/// <param name="val">The value being set for the specified key.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSetInfo(Network.Connection connection, string key, string val)
{
    Puts($"Player {connection.username} has set their info: {key} = {val}");
    
    if (key == "username" && string.IsNullOrWhiteSpace(val))
    {
        Puts("Attempt to set an empty username detected. Rejecting.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void SetInfo(string key, string val)
	{
		if (IsConnected)
		{
			Interface.CallHook("OnPlayerSetInfo", net.connection, key, val);
			net.connection.info.Set(key, val);
		}
	}

```

## OnEngineStarted(ModularCar)

```csharp
```csharp
/// <summary>
/// Called when the engine of a modular car has successfully started.
/// </summary>
/// <param name="car">The modular car whose engine has started.</param>
/// <returns>No return behavior.</returns>
void OnEngineStarted(ModularCar car)
{
    Puts($"Engine started for car ID: {car.net.ID}, Owner: {car.OwnerID}");
    if (car.IsDead())
    {
        Puts($"Warning: Attempted to start engine on a dead car (ID: {car.net.ID}).");
    }
}
```
```

### Source Code from the Library

```csharp

	public void FinishStartingEngine()
	{
		if (!IsDead() && CurEngineState != EngineState.On)
		{
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			Interface.CallHook("OnEngineStarted", this);
		}
	}

```

## OnEntityStabilityCheck(StabilityEntity)

```csharp
```csharp
/// <summary>
/// Called to perform a stability check on the entity.
/// </summary>
/// <param name="entity">The stability entity being checked.</param>
/// <returns>No return behavior.</returns>
void OnEntityStabilityCheck(StabilityEntity entity)
{
    Puts($"Stability check initiated for entity ID: {entity.net.ID}.");
    
    if (entity.IsDestroyed)
    {
        Puts($"Entity ID: {entity.net.ID} is already destroyed.");
        return;
    }

    // Additional stability logic can be added here
    Puts($"Entity ID: {entity.net.ID} is stable.");
}
```
```

### Source Code from the Library

```csharp

	public void StabilityCheck()
	{
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			cachedDistanceFromGround = num;
			flag = true;
		}
		float num2 = SupportValue();
		if (Mathf.Abs(cachedStability - num2) > Stability.accuracy)
		{
			cachedStability = num2;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability();
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num2 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				UpdateStability();
				stabilityStrikes++;
			}
			else
			{
				Kill(DestroyMode.Gib);
			}
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

```

## CanSetBedPublic(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can set a sleeping bag as public.
/// </summary>
/// <param name="player">The player attempting to set the sleeping bag as public.</param>
/// <param name="sleepingBag">The sleeping bag being modified.</param>
/// <returns>
/// Returns `true` if the player can set the sleeping bag as public, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can set the sleeping bag as public.
/// </returns>
bool? CanSetBedPublic(BasePlayer player, SleepingBag sleepingBag)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to set sleeping bag {sleepingBag.ID} as public.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can set the sleeping bag as public.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsPublic() && Interface.CallHook("CanSetBedPublic", msg.player, this) == null)
		{
			SetPublic(flag);
			if (!IsPublic())
			{
				deployerUserID = msg.player.userID;
			}
			SendNetworkUpdate();
		}
	}

```

## OnPlayerWantsDismount(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player requests to dismount from a mountable entity.
/// </summary>
/// <param name="player">The player who wants to dismount.</param>
/// <param name="mountable">The mountable entity the player is currently on.</param>
/// <returns>
/// Returns `null` to allow the dismount action, or any non-null value to prevent the dismount.
/// </returns>
object OnPlayerWantsDismount(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) wants to dismount from {mountable.GetType().Name}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot dismount while in a safe zone.");
        return "You cannot dismount in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (HasValidDismountPosition(player) && Interface.CallHook("OnPlayerWantsDismount", player, this) == null)
		{
			AttemptDismount(player);
		}
	}

```

## OnPlayerBanned(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned from the server.
/// </summary>
/// <param name="connection">The network connection of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(Network.Connection connection, string reason)
{
    Puts($"Player {connection.username} (ID: {connection.userid}) has been banned. Reason: {reason}");
    // Additional logic for handling player bans can be added here.
}
```
```

### Source Code from the Library

```csharp

	private static void HandleClientUpdate(ClientStatusUpdate<EasyAntiCheat.Server.Hydra.Client> clientStatus)
	{
		using (TimeWarning.New("AntiCheatKickPlayer", 10))
		{
			EasyAntiCheat.Server.Hydra.Client client = clientStatus.Client;
			Connection connection = GetConnection(client);
			if (connection == null)
			{
				Debug.LogError("EAC status update for invalid client: " + client.ClientID);
			}
			else
			{
				if (ShouldIgnore(connection))
				{
					return;
				}
				if (clientStatus.RequiresKick)
				{
					string text = clientStatus.Message;
					if (string.IsNullOrEmpty(text))
					{
						text = clientStatus.Status.ToString();
					}
					Debug.Log($"[EAC] Kicking {connection.userid} / {connection.username} ({text})");
					connection.authStatus = "eac";
					Network.Net.sv.Kick(connection, "EAC: " + text);
					Interface.CallHook("OnPlayerKicked", connection, text);
					if (clientStatus.IsBanned(out var timeBanExpires))
					{
						connection.authStatus = "eacbanned";
						object[] args = new object[3]
						{
							2,
							0,
							"<color=#fff>SERVER</color> Kicking " + connection.username + " (banned by anticheat)"
						};
						Interface.CallHook("OnPlayerBanned", connection, text);
						ConsoleNetwork.BroadcastToAllClients("chat.add", args);
						if (!timeBanExpires.HasValue)
						{
							Entity.DeleteBy(connection.userid);
						}
					}
					easyAntiCheat.UnregisterClient(client);
					client2connection.Remove(client);
					connection2client.Remove(connection);
					connection2status.Remove(connection);
				}
				else if (clientStatus.Status == ClientStatus.ClientAuthenticatedLocal)
				{
					OnAuthenticatedLocal(connection);
					easyAntiCheat.SetClientNetworkState(client, networkActive: false);
				}
				else if (clientStatus.Status == ClientStatus.ClientAuthenticatedRemote)
				{
					OnAuthenticatedRemote(connection);
				}
			}
		}
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
```csharp
/// <summary>
/// Called when a weapon is fired by a player.
/// </summary>
/// <param name="projectile">The projectile being fired.</param>
/// <param name="player">The player who fired the weapon.</param>
/// <param name="ammoMod">The ammunition modification associated with the projectile.</param>
/// <param name="projectileData">The data related to the projectile's shooting parameters.</param>
/// <returns>No return behavior.</returns>
void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile ammoMod, ProtoBuf.ProjectileShoot projectileData)
{
    Puts($"Player {player.displayName} fired weapon {projectile.ShortPrefabName} with {projectileData.projectiles.Count} projectiles.");
    
    if (projectileData.projectiles.Count > ammoMod.numProjectiles)
    {
        Puts($"Warning: Player {player.displayName} attempted to fire more projectiles than allowed.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_missing");
			return;
		}
		ItemDefinition ammoType = primaryMagazine.ammoType;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (ammoType.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_mismatch");
			return;
		}
		if (!UsingInfiniteAmmoCheat)
		{
			primaryMagazine.contents--;
		}
		ItemModProjectile component = ammoType.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection);
		player.CleanupExpiredProjectiles();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.Log(this, "duplicate_id");
			}
			else if (ValidateEyePos(player, projectile.startPos))
			{
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, ammoType);
				CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
			}
		}
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count(), (Stats)5);
		player.LifeStoryShotFired(this);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);
		player.MarkHostileFor();
		UpdateItemCondition();
		DidAttackServerside();
		float num = 0f;
		if (component.projectileObject != null)
		{
			GameObject gameObject = component.projectileObject.Get();
			if (gameObject != null)
			{
				Projectile component2 = gameObject.GetComponent<Projectile>();
				if (component2 != null)
				{
					foreach (DamageTypeEntry damageType in component2.damageTypes)
					{
						num += damageType.amount;
					}
				}
			}
		}
		float num2 = NoiseRadius;
		if (IsSilenced())
		{
			num2 *= AI.npc_gun_noise_silencer_modifier;
		}
		Sensation sensation = default(Sensation);
		sensation.Type = SensationType.Gunshot;
		sensation.Position = player.transform.position;
		sensation.Radius = num2;
		sensation.DamagePotential = num;
		sensation.InitiatorPlayer = player;
		sensation.Initiator = player;
		Sense.Stimulate(sensation);
		if (EACServer.playerTracker == null)
		{
			return;
		}
		using (TimeWarning.New("LogPlayerShooting"))
		{
			UnityEngine.Vector3 networkPosition = player.GetNetworkPosition();
			UnityEngine.Quaternion networkRotation = player.GetNetworkRotation();
			int weaponID = GetItem()?.info.itemid ?? 0;
			EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(player.net.connection);
			PlayerUseWeapon eventParams = default(PlayerUseWeapon);
			eventParams.Position = new EasyAntiCheat.Server.Cerberus.Vector3(networkPosition.x, networkPosition.y, networkPosition.z);
			eventParams.ViewRotation = new EasyAntiCheat.Server.Cerberus.Quaternion(networkRotation.w, networkRotation.x, networkRotation.y, networkRotation.z);
			eventParams.WeaponID = weaponID;
			EACServer.playerTracker.LogPlayerUseWeapon(client, eventParams);
		}
	}

```

## OnItemRemove(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from the game or inventory.
/// </summary>
/// <param name="item">The item that is being removed.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being removed. 
/// If `null` is returned, the item will be removed as normal.
/// </returns>
object OnItemRemove(Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) is being removed.");
    
    if (item.amount <= 0)
    {
        Puts($"Item {item.info.displayName.english} cannot be removed because its amount is zero.");
        return "Cannot remove item with zero amount.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = UnityEngine.Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		if (isServer)
		{
			ItemManager.RemoveItem(this, fTime);
		}
	}

```

## OnItemDeployed(Deployer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is successfully deployed in the game world.
/// </summary>
/// <param name="deployer">The player who deployed the item.</param>
/// <param name="entity">The entity that was deployed.</param>
/// <returns>No return behavior.</returns>
void OnItemDeployed(BasePlayer deployer, BaseEntity entity)
{
    Puts($"Item deployed by {deployer.displayName} (ID: {deployer.UserIDString}) at position: {entity.transform.position}.");
    
    if (entity is Deployable deployable)
    {
        Puts($"Deployable item {deployable.shortname} has been placed.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ChatMessage("Building is blocked at player position!");
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		if (ownerPlayer.Distance(baseEntity) > 3f)
		{
			ownerPlayer.ChatMessage("Too far away!");
			return;
		}
		if (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))
		{
			ownerPlayer.ChatMessage("Building is blocked at placement position!");
			return;
		}
		Item ownerItem = GetOwnerItem();
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			baseEntity2.skinID = ownerItem.skin;
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity, ownerPlayer);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity);
		UseItemAmount(1);
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player loots an item.
/// </summary>
/// <param name="player">The player who is looting the item.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootItem(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is looting item: {item.info.displayName.english} (ID: {item.info.itemid}).");
    
    if (item.info.shortname == "loot.bag")
    {
        Puts($"Player {player.displayName} has looted a special loot bag!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
			MarkDirty();
		}
	}

```

## OnRecycleItem(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled in the recycler.
/// </summary>
/// <param name="recycler">The recycler that is processing the item.</param>
/// <param name="item">The item being recycled.</param>
/// <returns>No return behavior.</returns>
void OnRecycleItem(Recycler recycler, Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) is being recycled in {recycler.gameObject.name}.");

    if (item.amount > 10)
    {
        Puts($"Warning: Recycling a large quantity of {item.info.displayName.english}. Consider reducing the amount.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = recycleEfficiency;
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (slot == null)
				{
					goto IL_034f;
				}
				if (Interface.CallHook("OnRecycleItem", this, slot) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (!(slot.info.Blueprint != null))
				{
					goto IL_034f;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.info.stackable * 0.1f));
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					int num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.info.stackable == 1 && slot.hasCondition)
					{
						num4 = Mathf.CeilToInt((float)num4 * slot.conditionNormalized);
					}
					if (num4 >= 1)
					{
						Item newItem = ItemManager.CreateByName("scrap", num4, 0uL);
						MoveItemToOutput(newItem);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj = Facepunch.Pool.GetList<BasePlayer>();
					Vis.Entities(base.transform.position, 3f, obj, 131072);
					foreach (BasePlayer item in obj)
					{
						if (item.IsAlive() && !item.IsSleeping() && item.inventory.loot.entitySource == this)
						{
							item.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item.stats.Save();
						}
					}
					Facepunch.Pool.FreeList(ref obj);
				}
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num5 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
					int num6 = 0;
					if (num5 <= 1f)
					{
						for (int i = 0; i < num3; i++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= num5 * num)
							{
								num6++;
							}
						}
					}
					else
					{
						num6 = Mathf.CeilToInt(Mathf.Clamp(num5 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount)) * num3;
					}
					if (num6 <= 0)
					{
						continue;
					}
					int num7 = Mathf.CeilToInt((float)num6 / (float)ingredient.itemDef.stackable);
					for (int j = 0; j < num7; j++)
					{
						int num8 = ((num6 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num6);
						Item newItem2 = ItemManager.Create(ingredient.itemDef, num8, 0uL);
						if (!MoveItemToOutput(newItem2))
						{
							flag = true;
						}
						num6 -= num8;
						if (num6 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
			IL_034f:
			num2++;
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
```csharp
/// <summary>
/// Called every tick for a player to process input and update state.
/// </summary>
/// <param name="player">The player whose tick is being processed.</param>
/// <param name="msg">The input state and other tick-related data.</param>
/// <param name="wasPlayerStalled">Indicates if the player was stalled during the last tick.</param>
/// <returns>No return behavior.</returns>
void OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
{
    Puts($"Processing tick for player {player.displayName} (ID: {player.UserIDString}).");

    if (wasPlayerStalled)
    {
        Puts($"Player {player.displayName} was stalled during the last tick.");
    }

    // Additional logic can be added here to handle player state updates
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item is being removed.</param>
/// <param name="item">The item that is being removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) has been removed from container {container.name}.");
    
    if (item.amount <= 0)
    {
        Puts($"Item {item.info.displayName.english} is depleted and will be discarded.");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		if (onPreItemRemove != null)
		{
			onPreItemRemove(item);
		}
		itemList.Remove(item);
		item.parent = null;
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: false);
		}
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when an item's condition is reduced.
/// </summary>
/// <param name="item">The item whose condition is being reduced.</param>
/// <param name="amount">The amount of condition to lose.</param>
/// <returns>
/// Returns a non-null value to prevent the condition loss, or `null` to allow it.
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Condition loss requested for {item.info.displayName.english} by {amount}.");

    if (item.condition <= 10f)
    {
        Puts($"Condition loss for {item.info.displayName.english} is blocked due to low condition.");
        return true; // Prevent further condition loss
    }

    return null; // Allow condition loss
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped in the game world.
/// </summary>
/// <param name="item">The item that is being dropped.</param>
/// <param name="entity">The entity that the item is being dropped from.</param>
/// <returns>No return behavior.</returns>
void OnItemDropped(Item item, BaseEntity entity)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) has been dropped by {entity?.name ?? "an unknown entity"}.");
    
    if (item.info.itemid == 12345) // Example item ID for a special item
    {
        Puts("A special item has been dropped! Handle with care.");
    }
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		RemoveFromWorld();
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## IOnPlayerBanned(Network.Connection,AuthResponse)

```csharp
```csharp
/// <summary>
/// Called when a player is banned based on their authentication response from Steam.
/// </summary>
/// <param name="connection">The network connection of the banned player.</param>
/// <param name="status">The authentication response indicating the reason for the ban.</param>
/// <returns>No return behavior.</returns>
void IOnPlayerBanned(Network.Connection connection, AuthResponse status)
{
    Puts($"Player {connection.username} (ID: {connection.userid}) has been banned. Reason: {status}.");
    
    if (status == AuthResponse.VACBanned)
    {
        Puts($"Player {connection.username} is VAC banned.");
    }
    else if (status == AuthResponse.PublisherBanned)
    {
        Puts($"Player {connection.username} is banned by the publisher.");
    }
}
```
```

### Source Code from the Library

```csharp

	internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
	{
		if (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))
		{
			return;
		}
		Network.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) => x.userid == SteamId);
		if (connection == null)
		{
			UnityEngine.Debug.LogWarning($"Steam gave us a {Status} ticket response for unconnected id {SteamId}");
			return;
		}
		switch (Status)
		{
		case AuthResponse.OK:
			UnityEngine.Debug.LogWarning($"Steam gave us a 'ok' ticket response for already connected id {SteamId}");
			return;
		case AuthResponse.TimedOut:
			return;
		case AuthResponse.VACBanned:
		case AuthResponse.PublisherBanned:
			if (!bannedPlayerNotices.Contains(SteamId))
			{
				Interface.CallHook("IOnPlayerBanned", connection, Status);
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + connection.username.EscapeRichText() + " (banned by anticheat)");
				bannedPlayerNotices.Add(SteamId);
			}
			break;
		}
		UnityEngine.Debug.Log($"Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \"{Status.ToString()}\")");
		connection.authStatus = Status.ToString();
		Network.Net.sv.Kick(connection, "Steam: " + Status);
	}

```

## OnTick()

```csharp
```csharp
/// <summary>
/// Called every tick to perform regular updates and checks.
/// </summary>
/// <returns>No return behavior.</returns>
void OnTick()
{
    Puts("OnTick event triggered. Performing updates...");

    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		Interface.CallHook("OnTick");
		RCon.Update();
		CompanionServer.Server.Update();
		CCTVRender.Manager.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Network.Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## OnPayForPlacement(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Called when a player pays for the placement of a construction item.
/// </summary>
/// <param name="player">The player who is placing the construction.</param>
/// <param name="planner">The planner used for the construction placement.</param>
/// <param name="construction">The construction being placed.</param>
/// <returns>No return behavior.</returns>
void OnPayForPlacement(BasePlayer player, Planner planner, Construction construction)
{
    Puts($"Player {player.displayName} is paying for placement of {construction.fullName}.");
    
    if (player.inventory.GetAmount(construction.defaultGrade.costToBuild[0].itemDef.itemid) < construction.defaultGrade.costToBuild[0].amount)
    {
        Puts($"Player {player.displayName} does not have enough resources to place {construction.fullName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", player, this, component) != null)
		{
			return;
		}
		if (isTypeDeployable)
		{
			GetItem().UseItem();
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in component.defaultGrade.costToBuild)
		{
			player.inventory.Take(list, item.itemDef.itemid, (int)item.amount);
			player.Command("note.inv", item.itemDef.itemid, item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed by a player.
/// </summary>
/// <param name="trap">The bear trap that is being armed.</param>
/// <param name="player">The player who is arming the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to be armed, or any non-null value to prevent it from being armed.
/// </returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to arm a bear trap at position: {trap.transform.position}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot arm traps in a safe zone.");
        return "You cannot arm traps in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## OnEntityEnter(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger area.
/// </summary>
/// <param name="entity">The entity that has entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity?.name} has entered the trigger area of {trigger?.name}.");
    
    if (entity is BasePlayer player)
    {
        Puts($"Player {player.displayName} has entered the comfort zone.");
        _players.Add(player);
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityEnter(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityEnter", this, ent) == null)
		{
			_players.Add(basePlayer);
		}
	}

```

## OnStructureDemolish(BuildingBlock,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a structure is being demolished by a player.
/// </summary>
/// <param name="structure">The building block structure being demolished.</param>
/// <param name="player">The player who is demolishing the structure.</param>
/// <param name="cancelled">Indicates if the demolition was cancelled.</param>
/// <returns>No return behavior.</returns>
void OnStructureDemolish(BuildingBlock structure, BasePlayer player, bool cancelled)
{
    Puts($"Player {player.displayName} is attempting to demolish structure: {structure.name}.");

    if (cancelled)
    {
        Puts($"Demolition of structure {structure.name} by player {player.displayName} was cancelled.");
    }
    else
    {
        Puts($"Structure {structure.name} has been successfully demolished by player {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## OnProjectileRicochet(BasePlayer,ProtoBuf.PlayerProjectileRicochet)

```csharp
```csharp
/// <summary>
/// Called when a projectile ricochets off a surface.
/// </summary>
/// <param name="player">The player who fired the projectile.</param>
/// <param name="ricochetData">Data related to the ricochet event, including position and velocity.</param>
/// <returns>No return behavior.</returns>
void OnProjectileRicochet(BasePlayer player, ProtoBuf.PlayerProjectileRicochet ricochetData)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString})'s projectile has ricocheted at position: {ricochetData.hitPosition}.");

    if (ricochetData.ricochets > 3)
    {
        Puts($"Warning: Player {player.displayName} has exceeded the maximum ricochets with projectile ID: {ricochetData.projectileID}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void OnProjectileRicochet(RPCMessage msg)
	{
		PlayerProjectileRicochet playerProjectileRicochet = PlayerProjectileRicochet.Deserialize(msg.read);
		if (playerProjectileRicochet != null)
		{
			FiredProjectile value;
			if (playerProjectileRicochet.hitPosition.IsNaNOrInfinity() || playerProjectileRicochet.inVelocity.IsNaNOrInfinity() || playerProjectileRicochet.outVelocity.IsNaNOrInfinity() || playerProjectileRicochet.hitNormal.IsNaNOrInfinity() || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (value.firedTime < UnityEngine.Time.realtimeSinceStartup - 8f)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (Interface.CallHook("OnProjectileRicochet", this, playerProjectileRicochet) == null)
			{
				value.ricochets++;
				firedProjectiles[playerProjectileRicochet.projectileID] = value;
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
		}
	}

```

## OnNpcConversationResponded(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
```csharp
/// <summary>
/// Called when a player responds to an NPC conversation.
/// </summary>
/// <param name="npc">The NPC that the player is conversing with.</param>
/// <param name="player">The player who responded to the conversation.</param>
/// <param name="conversation">The conversation data associated with the interaction.</param>
/// <param name="responseNode">The specific response node that the player selected.</param>
/// <returns>No return behavior.</returns>
void OnNpcConversationResponded(NPCTalking npc, BasePlayer player, ConversationData conversation, ConversationData.ResponseNode responseNode)
{
    Puts($"Player {player.displayName} responded to NPC {npc.name} with response: {responseNode.text}");

    if (responseNode.text.Contains("goodbye"))
    {
        Puts($"Player {player.displayName} ended the conversation with NPC {npc.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode != null && Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) == null)
		{
			if (responseNode.conditions.Length != 0)
			{
				UpdateFlags();
			}
			bool flag = responseNode.PassesConditions(player, this);
			if (flag && !string.IsNullOrEmpty(responseNode.actionString))
			{
				OnConversationAction(player, responseNode.actionString);
			}
			int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
			if (speechNodeIndex == -1)
			{
				ForceEndConversation(player);
				return;
			}
			ForceSpeechNode(player, speechNodeIndex);
			Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
		}
	}

```

## OnCrateLanded(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate has successfully landed.
/// </summary>
/// <param name="crate">The hackable locked crate that has landed.</param>
/// <returns>No return behavior.</returns>
void OnCrateLanded(HackableLockedCrate crate)
{
    Puts($"Hackable locked crate has landed at position: {crate.transform.position}.");
    // Additional logic can be added here, such as notifying players or spawning loot.
}
```
```

### Source Code from the Library

```csharp

	public void LandCheck()
	{
		RaycastHit hitInfo;
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", this);
		}
		else if (UnityEngine.Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1218511105))
		{
			Effect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);
			hasLanded = true;
			CancelInvoke(LandCheck);
		}
	}

```

## CanEquipItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be equipped in a specified slot of the player's inventory.
/// </summary>
/// <param name="item">The item to be equipped.</param>
/// <param name="targetSlot">The slot in which the item is to be equipped.</param>
/// <returns>
/// Returns `true` if the item can be equipped; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the item can be equipped.
/// </returns>
bool? CanEquipItem(Item item, int targetSlot)
{
    Puts($"Checking if item {item.info.displayName.english} can be equipped in slot {targetSlot}.");

    if (item.info.shortname == "restricted.item")
    {
        Puts($"Item {item.info.displayName.english} is restricted and cannot be equipped.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanEquipItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanEquipItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
		if (component == null)
		{
			return true;
		}
		Item[] array = containerBelt.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
				}
			}
		}
		return true;
	}

```

## CanLootEntity(BasePlayer,ResourceContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="container">The resource container being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, ResourceContainer container)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot the container.");

    if (container.IsLocked())
    {
        Puts($"Container is locked. Player {player.displayName} cannot loot.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.IsVisible(3f)]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}

```

## InitLogging()

```csharp
```csharp
/// <summary>
/// Initializes the logging system for the application.
/// </summary>
/// <returns>No return behavior.</returns>
void InitLogging()
{
    Puts("Logging system initialized successfully.");
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

```

## OnNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC initiates an attack on a target.
/// </summary>
/// <param name="npc">The NPC that is attacking.</param>
/// <param name="target">The entity that is being attacked.</param>
/// <returns>No return behavior.</returns>
void OnNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is attacking {target.displayName} at position {target.ServerPosition}.");
    
    if (target is BasePlayer playerTarget)
    {
        Puts($"NPC {npc.displayName} is targeting a player: {playerTarget.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if ((bool)AttackTarget && AttackReady() && Interface.CallHook("OnNpcAttack", this, AttackTarget) == null && !((AttackTarget.ServerPosition - ServerPosition).magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(null, "Attack", AttackTarget.ServerPosition);
			}
		}
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a different building grade.
/// </summary>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="newGrade">The new building grade to which the structure is being upgraded.</param>
/// <returns>
/// Returns `null` to allow the upgrade, or any non-null value to prevent the upgrade.
/// </returns>
object OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum newGrade)
{
    Puts($"Player {player.displayName} is upgrading {buildingBlock.name} to grade {newGrade}.");
    
    if (newGrade == BuildingGrade.Enum.Stone)
    {
        Puts($"Upgrade to stone grade is not allowed for {player.displayName}.");
        return "You cannot upgrade to stone grade.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoUpgradeToGrade(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
			ConstructionGrade constructionGrade = GetGrade(@enum);
			if (!(constructionGrade == null) && CanChangeToGrade(@enum, msg.player) && CanAffordUpgrade(@enum, msg.player) && !(base.SecondsSinceAttacked < 30f) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum) == null)
			{
				PayForUpgrade(constructionGrade, msg.player);
				SetGrade(@enum);
				SetHealthToMax();
				StartBeingRotatable();
				SendNetworkUpdate();
				UpdateSkin();
				ResetUpkeepTime();
				BuildingManager.server.GetBuilding(buildingID)?.Dirty();
				Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + @enum.ToString().ToLower() + ".prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client attempts to authenticate with the server.
/// </summary>
/// <param name="connection">The network connection of the client attempting to authenticate.</param>
/// <returns>No return behavior.</returns>
void OnClientAuth(Network.Connection connection)
{
    Puts($"Client {connection.username} (ID: {connection.userid}) is attempting to authenticate.");
    
    if (connection.state != Network.Connection.State.Connecting)
    {
        Puts($"Client {connection.username} has an invalid connection state.");
        Network.Net.sv.Kick(connection, "Invalid connection state");
        return;
    }

    // Additional checks and logic can be added here as needed.
}
```
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Network.Connection.State.Connecting;
		if (packet.read.UInt8() != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String(128);
		packet.connection.username = packet.read.String();
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.Unread >= 4)
		{
			text = packet.read.String(128);
		}
		Interface.CallHook("OnClientAuth", packet.connection);
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their branch is '", text, "' not '", branch, "'"));
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2271)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2271));
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2271)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2271));
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize(512u);
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
			}
			else
			{
				auth.OnNewConnection(packet.connection);
			}
		}
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
```csharp
/// <summary>
/// Called when a new resource deposit is created in the world.
/// </summary>
/// <param name="deposit">The resource deposit that has been created.</param>
/// <returns>No return behavior.</returns>
void OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit deposit)
{
    Puts($"Resource deposit created at position: {deposit.origin}. Contains: {deposit.GetContents()}.");
    
    if (deposit.GetContents().Contains("metal.ore"))
    {
        Puts("A metal ore deposit has been created!");
    }
}
```
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		UnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)
		};
		if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else if (0 == 0)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
			float num = 0f;
			num = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num2 = 0f;
			num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num3 = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
				{
					num3 += 0.25f;
				}
			}
			else
			{
				num3 += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num3)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnItemRepair(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player repairs an item.
/// </summary>
/// <param name="player">The player who is repairing the item.</param>
/// <param name="item">The item being repaired.</param>
/// <returns>
/// Returns `null` to allow the repair to proceed, or any non-null value to prevent the repair action.
/// </returns>
object OnItemRepair(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is attempting to repair item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.condition == item.maxCondition)
    {
        Puts($"Item {item.info.displayName.english} is already in perfect condition and cannot be repaired.");
        return "Item is already fully repaired.";
    }

    if (!player.HasPermission("repair.items"))
    {
        Puts($"Player {player.displayName} does not have permission to repair items.");
        return "You do not have permission to repair items.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
	{
		if (itemToRepair == null)
		{
			return;
		}
		ItemDefinition info = itemToRepair.info;
		ItemBlueprint component = info.GetComponent<ItemBlueprint>();
		if (!component || !info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)
		{
			return;
		}
		if (mustKnowBlueprint)
		{
			ItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);
			if (!player.blueprints.HasUnlocked(itemDefinition) && (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))
			{
				return;
			}
		}
		if (Interface.CallHook("OnItemRepair", player, itemToRepair) != null)
		{
			return;
		}
		float num = RepairCostFraction(itemToRepair);
		bool flag = false;
		List<ItemAmount> obj = Facepunch.Pool.GetList<ItemAmount>();
		GetRepairCostList(component, obj);
		foreach (ItemAmount item in obj)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				if (Mathf.CeilToInt(item.amount * num) > amount)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Facepunch.Pool.FreeList(ref obj);
			return;
		}
		foreach (ItemAmount item2 in obj)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
			}
		}
		Facepunch.Pool.FreeList(ref obj);
		itemToRepair.DoRepair(maxConditionLostOnRepair);
		if (Global.developer > 0)
		{
			Debug.Log("Item repaired! condition : " + itemToRepair.condition + "/" + itemToRepair.maxCondition);
		}
		Effect.server.Run("assets/bundled/prefabs/fx/repairbench/itemrepair.prefab", repairBenchEntity, 0u, Vector3.zero, Vector3.zero);
	}

```

## OnSignUpdated(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated by a player.
/// </summary>
/// <param name="sign">The sign that has been updated.</param>
/// <param name="player">The player who updated the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(Signage sign, BasePlayer player)
{
    Puts($"Sign updated by player {player.displayName} (ID: {player.UserIDString}). Sign ID: {sign.net.ID}");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || UnityEngine.Time.realtimeSinceStartup - msg.player.lastSignUpdate < ConVar.AntiHack.signpause)
		{
			return;
		}
		msg.player.lastSignUpdate = UnityEngine.Time.realtimeSinceStartup;
		if (CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				Interface.CallHook("OnSignUpdated", this, msg.player);
				FileStorage.server.RemoveAllByEntity(net.ID);
				textureID = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				SendNetworkUpdate();
			}
		}
	}

```

## CanWearItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether a specific item can be worn in a given slot of the player's inventory.
/// </summary>
/// <param name="item">The item to check for wearability.</param>
/// <param name="targetSlot">The inventory slot where the item is intended to be worn.</param>
/// <returns>
/// Returns `true` if the item can be worn in the specified slot; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the item can be worn.
/// </returns>
bool? CanWearItem(Item item, int targetSlot)
{
    Puts($"Checking if item {item.info.displayName.english} can be worn in slot {targetSlot}.");

    if (item.info.shortname == "hat.ugly")
    {
        Puts("The ugly hat cannot be worn.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanWearItem(Item item, int targetSlot)
	{
		ItemModWearable component = item.info.GetComponent<ItemModWearable>();
		if (component == null)
		{
			return false;
		}
		object obj = Interface.CallHook("CanWearItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Item[] array = containerWear.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 == item)
			{
				continue;
			}
			ItemModWearable component2 = item2.info.GetComponent<ItemModWearable>();
			if (!(component2 == null) && !component.CanExistWith(component2))
			{
				bool flag = false;
				if (item.parent == containerBelt)
				{
					flag = item2.MoveToContainer(containerBelt);
				}
				if (!flag && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
				}
			}
		}
		return true;
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the active item can be dropped by the player.
/// </summary>
/// <param name="player">The player attempting to drop the active item.</param>
/// <returns>
/// Returns `true` if the active item can be dropped; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the item can be dropped.
/// </returns>
bool? CanDropActiveItem(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to drop their active item.");
    
    // Example condition to prevent dropping a specific item
    if (player.activeItem?.info.shortname == "special.item")
    {
        Puts($"Player {player.displayName} cannot drop the special item.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnRidableAnimalClaim(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to claim a ridable animal.
/// </summary>
/// <param name="animal">The ridable animal being claimed.</param>
/// <param name="player">The player attempting to claim the animal.</param>
/// <returns>
/// Returns `null` to allow the claim, or any non-null value to prevent the claim from occurring.
/// </returns>
object OnRidableAnimalClaim(BaseRidableAnimal animal, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to claim a ridable animal: {animal.name}.");

    if (player.inventory.GetAmount("claim_token") < 1)
    {
        Puts($"Player {player.displayName} does not have a claim token.");
        return "You need a claim token to claim this animal.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && Interface.CallHook("OnRidableAnimalClaim", this, player) == null && IsForSale())
		{
			Item item = GetPurchaseToken(player);
			if (item != null)
			{
				item.UseItem();
				SetFlag(Flags.Reserved2, b: false);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## OnBookmarkAdd(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a bookmark is added to a computer station by a player.
/// </summary>
/// <param name="station">The computer station where the bookmark is being added.</param>
/// <param name="player">The player adding the bookmark.</param>
/// <param name="identifier">The identifier for the bookmark being added.</param>
/// <returns>
/// Returns `null` to allow the bookmark to be added, or any non-null value to prevent the addition.
/// </returns>
object OnBookmarkAdd(ComputerStation station, BasePlayer player, string identifier)
{
    Puts($"Player {player.displayName} is attempting to add a bookmark: {identifier} to station {station.net.ID}.");

    if (identifier.Contains("forbidden"))
    {
        Puts($"Bookmark '{identifier}' is not allowed.");
        return "This bookmark is forbidden.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void AddBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		if (UnityEngine.Time.realtimeSinceStartup < nextAddTime)
		{
			player.ChatMessage("Slow down...");
			return;
		}
		if (controlBookmarks.Count >= 128)
		{
			player.ChatMessage("Too many bookmarks, delete some");
			return;
		}
		nextAddTime = UnityEngine.Time.realtimeSinceStartup + 1f;
		string text = msg.read.String();
		if (!IsValidIdentifier(text))
		{
			return;
		}
		foreach (KeyValuePair<string, uint> controlBookmark in controlBookmarks)
		{
			if (controlBookmark.Key == text)
			{
				return;
			}
		}
		uint num = 0u;
		bool flag = false;
		foreach (IRemoteControllable allControllable in RemoteControlEntity.allControllables)
		{
			if (allControllable != null && allControllable.GetIdentifier() == text)
			{
				if (!(allControllable.GetEnt() == null))
				{
					num = allControllable.GetEnt().net.ID;
					flag = true;
					break;
				}
				Debug.LogWarning("Computer station added bookmark with missing ent, likely a static CCTV (wipe the server)");
			}
		}
		if (!flag)
		{
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(num);
		if (baseNetworkable == null)
		{
			return;
		}
		IRemoteControllable component = baseNetworkable.GetComponent<IRemoteControllable>();
		if (component != null && Interface.CallHook("OnBookmarkAdd", this, player, text) == null)
		{
			string identifier = component.GetIdentifier();
			if (text == identifier)
			{
				controlBookmarks.Add(text, num);
			}
			SendControlBookmarks(player);
		}
	}

```

## OnVendingShopRename(VendingMachine,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop's name is updated.
/// </summary>
/// <param name="vendingMachine">The vending machine whose name is being changed.</param>
/// <param name="newName">The new name for the vending shop.</param>
/// <param name="player">The player who is renaming the shop.</param>
/// <returns>
/// Returns `null` to allow the name change, or any non-null value to prevent the renaming.
/// </returns>
object OnVendingShopRename(VendingMachine vendingMachine, string newName, BasePlayer player)
{
    Puts($"Vending shop renamed to '{newName}' by player {player.displayName} (ID: {player.UserIDString}).");

    if (newName.Length < 3)
    {
        Puts("The new shop name is too short. Renaming denied.");
        return "Shop name must be at least 3 characters long.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_UpdateShopName(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string obj = msg.read.String(32);
		if (CanPlayerAdmin(player) && Interface.CallHook("OnVendingShopRename", this, obj, player) == null)
		{
			shopName = obj;
			UpdateMapMarker();
		}
	}

```

## OnSignUpdated(PhotoFrame,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated with a new image by a player.
/// </summary>
/// <param name="photoFrame">The sign (photo frame) that is being updated.</param>
/// <param name="player">The player who is updating the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(PhotoFrame photoFrame, BasePlayer player)
{
    Puts($"Sign updated by player {player.displayName} (ID: {player.UserIDString}) on sign ID: {photoFrame.net.ID}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has updated the sign.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null)
		{
			return;
		}
		msg.player.lastSignUpdate = UnityEngine.Time.realtimeSinceStartup;
		if (CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				Interface.CallHook("OnSignUpdated", this, msg.player);
				FileStorage.server.RemoveAllByEntity(net.ID);
				_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				SendNetworkUpdate();
			}
		}
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the Bradley APC can target a specified entity.
/// </summary>
/// <param name="apc">The Bradley APC attempting to target the entity.</param>
/// <param name="entity">The entity being targeted.</param>
/// <returns>
/// Returns `true` if the APC can target the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default visibility logic will be used to determine if the entity can be targeted.
/// </returns>
bool? CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
{
    Puts($"Checking if Bradley APC can target entity: {entity?.name ?? "null"}");

    if (entity is BasePlayer player)
    {
        Puts($"Entity is a player: {player.displayName}");
    }
    else
    {
        Puts($"Entity is of type: {entity?.GetType().Name}");
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.transform.position, base.transform.position) < viewDistance))
		{
			return false;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			flag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position, position);
		}
		else
		{
			Debug.LogWarning("Standard vis test!");
			flag = IsVisible(ent.CenterPoint());
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return flag;
	}

```

## OnElevatorMove(Elevator,int)

```csharp
```csharp
/// <summary>
/// Called when an elevator is requested to move to a specific floor.
/// </summary>
/// <param name="elevator">The elevator that is being moved.</param>
/// <param name="targetFloor">The floor to which the elevator is requested to move.</param>
/// <returns>
/// Returns `true` if the elevator can move to the target floor; otherwise, returns `false`.
/// If the method returns a non-null value, it will prevent the elevator from moving.
/// </returns>
bool OnElevatorMove(Elevator elevator, int targetFloor)
{
    Puts($"Elevator {elevator.ID} is requested to move to floor {targetFloor}.");
    
    if (targetFloor < 0)
    {
        Puts("Invalid floor request: Floor cannot be negative.");
        return false;
    }

    return null; // Allow the elevator to proceed with the move if no other conditions are met.
}
```
```

### Source Code from the Library

```csharp

	public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel)
	{
		timeToTravel = 0f;
		if (Interface.CallHook("OnElevatorMove", this, targetFloor) != null)
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (ioEntity != null && !ioEntity.IsPowered())
		{
			return false;
		}
		if (!IsValidFloor(targetFloor))
		{
			return false;
		}
		if (!liftEntity.CanMove())
		{
			return false;
		}
		Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);
		Vector3 vector = base.transform.InverseTransformPoint(worldSpaceFloorPosition);
		timeToTravel = TimeToTravelDistance(Mathf.Abs(liftEntity.transform.localPosition.y - vector.y));
		LeanTween.moveLocalY(liftEntity.gameObject, vector.y, timeToTravel);
		SetFlag(Flags.Busy, b: true);
		if (targetFloor < Floor)
		{
			liftEntity.ToggleHurtTrigger(state: true);
		}
		Invoke(ClearBusy, timeToTravel);
		if (ioEntity != null)
		{
			ioEntity.SetFlag(Flags.Busy, b: true);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		return true;
	}

```

## OnEngineStatsRefreshed(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called to refresh the performance statistics of the vehicle engine.
/// </summary>
/// <param name="engine">The vehicle engine module whose stats are being refreshed.</param>
/// <param name="engineStorage">The storage containing the engine's performance data.</param>
/// <returns>No return behavior.</returns>
void OnEngineStatsRefreshed(VehicleModuleEngine engine, Rust.Modular.EngineStorage engineStorage)
{
    Puts($"Refreshing engine stats for {engine.GetType().Name}.");

    if (engineStorage == null)
    {
        Puts("Engine storage is null, setting performance to unusable.");
    }
    else
    {
        Puts($"Engine is usable: {engineStorage.isUsable}. " +
             $"Acceleration Boost: {engineStorage.accelerationBoostPercent}, " +
             $"Top Speed Boost: {engineStorage.topSpeedBoostPercent}, " +
             $"Fuel Economy Boost: {engineStorage.fuelEconomyBoostPercent}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## OnPlayerVoice(BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a player sends voice data.
/// </summary>
/// <param name="player">The player who sent the voice data.</param>
/// <param name="data">The voice data sent by the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerVoice(BasePlayer player, byte[] data)
{
    Puts($"Voice data received from player {player.displayName} (ID: {player.UserIDString}). Data length: {data.Length} bytes.");
    
    // Additional processing can be done here if needed
}
```
```

### Source Code from the Library

```csharp

	public void OnReceivedVoice(byte[] data)
	{
		if (Interface.CallHook("OnPlayerVoice", this, data) == null)
		{
			if (Network.Net.sv.write.Start())
			{
				Network.Net.sv.write.PacketID(Message.Type.VoiceData);
				Network.Net.sv.write.UInt32(net.ID);
				Network.Net.sv.write.BytesWithSize(data);
				Network.Net.sv.write.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f))
				{
					priority = Priority.Immediate
				});
			}
			if (activeTelephone != null)
			{
				activeTelephone.OnReceivedVoiceFromUser(data);
			}
		}
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford to upgrade a building block to a specified grade.
/// </summary>
/// <param name="player">The player attempting to upgrade the building block.</param>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="grade">The target grade to which the building block is being upgraded.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can afford the upgrade.
/// </returns>
bool? CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum grade)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to upgrade a building block to grade {grade}.");

    if (grade == BuildingGrade.Enum.Stone)
    {
        Puts($"Player {player.displayName} is not allowed to upgrade to stone grade.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount item in GetGrade(iGrade).costToBuild)
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is rotated by a player.
/// </summary>
/// <param name="buildingBlock">The building block that is being rotated.</param>
/// <param name="player">The player who is rotating the structure.</param>
/// <returns>
/// Returns `null` to allow the rotation, or any non-null value to prevent the rotation.
/// </returns>
object OnStructureRotate(BuildingBlock buildingBlock, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to rotate a structure: {buildingBlock.name}.");

    if (buildingBlock.IsLocked())
    {
        Puts($"Rotation denied: Structure {buildingBlock.name} is locked.");
        return "Structure is locked and cannot be rotated.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotateAfterPlacement && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			UpdateSkin(force: true);
			RefreshNeighbours(linkToNeighbours: false);
			SendNetworkUpdateImmediate();
			ClientRPC(null, "RefreshSkin");
		}
	}

```

## OnCargoShipSpawnCrate(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship is about to spawn a loot crate.
/// </summary>
/// <param name="cargoShip">The cargo ship that is spawning the crate.</param>
/// <returns>
/// Returns `null` to allow the crate to spawn, or any non-null value to prevent the spawning of the crate.
/// </returns>
object OnCargoShipSpawnCrate(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip.net.ID} is attempting to spawn a loot crate.");
    
    // Example condition to prevent spawning
    if (cargoShip.IsUnderAttack)
    {
        Puts($"Cargo ship {cargoShip.net.ID} cannot spawn crates while under attack.");
        return "Crate spawning blocked due to attack.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RespawnLoot()
	{
		if (Interface.CallHook("OnCargoShipSpawnCrate", this) == null)
		{
			InvokeRepeating(PlayHorn, 0f, 8f);
			SpawnCrate(lockedCratePrefab.resourcePath);
			SpawnCrate(eliteCratePrefab.resourcePath);
			for (int i = 0; i < 4; i++)
			{
				SpawnCrate(militaryCratePrefab.resourcePath);
			}
			for (int j = 0; j < 4; j++)
			{
				SpawnCrate(junkCratePrefab.resourcePath);
			}
			lootRoundsPassed++;
			if (lootRoundsPassed >= loot_rounds)
			{
				CancelInvoke(RespawnLoot);
			}
		}
	}

```

## OnNpcEquipWeapon(NPCPlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon.
/// </summary>
/// <param name="npc">The NPC that is equipping the weapon.</param>
/// <param name="weapon">The weapon being equipped by the NPC.</param>
/// <returns>
/// Returns a non-null value to prevent the NPC from equipping the weapon. 
/// If `null` is returned, the NPC will proceed to equip the weapon as normal.
/// </returns>
object OnNpcEquipWeapon(NPCPlayer npc, Item weapon)
{
    Puts($"NPC {npc.displayName} is attempting to equip weapon: {weapon.info.displayName.english} (ID: {weapon.info.itemid}).");

    if (weapon.info.itemid == 12345) // Example item ID for a restricted weapon
    {
        Puts($"NPC {npc.displayName} is not allowed to equip this weapon.");
        return true; // Prevent equipping
    }

    return null; // Allow equipping
}
```
```

### Source Code from the Library

```csharp

	public virtual void EquipWeapon()
	{
		Item slot = inventory.containerBelt.GetSlot(0);
		if (slot == null || Interface.CallHook("OnNpcEquipWeapon", this, slot) != null)
		{
			return;
		}
		UpdateActiveItem(inventory.containerBelt.GetSlot(0).uid);
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (heldEntity != null)
		{
			AttackEntity component = heldEntity.GetComponent<AttackEntity>();
			if (component != null)
			{
				component.TopUpAmmo();
			}
		}
	}

```

## OnExcavatorGather(ExcavatorArm,Item)

```csharp
```csharp
/// <summary>
/// Called when the excavator gathers resources.
/// </summary>
/// <param name="excavator">The excavator arm that is gathering resources.</param>
/// <param name="item">The item being gathered by the excavator.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being processed further. 
/// If `null` is returned, the item will be processed as normal.
/// </returns>
object OnExcavatorGather(ExcavatorArm excavator, Item item)
{
    Puts($"Excavator {excavator.net.ID} is gathering item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "metal.fragments")
    {
        Puts("Gathering of metal fragments is currently disabled.");
        return true; // Prevent further processing of this item.
    }

    return null; // Allow normal processing of the item.
}
```
```

### Source Code from the Library

```csharp

	public void ProduceResources()
	{
		float num = resourceProductionTickRate / timeForFullResources;
		float num2 = resourcesToMine[resourceMiningIndex].amount * num;
		pendingResources[resourceMiningIndex].amount += num2;
		ItemAmount[] array = pendingResources;
		foreach (ItemAmount itemAmount in array)
		{
			if (!(itemAmount.amount >= (float)outputPiles.Count))
			{
				continue;
			}
			int num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);
			itemAmount.amount -= num3 * 2;
			foreach (ExcavatorOutputPile outputPile in outputPiles)
			{
				Item item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);
				if (Interface.CallHook("OnExcavatorGather", this, item) != null)
				{
					return;
				}
				if (!item.MoveToContainer(outputPile.inventory))
				{
					item.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());
				}
			}
		}
	}

```

## CanSpectateTarget(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can spectate a target.
/// </summary>
/// <param name="player">The player attempting to spectate.</param>
/// <param name="targetName">The name of the target the player wishes to spectate.</param>
/// <returns>
/// Returns `null` to allow the player to spectate the target, or any non-null value to prevent them from doing so.
/// </returns>
object CanSpectateTarget(BasePlayer player, string targetName)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to spectate target: {targetName}.");

    if (targetName == "admin")
    {
        Puts($"Player {player.displayName} is not allowed to spectate admin targets.");
        return "You cannot spectate admin players.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateSpectateTarget(string strName)
	{
		if (Interface.CallHook("CanSpectateTarget", this, strName) != null)
		{
			return;
		}
		spectateFilter = strName;
		IEnumerable<BaseEntity> enumerable = null;
		if (spectateFilter.StartsWith("@"))
		{
			string filter = spectateFilter.Substring(1);
			enumerable = (from x in BaseNetworkable.serverEntities
				where x.name.Contains(filter, CompareOptions.IgnoreCase)
				where x != this
				select x).Cast<BaseEntity>();
		}
		else
		{
			IEnumerable<BasePlayer> source = activePlayerList.Where((BasePlayer x) => !x.IsSpectating() && !x.IsDead() && !x.IsSleeping());
			if (strName.Length > 0)
			{
				source = from x in source
					where x.displayName.Contains(spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)
					where x != this
					select x;
			}
			source = source.OrderBy((BasePlayer x) => x.displayName);
			enumerable = source.Cast<BaseEntity>();
		}
		BaseEntity[] array = enumerable.ToArray();
		if (array.Length == 0)
		{
			ChatMessage("No valid spectate targets!");
			return;
		}
		BaseEntity baseEntity = array[SpectateOffset % array.Length];
		if (!(baseEntity != null))
		{
			return;
		}
		if (baseEntity is BasePlayer)
		{
			ChatMessage("Spectating: " + (baseEntity as BasePlayer).displayName);
		}
		else
		{
			ChatMessage("Spectating: " + baseEntity.ToString());
		}
		using (TimeWarning.New("SendEntitySnapshot"))
		{
			SendEntitySnapshot(baseEntity);
		}
		UnityEngine.TransformEx.Identity(base.gameObject);
		using (TimeWarning.New("SetParent"))
		{
			SetParent(baseEntity);
		}
	}

```

## OnShopCancelClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player clicks the cancel button on the shop interface.
/// </summary>
/// <param name="shopFront">The shop front where the cancel action occurred.</param>
/// <param name="player">The player who clicked the cancel button.</param>
/// <returns>No return behavior.</returns>
void OnShopCancelClick(ShopFront shopFront, BasePlayer player)
{
    Puts($"Player {player.displayName} has canceled the shop interaction at {shopFront.name}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", this, msg.player) == null)
		{
			_ = (bool)vendorPlayer;
			_ = (bool)customerPlayer;
			ResetTrade();
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed at the shop front.
/// </summary>
/// <param name="shopFront">The shop front where the trade is completed.</param>
/// <returns>No return behavior.</returns>
void OnShopCompleteTrade(ShopFront shopFront)
{
    Puts($"Trade completed at shop front: {shopFront.name}. Transaction details processed.");
    
    // Additional logic can be added here, such as logging or notifying players.
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			for (int num = vendorInventory.capacity - 1; num >= 0; num--)
			{
				Item slot = vendorInventory.GetSlot(num);
				Item slot2 = customerInventory.GetSlot(num);
				if ((bool)customerPlayer && slot != null)
				{
					customerPlayer.GiveItem(slot);
				}
				if ((bool)vendorPlayer && slot2 != null)
				{
					vendorPlayer.GiveItem(slot2);
				}
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnPlayerCorpseSpawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's corpse is about to be spawned.
/// </summary>
/// <param name="player">The player whose corpse is being spawned.</param>
/// <returns>
/// Returns `null` to allow the corpse to spawn, or any non-null value to prevent the spawning of the corpse.
/// </returns>
object OnPlayerCorpseSpawn(BasePlayer player)
{
    Puts($"Attempting to spawn corpse for player: {player.displayName} (ID: {player.UserIDString})");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone; corpse spawning is prevented.");
        return "Corpse spawning is not allowed in safe zones.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse()
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			PlayerCorpse playerCorpse = DropCorpse("assets/prefabs/player/player_corpse.prefab") as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				playerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				playerCorpse.playerName = displayName;
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
	}

```

## OnItemCraftFinished(ItemCraftTask,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is completed.
/// </summary>
/// <param name="task">The item crafting task that has been finished.</param>
/// <param name="item">The item that was crafted as a result of the task.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftFinished(ItemCraftTask task, Item item)
{
    Puts($"Crafting finished: {item.info.displayName.english} (ID: {item.info.itemid}) for task UID: {task.taskUID}.");

    if (item.info.shortname == "explosive.timed")
    {
        Puts("Warning: A timed explosive has been crafted!");
    }

    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item.amount = task.blueprint.amountToCreate;
		if (item.hasCondition && task.conditionScale != 1f)
		{
			item.maxCondition *= task.conditionScale;
			item.condition = item.maxCondition;
		}
		item.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					takenItem.UseItem(num);
					num -= num2;
				}
				_ = 0;
			}
		}
		Facepunch.Rust.Analytics.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		task.owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item);
		if (task.instanceData != null)
		{
			item.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			task.owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		if (task.owner.inventory.GiveItem(item))
		{
			task.owner.Command("note.inv", item.info.itemid, item.amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		task.owner.Command("note.inv", item.info.itemid, item.amount);
		task.owner.Command("note.inv", item.info.itemid, -item.amount);
		item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnEngineStart(MotorRowboat,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the engine of a motorized rowboat is requested to start.
/// </summary>
/// <param name="rowboat">The motorized rowboat whose engine is being started.</param>
/// <param name="driver">The player attempting to start the engine.</param>
/// <returns>
/// Returns `null` to allow the engine to start, or any non-null value to prevent the engine from starting.
/// </returns>
object OnEngineStart(MotorRowboat rowboat, BasePlayer driver)
{
    Puts($"Player {driver.displayName} is attempting to start the engine of the rowboat.");
    
    if (driver.IsInSafeZone())
    {
        Puts($"Engine start denied: {driver.displayName} is in a safe zone.");
        return "Cannot start engine in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.Reserved1, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
		}
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player who is going to sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has started sleeping.");
    
    if (player.InSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and can sleep without danger.");
    }
    else
    {
        Puts($"Warning: Player {player.displayName} is attempting to sleep outside of a safe zone!");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping())
		{
			Interface.CallHook("OnPlayerSleep", this);
			if (InSafeZone() && !IsInvoking(ScheduledDeath))
			{
				Invoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);
			}
			EnsureDismounted();
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			sleepStartTime = UnityEngine.Time.time;
			sleepingPlayerList.Add(this);
			bots.Remove(this);
			CancelInvoke(InventoryUpdate);
			CancelInvoke(TeamUpdate);
			inventory.loot.Clear();
			inventory.crafting.CancelAll(returnItems: true);
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			TurnOffAllLights();
			EnablePlayerCollider();
			RemovePlayerRigidbody();
			EnableServerFall(wantsOn: true);
		}
	}

```

## IOnRconInitialize()

```csharp
```csharp
/// <summary>
/// Called to initialize the RCON (Remote Console) system.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRconInitialize()
{
    Puts("Initializing RCON system...");
    if (Port == 0)
    {
        Puts("Using default server port for RCON.");
    }
    else
    {
        Puts($"RCON will use port: {Port}");
    }
}
```
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", ""));
		if (Password == "password" || Password == "")
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)
			{
				lock (Commands)
				{
					Command item = JsonConvert.DeserializeObject<Command>(msg);
					item.Ip = ip;
					item.ConnectionId = id;
					Commands.Enqueue(item);
				}
			};
			listenerNew.Start();
			Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			Debug.Log("RCon Started on " + Port);
			Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## OnTeamCreate(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to create a team.
/// </summary>
/// <param name="player">The player who is trying to create a team.</param>
/// <returns>
/// Returns `null` to allow the team creation, or any non-null value to prevent it.
/// </returns>
object OnTeamCreate(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to create a team.");

    if (player.IsBannedFromTeams)
    {
        Puts($"Player {player.displayName} is banned from creating teams.");
        return "You are banned from creating teams.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = Instance.CreateTeam();
			playerTeam.teamLeader = basePlayer.userID;
			playerTeam.AddPlayer(basePlayer);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a rocket is launched by a player.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="rocket">The rocket entity that was launched.</param>
/// <returns>No return behavior.</returns>
void OnRocketLaunched(BasePlayer player, BaseEntity rocket)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) launched a rocket with ID: {rocket.net.ID}.");
    
    if (rocket is ServerProjectile)
    {
        Puts($"Rocket launched successfully: {rocket.info.displayName.english}.");
    }
    else
    {
        Puts($"Failed to launch rocket: {rocket?.ShortPrefabName ?? "Unknown entity"}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "magazine_empty");
			return;
		}
		primaryMagazine.contents--;
		SignalBroadcast(Signal.Attack, string.Empty, player.net.connection);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		bool num = msg.read.Bit();
		BaseEntity mounted = player.GetParentEntity();
		if (mounted == null)
		{
			mounted = player.GetMounted();
		}
		if (num)
		{
			if (mounted != null)
			{
				vector = mounted.transform.TransformPoint(vector);
				vector2 = mounted.transform.TransformDirection(vector2);
			}
			else
			{
				vector = player.eyes.position;
				vector2 = player.eyes.BodyForward();
			}
		}
		if (!ValidateEyePos(player, vector))
		{
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		float num2 = GetAimCone() + component.projectileSpread;
		if (num2 > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);
		}
		float num3 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1236478737))
		{
			num3 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num3);
		if (!(baseEntity == null))
		{
			baseEntity.creatorEntity = player;
			ServerProjectile component2 = baseEntity.GetComponent<ServerProjectile>();
			if ((bool)component2)
			{
				component2.InitializeVelocity(GetInheritedVelocity(player) + vector2 * component2.speed);
			}
			baseEntity.Spawn();
			StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
			Interface.CallHook("OnRocketLaunched", player, baseEntity);
			GetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));
		}
	}

```

## OnSleepingBagDestroyed(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The sleeping bag that is being destroyed.</param>
/// <param name="player">The player who destroyed the sleeping bag.</param>
/// <returns>No return behavior.</returns>
void OnSleepingBagDestroyed(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Sleeping bag owned by player {player.displayName} (ID: {player.UserIDString}) has been destroyed.");
    
    if (sleepingBag.canBePublic)
    {
        Puts($"Sleeping bag {sleepingBag.ID} was public and is now set to public.");
    }
    else
    {
        Puts($"Sleeping bag {sleepingBag.ID} was destroyed permanently.");
    }
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(BasePlayer player, uint sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, player) != null)
		{
			return false;
		}
		if (sleepingBag2.canBePublic)
		{
			sleepingBag2.SetPublic(isPublic: true);
			sleepingBag2.deployerUserID = 0uL;
		}
		else
		{
			sleepingBag2.Kill();
		}
		player.SendRespawnOptions();
		Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, player);
		return true;
	}

```

## OnHorseHitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is hitched to a hitching spot.
/// </summary>
/// <param name="horse">The horse that is being hitched.</param>
/// <param name="hitch">The hitching spot where the horse is being hitched.</param>
/// <returns>
/// Returns `true` if the horse was successfully hitched; otherwise, returns `false`.
/// If the method returns a non-null value, it overrides the default hitching behavior.
/// </returns>
bool OnHorseHitch(RidableHorse horse, HitchSpot hitch)
{
    Puts($"Attempting to hitch horse {horse.name} to hitch spot {hitch.name}.");
    
    if (hitch.IsOccupied())
    {
        Puts($"Hitch spot {hitch.name} is already occupied.");
        return false;
    }

    return null; // Allow default behavior to proceed if no conditions are met.
}
```
```

### Source Code from the Library

```csharp

	public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch = null)
	{
		if (horse == null)
		{
			return false;
		}
		if (hitch == null)
		{
			hitch = GetClosest(horse.transform.position);
		}
		if (hitch != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", horse, hitch);
			if (obj is bool)
			{
				return (bool)obj;
			}
			hitch.SetOccupiedBy(horse);
			horse.SetHitch(this);
			horse.transform.rotation = hitch.spot.transform.rotation;
			horse.transform.position = hitch.spot.transform.position;
			horse.DismountAllPlayers();
			return true;
		}
		return false;
	}

```

## OnMapMarkersCleared(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player's map markers are cleared.
/// </summary>
/// <param name="player">The player whose map markers have been cleared.</param>
/// <param name="mapNote">The map note that was cleared, if applicable.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkersCleared(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has cleared their map markers.");
    
    if (mapNote != null)
    {
        Puts($"Cleared map note: {mapNote.title} at position {mapNote.position}");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, ServerCurrentMapNote) == null)
		{
			ServerCurrentDeathNote?.Dispose();
			ServerCurrentDeathNote = null;
			ServerCurrentMapNote?.Dispose();
			ServerCurrentMapNote = null;
			DirtyPlayerState();
			TeamUpdate();
			Interface.CallHook("OnMapMarkersCleared", this, ServerCurrentMapNote);
		}
	}

```

## OnBookmarkControl(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to control a bookmark on a computer station.
/// </summary>
/// <param name="station">The computer station being controlled.</param>
/// <param name="player">The player attempting to control the bookmark.</param>
/// <param name="bookmarkId">The identifier of the bookmark being controlled.</param>
/// <param name="controllable">The remote controllable entity associated with the bookmark.</param>
/// <returns>Returns `null` to allow control, or any non-null value to prevent it.</returns>
object OnBookmarkControl(ComputerStation station, BasePlayer player, string bookmarkId, IRemoteControllable controllable)
{
    Puts($"Player {player.displayName} is attempting to control bookmark: {bookmarkId} on station: {station.net.ID}.");

    if (!controllable.CanControl())
    {
        Puts($"Control denied for player {player.displayName} on bookmark: {bookmarkId}.");
        return "You cannot control this bookmark.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.ContainsKey(text))
		{
			return;
		}
		uint uid = controlBookmarks[text];
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (baseNetworkable == null)
		{
			return;
		}
		IRemoteControllable component = baseNetworkable.GetComponent<IRemoteControllable>();
		if (component.CanControl() && !(component.GetIdentifier() != text) && Interface.CallHook("OnBookmarkControl", this, player, text, component) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				baseEntity.GetComponent<IRemoteControllable>()?.StopControl();
			}
			player.net.SwitchSecondaryGroup(baseNetworkable.net.group);
			currentlyControllingEnt.uid = baseNetworkable.net.ID;
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			component.InitializeControl(player);
			InvokeRepeating(ControlCheck, 0f, 0f);
		}
	}

```

## CanAssignBed(BasePlayer,SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can assign a sleeping bag to another player.
/// </summary>
/// <param name="player">The player attempting to assign the sleeping bag.</param>
/// <param name="sleepingBag">The sleeping bag being assigned.</param>
/// <param name="friendId">The user ID of the friend to whom the sleeping bag is being assigned.</param>
/// <returns>
/// Returns `true` if the assignment is allowed, or `false` if it is not. 
/// If the method returns `null`, the default game logic will determine if the assignment can proceed.
/// </returns>
bool? CanAssignBed(BasePlayer player, SleepingBag sleepingBag, ulong friendId)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to assign a sleeping bag to friend ID: {friendId}.");

    if (friendId == player.userID)
    {
        Puts("A player cannot assign a sleeping bag to themselves.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (msg.player.CanInteract() && deployerUserID == msg.player.userID)
		{
			ulong num = msg.read.UInt64();
			if (num != 0L && Interface.CallHook("CanAssignBed", msg.player, this, num) == null)
			{
				deployerUserID = num;
				SendNetworkUpdate();
			}
		}
	}

```

## CanSwapToSeat(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Determines whether a player can swap to a seat on the mountable entity.
/// </summary>
/// <param name="player">The player attempting to swap to the seat.</param>
/// <param name="mountable">The mountable entity the player is trying to access.</param>
/// <returns>
/// Returns `true` if the player can swap to the seat; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the swap is allowed.
/// </returns>
bool? CanSwapToSeat(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to swap to a seat on {mountable.gameObject.name}.");

    if (player.IsInCombat)
    {
        Puts($"Player {player.displayName} cannot swap to seat while in combat.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnEntityDestroy(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is destroyed.
/// </summary>
/// <param name="info">Information about the hit that caused the destruction.</param>
/// <returns>No return behavior.</returns>
void OnEntityDestroy(BradleyAPC apc, HitInfo info)
{
    Puts($"Bradley APC destroyed at position: {apc.transform.position} by {info.Initiator?.ToString() ?? "unknown source"}.");

    // Additional logic for handling destruction effects can be added here.
    CreateExplosionMarker(10f);
    Effect.server.Run(explosionEffect.resourcePath, apc.mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (base.isClient || Interface.CallHook("OnEntityDestroy", this) != null)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);
		Vector3 zero = Vector3.zero;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);
		for (int i = 0; i < 12 - maxCratesToSpawn; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);
			if (!baseEntity)
			{
				continue;
			}
			float min = 3f;
			float max = 10f;
			Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
			baseEntity.transform.position = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * UnityEngine.Random.Range(-4f, 4f);
			Collider component = baseEntity.GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(zero + onUnitSphere * UnityEngine.Random.Range(min, max));
			foreach (ServerGib item in list)
			{
				UnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;
			onUnitSphere2.y = 0f;
			onUnitSphere2.Normalize();
			Vector3 pos = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if ((bool)lootContainer)
			{
				lootContainer.Invoke(lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = baseEntity2.GetComponent<Collider>();
			Rigidbody rigidbody = baseEntity2.gameObject.AddComponent<Rigidbody>();
			rigidbody.useGravity = true;
			rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
			rigidbody.mass = 2f;
			rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
			rigidbody.velocity = zero + onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);
			rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
			rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if ((bool)fireBall)
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				fireBall.GetComponent<Rigidbody>().isKinematic = true;
				fireBall.GetComponent<Collider>().enabled = false;
			}
			baseEntity2.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);
			foreach (ServerGib item2 in list)
			{
				UnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);
			}
		}
		base.OnKilled(info);
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be accepted into the specified item container at the given position.
/// </summary>
/// <param name="item">The item to be checked for acceptance.</param>
/// <param name="targetPos">The target position in the container where the item is to be placed.</param>
/// <returns>
/// Returns <c>CanAcceptResult.CannotAccept</c> if the item cannot be accepted, 
/// <c>CanAcceptResult.CannotAcceptRightNow</c> if it cannot be accepted at the moment, 
/// or <c>CanAcceptResult.CanAccept</c> if the item can be accepted.
/// If the method returns a non-null value from the hook, that value will be used to determine acceptance.
/// </returns>
CanAcceptResult CanAcceptItem(Item item, int targetPos)
{
    Puts($"Checking if item {item.info.displayName.english} can be accepted in the container at position {targetPos}.");
    return CanAcceptResult.CanAccept; // Default return value
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (onlyAllowedItem != null && onlyAllowedItem != item.info)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			int[] array = new int[32];
			foreach (ItemSlot availableSlot in availableSlots)
			{
				array[(int)Mathf.Log((float)availableSlot, 2f)]++;
			}
			foreach (Item item2 in itemList)
			{
				for (int i = 0; i < 32; i++)
				{
					if (((uint)item2.info.occupySlots & (uint)(1 << i)) != 0)
					{
						array[i]--;
					}
				}
			}
			for (int j = 0; j < 32; j++)
			{
				if (((uint)item.info.occupySlots & (uint)(1 << j)) != 0 && array[j] <= 0)
				{
					return CanAcceptResult.CannotAcceptRightNow;
				}
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		return CanAcceptResult.CanAccept;
	}

```

## OnItemSplit(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is split into a smaller quantity.
/// </summary>
/// <param name="item">The item being split.</param>
/// <param name="splitAmount">The amount to split from the original item.</param>
/// <returns>
/// Returns a new item representing the split portion if successful; otherwise, returns `null`.
/// If a non-null item is returned from the hook, that item will be used instead of the default split behavior.
/// </returns>
Item OnItemSplit(Item item, int splitAmount)
{
    Puts($"Item {item.info.displayName.english} is being split. Amount to split: {splitAmount}.");

    if (splitAmount > item.amount)
    {
        Puts("Cannot split more than the available amount.");
        return null;
    }

    return null; // Allow default behavior to proceed
}
```
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		if (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
		}
		MarkDirty();
		return item;
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is upgraded successfully.
/// </summary>
/// <param name="originalItem">The original item before the upgrade.</param>
/// <param name="upgradedItem">The new item created as a result of the upgrade.</param>
/// <param name="player">The player who performed the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnItemUpgrade(Item originalItem, Item upgradedItem, BasePlayer player)
{
    Puts($"Player {player.displayName} upgraded {originalItem.info.displayName.english} to {upgradedItem.info.displayName.english}.");
    
    if (upgradedItem.info.shortname == "better.item")
    {
        Puts($"Congratulations {player.displayName}, you have upgraded to a better item!");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (UnityEngine.Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnHelicopterDropDoorOpen(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the drop door of the helicopter is opened or closed.
/// </summary>
/// <param name="helicopter">The helicopter whose drop door state is being changed.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropDoorOpen(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter drop door state changed for Helicopter ID: {helicopter.net.ID}. Door is now {(helicopter.HasFlag(Flags.Reserved8) ? "open" : "closed")}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting a storage container.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="container">The storage container that was looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.displayName} has stopped looting the container: {container.ShortPrefabName}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnExperimentStarted(Workbench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an experiment is started at a workbench by a player.
/// </summary>
/// <param name="workbench">The workbench where the experiment is being conducted.</param>
/// <param name="player">The player who initiated the experiment.</param>
/// <returns>No return behavior.</returns>
void OnExperimentStarted(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment started at workbench by player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can start experiments freely.");
    }
    else
    {
        Puts($"Player {player.displayName} is not in creative mode and must meet requirements to start an experiment.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !playerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## CanChangeCode(BasePlayer,CodeLock,string,bool)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the code on a code lock.
/// </summary>
/// <param name="player">The player attempting to change the code.</param>
/// <param name="codeLock">The code lock being modified.</param>
/// <param name="newCode">The new code to set.</param>
/// <param name="isGuestCode">Indicates if the new code is a guest code.</param>
/// <returns>
/// Returns `null` to allow the code change, or any non-null value to prevent it.
/// </returns>
object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
{
    Puts($"Player {player.displayName} is attempting to change the code on a code lock.");

    if (newCode == "1234")
    {
        Puts("Attempt to set a default code is blocked.");
        return "Default code cannot be used.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (IsLocked() || text.Length != 4 || !text.IsNumeric() || (!hasCode && flag))
		{
			return;
		}
		if (!hasCode && !flag)
		{
			SetFlag(Flags.Locked, b: true);
		}
		if (Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when an auto turret is starting up.
/// </summary>
/// <param name="turret">The auto turret that is initiating startup.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally. 
/// Any non-null value will prevent the turret from starting up.
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"AutoTurret ID: {turret.net.ID} is attempting to start up.");
    
    if (turret.IsUnderMaintenance)
    {
        Puts($"AutoTurret ID: {turret.net.ID} cannot start up while under maintenance.");
        return "Turret is under maintenance.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnPlayerSpawn(BasePlayer,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a player spawns into the game.
/// </summary>
/// <param name="player">The player that is spawning.</param>
/// <param name="connection">The network connection associated with the player.</param>
/// <returns>
/// Returns `null` to allow the player to spawn normally, or any non-null value to prevent spawning.
/// </returns>
object OnPlayerSpawn(BasePlayer player, Network.Connection connection)
{
    Puts($"Player {player.displayName} is attempting to spawn with connection ID: {connection.userid}.");

    if (player.IsBanned)
    {
        Puts($"Player {player.displayName} is banned and cannot spawn.");
        return "You are banned from this server.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private BasePlayer SpawnNewPlayer(Network.Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer, connection) != null)
		{
			return null;
		}
		basePlayer.health = 0f;
		basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
		basePlayer.ResetLifeStateOnSpawn = false;
		basePlayer.limitNetworking = true;
		basePlayer.Spawn();
		basePlayer.limitNetworking = false;
		basePlayer.PlayerInit(connection);
		if (UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife))
		{
			basePlayer.Respawn();
		}
		else
		{
			basePlayer.SendRespawnOptions();
		}
		DebugEx.Log($"{basePlayer.displayName} with steamid {basePlayer.userID} joined from ip {basePlayer.net.connection.ipaddress}");
		DebugEx.Log($"\tNetworkId {basePlayer.userID} is {basePlayer.net.ID} ({basePlayer.displayName})");
		if (basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
		{
			DebugEx.Log($"\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}");
		}
		return basePlayer;
	}

```

## CanRenameBed(BasePlayer,SleepingBag,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can rename a sleeping bag.
/// </summary>
/// <param name="player">The player attempting to rename the sleeping bag.</param>
/// <param name="sleepingBag">The sleeping bag being renamed.</param>
/// <param name="newName">The new name for the sleeping bag.</param>
/// <returns>
/// Returns `null` to allow the renaming, or a non-null value to prevent the renaming with a reason.
/// </returns>
object CanRenameBed(BasePlayer player, SleepingBag sleepingBag, string newName)
{
    Puts($"Player {player.displayName} is attempting to rename a sleeping bag to '{newName}'.");

    if (newName.Contains("forbidden"))
    {
        Puts($"Player {player.displayName} tried to use a forbidden name.");
        return "You cannot use that name.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("CanRenameBed", msg.player, this, text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
		}
	}

```

## OnNetworkGroupLeft(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network group is left by a networkable entity.
/// </summary>
/// <param name="networkable">The networkable entity that left the group.</param>
/// <param name="group">The network visibility group that was left.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupLeft(BaseNetworkable networkable, Network.Visibility.Group group)
{
    Puts($"Networkable entity {networkable.net.ID} has left the group {group.name}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", this, group);
	}

```

## OnBigWheelLoss(BigWheelGame,Item,BigWheelBettingTerminal)

```csharp
```csharp
/// <summary>
/// Called when a player loses in the Big Wheel game.
/// </summary>
/// <param name="game">The Big Wheel game instance.</param>
/// <param name="item">The item associated with the loss.</param>
/// <param name="terminal">The betting terminal where the bet was placed.</param>
/// <returns>
/// Returns a non-null value to override the default loss behavior. If a string is returned, it can be used as a message to the player.
/// If `null` is returned, the default loss behavior will proceed.
/// </returns>
object OnBigWheelLoss(BigWheelGame game, Item item, BigWheelBettingTerminal terminal)
{
    Puts($"Player lost at the Big Wheel! Item: {item.info.displayName.english}, Terminal: {terminal.net.ID}");
    
    // Example condition to prevent loss
    if (item.info.shortname == "special.token")
    {
        Puts("Player cannot lose special tokens!");
        return "You cannot lose special tokens!";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) != null)
				{
					return;
				}
				slot.amount += slot.amount * num;
				slot.RemoveFromContainer();
				slot.MoveToContainer(terminal.inventory, 5);
				flag = true;
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) != null)
				{
					return;
				}
				if (slot2 != null)
				{
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(null, "WinOrLoseSound", flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## OnVehicleModulesAssigned(ModularCar,Rust.Modular.ItemModVehicleModule[])

```csharp
```csharp
/// <summary>
/// Called when vehicle modules are assigned to a modular car.
/// </summary>
/// <param name="car">The modular car to which the modules are being assigned.</param>
/// <param name="modules">The array of vehicle modules being assigned.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModulesAssigned(ModularCar car, Rust.Modular.ItemModVehicleModule[] modules)
{
    Puts($"Vehicle modules assigned to car ID: {car.net.ID}. Number of modules: {modules.Length}.");

    foreach (var module in modules)
    {
        if (module != null)
        {
            Puts($"Module {module.shortname} assigned to car.");
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", this, modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				itemModVehicleModule.doNonUserSpawn = true;
				Item item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);
				float num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", this, modularCarPresetConfig.socketItemDefs);
	}

```

## OnTakeCurrencyItem(NPCVendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is taken as currency by the vending machine.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that is taking the currency item.</param>
/// <param name="currencyItem">The item being taken as currency.</param>
/// <returns>No return behavior.</returns>
void OnTakeCurrencyItem(NPCVendingMachine vendingMachine, Item currencyItem)
{
    Puts($"Currency item {currencyItem.info.displayName.english} taken by vending machine {vendingMachine.net.ID}.");
}
```
```

### Source Code from the Library

```csharp

	public override void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null)
		{
			takenCurrencyItem.MoveToContainer(base.inventory);
			takenCurrencyItem.RemoveFromContainer();
			takenCurrencyItem.Remove();
		}
	}

```

## IOnNpcTarget(Rust.Ai.HTN.IHTNAgent,BasePlayer,int)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player, allowing for custom behavior or modifications.
/// </summary>
/// <param name="npc">The NPC agent that is targeting the player.</param>
/// <param name="player">The player being targeted by the NPC.</param>
/// <param name="index">The index of the player in the NPC's target list.</param>
/// <returns>
/// Returns a non-null value to override the default targeting behavior. 
/// If `null` is returned, the NPC will proceed with its default targeting logic.
/// </returns>
object IOnNpcTarget(IHTNAgent npc, BasePlayer player, int index)
{
    Puts($"NPC {npc.GetType().Name} is targeting Player {player.displayName} (ID: {player.UserIDString}) at index {index}.");

    if (player.IsWounded())
    {
        Puts($"NPC {npc.GetType().Name} will not target a wounded player: {player.displayName}.");
        return true; // Prevents the NPC from targeting wounded players.
    }

    return null; // Allow default behavior to continue.
}
```
```

### Source Code from the Library

```csharp

	public void Tick(IHTNAgent npc, float deltaTime, float time)
	{
		if (ConVar.AI.ignoreplayers || npc == null || npc.transform == null || npc.IsDestroyed || npc.AiDefinition == null)
		{
			return;
		}
		PlayerQueryResultCount = BaseEntity.Query.Server.GetPlayersInSphere(npc.transform.position, npc.AiDefinition.Sensory.VisionRange, PlayerQueryResults, delegate(BasePlayer player)
		{
			if (player == null || !player.isServer || player.IsDestroyed || player.transform == null || player.IsDead() || player.IsWounded())
			{
				return false;
			}
			return (!player.IsSleeping() || !(player.secondsSleeping < NPCAutoTurret.sleeperhostiledelay)) ? true : false;
		});
		List<NpcPlayerInfo> playersInRange = npc.AiDomain.NpcContext.PlayersInRange;
		if (PlayerQueryResultCount > 0)
		{
			for (int i = 0; i < PlayerQueryResultCount; i++)
			{
				BasePlayer basePlayer = PlayerQueryResults[i];
				HTNPlayer hTNPlayer = npc as HTNPlayer;
				if ((hTNPlayer != null && basePlayer == hTNPlayer) || (basePlayer.transform.position - npc.transform.position).sqrMagnitude > npc.AiDefinition.Sensory.SqrVisionRange)
				{
					continue;
				}
				bool flag = false;
				for (int j = 0; j < playersInRange.Count; j++)
				{
					NpcPlayerInfo value = playersInRange[j];
					if (value.Player == basePlayer)
					{
						value.Time = time;
						playersInRange[j] = value;
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					playersInRange.Add(new NpcPlayerInfo
					{
						Player = basePlayer,
						Time = time
					});
				}
			}
		}
		for (int k = 0; k < playersInRange.Count; k++)
		{
			NpcPlayerInfo player2 = playersInRange[k];
			if (Interface.CallHook("IOnNpcTarget", npc, player2.Player, k) != null)
			{
				break;
			}
			if (time - player2.Time > npc.AiDefinition.Memory.ForgetInRangeTime && npc.AiDomain.NpcContext.BaseMemory.ShouldRemoveOnPlayerForgetTimeout(time, player2))
			{
				playersInRange.RemoveAt(k);
				k--;
			}
		}
	}

```

## OnEntityControl(PoweredRemoteControlEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if the entity can be controlled by a player or another entity.
/// </summary>
/// <param name="remoteControl">The powered remote control entity attempting to control this entity.</param>
/// <returns>
/// Returns `true` if the entity can be controlled; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will be used to determine control ability.
/// </returns>
bool? OnEntityControl(PoweredRemoteControlEntity remoteControl)
{
    Puts($"Entity control check initiated by {remoteControl?.gameObject.name ?? "Unknown Remote Control"}.");

    if (!IsPowered())
    {
        Puts("Entity is not powered and cannot be controlled.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl()
	{
		object obj = Interface.CallHook("OnEntityControl", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsPowered())
		{
			return IsStatic();
		}
		return true;
	}

```

## OnItemAction(Item,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an action is performed on an item by a player.
/// </summary>
/// <param name="item">The item on which the action is performed.</param>
/// <param name="action">The action being performed on the item (e.g., "drop").</param>
/// <param name="player">The player performing the action.</param>
/// <returns>
/// Returns a non-null value to prevent the action from being executed. 
/// If `null` is returned, the action proceeds as normal.
/// </returns>
object OnItemAction(Item item, string action, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to perform action '{action}' on item {item.info.displayName.english}.");

    if (action == "drop" && item.amount > 10)
    {
        Puts($"Player {player.displayName} cannot drop more than 10 of this item at once.");
        return "Cannot drop more than 10 items.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		if (msg.player != null && msg.player.IsWounded())
		{
			return;
		}
		uint id = msg.read.UInt32();
		string text = msg.read.String();
		Item item = FindItemUID(id);
		if (item == null || Interface.CallHook("OnItemAction", item, text, msg.player) != null || item.IsLocked() || !CanMoveItemsFrom(item.parent.entityOwner, item))
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.Unread >= 4)
			{
				num = msg.read.Int32();
			}
			base.baseEntity.stats.Add("item_drop", 1, (Stats)5);
			if (num < item.amount)
			{
				item.SplitItem(num)?.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
			}
			else
			{
				item.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="message">The chat message sent by the player.</param>
/// <param name="player">The player who sent the message.</param>
/// <returns>
/// Returns `null` to allow the message to be sent, or any non-null value to prevent the message from being sent.
/// </returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Player {player.displayName} sent a message: {message}");
    
    if (message.Contains("forbidden"))
    {
        Puts($"Message from {player.displayName} contains forbidden content and will not be sent.");
        return "Your message contains forbidden content.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 2, 0, msg);
		}
	}

```

## OnFireBallSpread(FireBall,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a fireball attempts to spread to create a new fireball entity.
/// </summary>
/// <param name="fireBall">The fireball that is spreading.</param>
/// <param name="entity">The base entity that is being created as a result of the spread.</param>
/// <returns>No return behavior.</returns>
void OnFireBallSpread(FireBall fireBall, BaseEntity entity)
{
    Puts($"Fireball {fireBall.net.ID} is spreading to create a new entity: {entity?.net.ID ?? 0}.");
    
    if (entity is FireBall)
    {
        Puts("A new fireball has been created from the spread.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void TryToSpread()
	{
		float num = 0.9f - generation * 0.1f;
		if (UnityEngine.Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", this, baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));
				baseEntity.SendMessage("SetGeneration", generation + 1f);
			}
		}
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an object triggers the bear trap.
/// </summary>
/// <param name="trap">The bear trap that was triggered.</param>
/// <param name="triggeredObject">The game object that triggered the trap.</param>
/// <returns>No return behavior.</returns>
void OnTrapTrigger(BearTrap trap, UnityEngine.GameObject triggeredObject)
{
    Puts($"Trap triggered by: {triggeredObject.name} at position: {triggeredObject.transform.position}");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## CanLock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can lock the specified key lock.
/// </summary>
/// <param name="player">The player attempting to lock the key lock.</param>
/// <param name="keyLock">The key lock that the player is trying to lock.</param>
/// <returns>
/// Returns `true` if the player can lock the key lock, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can lock it.
/// </returns>
bool? CanLock(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to lock the key lock.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can lock anything.");
        return true;
    }

    if (keyLock.IsLocked())
    {
        Puts($"Key lock is already locked. Player {player.displayName} cannot lock it.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Lock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			LockLock(rpc.player);
			SendNetworkUpdate();
		}
	}

```

## OnNpcDuck(HumanNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC is requested to duck.
/// </summary>
/// <param name="npc">The NPC that is attempting to duck.</param>
/// <returns>Returns `null` to allow the NPC to duck, or any non-null value to prevent the action.</returns>
object OnNpcDuck(HumanNPC npc)
{
    Puts($"NPC {npc.displayName} is attempting to duck.");
    
    // Example condition to prevent ducking
    if (npc.IsInCombat)
    {
        Puts($"NPC {npc.displayName} cannot duck while in combat.");
        return true; // Prevents the duck action
    }
    
    return null; // Allows the duck action
}
```
```

### Source Code from the Library

```csharp

	public void SetDucked(bool wantsDucked)
	{
		if (Interface.CallHook("OnNpcDuck", this) == null)
		{
			pendingDucked = wantsDucked;
			ApplyPendingDucked();
		}
	}

```

## OnElevatorButtonPress(ElevatorLift,BasePlayer,Elevator.Direction,bool)

```csharp
```csharp
/// <summary>
/// Called when a player presses the button on the elevator to raise or lower the floor.
/// </summary>
/// <param name="elevator">The elevator that is being controlled.</param>
/// <param name="player">The player who pressed the button.</param>
/// <param name="direction">The direction in which the elevator is to move.</param>
/// <param name="isEmergency">Indicates if the button press is for an emergency stop.</param>
/// <returns>No return behavior.</returns>
void OnElevatorButtonPress(ElevatorLift elevator, BasePlayer player, Elevator.Direction direction, bool isEmergency)
{
    Puts($"Player {player.displayName} pressed the elevator button. Direction: {direction}, Emergency: {isEmergency}");
    
    if (isEmergency)
    {
        Puts("Emergency stop activated!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Server_RaiseLowerFloor(RPCMessage msg)
	{
		if (!CanMove())
		{
			return;
		}
		Elevator.Direction direction = (Elevator.Direction)msg.read.Int32();
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnElevatorButtonPress", this, msg.player, direction, flag) == null)
		{
			SetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);
			owner.Server_RaiseLowerElevator(direction, flag);
			Invoke(ClearDirection, 0.7f);
			if (liftButtonPressedEffect.isValid)
			{
				Effect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an object triggers the trap.
/// </summary>
/// <param name="trap">The landmine trap that was triggered.</param>
/// <param name="triggeredObject">The game object that triggered the trap.</param>
/// <returns>No return behavior.</returns>
void OnTrapTrigger(Landmine trap, UnityEngine.GameObject triggeredObject)
{
    Puts($"Trap triggered by object: {triggeredObject.name}. Trap ID: {trap.net.ID}");

    BasePlayer player = GameObjectEx.ToBaseEntity(triggeredObject) as BasePlayer;
    if (player != null)
    {
        Puts($"Player {player.displayName} has triggered the trap!");
    }
    else
    {
        Puts($"Non-player object {triggeredObject.name} has triggered the trap.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## OnRidableAnimalClaimed(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a ridable animal is claimed by a player.
/// </summary>
/// <param name="animal">The ridable animal that is being claimed.</param>
/// <param name="player">The player who is claiming the animal.</param>
/// <returns>No return behavior.</returns>
void OnRidableAnimalClaimed(BaseRidableAnimal animal, BasePlayer player)
{
    Puts($"Player {player.displayName} has claimed the ridable animal: {animal.name}.");
    
    if (animal.IsForSale())
    {
        Puts($"Animal {animal.name} was successfully claimed by {player.displayName}.");
    }
    else
    {
        Puts($"Animal {animal.name} is not available for claiming.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && Interface.CallHook("OnRidableAnimalClaim", this, player) == null && IsForSale())
		{
			Item item = GetPurchaseToken(player);
			if (item != null)
			{
				item.UseItem();
				SetFlag(Flags.Reserved2, b: false);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## OnTeamKick(RelationshipManager.PlayerTeam,BasePlayer,ulong)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from a team.
/// </summary>
/// <param name="team">The team from which the player is being kicked.</param>
/// <param name="player">The player who is being kicked.</param>
/// <param name="kickerId">The user ID of the player who initiated the kick.</param>
/// <returns>
/// Returns `null` to allow the kick to proceed, or any non-null value to prevent the kick.
/// </returns>
object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong kickerId)
{
    Puts($"Player {player.displayName} (ID: {player.userID}) is being kicked from team {team.TeamName} by player ID: {kickerId}.");

    if (player.userID == kickerId)
    {
        Puts($"Player {player.displayName} cannot kick themselves.");
        return "You cannot kick yourself from the team.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void kickmember(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer == null)
		{
			return;
		}
		PlayerTeam playerTeam = Instance.FindTeam(basePlayer.currentTeam);
		if (playerTeam != null && !(playerTeam.GetLeader() != basePlayer))
		{
			ulong uLong = arg.GetULong(0, 0uL);
			if (basePlayer.userID != uLong && Interface.CallHook("OnTeamKick", playerTeam, basePlayer, uLong) == null)
			{
				playerTeam.RemovePlayer(uLong);
			}
		}
	}

```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
```csharp
/// <summary>
/// Determines whether a player can be targeted by a flame turret.
/// </summary>
/// <param name="player">The player being checked for targeting.</param>
/// <param name="turret">The flame turret attempting to target the player.</param>
/// <returns>
/// Returns `true` if the player can be targeted by the turret; otherwise, returns `false`.
/// If the method returns `null`, the default targeting logic will be applied.
/// </returns>
bool? CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts($"Checking if player {player.displayName} (ID: {player.UserIDString}) can be targeted by turret {turret.net.ID}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot be targeted.");
        return false;
    }

    if (player.HasActiveBuff("invisible"))
    {
        Puts($"Player {player.displayName} is currently invisible and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = item.GetComponent<BasePlayer>();
				if (component.IsSleeping() || !component.IsAlive() || component.IsBuildingAuthed())
				{
					continue;
				}
				object obj2 = Interface.CallHook("CanBeTargeted", component, this);
				if (obj2 is bool)
				{
					Pool.FreeList(ref obj);
					return (bool)obj2;
				}
				if (component.transform.position.y > GetEyePosition().y + 0.5f)
				{
					continue;
				}
				obj.Clear();
				GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
				for (int i = 0; i < obj.Count; i++)
				{
					BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
					if (entity != null && (entity == this || entity.EqualNetID(this)))
					{
						flag = true;
						break;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeList(ref obj);
		return flag;
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player stops spectating.
/// </summary>
/// <param name="player">The player who is stopping their spectating.</param>
/// <param name="filter">The filter that was used for spectating, which could be a player name or other identifier.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player.displayName} has stopped spectating with filter: {filter}");
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## CanUseVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use the vending machine.
/// </summary>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <returns>
/// Returns `true` if the player can use the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine access.
/// </returns>
bool? CanUseVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use the vending machine.");

    if (player.IsBannedFromVending())
    {
        Puts($"Player {player.displayName} is banned from using vending machines.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName = "")
	{
		object obj = Interface.CallHook("CanUseVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

```

## OnServerInitialize()

```csharp
```csharp
/// <summary>
/// Called when the server is initialized, setting up necessary components and loading data.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerInitialize()
{
    Puts("Server is initializing...");

    // Additional initialization logic can be added here
    // For example, setting up default configurations or loading initial data
}
```
```

### Source Code from the Library

```csharp

	public void Initialize(bool loadSave = true, string saveFile = "", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)
	{
		Interface.CallHook("OnServerInitialize");
		persistance = new UserPersistance(ConVar.Server.rootFolder);
		playerStateManager = new PlayerStateManager(persistance);
		SpawnMapEntities();
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			using (TimeWarning.New("SpawnHandler.UpdateDistributions"))
			{
				SingletonComponent<SpawnHandler>.Instance.UpdateDistributions();
			}
		}
		if (loadSave)
		{
			skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves);
		}
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			if (!skipInitialSpawn)
			{
				using (TimeWarning.New("SpawnHandler.InitialSpawn", 200))
				{
					SingletonComponent<SpawnHandler>.Instance.InitialSpawn();
				}
			}
			using (TimeWarning.New("SpawnHandler.StartSpawnTick", 200))
			{
				SingletonComponent<SpawnHandler>.Instance.StartSpawnTick();
			}
		}
		CreateImportantEntities();
		auth = GetComponent<ConnectionAuth>();
	}

```

## IOnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved to the network stream.
/// </summary>
/// <param name="entity">The entity that is being saved.</param>
/// <param name="saveInfo">Information related to the save operation.</param>
/// <returns>No return behavior.</returns>
void IOnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity.net.ID} is being saved with save info: {saveInfo}");
    
    if (saveInfo.msg == null)
    {
        Puts($"Warning: SaveInfo message for entity {entity.net.ID} is null.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void ToStream(Stream stream, SaveInfo saveInfo)
	{
		using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError(string.Concat(this, ": ToStream - no BaseEntity!?"));
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError(string.Concat(this, ": ToStream - no baseNetworkable!?"));
			}
			Interface.CallHook("IOnEntitySaved", this, saveInfo);
			saveInfo.msg.ToProto(stream);
			PostSave(saveInfo);
		}
	}

```

## OnTeamDisbanded(RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team has been disbanded.
/// </summary>
/// <param name="team">The team that has been disbanded.</param>
/// <returns>No return behavior.</returns>
void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
{
    Puts($"Team with ID {team.teamID} has been disbanded. Members: {string.Join(", ", team.members)}");
    
    foreach (var member in team.members)
    {
        Puts($"Notifying member {member.displayName} of team disbandment.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Pool.Free(ref teamToDisband);
		}
	}

```

## OnHorseUnhitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is unhitched from a hitching spot.
/// </summary>
/// <param name="horse">The horse that is being unhitched.</param>
/// <param name="hitchSpot">The hitching spot from which the horse is being unhitched.</param>
/// <returns>No return behavior.</returns>
void OnHorseUnhitch(RidableHorse horse, HitchSpot hitchSpot)
{
    Puts($"Horse {horse.name} has been unhitched from {hitchSpot.name}.");
    
    if (horse.IsTired())
    {
        Puts($"Horse {horse.name} is tired after unhitching.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Unhitch(RidableHorse horse)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHorse(base.isServer) == horse)
			{
				if (Interface.CallHook("OnHorseUnhitch", horse, hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				horse.SetHitch(null);
			}
		}
	}

```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when the stock level of a vending machine is refreshed.
/// </summary>
/// <param name="vendingMachine">The vending machine whose stock is being refreshed.</param>
/// <param name="itemDef">The item definition for the item being checked, or <c>null</c> to refresh all items.</param>
/// <returns>No return behavior.</returns>
void OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDef)
{
    Puts($"Refreshing stock for Vending Machine ID: {vendingMachine.net.ID}, Item: {itemDef?.displayName.english ?? "All Items"}");
    
    if (itemDef != null && itemDef.itemid == 12345) // Example item ID check
    {
        Puts($"Special handling for item: {itemDef.displayName.english}");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		foreach (ProtoBuf.VendingMachine.SellOrder so in sellOrders.sellOrders)
		{
			if (!(itemDef == null) && itemDef.itemid != so.itemToSellID)
			{
				continue;
			}
			if (so.itemToSellIsBP)
			{
				List<Item> list = (from x in base.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
					where x.blueprintTarget == so.itemToSellID
					select x).ToList();
				ProtoBuf.VendingMachine.SellOrder sellOrder = so;
				int inStock;
				if (list == null || list.Count() < 0)
				{
					inStock = 0;
				}
				else
				{
					Interface.CallHook("OnRefreshVendingStock", this, itemDef);
					inStock = list.Sum((Item x) => x.amount) / so.itemToSellAmount;
				}
				sellOrder.inStock = inStock;
				continue;
			}
			List<Item> list2 = base.inventory.FindItemsByItemID(so.itemToSellID);
			ProtoBuf.VendingMachine.SellOrder sellOrder2 = so;
			int inStock2;
			if (list2 == null || list2.Count < 0)
			{
				inStock2 = 0;
			}
			else
			{
				Interface.CallHook("OnRefreshVendingStock", this, itemDef);
				inStock2 = list2.Sum((Item x) => x.amount) / so.itemToSellAmount;
			}
			sellOrder2.inStock = inStock2;
		}
	}

```

## OnNpcDestinationSet(NPCPlayerApex,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when the destination of an NPC is set.
/// </summary>
/// <param name="npc">The NPC whose destination is being set.</param>
/// <param name="destination">The new destination for the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC to move to the new destination; otherwise, returns a non-null value to prevent the movement.
/// </returns>
object OnNpcDestinationSet(NPCPlayerApex npc, UnityEngine.Vector3 destination)
{
    Puts($"NPC {npc.displayName} is attempting to set a new destination to {destination}.");
    
    if (Vector3.Distance(npc.transform.position, destination) < 5f)
    {
        Puts($"NPC {npc.displayName} cannot set destination too close to current position.");
        return true; // Prevents setting the destination
    }
    
    return null; // Allows setting the destination
}
```
```

### Source Code from the Library

```csharp

	public override void SetDestination(Vector3 newDestination)
	{
		if (Interface.CallHook("OnNpcDestinationSet", this, newDestination) == null)
		{
			base.SetDestination(newDestination);
			Destination = newDestination;
		}
	}

```

## OnItemDeployed(Deployer,ItemModDeployable)

```csharp
```csharp
/// <summary>
/// Called when an item is successfully deployed by a player.
/// </summary>
/// <param name="deployer">The player who deployed the item.</param>
/// <param name="deployable">The deployable item that was deployed.</param>
/// <returns>No return behavior.</returns>
void OnItemDeployed(BasePlayer deployer, ItemModDeployable deployable)
{
    Puts($"Item {deployable.shortname} has been deployed by {deployer.displayName} (ID: {deployer.UserIDString}).");

    if (deployable.shortname == "turret.auto")
    {
        Puts($"Warning: {deployer.displayName} deployed an auto turret!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Regular(Deployable deployable, Ray ray)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ChatMessage("Building is blocked at player position!");
		}
		else if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
		}
		else
		{
			if (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))
			{
				return;
			}
			Vector3 point = hitInfo.point;
			Quaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);
			Item ownerItem = GetOwnerItem();
			ItemModDeployable modDeployable = GetModDeployable();
			if (ownerPlayer.Distance(point) > 3f)
			{
				ownerPlayer.ChatMessage("Too far away!");
				return;
			}
			if (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))
			{
				ownerPlayer.ChatMessage("Building is blocked at placement position!");
				return;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);
			if (!baseEntity)
			{
				Debug.LogWarning("Couldn't create prefab:" + modDeployable.entityPrefab.resourcePath);
				return;
			}
			baseEntity.skinID = ownerItem.skin;
			baseEntity.SendMessage("SetDeployedBy", ownerPlayer, SendMessageOptions.DontRequireReceiver);
			baseEntity.OwnerID = ownerPlayer.userID;
			baseEntity.Spawn();
			modDeployable.OnDeployed(baseEntity, ownerPlayer);
			Interface.CallHook("OnItemDeployed", this, modDeployable);
			UseItemAmount(1);
		}
	}

```

## OnShopAcceptClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player accepts a shop transaction.
/// </summary>
/// <param name="shop">The shop front where the transaction is taking place.</param>
/// <param name="player">The player who clicked to accept the transaction.</param>
/// <returns>No return behavior.</returns>
void OnShopAcceptClick(ShopFront shop, BasePlayer player)
{
    Puts($"Player {player.displayName} has accepted the shop transaction at {shop.name}.");
    
    if (IsPlayerVendor(player))
    {
        Puts($"Vendor {player.displayName} is locking their inventory.");
    }
    else if (IsPlayerCustomer(player))
    {
        Puts($"Customer {player.displayName} is locking their inventory.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !(vendorPlayer == null) && !(customerPlayer == null) && Interface.CallHook("OnShopAcceptClick", this, msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				Invoke(CompleteTrade, 2f);
			}
		}
	}

```

## OnEngineLoadoutRefresh(Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called to refresh the loadout data of the engine storage.
/// </summary>
/// <param name="engineStorage">The engine storage whose loadout is being refreshed.</param>
/// <returns>No return behavior.</returns>
void OnEngineLoadoutRefresh(Rust.Modular.EngineStorage engineStorage)
{
    Puts($"Refreshing loadout data for engine storage ID: {engineStorage.net.ID}");
    // Additional logic can be added here if needed for specific engine storage behaviors.
}
```
```

### Source Code from the Library

```csharp

	public void RefreshLoadoutData()
	{
		if (Interface.CallHook("OnEngineLoadoutRefresh", this) == null)
		{
			isUsable = base.inventory.IsFull() && base.inventory.itemList.All((Item item) => !item.isBroken);
			accelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;
			topSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;
			fuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;
			SendNetworkUpdate();
			GetEngineModule()?.RefreshPerformanceStats(this);
		}
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int,bool)

```csharp
```csharp
/// <summary>
/// Determines whether the specified item blueprint can be crafted by the item crafter.
/// </summary>
/// <param name="crafter">The item crafter attempting to craft the item.</param>
/// <param name="blueprint">The blueprint of the item to be crafted.</param>
/// <param name="amount">The amount of items to craft.</param>
/// <param name="free">Indicates whether crafting should be free of resource costs.</param>
/// <returns>
/// Returns `true` if the item can be crafted, `false` if it cannot, 
/// or `null` if the crafting decision is deferred to a hook.
/// </returns>
bool? CanCraft(ItemCrafter crafter, ItemBlueprint blueprint, int amount = 1, bool free = false)
{
    Puts($"Checking crafting ability for {amount} of {blueprint.targetItem.shortname} by {crafter?.gameObject.name ?? "unknown crafter"}.");

    if (amount < 1 || amount > blueprint.targetItem.craftingStackable)
    {
        Puts("Invalid crafting amount.");
        return false;
    }

    if (free)
    {
        Puts("Crafting is free, allowing crafting.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)
	{
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount, free);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="keyLock">The key lock associated with the entity.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can use the entity.
/// </returns>
bool? CanUseLockedEntity(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is trying to access a locked entity.");
    
    if (keyLock.IsLocked())
    {
        Puts($"Entity is currently locked. Player {player.displayName} cannot access it.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## OnElevatorCall(Elevator,Elevator)

```csharp
```csharp
/// <summary>
/// Called when an elevator is requested to move by a player.
/// </summary>
/// <param name="caller">The entity that is calling the elevator.</param>
/// <param name="elevator">The elevator that is being called.</param>
/// <returns>
/// Returns `null` to allow the elevator to move, or any non-null value to prevent the elevator from moving.
/// </returns>
object OnElevatorCall(Elevator caller, Elevator elevator)
{
    Puts($"Elevator call received from {caller?.gameObject.name} for elevator {elevator?.gameObject.name}.");
    
    if (elevator.IsInUse)
    {
        Puts("Elevator is currently in use and cannot be called.");
        return "Elevator is busy.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CallElevator()
	{
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.IsTop && Interface.CallHook("OnElevatorCall", this, elevatorEnt) == null)
			{
				elevatorEnt.RequestMoveLiftTo(Floor, out var _);
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

```

## OnBookmarkControlEnd(ComputerStation,BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player stops controlling a bookmark on a computer station.
/// </summary>
/// <param name="station">The computer station being controlled.</param>
/// <param name="player">The player who is stopping control.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnd(ComputerStation station, BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player.displayName} has stopped controlling the entity: {entity?.name ?? "Unknown Entity"} on station: {station?.name ?? "Unknown Station"}.");
    
    if (entity != null)
    {
        Puts($"Entity {entity.name} control has been released.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl();
			if ((bool)ply)
			{
				ply.net.SwitchSecondaryGroup(null);
			}
		}
		currentlyControllingEnt.uid = 0u;
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player picks up an item.
/// </summary>
/// <param name="item">The item that is being picked up.</param>
/// <param name="player">The player who is picking up the item.</param>
/// <returns>
/// Returns `null` to allow the item pickup, or any non-null value to prevent the pickup action.
/// </returns>
object OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to pick up item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.itemid == 12345) // Example item ID for a restricted item
    {
        Puts($"Player {player.displayName} is not allowed to pick up this item.");
        return "You cannot pick up this item.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && item != null && allowPickup && Interface.CallHook("OnItemPickup", item, msg.player) == null)
		{
			ClientRPC(null, "PickupSound");
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is deauthorized from an auto turret.
/// </summary>
/// <param name="turret">The auto turret from which the player is being deauthorized.</param>
/// <param name="player">The player being deauthorized from the turret.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has been deauthorized from turret {turret.net.ID}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			SendNetworkUpdate();
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="sign">The sign that is being updated.</param>
/// <returns>
/// Returns `true` if the player can update the sign; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can update the sign.
/// </returns>
bool? CanUpdateSign(BasePlayer player, Signage sign)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to update a sign.");

    if (sign.IsLocked())
    {
        Puts($"Sign is locked. Only the owner can update it.");
        return player.userID == sign.OwnerID;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## OnPlayerRespawn(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called when a player respawns at a sleeping bag.
/// </summary>
/// <param name="player">The player who is respawning.</param>
/// <param name="sleepingBag">The sleeping bag the player is respawning at.</param>
/// <returns>
/// Returns a `SleepingBag` object if the respawn is overridden; otherwise, returns `null` to proceed with the default respawn behavior.
/// </returns>
object OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag)
{
    Puts($"Player {player.displayName} is respawning at sleeping bag ID: {sleepingBag.net.ID}.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot respawn because they are dead.");
        return null; // Allow default behavior
    }

    // Example condition to override respawn
    if (sleepingBag.IsLocked())
    {
        Puts($"Sleeping bag ID: {sleepingBag.net.ID} is locked. Respawn denied.");
        return sleepingBag; // Prevent respawn
    }

    return null; // Proceed with default respawn behavior
}
```
```

### Source Code from the Library

```csharp

	public static bool SpawnPlayer(BasePlayer player, uint sleepingBag)
	{
		BasePlayer player2 = player;
		SleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);
		SleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) => x.deployerUserID == player2.userID && x.net.ID == sleepingBag && x.unlockTime < UnityEngine.Time.realtimeSinceStartup);
		if (sleepingBag2 == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", player, sleepingBag2);
		if (obj is SleepingBag)
		{
			sleepingBag2 = (SleepingBag)obj;
		}
		Vector3 vector = sleepingBag2.transform.position + sleepingBag2.spawnOffset;
		Quaternion rotation = Quaternion.Euler(0f, sleepingBag2.transform.rotation.eulerAngles.y, 0f);
		player2.RespawnAt(vector, rotation);
		SleepingBag[] array2 = array;
		foreach (SleepingBag sleepingBag3 in array2)
		{
			if (Vector3.Distance(vector, sleepingBag3.transform.position) <= ConVar.Server.respawnresetrange)
			{
				sleepingBag3.unlockTime = UnityEngine.Time.realtimeSinceStartup + sleepingBag3.secondsBetweenReuses;
			}
		}
		return true;
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a vending transaction occurs between a player and a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine involved in the transaction.</param>
/// <param name="buyer">The player attempting to make a purchase.</param>
/// <param name="sellOrderId">The ID of the sell order being processed.</param>
/// <param name="numberOfTransactions">The number of items the player wishes to purchase.</param>
/// <returns>
/// Returns `true` if the transaction was successful; otherwise, returns `false`.
/// If the method returns a non-null value, it will override the default transaction behavior.
/// </returns>
bool? OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions)
{
    Puts($"Player {buyer.displayName} is attempting to purchase from vending machine with SellOrder ID: {sellOrderId}.");

    if (sellOrderId < 0)
    {
        Puts("Invalid SellOrder ID.");
        return false;
    }

    if (buyer.inventory.GetAmount(sellOrderId) < numberOfTransactions)
    {
        Puts($"Player {buyer.displayName} does not have enough items to complete the transaction.");
        return false;
    }

    return null; // Allow default transaction processing to continue
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
	{
		if (sellOrderId < 0 || sellOrderId > sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> list = base.inventory.FindItemsByItemID(sellOrder.itemToSellID);
		if (sellOrder.itemToSellIsBP)
		{
			list = (from x in base.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.itemToSellID
				select x).ToList();
		}
		if (list == null || list.Count == 0)
		{
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = list.Sum((Item x) => x.amount);
		if (num > num2)
		{
			return false;
		}
		List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
		if (source.Count == 0)
		{
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
		if (num3 < num4)
		{
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item2 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item2.amount);
			Item takenCurrencyItem = ((item2.amount > num6) ? item2.SplitItem(num6) : item2);
			TakeCurrencyItem(takenCurrencyItem);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		int num7 = 0;
		foreach (Item item3 in list)
		{
			int num8 = num - num7;
			Item item = ((item3.amount > num8) ? item3.SplitItem(num8) : item3);
			if (item == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item.amount;
				GiveSoldItem(item, buyer);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## OnDeleteVendingOffer(VendingMachine,int)

```csharp
```csharp
/// <summary>
/// Called when a vending machine's sell order is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the offer is being deleted.</param>
/// <param name="offerIndex">The index of the sell order being deleted.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, int offerIndex)
{
    Puts($"Vending machine {vendingMachine.net.ID} is deleting sell order at index {offerIndex}.");
    
    if (offerIndex < 0)
    {
        Puts("Attempted to delete a sell order with a negative index.");
    }
    else
    {
        Puts($"Sell order {offerIndex} deleted from vending machine {vendingMachine.net.ID}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", this, num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## OnPlayerRespawn(BasePlayer,BasePlayer.SpawnPoint)

```csharp
```csharp
/// <summary>
/// Called when a player is about to respawn.
/// </summary>
/// <param name="player">The player who is respawning.</param>
/// <param name="spawnPoint">The spawn point where the player will respawn.</param>
/// <returns>
/// Returns a modified spawn point if the hook alters the respawn location; otherwise, returns `null` to use the default spawn point.
/// </returns>
SpawnPoint? OnPlayerRespawn(BasePlayer player, SpawnPoint spawnPoint)
{
    Puts($"Player {player.displayName} is respawning at {spawnPoint.pos}.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot respawn because they are dead.");
        return null; // Prevent respawn if the player is dead
    }

    return spawnPoint; // Allow default behavior if no modifications are made
}
```
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint();
		object obj = Interface.CallHook("OnPlayerRespawn", this, spawnPoint);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnServerMessage(string,string,string,ulong)

```csharp
```csharp
/// <summary>
/// Called when a server message is broadcasted to all players.
/// </summary>
/// <param name="message">The message to be sent to all players.</param>
/// <param name="username">The username of the sender, defaults to "SERVER".</param>
/// <param name="color">The color of the message text, defaults to "#eee".</param>
/// <param name="userid">The user ID of the sender, defaults to 0.</param>
/// <returns>
/// Returns `null` to allow the message to be broadcasted, or any non-null value to prevent the broadcast.
/// </returns>
object OnServerMessage(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
{
    Puts($"Broadcasting message from {username} (ID: {userid}): {message}");

    if (message.Contains("forbidden"))
    {
        Puts("Message contains forbidden content and will not be broadcasted.");
        return "Message blocked due to forbidden content.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", message, username, color, userid) == null)
		{
			string text = username.EscapeRichText();
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=" + color + ">" + text + "</color> " + message);
			ChatEntry chatEntry = default(ChatEntry);
			chatEntry.Channel = ChatChannel.Server;
			chatEntry.Message = message;
			chatEntry.UserId = userid.ToString();
			chatEntry.Username = username;
			chatEntry.Color = color;
			chatEntry.Time = Epoch.Current;
			ChatEntry chatEntry2 = chatEntry;
			History.Add(chatEntry2);
			RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		}
	}

```

## OnNpcTarget(Rust.Ai.HTN.BaseNpcMemory,BaseNpc)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets another NPC or animal.
/// </summary>
/// <param name="memory">The memory context of the NPC targeting.</param>
/// <param name="target">The NPC or animal being targeted.</param>
/// <returns>
/// Returns a non-null value to override the default targeting behavior. 
/// If `null` is returned, the NPC will proceed with its targeting logic.
/// </returns>
object OnNpcTarget(Rust.Ai.HTN.BaseNpcMemory memory, BaseNpc target)
{
    Puts($"NPC targeting initiated for {target.displayName} (ID: {target.net.ID}).");

    if (target.IsDead())
    {
        Puts($"Target {target.displayName} is dead and cannot be targeted.");
        return "Target is dead.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RememberPrimaryAnimal(BaseNpc animal)
	{
		if (Interface.CallHook("OnNpcTarget", this, animal) != null)
		{
			return;
		}
		for (int i = 0; i < NpcContext.AnimalsInRange.Count; i++)
		{
			AnimalInfo primaryKnownAnimal = NpcContext.AnimalsInRange[i];
			if (primaryKnownAnimal.Animal == animal)
			{
				PrimaryKnownAnimal = primaryKnownAnimal;
				break;
			}
		}
	}

```

## OnCrateHackEnd(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when the hacking of a locked crate is completed.
/// </summary>
/// <param name="crate">The hackable locked crate that has been successfully hacked.</param>
/// <returns>No return behavior.</returns>
void OnCrateHackEnd(HackableLockedCrate crate)
{
    Puts($"Hacking completed for crate ID: {crate.net.ID}. It is now lootable.");
    // Additional logic can be added here, such as spawning loot or notifying players.
}
```
```

### Source Code from the Library

```csharp

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", this);
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			CancelInvoke(HackProgress);
		}
		ClientRPC(null, "UpdateHackProgress", (int)hackSeconds, (int)requiredHackSeconds);
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a melee weapon is thrown by a player.
/// </summary>
/// <param name="player">The player who threw the melee weapon.</param>
/// <param name="item">The item that was thrown.</param>
/// <returns>No return behavior.</returns>
void OnMeleeThrown(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} has thrown a melee weapon: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "rock")
    {
        Puts("Warning: Player threw a rock!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.IsActiveItem]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (player == null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsProjectile)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "item_missing");
				return;
			}
			ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
			if (component == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "mod_missing");
				return;
			}
			ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
			if (projectileShoot.projectiles.Count != 1)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "count_mismatch");
				return;
			}
			player.CleanupExpiredProjectiles();
			foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.Log(this, "duplicate_id");
				}
				else if (ValidateEyePos(player, projectile.startPos))
				{
					player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, item);
					Effect effect = new Effect();
					effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
					effect.scale = 1f;
					effect.pooledString = component.projectileObject.resourcePath;
					effect.number = projectile.seed;
					EffectNetwork.Send(effect);
				}
			}
			projectileShoot?.Dispose();
			item.SetParent(null);
			Interface.CallHook("OnMeleeThrown", player, item);
			if (!canAiHearIt)
			{
				return;
			}
			float num = 0f;
			if (component.projectileObject != null)
			{
				GameObject gameObject = component.projectileObject.Get();
				if (gameObject != null)
				{
					Projectile component2 = gameObject.GetComponent<Projectile>();
					if (component2 != null)
					{
						foreach (DamageTypeEntry damageType in component2.damageTypes)
						{
							num += damageType.amount;
						}
					}
				}
			}
			if (player != null)
			{
				Sensation sensation = default(Sensation);
				sensation.Type = SensationType.ThrownWeapon;
				sensation.Position = player.transform.position;
				sensation.Radius = 50f;
				sensation.DamagePotential = num;
				sensation.InitiatorPlayer = player;
				sensation.Initiator = player;
				Sense.Stimulate(sensation);
			}
		}
	}

```

## OnMapMarkerAdded(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player adds a new map marker.
/// </summary>
/// <param name="player">The player who added the map marker.</param>
/// <param name="mapNote">The details of the map marker that was added.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.displayName} added a map marker at position: {mapNote.position} with note: {mapNote.note}.");
    
    if (mapNote.note.Contains("danger"))
    {
        Puts($"Warning: Player {player.displayName} marked a dangerous area on the map.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 9L;
			ServerCurrentMapNote?.Dispose();
			ServerCurrentMapNote = MapNote.Deserialize(msg.read);
			DirtyPlayerState();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, ServerCurrentMapNote);
		}
	}

```

## OnDemoRecordingStop(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is stopped.
/// </summary>
/// <param name="filename">The name of the recording file that was stopped.</param>
/// <param name="player">The player who stopped the recording.</param>
/// <returns>
/// Returns `null` to allow the recording to stop normally, or any non-null value to prevent the stop action.
/// </returns>
object OnDemoRecordingStop(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped for player {player.displayName}. Filename: {filename}");
    if (filename.Contains("restricted"))
    {
        Puts($"Recording {filename} is restricted and cannot be stopped.");
        return "Recording cannot be stopped due to restrictions.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnDefaultItemsReceive(PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when default items are given to a player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory receiving the default items.</param>
/// <returns>No return behavior.</returns>
void OnDefaultItemsReceive(PlayerInventory inventory)
{
    Puts($"Default items are being given to player with inventory ID: {inventory.ID}.");
}
```
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		ulong skin = 0uL;
		int infoInt = base.baseEntity.GetInfoInt("client.rockskin", 0);
		if (infoInt > 0 && base.baseEntity.blueprints.steamInventory.HasItem(infoInt))
		{
			IPlayerItemDefinition itemDefinition = PlatformService.Instance.GetItemDefinition(infoInt);
			if (itemDefinition != null)
			{
				skin = itemDefinition.WorkshopDownload;
			}
		}
		GiveItem(ItemManager.CreateByName("rock", 1, skin), containerBelt);
		GiveItem(ItemManager.CreateByName("torch", 1, 0uL), containerBelt);
		if (IsBirthday())
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas())
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Determines whether a player can be wounded based on various conditions.
/// </summary>
/// <param name="player">The player being checked for wounding eligibility.</param>
/// <param name="hitInfo">Information about the hit that may cause wounding.</param>
/// <returns>
/// Returns `true` if the player can be wounded, `false` if they cannot, 
/// or `null` if the default game logic should be used to determine eligibility.
/// </returns>
bool? CanBeWounded(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Checking if player {player.displayName} (ID: {player.UserIDString}) can be wounded.");

    if (player.IsSleeping())
    {
        Puts($"Player {player.displayName} is sleeping and cannot be wounded.");
        return false;
    }

    if (player.isMounted)
    {
        Puts($"Player {player.displayName} is mounted and cannot be wounded.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastWoundedTime < 60f)
		{
			return false;
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing ground support.
/// </summary>
/// <param name="entity">The entity that is missing ground support.</param>
/// <returns>No return behavior.</returns>
void OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity.net.ID} is missing ground support and will be processed accordingly.");
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (baseEntity != null && Interface.CallHook("OnEntityGroundMissing", baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}

```

## CanNetworkTo(BaseEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player can network to this entity.
/// </summary>
/// <param name="entity">The entity that is being checked for networking.</param>
/// <param name="player">The player attempting to network to the entity.</param>
/// <returns>
/// Returns `true` if the player can network to the entity; otherwise, returns `false`.
/// If the method returns `null`, the default networking logic will be applied.
/// </returns>
bool? CanNetworkTo(BaseEntity entity, BasePlayer player)
{
    Puts($"Checking network access for Player {player.displayName} to Entity ID: {entity.net.ID}");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can network to any entity.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		if (player == this)
		{
			return true;
		}
		BaseEntity baseEntity = GetParentEntity();
		if (base.limitNetworking)
		{
			if (baseEntity == null)
			{
				return false;
			}
			if (baseEntity != player)
			{
				return false;
			}
		}
		if (baseEntity != null)
		{
			object obj = Interface.CallHook("CanNetworkTo", this, player);
			if (obj is bool)
			{
				return (bool)obj;
			}
			return baseEntity.ShouldNetworkTo(player);
		}
		return base.ShouldNetworkTo(player);
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an entity is successfully built in the game world.
/// </summary>
/// <param name="planner">The planner that initiated the build action.</param>
/// <param name="gameObject">The game object that was created as a result of the build action.</param>
/// <returns>No return behavior.</returns>
void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
{
    Puts($"Entity built: {gameObject.name} by planner: {planner.GetOwnerPlayer()?.displayName ?? "Unknown"}.");

    if (gameObject.CompareTag("Deployable"))
    {
        Puts($"A deployable entity has been built: {gameObject.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())
		{
			return;
		}
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ChatMessage("Target socket is not female. (" + target.socket.socketName + ")");
				return;
			}
			if (target.entity != null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ChatMessage("Target socket is occupied. (" + target.socket.socketName + ")");
				return;
			}
		}
		if (ConVar.AntiHack.eye_protection >= 2)
		{
			Vector3 center = ownerPlayer.eyes.center;
			Vector3 position = ownerPlayer.eyes.position;
			Vector3 origin = target.ray.origin;
			Vector3 p = ((target.entity != null && target.socket != null) ? target.GetWorldPosition() : target.position);
			if (target.entity != null)
			{
				DeployShell deployShell = PrefabAttribute.server.Find<DeployShell>(target.entity.prefabID);
				if (deployShell != null)
				{
					p += target.normal.normalized * deployShell.LineOfSightPadding();
				}
			}
			int num = 2097152;
			int num2 = (ConVar.AntiHack.build_terraincheck ? 10551296 : 2162688);
			if (!GamePhysics.LineOfSight(padding: (target.socket != null) ? 0.5f : 0.01f, layerMask: (target.socket != null) ? num : num2, p0: center, p1: position, p2: origin, p3: p))
			{
				ownerPlayer.ChatMessage("Line of sight blocked.");
				return;
			}
		}
		Construction.lastPlacementError = "No Error";
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			ownerPlayer.ChatMessage("Can't place: " + Construction.lastPlacementError);
		}
		if (!(gameObject != null))
		{
			return;
		}
		Interface.CallHook("OnEntityBuilt", this, gameObject);
		Deployable deployable = GetDeployable();
		if (deployable != null)
		{
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
			if (deployable.setSocketParent && target.entity != null && target.entity.SupportsChildDeployables() && (bool)baseEntity)
			{
				baseEntity.SetParent(target.entity, worldPositionStays: true);
			}
			if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
			{
				(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
			}
			if (deployable.copyInventoryFromItem)
			{
				StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
				if ((bool)component2)
				{
					component2.ReceiveInventoryFromItem(GetOwnerItem());
				}
			}
			ItemModDeployable modDeployable = GetModDeployable();
			if (modDeployable != null)
			{
				modDeployable.OnDeployed(baseEntity, ownerPlayer);
			}
			baseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer);
		}
		PayForPlacement(ownerPlayer, component);
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is assigned to a player from a resource dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser providing the bonus.</param>
/// <param name="player">The player receiving the bonus item.</param>
/// <param name="item">The item being given as a bonus.</param>
/// <returns>No return behavior.</returns>
void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Bonus item {item.info.displayName.english} given to player {player.displayName} from dispenser {dispenser.net.ID}.");
    
    if (item.info.shortname == "special.item")
    {
        Puts($"Player {player.displayName} received a special bonus item!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction)
	{
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnBookmarksSendControl(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when control bookmarks are sent to a player from a computer station.
/// </summary>
/// <param name="station">The computer station sending the bookmarks.</param>
/// <param name="player">The player receiving the bookmarks.</param>
/// <param name="bookmarks">The generated bookmarks string.</param>
/// <returns>No return behavior.</returns>
void OnBookmarksSendControl(ComputerStation station, BasePlayer player, string bookmarks)
{
    Puts($"Sending control bookmarks to player {player.displayName} from station {station.name}.");
    Puts($"Bookmarks content: {bookmarks}");
}
```
```

### Source Code from the Library

```csharp

	public void SendControlBookmarks(BasePlayer player)
	{
		if (!(player == null))
		{
			string text = GenerateControlBookmarkString();
			if (Interface.CallHook("OnBookmarksSendControl", this, player, text) == null)
			{
				ClientRPCPlayer(null, player, "ReceiveBookmarks", text);
			}
		}
	}

```

## OnWireClear(BasePlayer,IOEntity,int,IOEntity,bool)

```csharp
```csharp
/// <summary>
/// Called when a player clears a wire connection from an IOEntity.
/// </summary>
/// <param name="player">The player who is clearing the wire.</param>
/// <param name="entity">The IOEntity from which the wire is being cleared.</param>
/// <param name="slotIndex">The index of the input/output slot being cleared.</param>
/// <param name="connectedEntity">The IOEntity that is connected to the slot being cleared.</param>
/// <param name="isInput">Indicates whether the slot being cleared is an input (true) or an output (false).</param>
/// <returns>No return behavior.</returns>
void OnWireClear(BasePlayer player, IOEntity entity, int slotIndex, IOEntity connectedEntity, bool isInput)
{
    Puts($"Player {player.displayName} cleared a wire from {entity.name} (Slot: {slotIndex}, IsInput: {isInput}) to {connectedEntity?.name ?? "null"}.");
    
    if (isInput)
    {
        Puts($"Input wire cleared from {entity.name} to {connectedEntity.name}.");
    }
    else
    {
        Puts($"Output wire cleared from {entity.name} to {connectedEntity.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void RequestClear(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		uint uid = msg.read.UInt32();
		int num = msg.read.Int32();
		bool flag = msg.read.Bit();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		IOEntity iOEntity = ((baseNetworkable == null) ? null : baseNetworkable.GetComponent<IOEntity>());
		if (iOEntity == null || !CanModifyEntity(player, iOEntity) || num >= (flag ? iOEntity.inputs.Length : iOEntity.outputs.Length))
		{
			return;
		}
		IOEntity.IOSlot iOSlot = (flag ? iOEntity.inputs[num] : iOEntity.outputs[num]);
		if (iOSlot.connectedTo.Get() == null)
		{
			return;
		}
		IOEntity iOEntity2 = iOSlot.connectedTo.Get();
		if (Interface.CallHook("OnWireClear", msg.player, iOEntity, num, iOEntity2, flag) != null)
		{
			return;
		}
		IOEntity.IOSlot obj = (flag ? iOEntity2.outputs[iOSlot.connectedToSlot] : iOEntity2.inputs[iOSlot.connectedToSlot]);
		if (flag)
		{
			iOEntity.UpdateFromInput(0, num);
		}
		else if ((bool)iOEntity2)
		{
			iOEntity2.UpdateFromInput(0, iOSlot.connectedToSlot);
		}
		iOSlot.Clear();
		obj.Clear();
		iOEntity.MarkDirtyForceUpdateOutputs();
		iOEntity.SendNetworkUpdate();
		if (flag && iOEntity2 != null)
		{
			iOEntity2.SendChangedToRoot(forceUpdate: true);
		}
		else if (!flag)
		{
			IOEntity.IOSlot[] inputs = iOEntity.inputs;
			foreach (IOEntity.IOSlot iOSlot2 in inputs)
			{
				if (iOSlot2.mainPowerSlot && (bool)iOSlot2.connectedTo.Get())
				{
					iOSlot2.connectedTo.Get().SendChangedToRoot(forceUpdate: true);
				}
			}
		}
		iOEntity2.SendNetworkUpdate();
	}

```

## OnBroadcastCommand(string,object[])

```csharp
```csharp
/// <summary>
/// Called when a broadcast command is issued to all clients.
/// </summary>
/// <param name="command">The command being broadcasted.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>No return behavior.</returns>
void OnBroadcastCommand(string command, object[] args)
{
    Puts($"Broadcasting command: {command} with arguments: {string.Join(", ", args)}");
}
```
```

### Source Code from the Library

```csharp

	public static void BroadcastToAllClients(string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected())
		{
			Interface.CallHook("OnBroadcastCommand", strCommand, args);
			Network.Net.sv.write.Start();
			Network.Net.sv.write.PacketID(Message.Type.ConsoleCommand);
			Network.Net.sv.write.String(ConsoleSystem.BuildCommand(strCommand, args));
			Network.Net.sv.write.Send(new SendInfo(Network.Net.sv.connections));
		}
	}

```

## OnFindSpawnPoint()

```csharp
```csharp
/// <summary>
/// Called to find a suitable spawn point for a player.
/// </summary>
/// <returns>
/// Returns a <c>BasePlayer.SpawnPoint</c> object representing the chosen spawn point.
/// If a hook returns a non-null value, that value will be used as the spawn point.
/// </returns>
BasePlayer.SpawnPoint OnFindSpawnPoint()
{
    Puts("Searching for a suitable spawn point for the player.");
    return new BasePlayer.SpawnPoint(); // Placeholder for actual spawn point logic
}
```
```

### Source Code from the Library

```csharp

	public static BasePlayer.SpawnPoint FindSpawnPoint()
	{
		object obj = Interface.CallHook("OnFindSpawnPoint");
		if (obj is BasePlayer.SpawnPoint)
		{
			return (BasePlayer.SpawnPoint)obj;
		}
		bool flag = false;
		if (SingletonComponent<SpawnHandler>.Instance != null && !flag)
		{
			BasePlayer.SpawnPoint spawnPoint = SpawnHandler.GetSpawnPoint();
			if (spawnPoint != null)
			{
				return spawnPoint;
			}
		}
		BasePlayer.SpawnPoint spawnPoint2 = new BasePlayer.SpawnPoint();
		GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (array.Length != 0)
		{
			GameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];
			spawnPoint2.pos = gameObject.transform.position;
			spawnPoint2.rot = gameObject.transform.rotation;
		}
		else
		{
			UnityEngine.Debug.Log("Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
			if (MainCamera.mainCamera != null)
			{
				spawnPoint2.pos = MainCamera.position;
				spawnPoint2.rot = MainCamera.rotation;
			}
		}
		if (UnityEngine.Physics.Raycast(new Ray(spawnPoint2.pos, Vector3.down), out var hitInfo, 32f, 1537286401))
		{
			spawnPoint2.pos = hitInfo.point;
		}
		return spawnPoint2;
	}

```

## CanUnlock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a code lock.
/// </summary>
/// <param name="player">The player attempting to unlock the code lock.</param>
/// <param name="codeLock">The code lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the unlocking process, or any non-null value to prevent it.
/// </returns>
object CanUnlock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to unlock a code lock.");

    if (player.IsBannedFromUnlocking)
    {
        Puts($"Player {player.displayName} is banned from unlocking code locks.");
        return "You are not allowed to unlock this.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null)
		{
			if (whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectUnlocked.resourcePath);
				SetFlag(Flags.Locked, b: false);
				SendNetworkUpdate();
			}
			else
			{
				ClientRPCPlayer(null, rpc.player, "EnterUnlockCode");
			}
		}
	}

```

## OnTakeCurrencyItem(VendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called when a currency item is taken from the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the currency item is taken.</param>
/// <param name="takenCurrencyItem">The currency item that is being taken.</param>
/// <returns>No return behavior.</returns>
void OnTakeCurrencyItem(VendingMachine vendingMachine, Item takenCurrencyItem)
{
    Puts($"Currency item {takenCurrencyItem.info.displayName.english} taken from vending machine ID: {vendingMachine.net.ID}.");
    
    if (takenCurrencyItem.amount <= 0)
    {
        Puts("Attempted to take an empty currency item.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null && !takenCurrencyItem.MoveToContainer(base.inventory))
		{
			takenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);
		}
	}

```

## OnItemRefill(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is refilled by a player.
/// </summary>
/// <param name="item">The item that is being refilled.</param>
/// <param name="player">The player who is refilling the item.</param>
/// <returns>
/// Returns `null` to allow the refill to proceed, or any non-null value to prevent the refill action.
/// </returns>
object OnItemRefill(Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to refill item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.itemid == 12345) // Example item ID for a restricted item
    {
        Puts($"Player {player.displayName} is not allowed to refill this item.");
        return "Refill not allowed for this item.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", item, player) == null)
		{
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnHelicopterOutOfCrates(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if the helicopter has run out of crates to drop.
/// </summary>
/// <param name="helicopter">The helicopter AI controller checking for crate availability.</param>
/// <returns>
/// Returns `true` if the helicopter is out of crates, or `false` if it still has crates available.
/// If the method returns `null`, the default logic will be used to determine crate availability.
/// </returns>
bool? OnHelicopterOutOfCrates(CH47HelicopterAIController helicopter)
{
    Puts($"Checking crate availability for helicopter ID: {helicopter.net.ID}.");
    
    if (helicopter.numCrates <= 0)
    {
        Puts($"Helicopter ID: {helicopter.net.ID} is out of crates.");
        return true;
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

```

## OnNpcAlert(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when a Scientist NPC is alerted.
/// </summary>
/// <param name="npc">The Scientist NPC that is being alerted.</param>
/// <returns>No return behavior.</returns>
void OnNpcAlert(ScientistNPC npc)
{
    Puts($"NPC {npc.name} has been alerted at time {Time.time}.");
    // Additional alert handling logic can be added here.
}
```
```

### Source Code from the Library

```csharp

	public void Alert()
	{
		if (Interface.CallHook("OnNpcAlert", this) == null)
		{
			lastAlertedTime = Time.time;
			SetChatterType(RadioChatterType.Alert);
		}
	}

```

## OnPlayerWound(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is wounded by another player.
/// </summary>
/// <param name="woundedPlayer">The player who is wounded.</param>
/// <param name="attacker">The player who caused the wound.</param>
/// <returns>
/// Returns `null` to allow the wounding process to continue, or any non-null value to prevent it.
/// </returns>
object OnPlayerWound(BasePlayer woundedPlayer, BasePlayer attacker)
{
    Puts($"Player {woundedPlayer.displayName} has been wounded by {attacker?.displayName ?? "an unknown source"}.");
    
    if (woundedPlayer.health < 20)
    {
        Puts($"Player {woundedPlayer.displayName} is critically wounded and cannot be wounded further.");
        return true; // Prevent further wounding
    }
    
    return null; // Allow the wounding to proceed
}
```
```

### Source Code from the Library

```csharp

	public void StartWounded(BasePlayer source = null)
	{
		if (IsWounded() || Interface.CallHook("OnPlayerWound", this, source) != null)
		{
			return;
		}
		stats.Add("wounded", 1, (Stats)5);
		woundedDuration = UnityEngine.Random.Range(40f, 50f);
		woundedStartTime = UnityEngine.Time.realtimeSinceStartup;
		SetPlayerFlag(PlayerFlags.Wounded, b: true);
		EnableServerFall(wantsOn: true);
		SendNetworkUpdateImmediate();
		if (EACServer.playerTracker != null && net.connection != null && source != null && source.net.connection != null)
		{
			using (TimeWarning.New("playerTracker.LogPlayerDowned"))
			{
				EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
				EasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(source.net.connection);
				EACServer.playerTracker.LogPlayerDowned(client, client2);
			}
		}
		Invoke(WoundingTick, 1f);
	}

```

## OnEngineStatsRefresh(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called to refresh the performance statistics of the engine based on its storage.
/// </summary>
/// <param name="engine">The engine module whose stats are being refreshed.</param>
/// <param name="engineStorage">The storage containing the engine's performance data.</param>
/// <returns>No return behavior.</returns>
void OnEngineStatsRefresh(VehicleModuleEngine engine, Rust.Modular.EngineStorage engineStorage)
{
    Puts($"Refreshing engine stats for {engine.GetType().Name} with storage ID: {engineStorage?.GetInstanceID()}");

    if (engineStorage == null)
    {
        Puts("Engine storage is null, setting performance stats to zero.");
    }
    else
    {
        Puts($"Engine is usable: {engineStorage.isUsable}. Acceleration Boost: {engineStorage.accelerationBoostPercent}%, " +
             $"Top Speed Boost: {engineStorage.topSpeedBoostPercent}%, Fuel Economy Boost: {engineStorage.fuelEconomyBoostPercent}%.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## CanSwapToSeat(BasePlayer,ModularCarSeat)

```csharp
```csharp
/// <summary>
/// Determines whether a player can swap to a specific seat in a modular car.
/// </summary>
/// <param name="player">The player attempting to swap seats.</param>
/// <param name="seat">The seat the player is trying to swap to.</param>
/// <returns>
/// Returns `true` if the player can swap to the seat, `false` if they cannot, 
/// or `null` if the default game logic should be used to determine the outcome.
/// </returns>
bool? CanSwapToSeat(BasePlayer player, ModularCarSeat seat)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to swap to seat: {seat.seatName}.");

    if (seat.associatedSeatingModule.DoorsAreLockable)
    {
        Puts($"Checking if player can open the door for seat: {seat.seatName}.");
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (associatedSeatingModule.DoorsAreLockable)
		{
			ModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;
			if (modularCar != null)
			{
				return modularCar.PlayerCanOpenThis(player, ModularCarLock.LockType.Door);
			}
		}
		return true;
	}

```

## OnVehicleModuleSelected(Item,ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is selected by a player.
/// </summary>
/// <param name="item">The vehicle item that represents the selected module.</param>
/// <param name="garage">The modular car garage that contains the vehicle.</param>
/// <param name="player">The player who selected the vehicle module.</param>
/// <returns>
/// Returns a non-null value to prevent the selection action, or `null` to allow it.
/// </returns>
object OnVehicleModuleSelected(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.displayName} selected module: {item.info.displayName.english} from garage: {garage.net.ID}.");

    if (item.info.shortname == "engine")
    {
        Puts($"Player {player.displayName} cannot select the engine module.");
        return "You cannot select the engine module.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		uint itemUID = msg.read.UInt32();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result) && result is VehicleModuleStorage vehicleModuleStorage)
		{
			IItemContainerEntity container = vehicleModuleStorage.GetContainer();
			if (!ObjectEx.IsUnityNull(container))
			{
				player.inventory.loot.AddContainer(container.inventory);
				flag = true;
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## OnPlayerReported(BasePlayer,string,string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player reports another player.
/// </summary>
/// <param name="reporter">The player who is making the report.</param>
/// <param name="reportMessage">The message detailing the report.</param>
/// <param name="reportType">The type of report being made.</param>
/// <param name="targetId">The ID of the player being reported.</param>
/// <param name="targetName">The name of the player being reported.</param>
/// <param name="additionalInfo">Any additional information related to the report.</param>
/// <returns>No return behavior.</returns>
void OnPlayerReported(BasePlayer reporter, string reportMessage, string reportType, string targetId, string targetName, string additionalInfo)
{
    Puts($"Player {reporter.displayName} reported {targetName} (ID: {targetId}) with message: \"{reportMessage}\" and type: {reportType}.");
    
    if (reportType == "cheating")
    {
        Puts($"Alert: {targetName} has been reported for cheating!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnPlayerReported(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		string text3 = msg.read.String();
		string text4 = msg.read.String();
		string text5 = msg.read.String();
		DebugEx.Log($"[PlayerReport] {this} reported {text5}[{text4}] - \"{text}\"");
		RCon.Broadcast(RCon.LogType.Report, new
		{
			PlayerId = UserIDString,
			PlayerName = displayName,
			TargetId = text4,
			TargetName = text5,
			Subject = text,
			Message = text2,
			Type = text3
		});
		Interface.CallHook("OnPlayerReported", this, text5, text4, text, text2, text3);
	}

```

## IOnUpdateServerDescription()

```csharp
```csharp
/// <summary>
/// Called to update the server's description in the Steam server list.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnUpdateServerDescription()
{
    Puts("Updating server description for the Steam server list.");
    // Additional logic can be added here if needed for handling the update.
}
```
```

### Source Code from the Library

```csharp

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		using (TimeWarning.New("UpdateServerInformation"))
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.Name;
			string text = "stok";
			if (Restarting)
			{
				text = "strst";
			}
			string text2 = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text3 = $"gm{GamemodeName()}";
			string text4 = (ConVar.Server.pve ? ",pve" : string.Empty);
			SteamServer.GameTags = $"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},v{2271}{text4},h{AssemblyHash},{text},{text2},{text3}";
			Interface.CallHook("IOnUpdateServerInformation");
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = ConVar.Server.description.SplitToChunks(100).ToArray();
				Interface.CallHook("IOnUpdateServerDescription");
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			SteamServer.SetKey("world.seed", World.Seed.ToString());
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("logoimage", ConVar.Server.logoimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("gmd", GamemodeDesc());
			SteamServer.SetKey("gmu", GamemodeUrl());
			SteamServer.SetKey("uptime", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
	}

```

## CanAdministerVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Determines whether a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine in question.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine the player's permissions.
/// </returns>
bool? CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Checking administration rights for player {player.displayName} on vending machine {vendingMachine.net.ID}.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can administer the vending machine.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

```

## OnCreateWorldProjectile(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="info">The hit information related to the projectile's creation.</param>
/// <param name="item">The item associated with the projectile.</param>
/// <returns>No return behavior.</returns>
void OnCreateWorldProjectile(HitInfo info, Item item)
{
    Puts($"Creating world projectile at position: {info.HitPositionWorld} with item: {item.info.displayName.english}.");

    if (item.info.shortname == "rocket.launcher")
    {
        Puts("Warning: A rocket launcher projectile is being created!");
    }
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			return;
		}
		baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		component.AddForce(projectileVelocity.normalized * 200f);
		component.WakeUp();
	}

```

## OnItemResearched(ResearchTable,int)

```csharp
```csharp
/// <summary>
/// Called when an item has been successfully researched at a research table.
/// </summary>
/// <param name="researchTable">The research table where the item was researched.</param>
/// <param name="scrapUsed">The amount of scrap used for the research.</param>
/// <returns>No return behavior.</returns>
void OnItemResearched(ResearchTable researchTable, int scrapUsed)
{
    Puts($"Item researched at {researchTable.name} using {scrapUsed} scrap.");
    
    if (scrapUsed > 100)
    {
        Puts("Researching this item is too expensive!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", this, num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount <= num)
				{
					base.inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				base.inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
				item.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);
				if (!item.MoveToContainer(base.inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## OnNpcTarget(BaseEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC that is targeting the player.</param>
/// <param name="player">The player being targeted by the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC to continue targeting the player, or any non-null value to prevent the targeting.
/// </returns>
object OnNpcTarget(BaseEntity npc, BasePlayer player)
{
    Puts($"NPC {npc.net.ID} is attempting to target player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInvisible())
    {
        Puts($"Targeting blocked: Player {player.displayName} is invisible.");
        return "Targeting blocked: Player is invisible.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RememberEnemyPlayer(IHTNAgent npc, ref NpcPlayerInfo info, float time, float uncertainty = 0f, string debugStr = "ENEMY!")
	{
		if (info.Player == null || info.Player.transform == null || info.Player.IsDestroyed || info.Player.IsDead() || info.Player.IsWounded() || Interface.CallHook("OnNpcTarget", npc.Body, info.Player) != null)
		{
			return;
		}
		if (Mathf.Approximately(info.SqrDistance, 0f))
		{
			info.SqrDistance = (npc.BodyPosition - info.Player.transform.position).sqrMagnitude;
		}
		for (int i = 0; i < KnownEnemyPlayers.Count; i++)
		{
			EnemyPlayerInfo enemyPlayerInfo = KnownEnemyPlayers[i];
			if (enemyPlayerInfo.PlayerInfo.Player == info.Player)
			{
				enemyPlayerInfo.PlayerInfo = info;
				if (uncertainty < 0.05f)
				{
					enemyPlayerInfo.LastKnownLocalPosition = info.Player.transform.localPosition;
					enemyPlayerInfo.LastKnownLocalHeading = info.Player.GetLocalVelocity().normalized;
					enemyPlayerInfo.OurLastLocalPositionWhenLastSeen = npc.transform.localPosition;
					enemyPlayerInfo.BodyVisibleWhenLastNoticed = info.BodyVisible;
					enemyPlayerInfo.HeadVisibleWhenLastNoticed = info.HeadVisible;
				}
				else
				{
					Vector2 vector = UnityEngine.Random.insideUnitCircle * uncertainty;
					enemyPlayerInfo.LastKnownLocalPosition = info.Player.transform.localPosition + new Vector3(vector.x, 0f, vector.y);
					enemyPlayerInfo.LastKnownLocalHeading = (enemyPlayerInfo.LastKnownPosition - NpcContext.BodyPosition).normalized;
					enemyPlayerInfo.BodyVisibleWhenLastNoticed = info.BodyVisible;
					enemyPlayerInfo.HeadVisibleWhenLastNoticed = info.HeadVisible;
				}
				enemyPlayerInfo.Time = time;
				KnownEnemyPlayers[i] = enemyPlayerInfo;
				if (PrimaryKnownEnemyPlayer.PlayerInfo.Player == info.Player)
				{
					PrimaryKnownEnemyPlayer = enemyPlayerInfo;
				}
				return;
			}
		}
		KnownEnemyPlayers.Add(new EnemyPlayerInfo
		{
			PlayerInfo = info,
			LastKnownLocalPosition = info.Player.transform.localPosition,
			Time = time
		});
	}

```

## IOnPlayerChat(ulong,string,string,ConVar.Chat.ChatChannel,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="userId">The unique identifier of the user sending the message.</param>
/// <param name="username">The username of the player sending the message.</param>
/// <param name="message">The content of the chat message.</param>
/// <param name="targetChannel">The channel to which the message is being sent.</param>
/// <param name="player">The player instance of the user sending the message, if available.</param>
/// <returns>
/// Returns `true` if the message is successfully processed, or `false` if it is blocked or invalid.
/// </returns>
bool IOnPlayerChat(ulong userId, string username, string message, ConVar.Chat.ChatChannel targetChannel, BasePlayer player)
{
    Puts($"Player {username} (ID: {userId}) sent a message in channel {targetChannel}: {message}");

    if (message.Contains("badword"))
    {
        Puts($"Message from {username} contains prohibited content.");
        return false;
    }

    return true;
}
```
```

### Source Code from the Library

```csharp

	internal static bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)
	{
		if (!player)
		{
			player = null;
		}
		if (!enabled)
		{
			return false;
		}
		if (player != null && player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return false;
		}
		ServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;
		if (userGroup == ServerUsers.UserGroup.Banned)
		{
			return false;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0)
		{
			return false;
		}
		if (text.StartsWith("/") || text.StartsWith("\\"))
		{
			Interface.CallHook("IOnPlayerCommand", player, message);
			return false;
		}
		text = text.EscapeRichText();
		object obj = Interface.CallHook("IOnPlayerChat", userId, username, text, targetChannel, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured(ConsoleColor.DarkYellow, string.Concat("[", targetChannel, "] ", username, ": "), ConsoleColor.DarkGreen, text);
			string text2 = player?.ToString() ?? $"{username}[{userId}]";
			if (targetChannel == ChatChannel.Team)
			{
				DebugEx.Log("[TEAM CHAT] " + text2 + " : " + text);
			}
			else
			{
				DebugEx.Log("[CHAT] " + text2 + " : " + text);
			}
		}
		bool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;
		bool num = ((player != null) ? player.IsDeveloper : DeveloperList.Contains(userId));
		string text3 = "#5af";
		if (flag)
		{
			text3 = "#af5";
		}
		if (num)
		{
			text3 = "#fa5";
		}
		string text4 = username.EscapeRichText();
		ChatEntry chatEntry = default(ChatEntry);
		chatEntry.Channel = targetChannel;
		chatEntry.Message = text;
		chatEntry.UserId = ((player != null) ? player.UserIDString : userId.ToString());
		chatEntry.Username = username;
		chatEntry.Color = text3;
		chatEntry.Time = Epoch.Current;
		ChatEntry chatEntry2 = chatEntry;
		History.Add(chatEntry2);
		RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		switch (targetChannel)
		{
		case ChatChannel.Global:
			if (Server.globalchat)
			{
				ConsoleNetwork.BroadcastToAllClients("chat.add2", 0, userId, text, text4, text3, 1f);
				return true;
			}
			break;
		case ChatChannel.Team:
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.Instance.FindPlayersTeam(userId);
			if (playerTeam == null)
			{
				return false;
			}
			List<Network.Connection> onlineMemberConnections = playerTeam.GetOnlineMemberConnections();
			if (onlineMemberConnections != null)
			{
				ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add2", 1, userId, text, text4, text3, 1f);
			}
			playerTeam.BroadcastTeamChat(userId, text4, text, text3);
			return true;
		}
		}
		if (player != null)
		{
			float num2 = 2500f;
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				float sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;
				if (!(sqrMagnitude > num2))
				{
					ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", 0, userId, text, text4, text3, Mathf.Clamp01(num2 - sqrMagnitude + 0.2f));
				}
			}
			return true;
		}
		return false;
	}

```

## OnRemoveDying(GrowableEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a dying growable entity is removed.
/// </summary>
/// <param name="receiver">The player who is receiving the item from the dying entity.</param>
/// <param name="entity">The growable entity that is being removed.</param>
/// <returns>No return behavior.</returns>
void OnRemoveDying(GrowableEntity entity, BasePlayer receiver)
{
    Puts($"Removing dying entity: {entity.name} for player: {receiver?.displayName ?? "world"}.");
    
    if (receiver == null)
    {
        Puts("No player to receive the item, dropping it in the world.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RemoveDying(BasePlayer receiver)
	{
		if (State == PlantProperties.State.Dying && !(Properties.removeDyingItem == null) && Interface.CallHook("OnRemoveDying", this, receiver) == null)
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, Vector3.up);
			}
			Item item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);
			if (receiver != null)
			{
				receiver.GiveItem(item, GiveItemReason.PickedUp);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
			}
			Die();
		}
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player performs an attack.
/// </summary>
/// <param name="player">The player who is attacking.</param>
/// <param name="hitInfo">Information about the attack, including the target and damage details.</param>
/// <returns>
/// Returns a non-null value to prevent the default attack behavior. 
/// If `null` is returned, the attack proceeds as normal.
/// </returns>
object OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attacking with weapon: {hitInfo.Weapon?.info.shortname ?? "unknown"}.");

    if (hitInfo.HitEntity is BasePlayer targetPlayer && targetPlayer.IsInSafeZone())
    {
        Puts($"Attack on {targetPlayer.displayName} is blocked because they are in a safe zone.");
        return "Cannot attack players in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", GetOwnerPlayer(), info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (info.DoHitEffects)
		{
			if (base.isServer)
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.server.ImpactEffect(info);
				}
			}
			else
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.client.ImpactEffect(info);
				}
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay);
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to access the locked entity.</param>
/// <param name="codeLock">The code lock associated with the entity.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, `false` if they cannot, 
/// or `null` to allow the default logic to determine access.
/// </returns>
bool? CanUseLockedEntity(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is trying to access a locked entity with CodeLock.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can access locked entities.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player finishes looting.
/// </summary>
/// <param name="loot">The loot object associated with the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot loot)
{
    Puts($"Player {loot.Owner.displayName} has finished looting.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		containers.Clear();
		entitySource = null;
		itemSource = null;
	}

```

## OnEntitySnapshot(BaseNetworkable,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when an entity snapshot is sent to a network connection.
/// </summary>
/// <param name="entity">The entity being sent in the snapshot.</param>
/// <param name="connection">The network connection to which the snapshot is being sent.</param>
/// <returns>
/// Returns a non-null value to prevent the snapshot from being sent. 
/// If `null` is returned, the snapshot will be sent as normal.
/// </returns>
object OnEntitySnapshot(BaseNetworkable entity, Network.Connection connection)
{
    Puts($"Sending snapshot for entity ID: {entity.net.ID} to connection ID: {connection.userid}.");
    
    if (entity is BasePlayer player && player.IsInvisible())
    {
        Puts($"Entity {entity.net.ID} is invisible and cannot be sent.");
        return true; // Prevent sending the snapshot
    }
    
    return null; // Allow sending the snapshot
}
```
```

### Source Code from the Library

```csharp

	public void SendEntitySnapshot(BaseNetworkable ent)
	{
		if (Interface.CallHook("OnEntitySnapshot", ent, net.connection) != null)
		{
			return;
		}
		using (TimeWarning.New("SendEntitySnapshot"))
		{
			if (!(ent == null) && ent.net != null && ent.ShouldNetworkTo(this) && Network.Net.sv.write.Start())
			{
				net.connection.validate.entityUpdates++;
				SaveInfo saveInfo = default(SaveInfo);
				saveInfo.forConnection = net.connection;
				saveInfo.forDisk = false;
				SaveInfo saveInfo2 = saveInfo;
				Network.Net.sv.write.PacketID(Message.Type.Entities);
				Network.Net.sv.write.UInt32(net.connection.validate.entityUpdates);
				ent.ToStreamForNetwork(Network.Net.sv.write, saveInfo2);
				Network.Net.sv.write.Send(new SendInfo(net.connection));
			}
		}
	}

```

## OnPlayerKeepAlive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a keep-alive message while wounded.
/// </summary>
/// <param name="woundedPlayer">The player who is currently wounded.</param>
/// <param name="interactingPlayer">The player sending the keep-alive message.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKeepAlive(BasePlayer woundedPlayer, BasePlayer interactingPlayer)
{
    Puts($"Player {interactingPlayer.displayName} sent a keep-alive for wounded player {woundedPlayer.displayName}.");
    
    if (woundedPlayer.IsWounded())
    {
        Puts($"Wounded player {woundedPlayer.displayName} is being kept alive by {interactingPlayer.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_KeepAlive(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerKeepAlive", this, msg.player) == null)
		{
			ProlongWounding(10f);
		}
	}

```

## OnEntityControl(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if the player can control the specified entity.
/// </summary>
/// <param name="turret">The auto turret that is being controlled.</param>
/// <returns>
/// Returns `true` if the player can control the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine control permissions.
/// </returns>
bool OnEntityControl(AutoTurret turret)
{
    Puts($"Attempting to control AutoTurret ID: {turret.net.ID}, OwnerID: {turret.OwnerID}");

    // Example condition to restrict control
    if (turret.IsUnderAttack())
    {
        Puts("Control denied: AutoTurret is currently under attack.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl()
	{
		object obj = Interface.CallHook("OnEntityControl", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnBigWheelWin(BigWheelGame,Item,BigWheelBettingTerminal,int)

```csharp
```csharp
/// <summary>
/// Called when a player wins on the Big Wheel game.
/// </summary>
/// <param name="game">The Big Wheel game instance.</param>
/// <param name="item">The item associated with the win.</param>
/// <param name="terminal">The betting terminal where the win occurred.</param>
/// <param name="multiplier">The multiplier applied to the win.</param>
/// <returns>
/// Returns a non-null value to override the default win behavior. 
/// If a string is returned, it indicates a message or reason for not processing the win.
/// If `null` is returned, the win is processed normally.
/// </returns>
object OnBigWheelWin(BigWheelGame game, Item item, BigWheelBettingTerminal terminal, int multiplier)
{
    Puts($"Big Wheel win detected! Item: {item.info.displayName.english}, Multiplier: {multiplier}, Terminal: {terminal.net.ID}");

    if (item.info.shortname == "special.item")
    {
        Puts("Special item won! Processing special win logic.");
        return "Special win processing initiated.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) != null)
				{
					return;
				}
				slot.amount += slot.amount * num;
				slot.RemoveFromContainer();
				slot.MoveToContainer(terminal.inventory, 5);
				flag = true;
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) != null)
				{
					return;
				}
				if (slot2 != null)
				{
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(null, "WinOrLoseSound", flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanEntityBeHostile(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player entity can be considered hostile.
/// </summary>
/// <param name="player">The player entity to check for hostility.</param>
/// <returns>
/// Returns `true` if the entity can be hostile; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine hostility.
/// </returns>
bool? CanEntityBeHostile(BasePlayer player)
{
    Puts($"Checking hostility for player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot be hostile.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return State.unHostileTimestamp > TimeEx.currentTimestamp;
	}

```

## CanAdministerVending(BasePlayer,NPCVendingMachine)

```csharp
```csharp
/// <summary>
/// Determines whether a player can administer the specified vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine in question.</param>
/// <returns>
/// Returns `true` if the player is allowed to administer the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine the player's permissions.
/// </returns>
bool? CanAdministerVending(BasePlayer player, NPCVendingMachine vendingMachine)
{
    Puts($"Checking administration rights for player {player.displayName} on vending machine {vendingMachine.net.ID}.");
    
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can administer the vending machine.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnHelicopterStrafeEnter(PatrolHelicopterAI,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when the helicopter enters a strafing state.
/// </summary>
/// <param name="helicopter">The helicopter AI that is entering the strafe state.</param>
/// <param name="strafePosition">The target position for the strafe action.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterStrafeEnter(PatrolHelicopterAI helicopter, Vector3 strafePosition)
{
    Puts($"Helicopter {helicopter.GetInstanceID()} is entering strafe mode at position {strafePosition}.");
    
    if (helicopter.CanUseNapalm())
    {
        Puts($"Helicopter {helicopter.GetInstanceID()} is ready to use napalm.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm = false)
	{
		if (Interface.CallHook("OnHelicopterStrafeEnter", this, strafePos) == null)
		{
			if (CanUseNapalm() && shouldUseNapalm)
			{
				useNapalm = shouldUseNapalm;
				lastNapalmTime = UnityEngine.Time.realtimeSinceStartup;
			}
			lastStrafeTime = UnityEngine.Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			int mask = LayerMask.GetMask("Terrain", "World", "Construction", "Water");
			if (TransformUtil.GetGroundInfo(strafePos, out var pos, out var _, 100f, mask, base.transform))
			{
				strafe_target_position = pos;
			}
			else
			{
				strafe_target_position = strafePos;
			}
			numRocketsLeft = 12;
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafePos, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret acquires a new target.
/// </summary>
/// <param name="turret">The helicopter turret that is acquiring the target.</param>
/// <param name="target">The new target that the turret is aiming at.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts($"Helicopter turret {turret.net.ID} has acquired a new target: {target?.net.ID ?? 0}.");
    
    if (target is Player player)
    {
        Puts($"Target is a player: {player.displayName} (ID: {player.UserIDString}).");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine if a world projectile can be created based on the hit information and item definition.
/// </summary>
/// <param name="info">The hit information related to the projectile creation.</param>
/// <param name="itemDef">The item definition of the projectile being created.</param>
/// <returns>
/// Returns `null` to allow the projectile to be created, or any non-null value to prevent its creation.
/// </returns>
object CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
{
    Puts($"Attempting to create a world projectile with item: {itemDef.displayName.english} at position: {info.HitPositionWorld}.");

    if (itemDef.shortname == "rocket.launcher")
    {
        Puts("Rocket launchers cannot create projectiles in this context.");
        return true; // Prevent creation
    }

    return null; // Allow creation
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, UnityEngine.Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			return;
		}
		baseEntity = item.CreateWorldObject(info.HitPositionWorld, UnityEngine.Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		component.AddForce(projectileVelocity.normalized * 200f);
		component.WakeUp();
	}

```

## OnCorpsePopulate(HTNPlayer,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called to populate the corpse of an NPC player with loot or other items.
/// </summary>
/// <param name="target">The HTN player whose corpse is being populated.</param>
/// <param name="corpse">The NPC player corpse that is being created.</param>
/// <returns>
/// Returns a <c>BaseCorpse</c> object if the corpse is successfully populated with loot; otherwise, returns <c>null</c>.
/// </returns>
BaseCorpse OnCorpsePopulate(HTNPlayer target, NPCPlayerCorpse corpse)
{
    Puts($"Populating corpse for player {target.displayName} (SteamID: {target.userID}).");

    if (target.inventory.containerMain.itemList.Count == 0)
    {
        Puts("No items to populate in the corpse.");
        return null;
    }

    // Example of adding a specific item to the corpse
    if (target.inventory.containerMain.GetAmount("bandage") > 0)
    {
        corpse.containers[0].AddItem("bandage", 1);
        Puts("Added a bandage to the corpse.");
    }

    return corpse;
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse OnCreateCorpse(HTNPlayer target)
	{
		if (DeathEffect.isValid)
		{
			Effect.server.Run(DeathEffect.resourcePath, target, 0u, Vector3.zero, Vector3.zero);
		}
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = target.DropCorpse("assets/prefabs/npc/scientist/scientist_corpse.prefab") as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				if (target.AiDomain != null && target.AiDomain.NavAgent != null && target.AiDomain.NavAgent.isOnNavMesh)
				{
					nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * target.AiDomain.NavAgent.baseOffset;
				}
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(BaseEntity.Flags.Reserved5, target.HasPlayerFlag(BasePlayer.PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(BaseEntity.Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(target.inventory.containerMain, target.inventory.containerWear, target.inventory.containerBelt);
				nPCPlayerCorpse.playerName = target.displayName;
				nPCPlayerCorpse.playerSteamID = target.userID;
				nPCPlayerCorpse.Spawn();
				nPCPlayerCorpse.TakeChildren(target);
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
				if (Loot.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", target, nPCPlayerCorpse);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] loot = Loot;
					for (int i = 0; i < loot.Length; i++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = loot[i];
						for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnEntityVisibilityCheck(BaseEntity,BasePlayer,uint,string,float)

```csharp
```csharp
/// <summary>
/// Called to check if a player can see a specific entity within a given distance.
/// </summary>
/// <param name="entityId">The unique identifier of the entity being checked.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <param name="entity">The entity to check visibility for.</param>
/// <param name="player">The player attempting to see the entity.</param>
/// <param name="maximumDistance">The maximum distance within which the entity can be seen.</param>
/// <returns>
/// Returns `true` if the player can see the entity, `false` if they cannot, 
/// or `null` to allow the default visibility logic to determine the result.
/// </returns>
bool? OnEntityVisibilityCheck(uint entityId, string debugName, BaseEntity entity, BasePlayer player, float maximumDistance)
{
    Puts($"Checking visibility for Entity ID: {entityId}, Debug Name: {debugName}, Player: {player.displayName}");

    if (entity == null || player == null)
    {
        Puts("Entity or player is null, visibility check failed.");
        return false;
    }

    return null; // Allow default logic to determine visibility
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityVisibilityCheck", ent, player, id, debugName, maximumDistance);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 2162688))
				{
					if (!ent.IsVisible(player.eyes.HeadRay(), maximumDistance))
					{
						return ent.IsVisible(player.eyes.position, maximumDistance);
					}
					return true;
				}
				return false;
			}

```

## OnPlayerKicked(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="player">The player who has been kicked.</param>
/// <param name="reason">The reason for the kick.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has been kicked from the server. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void Kick(string reason)
	{
		if (IsConnected)
		{
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason);
		}
	}

```

## OnExperimentStart(Workbench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an experiment starts at a workbench.
/// </summary>
/// <param name="workbench">The workbench where the experiment is taking place.</param>
/// <param name="player">The player initiating the experiment.</param>
/// <returns>
/// Returns a non-null value to prevent the experiment from starting, or `null` to allow it to proceed.
/// </returns>
object OnExperimentStart(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment started at workbench by player {player.displayName} (ID: {player.UserIDString}).");

    if (player.inventory.GetAmount("experiment_item") < 1)
    {
        Puts($"Player {player.displayName} does not have the required items to start the experiment.");
        return "You need at least one experiment item to start.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !playerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## CanBuild(Planner,Construction,Construction.Target)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can build a specified construction at a target location.
/// </summary>
/// <param name="planner">The planner attempting to build the construction.</param>
/// <param name="construction">The construction being placed.</param>
/// <param name="target">The target location and context for the construction.</param>
/// <returns>
/// Returns `true` if the player can build the construction at the target location; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the construction can be placed.
/// </returns>
bool? CanBuild(Planner planner, Construction construction, Construction.Target target)
{
    Puts($"Player {target.player.displayName} is attempting to build {construction.fullName} at position {target.position}.");

    if (construction.fullName == "foundation.stone")
    {
        Puts($"Player {target.player.displayName} is not allowed to build a stone foundation here.");
        return false;
    }

    if (target.onTerrain)
    {
        Puts($"Building on terrain is allowed for {construction.fullName}.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ChatMessage("Couldn't find Construction " + msg.blockID);
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			ownerPlayer.ChatMessage("Can't afford to place!");
			return;
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ChatMessage("Building is blocked!");
			return;
		}
		Deployable deployable = GetDeployable();
		if (construction.deployable != deployable)
		{
			ownerPlayer.ChatMessage("Deployable mismatch!");
			AntiHack.NoteAdminHack(ownerPlayer);
			return;
		}
		Construction.Target target = default(Construction.Target);
		BaseEntity baseEntity = null;
		if (msg.entity != 0)
		{
			baseEntity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if (!baseEntity)
			{
				ownerPlayer.ChatMessage("Couldn't find entity " + msg.entity);
				return;
			}
			msg.position = baseEntity.transform.TransformPoint(msg.position);
			msg.normal = baseEntity.transform.TransformDirection(msg.normal);
			msg.rotation = baseEntity.transform.rotation * msg.rotation;
			if (msg.socket == 0)
			{
				if ((bool)deployable && deployable.setSocketParent && baseEntity.Distance(msg.position) > 1f)
				{
					ownerPlayer.ChatMessage("Parent too far away: " + baseEntity.Distance(msg.position));
					return;
				}
				if (baseEntity is Door)
				{
					ownerPlayer.ChatMessage("Can't deploy on door");
					return;
				}
			}
			target.entity = baseEntity;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != "" && target.entity != null)
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				else
				{
					ownerPlayer.ChatMessage("Invalid Socket!");
				}
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.valid = true;
		if (Interface.CallHook("CanBuild", this, construction, target) != null)
		{
			return;
		}
		if ((bool)deployable && deployable.placeEffect.isValid)
		{
			if ((bool)baseEntity && msg.socket != 0)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.TransformPoint(target.socket.worldPosition), baseEntity.transform.up);
			}
			else
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, msg.position, msg.normal);
			}
		}
		DoBuild(target, construction);
	}

```

## OnTeamDisband(RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team is disbanded.
/// </summary>
/// <param name="team">The team that is being disbanded.</param>
/// <returns>
/// Returns `null` to allow the team to be disbanded, or any non-null value to prevent the disbanding.
/// </returns>
object OnTeamDisband(RelationshipManager.PlayerTeam team)
{
    Puts($"Team with ID {team.teamID} is being disbanded. Members: {string.Join(", ", team.members)}");

    if (team.members.Count < 2)
    {
        Puts($"Team {team.teamID} cannot be disbanded as it has less than 2 members.");
        return "Cannot disband a team with less than 2 members.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Pool.Free(ref teamToDisband);
		}
	}

```

## IOnNpcSenseVision(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses players within its vision range.
/// </summary>
/// <param name="npc">The NPC that is sensing its surroundings.</param>
/// <returns>
/// Returns a non-null value to override the default vision sensing behavior. 
/// If `null` is returned, the NPC will proceed to check for players in its vision range.
/// </returns>
object IOnNpcSenseVision(NPCPlayerApex npc)
{
    Puts($"NPC {npc.displayName} is checking for players in vision range.");
    
    // Example condition to prevent NPC from sensing players
    if (npc.IsInStealthMode)
    {
        Puts($"NPC {npc.displayName} is in stealth mode and cannot sense players.");
        return true; // Prevents further processing
    }

    return null; // Allow default behavior
}
```
```

### Source Code from the Library

```csharp

	private void _FindPlayersInVisionRange()
	{
		if (AI.ignoreplayers || base.transform == null || Interface.CallHook("IOnNpcSenseVision", this) != null)
		{
			return;
		}
		PlayerQueryResultCount = Query.Server.GetPlayersInSphere(base.transform.position, Stats.VisionRange, PlayerQueryResults, delegate(BasePlayer player)
		{
			if (player == null || !player.isServer || player.IsDead())
			{
				return false;
			}
			if (player.IsSleeping() && player.secondsSleeping < NPCAutoTurret.sleeperhostiledelay)
			{
				return false;
			}
			float num = Stats.VisionRange * Stats.VisionRange;
			return !((player.ServerPosition - ServerPosition).sqrMagnitude > num);
		});
	}

```

## OnEntityDismounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player dismounts from an entity.
/// </summary>
/// <param name="entity">The entity from which the player is dismounting.</param>
/// <param name="player">The player who is dismounting.</param>
/// <returns>No return behavior.</returns>
void OnEntityDismounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.displayName} has dismounted from {entity.gameObject.name}.");
    
    if (player.IsDead())
    {
        Puts($"Player {player.displayName} was dead when dismounting.");
    }
    else
    {
        Puts($"Player {player.displayName} dismounted successfully.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			_mounted.DismountObject();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			SetFlag(Flags.Busy, b: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
		}
		else
		{
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPCPlayer(null, player, "ForcePositionToParentOffset", baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				Interface.CallHook("OnEntityDismounted", this, player);
				player.ClientRPCPlayer(null, player, "ForcePositionTo", res);
			}
			OnPlayerDismounted(player);
		}
	}

```

## OnActiveItemChanged(BasePlayer,Item,Item)

```csharp
```csharp
/// <summary>
/// Called when a player's active item changes.
/// </summary>
/// <param name="player">The player whose active item has changed.</param>
/// <param name="previousItem">The item that was previously active.</param>
/// <param name="newItem">The item that is now active.</param>
/// <returns>No return behavior.</returns>
void OnActiveItemChanged(BasePlayer player, Item previousItem, Item newItem)
{
    Puts($"Player {player.displayName} changed active item from {previousItem?.info.displayName.english ?? "none"} " +
         $"to {newItem?.info.displayName.english ?? "none"}.");
    
    if (newItem != null && newItem.info.shortname == "rocket.launcher")
    {
        Puts($"Warning: Player {player.displayName} has equipped a rocket launcher!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(uint itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = 0u;
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = 0u;
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = 0u;
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnSendCommand(System.Collections.Generic.List<Network.Connection>,string,object[])

```csharp
```csharp
/// <summary>
/// Called when a command is sent to one or more clients.
/// </summary>
/// <param name="connections">The list of connections to which the command is being sent.</param>
/// <param name="command">The command string to be executed on the client side.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>No return behavior.</returns>
void OnSendCommand(List<Network.Connection> connections, string command, object[] args)
{
    Puts($"Sending command '{command}' to {connections.Count} clients.");
    foreach (var connection in connections)
    {
        Puts($"Command '{command}' sent to client with ID: {connection.userid}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(List<Connection> cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected())
		{
			Interface.CallHook("OnSendCommand", cn, strCommand, args);
			Network.Net.sv.write.Start();
			Network.Net.sv.write.PacketID(Message.Type.ConsoleCommand);
			Network.Net.sv.write.String(ConsoleSystem.BuildCommand(strCommand, args));
			Network.Net.sv.write.Send(new SendInfo(cn));
		}
	}

```

## IOnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnServerShutdown()
{
    Puts("Server is shutting down. Performing cleanup operations.");
    // Additional cleanup logic can be added here if necessary.
}
```
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("IOnServerShutdown");
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## OnGrowableGather(GrowableEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to gather resources from a growable entity.
/// </summary>
/// <param name="growable">The growable entity being harvested.</param>
/// <param name="player">The player attempting to gather resources.</param>
/// <returns>
/// Returns `null` to allow the gathering action, or any non-null value to prevent it.
/// </returns>
object OnGrowableGather(GrowableEntity growable, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to gather from {growable.GetType().Name}.");

    if (player.inventory.GetAmount("special_item") > 0)
    {
        Puts($"Player {player.displayName} has a special item and can gather extra resources.");
        return null; // Allow gathering
    }

    Puts($"Player {player.displayName} is not allowed to gather from {growable.GetType().Name}.");
    return "You cannot gather from this plant right now."; // Prevent gathering
}
```
```

### Source Code from the Library

```csharp

	public void PickFruit(BasePlayer player)
	{
		if (!CanPick() || Interface.CallHook("OnGrowableGather", this, player) != null)
		{
			return;
		}
		harvests++;
		GiveFruit(player, CurrentPickAmount);
		ResetSeason();
		if (Properties.pickEffect.isValid)
		{
			Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
		}
		if (harvests >= Properties.maxHarvests)
		{
			if (Properties.disappearAfterHarvest)
			{
				Die();
			}
			else
			{
				ChangeState(PlantProperties.State.Dying, resetAge: true);
			}
		}
		else
		{
			ChangeState(PlantProperties.State.Mature, resetAge: true);
		}
	}

```

## CanDemolish(BasePlayer,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Determines whether a player can demolish a building block.
/// </summary>
/// <param name="player">The player attempting to demolish the building block.</param>
/// <param name="buildingBlock">The building block that is being targeted for demolition.</param>
/// <returns>
/// Returns `true` if the player can demolish the building block; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can demolish the block.
/// </returns>
bool? CanDemolish(BasePlayer player, BuildingBlock buildingBlock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to demolish a building block.");

    if (!buildingBlock.IsDemolishable())
    {
        Puts($"Player {player.displayName} cannot demolish this building block as it is not demolishable.");
        return false;
    }

    if (!buildingBlock.HasDemolishPrivilege(player))
    {
        Puts($"Player {player.displayName} does not have the privilege to demolish this building block.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsDemolishable())
		{
			return HasDemolishPrivilege(player);
		}
		return false;
	}

```

## IOnRunCommandLine()

```csharp
```csharp
/// <summary>
/// Called when the command line is run to update values based on provided switches.
/// </summary>
/// <returns>
/// Returns a non-null value to prevent further processing of command line switches. 
/// If `null` is returned, the command line switches will be processed as normal.
/// </returns>
object IOnRunCommandLine()
{
    Puts("Command line processing initiated.");
    // Example: Prevent processing if a specific condition is met
    if (SomeConditionToPreventProcessing())
    {
        Puts("Command line processing has been blocked.");
        return true; // Prevent further processing
    }
    return null; // Allow further processing
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed from the console.
/// </summary>
/// <param name="arg">The arguments associated with the console command.</param>
/// <returns>
/// Returns `true` if the command was successfully executed; otherwise, returns `false`.
/// If the method returns a non-null value, it will override the default command execution behavior.
/// </returns>
bool IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Executing server command: {arg.cmd.FullName} with arguments: {string.Join(", ", arg.Args)}");
    
    if (arg.cmd.FullName == "admin.ban")
    {
        Puts("Admin ban command is restricted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null && string.IsNullOrWhiteSpace(arg.Reply))
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## OnClientDisconnect(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The connection of the client that disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnect(Network.Connection connection, string reason)
{
    Puts($"Client disconnected: {connection.username} (ID: {connection.userid}) - Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	protected void OnDisconnected(string strReason, Connection cn)
	{
		if (cn != null)
		{
			cn.connected = false;
			cn.active = false;
			if (callbackHandler != null)
			{
				callbackHandler.OnDisconnected(strReason, cn);
			}
			Interface.CallHook("OnClientDisconnect", cn, strReason);
			RemoveConnection(cn);
		}
	}

```

## OnGroupCreated(string,string,int)

```csharp
```csharp
/// <summary>
/// Called when a new group is created.
/// </summary>
/// <param name="groupName">The name of the group that was created.</param>
/// <param name="groupTitle">The title of the group that was created.</param>
/// <param name="groupRank">The rank assigned to the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupCreated(string groupName, string groupTitle, int groupRank)
{
    Puts($"Group created: Name = {groupName}, Title = {groupTitle}, Rank = {groupRank}");
    
    if (groupRank < 1)
    {
        Puts($"Warning: Group {groupName} has a low rank of {groupRank}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string groupName, string groupTitle, int groupRank)
	{
		if (GroupExists(groupName) || string.IsNullOrEmpty(groupName))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = groupTitle,
			Rank = groupRank
		};
		groupsData.Add(groupName, value);
		Interface.CallHook("OnGroupCreated", groupName, groupTitle, groupRank);
		return true;
	}

```

## OnUserNameUpdated(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's nickname is updated.
/// </summary>
/// <param name="playerId">The ID of the player whose nickname is being updated.</param>
/// <param name="oldName">The player's previous nickname.</param>
/// <param name="newName">The player's new nickname.</param>
/// <returns>No return behavior.</returns>
void OnUserNameUpdated(string playerId, string oldName, string newName)
{
    Puts($"Player {playerId} changed their nickname from {oldName} to {newName}.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string playerId, string playerName)
	{
		if (UserExists(playerId))
		{
			UserData userData = GetUserData(playerId);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = playerName.Sanitize();
			userData.LastSeenNickname = playerName.Sanitize();
			Interface.CallHook("OnUserNameUpdated", playerId, lastSeenNickname, obj);
		}
	}

```

## OnGroupRankSet(string,int)

```csharp
```csharp
/// <summary>
/// Called when a group's rank is set or updated.
/// </summary>
/// <param name="groupName">The name of the group whose rank is being set.</param>
/// <param name="groupRank">The new rank to assign to the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupRankSet(string groupName, int groupRank)
{
    Puts($"Group rank updated: {groupName} is now ranked {groupRank}.");
    
    if (groupRank < 0)
    {
        Puts($"Warning: Group {groupName} has been assigned a negative rank.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string groupName, int groupRank)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Rank == groupRank)
		{
			return true;
		}
		value.Rank = groupRank;
		Interface.CallHook("OnGroupRankSet", groupName, groupRank);
		return true;
	}

```

## OnGroupTitleSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's title is set or updated.
/// </summary>
/// <param name="groupName">The name of the group whose title is being set.</param>
/// <param name="groupTitle">The new title for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupTitleSet(string groupName, string groupTitle)
{
    Puts($"The title for group '{groupName}' has been set to '{groupTitle}'.");
    
    // Additional logic can be added here if needed, such as notifying group members.
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string groupName, string groupTitle)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Title == groupTitle)
		{
			return true;
		}
		value.Title = groupTitle;
		Interface.CallHook("OnGroupTitleSet", groupName, groupTitle);
		return true;
	}

```

## OnPermissionRegistered(string,Oxide.Core.Plugins.Plugin)

```csharp
```csharp
/// <summary>
/// Called when a new permission is registered by a plugin.
/// </summary>
/// <param name="permission">The name of the permission being registered.</param>
/// <param name="owner">The plugin that is registering the permission.</param>
/// <returns>No return behavior.</returns>
void OnPermissionRegistered(string permission, Oxide.Core.Plugins.Plugin owner)
{
    Puts($"Permission '{permission}' has been registered by plugin '{owner.Title}'.");

    if (permission.Contains("admin"))
    {
        Puts($"Warning: The permission '{permission}' is an admin permission and should be handled with care.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string permission, Plugin owner)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return;
		}
		if (PermissionExists(permission))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", permission, owner.Title);
			return;
		}
		if (!registeredPermissions.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			registeredPermissions.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(permission);
		Interface.CallHook("OnPermissionRegistered", permission, owner);
		if (!permission.StartsWith(owner.Name + ".", StringComparison.OrdinalIgnoreCase) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", owner.Name.ToLower(), permission, owner.Title);
		}
	}

```

## OnGroupParentSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's parent is set or changed.
/// </summary>
/// <param name="groupName">The name of the group whose parent is being set.</param>
/// <param name="parentGroupName">The name of the new parent group.</param>
/// <returns>
/// Returns `true` if the parent group was successfully set, or `false` if the operation failed.
/// </returns>
bool OnGroupParentSet(string groupName, string parentGroupName)
{
    Puts($"Group '{groupName}' parent set to '{parentGroupName}'.");

    if (parentGroupName == "admin")
    {
        Puts($"Group '{groupName}' cannot have 'admin' as a parent.");
        return false;
    }

    return true;
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string groupName, string parentGroupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parentGroupName))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))
		{
			return false;
		}
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parentGroupName))
		{
			return true;
		}
		if (HasCircularParent(groupName, parentGroupName))
		{
			return false;
		}
		value.ParentGroup = parentGroupName;
		Interface.CallHook("OnGroupParentSet", groupName, parentGroupName);
		return true;
	}

```

## OnGroupDeleted(string)

```csharp
```csharp
/// <summary>
/// Called when a group is deleted from the system.
/// </summary>
/// <param name="groupName">The name of the group that has been deleted.</param>
/// <returns>No return behavior.</returns>
void OnGroupDeleted(string groupName)
{
    Puts($"Group '{groupName}' has been deleted from the system.");
    
    // Additional logic can be added here if needed, such as notifying users or logging.
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		bool flag = groupsData.Remove(groupName);
		if (flag)
		{
			foreach (GroupData item in groupsData.Values.Where((GroupData g) => g.ParentGroup == groupName))
			{
				item.ParentGroup = string.Empty;
			}
		}
		if (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(groupName)))
		{
			SaveUsers();
		}
		if (flag)
		{
			Interface.CallHook("OnGroupDeleted", groupName);
		}
		return true;
	}

```

## OnDestroyUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a UI element is destroyed for a player.
/// </summary>
/// <param name="player">The player for whom the UI element is being destroyed.</param>
/// <param name="element">The identifier of the UI element to be destroyed.</param>
/// <returns>
/// Returns `true` if the UI element was successfully destroyed; otherwise, returns `false`.
/// </returns>
bool OnDestroyUI(BasePlayer player, string element)
{
    Puts($"Destroying UI element '{element}' for player {player.displayName} (ID: {player.UserIDString}).");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		if (player?.net != null)
		{
			Interface.CallHook("OnDestroyUI", player, elem);
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "DestroyUI", elem);
			return true;
		}
		return false;
	}

```

## OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player executes a command.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The command that was issued.</param>
/// <param name="args">The arguments provided with the command.</param>
/// <returns>No return behavior.</returns>
void OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer player, string command, string[] args)
{
    Puts($"Player {player.Name} issued command: {command} with arguments: {string.Join(", ", args)}");

    if (command.Equals("testcommand", StringComparison.OrdinalIgnoreCase))
    {
        player.Reply("Test command executed successfully!");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(BasePlayer basePlayer, string message)
	{
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command != null)
		{
			object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
			object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
			if (((obj == null) ? obj2 : obj) == null && !Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
	}

```

## OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player changes their language setting.
/// </summary>
/// <param name="player">The player whose language has changed.</param>
/// <param name="newLanguage">The new language setting for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer player, string newLanguage)
{
    Puts($"Player {player.Name} has changed their language to {newLanguage}.");
    
    // Additional logic can be added here to handle language-specific settings or notifications.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnPlayerLanguageChanged(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player changes their language setting.
/// </summary>
/// <param name="player">The player whose language has changed.</param>
/// <param name="newLanguage">The new language setting for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(BasePlayer player, string newLanguage)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has changed their language to {newLanguage}.");
    
    // Additional logic can be added here to handle language-specific settings or notifications.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>
/// Returns a non-null value to override the default respawn behavior. 
/// If a string is returned, it will be used as a message to the player. 
/// If `null` is returned, the default respawn behavior will proceed.
/// </returns>
object OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.Name} has respawned. Special handling can be applied.");
        return "Welcome back, Admin!";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.CallHook("OnUserRespawn", iPlayer);
	}

```

## OnRconCommand(System.Net.IPAddress,string,string[])

```csharp
```csharp
/// <summary>
/// Called when an RCON command is received.
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the command.</param>
/// <param name="command">The command string sent via RCON.</param>
/// <param name="args">Additional arguments parsed from the command string.</param>
/// <returns>
/// Returns a non-null value to indicate that the command was handled, or `null` to allow default processing.
/// </returns>
object OnRconCommand(System.Net.IPAddress ipAddress, string command, string[] args)
{
    Puts($"RCON command received from {ipAddress}: {command}");

    if (command.StartsWith("kick"))
    {
        Puts($"Executing kick command from RCON: {command}");
        return true; // Indicate that the command was handled
    }

    return null; // Allow default processing for other commands
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconCommand")]
	private object IOnRconCommand(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnEntityTakeDamage(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit, including damage amount and source.</param>
/// <returns>
/// Returns a non-null value to override the default damage behavior. 
/// If a string is returned, it can be used to provide a custom message or action. 
/// If `null` is returned, the default damage processing will occur.
/// </returns>
object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.net.ID} is taking damage: {hitInfo.damageTypes.Total()} from {hitInfo.Initiator?.ShortPrefabName ?? "unknown source"}.");

    if (entity is BasePlayer player && player.health < 20)
    {
        Puts($"Player {player.displayName} is critically low on health!");
        return "Player health is critically low!";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.CallHook("OnEntityTakeDamage", entity, hitInfo);
		}
		return null;
	}

```

## OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>No return behavior.</returns>
void OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", iPlayer);
		}
	}

```

## OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user disconnects from the server.
/// </summary>
/// <param name="player">The player who has disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer player, string reason)
{
    Puts($"User {player.Name} has disconnected from the server. Reason: {reason}");
    
    if (reason == "timeout")
    {
        Puts($"User {player.Name} disconnected due to timeout.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer basePlayer, string reason)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(basePlayer);
	}

```

## OnServerInitialized(bool)

```csharp
```csharp
/// <summary>
/// Called when the server has been fully initialized.
/// </summary>
/// <param name="isInitialized">Indicates whether the server is initialized.</param>
/// <returns>No return behavior.</returns>
void OnServerInitialized(bool isInitialized)
{
    Puts($"Server initialization status: {isInitialized}");
    if (isInitialized)
    {
        Puts("The server is now fully initialized and ready for players.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			Analytics.Collect();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", serverInitialized);
		}
	}

```

## CanUserLogin(string,string,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a user can log in to the server.
/// </summary>
/// <param name="username">The username of the user attempting to log in.</param>
/// <param name="steamId">The Steam ID of the user attempting to log in.</param>
/// <param name="ipAddress">The IP address of the user attempting to log in.</param>
/// <returns>
/// Returns a non-null value to reject the login attempt, or `null` to allow the user to log in.
/// If a string is returned, it will be used as the rejection message.
/// </returns>
object CanUserLogin(string username, string steamId, string ipAddress)
{
    Puts($"Checking login for user: {username}, SteamID: {steamId}, IP: {ipAddress}");

    if (username == "bannedUser")
    {
        Puts($"User {username} is banned from logging in.");
        return "You are banned from this server.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnPlayerChat(BasePlayer,string,ConVar.Chat.ChatChannel)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="player">The player who sent the message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <param name="channel">The chat channel used for sending the message.</param>
/// <returns>
/// Returns a non-null value to prevent the message from being sent. 
/// If `null` is returned, the message will be processed normally.
/// </returns>
object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) sent a message: {message} in channel: {channel}.");

    if (message.Contains("badword"))
    {
        Puts($"Message from {player.displayName} contains prohibited content.");
        return "Your message contains inappropriate content and cannot be sent.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, string steamId, string ipAddress)
{
    Puts($"User {username} (SteamID: {steamId}) has been unbanned. IP Address: {ipAddress}");
    
    if (ipAddress == "192.168.1.100")
    {
        Puts($"Warning: User {username} has been unbanned from a restricted IP address.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## CanClientLogin(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a client can log in to the server.
/// </summary>
/// <param name="connection">The network connection of the client attempting to log in.</param>
/// <returns>
/// Returns a non-null value to reject the login attempt, or `null` to allow the client to log in.
/// If a string is returned, it will be used as the rejection message.
/// </returns>
object CanClientLogin(Network.Connection connection)
{
    Puts($"Client {connection.username} (ID: {connection.userid}) is attempting to log in from IP: {connection.ipaddress}.");

    if (connection.authLevel < 1)
    {
        Puts($"Client {connection.username} does not have sufficient permissions to log in.");
        return "Insufficient permissions to access the server.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnUserBanned(string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is banned from the server.
/// </summary>
/// <param name="username">The username of the banned player.</param>
/// <param name="steamId">The Steam ID of the banned player.</param>
/// <param name="ipAddress">The IP address of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string username, string steamId, string ipAddress, string reason)
{
    Puts($"User {username} (SteamID: {steamId}, IP: {ipAddress}) has been banned. Reason: {reason}");
    
    // Additional logic can be added here, such as notifying admins or logging the ban.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason);
		}
	}

```

## OnPlayerOfflineChat(ulong,string,string,ConVar.Chat.ChatChannel)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message while offline.
/// </summary>
/// <param name="playerId">The unique identifier of the player sending the message.</param>
/// <param name="playerName">The name of the player sending the message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <param name="channel">The chat channel used for sending the message.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. If `null` is returned, the message is processed normally.
/// </returns>
object OnPlayerOfflineChat(ulong playerId, string playerName, string message, ConVar.Chat.ChatChannel channel)
{
    Puts($"Offline chat from {playerName} (ID: {playerId}): {message} in channel {channel}.");

    if (message.Contains("urgent"))
    {
        Puts($"Urgent message from {playerName} detected!");
        return "Your message has been marked as urgent.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player or another entity.
/// </summary>
/// <param name="npc">The NPC that is targeting.</param>
/// <param name="target">The entity that is being targeted.</param>
/// <returns>
/// Returns `0` to indicate that the NPC should not engage the target, or `null` to allow the default targeting behavior.
/// </returns>
object OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is targeting {target?.ShortPrefabName ?? "unknown entity"}.");

    if (target is BasePlayer player && player.IsInvisible())
    {
        Puts($"NPC {npc.displayName} cannot target invisible player {player.displayName}.");
        return 0f;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcTarget", npc, target) != null)
		{
			npc.SetFact(BaseNpc.Facts.HasEnemy, 0);
			npc.SetFact(BaseNpc.Facts.EnemyRange, 3);
			npc.SetFact(BaseNpc.Facts.AfraidRange, 1);
			npc.AiContext.EnemyPlayer = null;
			npc.AiContext.LastEnemyPlayerScore = 0f;
			npc.playerTargetDecisionStartTime = 0f;
			return 0f;
		}
		return null;
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The player who was kicked.</param>
/// <param name="reason">The reason for the kick.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer player, string reason)
{
    Puts($"User {player.Name} has been kicked from the server. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer basePlayer, string reason)
	{
		if (basePlayer.IPlayer != null)
		{
			Interface.CallHook("OnUserKicked", basePlayer.IPlayer, reason);
		}
	}

```

## OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user connects to the server.
/// </summary>
/// <param name="player">The player who has connected.</param>
/// <returns>No return behavior.</returns>
void OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"Player {player.Name} (ID: {player.Id}) has connected to the server.");
    
    // Additional logic can be added here, such as welcome messages or player initialization.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnServerCommand(string,string[])

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="command">The name of the command being executed.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns a non-null value to prevent the command from executing further. 
/// If `null` is returned, the command will proceed with its default behavior.
/// </returns>
object OnServerCommand(string command, string[] args)
{
    Puts($"Server command executed: {command} with arguments: {string.Join(", ", args)}");

    if (command == "kick")
    {
        Puts("Kick command detected. Additional checks may be applied.");
        return "Kick command is restricted.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnLoseCondition(object[])

```csharp
```csharp
/// <summary>
/// Called when an item loses condition, typically due to usage or damage.
/// </summary>
/// <param name="item">The item that is losing condition.</param>
/// <param name="amount">The amount of condition being lost.</param>
/// <returns>
/// Returns `true` if the condition loss is processed successfully; otherwise, returns `false` if the item is broken.
/// </returns>
object OnLoseCondition(Item item, float amount)
{
    Puts($"Item {item.info.displayName.english} is losing condition: {amount}.");

    if (item.condition <= 0f)
    {
        Puts($"Item {item.info.displayName.english} is broken and cannot lose more condition.");
        return false;
    }

    return true;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

```

## OnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The arguments associated with the server command.</param>
/// <returns>
/// Returns a non-null value to prevent the command from executing further. 
/// If `null` is returned, the command will proceed with its default behavior.
/// </returns>
object OnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Server command received: {arg.cmd.FullName} from player: {arg.Player()?.displayName ?? "Console"}");

    if (arg.cmd.FullName == "server.shutdown")
    {
        Puts("Shutdown command received. Preparing to shut down the server.");
        return "Server is shutting down.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerShutdown()
{
    Puts("Server is shutting down. Saving all player data and cleaning up resources.");
    // Additional cleanup logic can be added here if necessary
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerShutdown")]
	private void IOnServerShutdown()
	{
		Interface.Oxide.CallHook("OnServerShutdown");
		Interface.Oxide.OnShutdown();
		Covalence.PlayerManager.SavePlayerData();
	}

```

## OnPlayerBanned(string,ulong,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned from the server.
/// </summary>
/// <param name="playerName">The name of the player being banned.</param>
/// <param name="steamId">The Steam ID of the player being banned.</param>
/// <param name="ipAddress">The IP address of the player being banned.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string playerName, ulong steamId, string ipAddress, string reason)
{
    Puts($"Player {playerName} (SteamID: {steamId}) has been banned. IP: {ipAddress}. Reason: {reason}");
    
    // Additional logic can be added here, such as notifying other players or logging the ban.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason);
		}
	}

```

## OnEntityTakeDamage(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player entity takes damage.
/// </summary>
/// <param name="player">The player entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns a non-null value to prevent the default damage handling, or `null` to allow it.
/// </returns>
object OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is taking damage from {hitInfo.Initiator?.ToString() ?? "unknown source"}.");

    if (hitInfo.damageTypes.GetTotal() > 50)
    {
        Puts($"Damage from {hitInfo.Initiator?.ToString()} is too high, preventing further damage.");
        return true; // Prevent further damage handling
    }

    return null; // Allow default damage handling
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)
	{
		if (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", basePlayer, hitInfo) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			basePlayer.OnAttacked(hitInfo);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

```

## OnUserApproved(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="username">The username of the approved user.</param>
/// <param name="steamId">The Steam ID of the approved user.</param>
/// <param name="ipAddress">The IP address of the approved user.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object OnUserApproved(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been approved to join the server.");
    
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    
    // Additional checks can be added here
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <returns>
/// Returns a non-null value to prevent the message from being sent to other players. 
/// If `null` is returned, the message will be processed normally.
/// </returns>
object OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer player, string message)
{
    Puts($"Player {player.Name} (ID: {player.Id}) sent a message: {message}");

    if (message.Contains("badword"))
    {
        Puts($"Player {player.Name} used a prohibited word.");
        return "Your message contains prohibited content.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player successfully connects to the server.
/// </summary>
/// <param name="player">The player who has connected.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has connected to the server.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved to the server.
/// </summary>
/// <param name="entity">The entity that is being saved.</param>
/// <param name="saveInfo">Information about the save operation.</param>
/// <returns>No return behavior.</returns>
void OnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity.net.ID} has been saved with save info for connection: {saveInfo.forConnection?.userid ?? 0}.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnEntitySaved")]
	private void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)
	{
		if (serverInitialized && saveInfo.forConnection != null)
		{
			Interface.CallHook("OnEntitySaved", baseNetworkable, saveInfo);
		}
	}

```

## OnNpcTarget(NPCPlayerApex,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC that is targeting the player.</param>
/// <param name="player">The player being targeted by the NPC.</param>
/// <returns>
/// Returns a non-null value to override the default targeting behavior. 
/// If the method returns `true`, the NPC will target the player; if it returns `false`, the NPC will not target the player.
/// </returns>
object OnNpcTarget(NPCPlayerApex npc, BasePlayer player)
{
    Puts($"NPC {npc.displayName} is attempting to target player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInStealthMode)
    {
        Puts($"NPC {npc.displayName} cannot target player {player.displayName} because they are in stealth mode.");
        return false;
    }

    return null; // Allow default behavior if no conditions are met
}
```
```

### Source Code from the Library

```csharp

	private int GetPlayersSensed(NPCPlayerApex npc, Vector3 position, float distance, BaseEntity[] targetList)
	{
		return BaseEntity.Query.Server.GetInSphere(position, distance, targetList, delegate(BaseEntity entity)
		{
			BasePlayer basePlayer = entity as BasePlayer;
			object obj = ((basePlayer != null && npc != null && basePlayer != npc) ? Interface.CallHook("OnNpcTarget", npc, basePlayer) : null);
			if (obj != null)
			{
				foreach (Memory.SeenInfo item in npc.AiContext.Memory.All)
				{
					if (item.Entity == basePlayer)
					{
						npc.AiContext.Memory.All.Remove(item);
						break;
					}
				}
				foreach (Memory.ExtendedInfo item2 in npc.AiContext.Memory.AllExtended)
				{
					if (item2.Entity == basePlayer)
					{
						npc.AiContext.Memory.AllExtended.Remove(item2);
						break;
					}
				}
			}
			return basePlayer != null && obj == null && basePlayer.isServer && !basePlayer.IsSleeping() && !basePlayer.IsDead() && basePlayer.Family != npc.Family;
		});
	}

```

## OnPlayerCommand(BasePlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player executes a command.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The command that was issued.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>No return behavior.</returns>
void OnPlayerCommand(BasePlayer player, string command, string[] args)
{
    Puts($"Player {player.displayName} issued command: {command} with arguments: {string.Join(", ", args)}");

    if (command.Equals("test", StringComparison.OrdinalIgnoreCase))
    {
        Puts($"Test command executed by {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(BasePlayer basePlayer, string message)
	{
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command != null)
		{
			object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
			object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
			if (((obj == null) ? obj2 : obj) == null && !Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
	}

```

## CanUseUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use a specific UI element.
/// </summary>
/// <param name="player">The player attempting to use the UI.</param>
/// <param name="uiIdentifier">The identifier for the UI element being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the UI; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the UI can be used.
/// </returns>
bool? CanUseUI(BasePlayer player, string uiIdentifier)
{
    Puts($"Checking UI access for player {player.displayName} (ID: {player.UserIDString}) for UI: {uiIdentifier}.");

    if (uiIdentifier == "restricted_ui")
    {
        Puts($"Player {player.displayName} is not allowed to access the restricted UI.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AddUi(BasePlayer player, string json)
	{
		if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
		{
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "AddUI", json);
			return true;
		}
		return false;
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned player.</param>
/// <param name="steamId">The Steam ID of the unbanned player.</param>
/// <param name="ipAddress">The IP address of the unbanned player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} (SteamID: {steamId}) has been unbanned. IP Address: {ipAddress}");
    
    if (ipAddress == "192.168.1.100")
    {
        Puts($"Warning: Player {username} has a potentially restricted IP address.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## OnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to connect to the server.
/// </summary>
/// <param name="connection">The network connection of the user being approved.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object OnUserApprove(Network.Connection connection)
{
    Puts($"User {connection.username} (ID: {connection.userid}) is being approved for connection.");
    
    if (connection.authLevel < 1)
    {
        Puts($"User {connection.username} does not have sufficient authorization level.");
        return "You do not have permission to connect.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## CanPickupEntity(BasePlayer,DoorCloser)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pick up a specified entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity that is being picked up.</param>
/// <returns>
/// Returns `true` if the player is not allowed to pick up the entity, or `null` if the default logic should apply.
/// If the method returns `false`, the player can pick up the entity.
/// </returns>
object CanPickupEntity(BasePlayer player, DoorCloser entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to pick up entity: {entity.name}.");

    if (entity.IsLocked())
    {
        Puts($"Entity {entity.name} is locked and cannot be picked up.");
        return true; // Deny pickup
    }

    return null; // Allow default logic to determine pickup
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)
	{
		object obj = Interface.CallHook("CanPickupEntity", basePlayer, entity);
		if (!(obj is bool) || (bool)obj)
		{
			return null;
		}
		return true;
	}

```

