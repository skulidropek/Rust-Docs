# Hook Definitions

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating another entity or player.
/// </summary>
/// <param name="player">The player who is starting to spectate.</param>
/// <param name="filter">The filter used to determine what the player is spectating.</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player} is attempting to spectate with filter: {filter}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnFuelConsumed(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The fuel item being consumed.</param>
/// <param name="burnable">The burnable item mod associated with the fuel.</param>
/// <returns>
/// Returns a non-null value to prevent the default fuel consumption behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnFuelConsumed(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel consumed: {fuel} in oven {oven} with burnable {burnable}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Facepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## OnNpcConversationStart(NPCTalking,BasePlayer,ConversationData)

```csharp
```csharp
/// <summary>
/// Called when a player starts a conversation with an NPC.
/// </summary>
/// <param name="npc">The NPC that the player is talking to.</param>
/// <param name="player">The player initiating the conversation.</param>
/// <param name="conversationData">The data related to the conversation being started.</param>
/// <returns>
/// Returns `null` to allow the conversation to proceed, or a non-null value to prevent it. (object)
/// </returns>
object OnNpcConversationStart(NPCTalking npc, BasePlayer player, ConversationData conversationData)
{
    Puts($"Player {player} has started a conversation with NPC {npc}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Server_BeginTalking(BasePlayer ply)
	{
		if (!CanTalkTo(ply))
		{
			return;
		}
		CleanupConversingPlayers();
		OnConversationStarted(ply);
		ConversationData conversationFor = GetConversationFor(ply);
		if (conversationFor != null)
		{
			if (conversingPlayers.Contains(ply))
			{
				OnConversationEnded(ply);
			}
			if (Interface.CallHook("OnNpcConversationStart", this, ply, conversationFor) == null)
			{
				conversingPlayers.Add(ply);
				UpdateFlags();
				ClientRPC(RpcTarget.Player("Client_StartConversation", ply), GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech(ply));
			}
		}
	}

```

## OnCrateHack(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate starts being hacked.
/// </summary>
/// <param name="crate">The hackable locked crate that is being hacked.</param>
/// <returns>No return behavior.</returns>
void OnCrateHack(HackableLockedCrate crate)
{
    Puts($"Hacking started on crate: {crate}.");
}
```
```

### Source Code from the Library

```csharp

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", this);
		BroadcastEntityMessage("HackingStarted", 20f, 256);
		SetFlag(Flags.Reserved1, b: true);
		InvokeRepeating(HackProgress, 1f, 1f);
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

```

## CanAffordToPlace(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford to place a construction using a planner.
/// </summary>
/// <param name="player">The player attempting to place the construction.</param>
/// <param name="planner">The planner being used for the construction.</param>
/// <param name="construction">The construction being placed.</param>
/// <returns>
/// Returns `true` if the player can afford to place the construction, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can afford the placement. (bool)
/// </returns>
object CanAffordToPlace(BasePlayer player, Planner planner, Construction construction)
{
    Puts($"Player {player} is attempting to place a {construction} using planner {planner}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordToPlace(Construction component)
	{
		if (isTypeDeployable)
		{
			return true;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return false;
		}
		object obj = Interface.CallHook("CanAffordToPlace", ownerPlayer, this, component);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			if ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnDoorKnocked(DoorKnocker,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player knocks on a door.
/// </summary>
/// <param name="doorKnocker">The door that is being knocked on.</param>
/// <param name="player">The player who is knocking on the door.</param>
/// <returns>No return behavior.</returns>
void OnDoorKnocked(DoorKnocker doorKnocker, BasePlayer player)
{
    Puts($"Player {player} knocked on door {doorKnocker}.");
}
```
```

### Source Code from the Library

```csharp

	public void Knock(BasePlayer player)
	{
		ClientRPC(RpcTarget.NetworkGroup("ClientKnock"), player.transform.position);
		Interface.CallHook("OnDoorKnocked", this, player);
	}

```

## CanLock(BasePlayer,ModularCar,ModularCarCodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can lock a modular car with a code lock.
/// </summary>
/// <param name="player">The player attempting to lock the car.</param>
/// <param name="car">The modular car being locked.</param>
/// <param name="codeLock">The code lock being used.</param>
/// <returns>
/// Returns `true` if the player can lock the car; otherwise, returns `false`. 
/// If the method returns `null`, the default locking logic will be applied. (bool)
/// </returns>
object CanLock(BasePlayer player, ModularCar car, ModularCarCodeLock codeLock)
{
    Puts($"Player {player} is attempting to lock the car {car} with a code lock.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool HasLockPermission(BasePlayer player)
	{
		if (!HasALock)
		{
			return true;
		}
		if (!player.IsValid() || player.IsDead())
		{
			return false;
		}
		object obj = Interface.CallHook("CanLock", player, owner, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return whitelistPlayers.Contains(player.userID);
	}

```

## OnGrowableGather(GrowableEntity,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to gather resources from a growable entity.
/// </summary>
/// <param name="growable">The growable entity being harvested.</param>
/// <param name="player">The player attempting to gather resources.</param>
/// <param name="eat">Indicates whether the player intends to eat the gathered fruit.</param>
/// <returns>
/// Returns `null` to allow the gathering; any non-null value will prevent the action. (object)
/// </returns>
object OnGrowableGather(GrowableEntity growable, BasePlayer player, bool eat)
{
    Puts($"Player {player} is attempting to gather from {growable} with eat flag set to {eat}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PickFruit(BasePlayer player, bool eat = false)
	{
		if (!CanPick() || Interface.CallHook("OnGrowableGather", this, player, eat) != null)
		{
			return;
		}
		harvests++;
		GiveFruit(player, CurrentPickAmount, eat);
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(player, base.transform.position);
		}
		ResetSeason();
		if (Properties.pickEffect.isValid)
		{
			Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
		}
		if (harvests >= Properties.maxHarvests)
		{
			if (Properties.disappearAfterHarvest)
			{
				TellPlanter();
				Die();
			}
			else
			{
				ChangeState(PlantProperties.State.Dying, resetAge: true);
			}
		}
		else
		{
			ChangeState(PlantProperties.State.Mature, resetAge: true);
		}
	}

```

## CanBeHomingTargeted(PlayerHelicopter)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player-controlled helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The player-controlled helicopter to check.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the helicopter can be targeted. (bool)
/// </returns>
object CanBeHomingTargeted(PlayerHelicopter helicopter)
{
    Puts($"Checking if helicopter {helicopter} can be targeted by homing missiles.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsOn();
	}

```

## OnItemUnlock(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is unlocked.
/// </summary>
/// <param name="item">The item that has been unlocked.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being unlocked; otherwise, returns null to allow the unlock action. (object)
/// </returns>
object OnItemUnlock(Item item)
{
    Puts($"Item {item} has been unlocked.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## CanUseHelicopter(BasePlayer,CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a helicopter.
/// </summary>
/// <param name="player">The player attempting to use the helicopter.</param>
/// <param name="helicopter">The helicopter that the player wants to use.</param>
/// <returns>
/// Returns `null` to allow the player to use the helicopter, or a non-null value to prevent usage. (object)
/// </returns>
object CanUseHelicopter(BasePlayer player, CH47HelicopterAIController helicopter)
{
    Puts($"Player {player} is attempting to use helicopter {helicopter}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", player, this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject,UnityEngine.Collider)

```csharp
```csharp
/// <summary>
/// Called when an object is detected by the trap trigger, indicating that the trap has been activated.
/// </summary>
/// <param name="trap">The trap that has been triggered.</param>
/// <param name="obj">The game object that triggered the trap.</param>
/// <param name="col">The collider associated with the triggering object.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trap, GameObject obj, Collider col)
{
    Puts($"Trap {trap} has been triggered by object: {obj}.");
}
```
```

### Source Code from the Library

```csharp

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		Interface.CallHook("OnTrapSnapped", this, obj, col);
		base.OnObjectAdded(obj, col);
		_trap.ObjectEntered(obj);
	}

```

## OnBoomboxToggle(BoomBox,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a boombox is toggled on or off by a player.
/// </summary>
/// <param name="boombox">The boombox that is being toggled.</param>
/// <param name="player">The player who is toggling the boombox.</param>
/// <param name="isPlaying">Indicates whether the boombox is being turned on (true) or off (false).</param>
/// <returns>No return behavior.</returns>
void OnBoomboxToggle(BoomBox boombox, BasePlayer player, bool isPlaying)
{
    Puts($"Boombox {boombox} toggled by {player}. IsPlaying: {isPlaying}");
}
```
```

### Source Code from the Library

```csharp

	public void ServerTogglePlay(BaseEntity.RPCMessage msg)
	{
		if (IsPowered())
		{
			bool flag = msg.read.ReadByte() == 1;
			if (Interface.CallHook("OnBoomboxToggle", this, msg.player, flag) == null)
			{
				ServerTogglePlay(flag);
			}
		}
	}

```

## OnDemoRecordingStopped(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when demo recording has been stopped for a player.
/// </summary>
/// <param name="filename">The filename of the recorded demo.</param>
/// <param name="player">The player for whom the demo recording was stopped.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStopped(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped for player {player} with filename: {filename}");
}
```
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a code is entered into a code lock by a player.
/// </summary>
/// <param name="codeLock">The code lock that is being interacted with.</param>
/// <param name="player">The player who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>
/// Returns a non-null value to prevent the default behavior of the code entry. If null is returned, the default behavior proceeds. (object)
/// </returns>
object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
{
    Puts($"Player {player} entered code: {code} on CodeLock {codeLock}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked() || IsCodeEntryBlocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, blockwarning, false);
			}
			if ((float)wrongCodes >= maxFailedAttempts)
			{
				SetFlag(Flags.Reserved11, b: true);
				Invoke(ClearCodeEntryBlocked, lockoutCooldown);
			}
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
				wrongCodes = 0;
			}
			Facepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: false);
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
			Facepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: true);
		}
	}

```

## OnCodeChanged(BasePlayer,CodeLock,string,bool)

```csharp
```csharp
/// <summary>
/// Called when the code for a code lock is changed by a player.
/// </summary>
/// <param name="player">The player who is changing the code.</param>
/// <param name="codeLock">The code lock being modified.</param>
/// <param name="newCode">The new code being set.</param>
/// <param name="isGuestCode">Indicates if the new code is a guest code.</param>
/// <returns>No return behavior.</returns>
void OnCodeChanged(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
{
    Puts($"Player {player} changed the code on {codeLock} to {newCode}. Guest code: {isGuestCode}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (!IsLocked() && text.Length == 4 && text.IsNumeric() && !(!hasCode && flag) && Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!hasCode && !flag)
			{
				SetFlag(Flags.Locked, b: true);
			}
			Facepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			Interface.CallHook("OnCodeChanged", rpc.player, this, text, flag);
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item,ItemCrafter)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is completed.
/// </summary>
/// <param name="task">The item crafting task that has been finished.</param>
/// <param name="item">The item that was crafted.</param>
/// <param name="craftingStation">The entity or station that performed the crafting.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter craftingStation)
{
    Puts($"Crafting finished: {item} (Shortname: {item.info.shortname}) for task UID: {task.taskUID}.");
}
```
```

### Source Code from the Library

```csharp

	public void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item2 = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item2.amount = task.blueprint.amountToCreate;
		int amount = item2.amount;
		_ = owner.currentCraftLevel;
		bool inSafezone = owner.InSafeZone();
		if (item2.hasCondition && task.conditionScale != 1f)
		{
			item2.maxCondition *= task.conditionScale;
			item2.condition = item2.maxCondition;
		}
		item2.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					Facepunch.Rust.Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item2.info.shortname);
					takenItem.UseItem(num);
					num -= num2;
				}
				if (num <= 0)
				{
					break;
				}
			}
		}
		task.takenItems?.RemoveAll((Item item) => item.amount == 0);
		Facepunch.Rust.Analytics.Server.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		Facepunch.Rust.Analytics.Azure.OnCraftItem(item2.info.shortname, item2.amount, base.baseEntity, task.workbenchEntity, inSafezone);
		owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item2, this);
		if (task.instanceData != null)
		{
			item2.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		owner.ProcessMissionEvent(BaseMission.MissionEventType.CRAFT_ITEM, item2.info.itemid, amount);
		if (owner.inventory.GiveItem(item2))
		{
			owner.Command("note.inv", item2.info.itemid, amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		owner.Command("note.inv", item2.info.itemid, amount);
		owner.Command("note.inv", item2.info.itemid, -item2.amount);
		item2.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnItemFilter(Item,StorageContainer,int)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be accepted into a storage container based on its category.
/// </summary>
/// <param name="item">The item being evaluated for storage.</param>
/// <param name="targetSlot">The target slot in the storage container.</param>
/// <returns>
/// Returns `true` if the item can be stored, or `false` if it cannot. 
/// If the method returns `null`, the default filtering logic will be applied. (bool)
/// </returns>
object OnItemFilter(Item item, StorageContainer storage, int targetSlot)
{
    Puts($"Filtering item {item} for storage in slot {targetSlot}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ItemFilter(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("OnItemFilter", item, this, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (onlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		return item.info.category == onlyAcceptCategory;
	}

```

## CanUnlock(BasePlayer,ModularCarCodeLock,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a modular car's code lock with the provided code.
/// </summary>
/// <param name="player">The player attempting to unlock the code lock.</param>
/// <param name="codeLock">The modular car's code lock being unlocked.</param>
/// <param name="code">The code entered by the player.</param>
/// <returns>
/// Returns `true` if the player can unlock the code lock, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can unlock the code lock. (bool)
/// </returns>
object CanUnlock(BasePlayer player, ModularCarCodeLock codeLock, string code)
{
    Puts($"Player {player} is attempting to unlock the code lock with code: {code}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool TryOpenWithCode(BasePlayer player, string codeEntered)
	{
		object obj = Interface.CallHook("CanUnlock", player, this, codeEntered);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CodeEntryBlocked(player))
		{
			return false;
		}
		if (!(codeEntered == Code))
		{
			if (Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				player.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning, false);
			}
			if ((float)wrongCodes >= CodeLock.maxFailedAttempts)
			{
				owner.SetFlag(BaseEntity.Flags.Reserved10, b: true);
				owner.Invoke(ClearCodeEntryBlocked, CodeLock.lockoutCooldown);
			}
			lastWrongTime = Time.realtimeSinceStartup;
			return false;
		}
		if (TryAddPlayer(player.userID))
		{
			wrongCodes = 0;
		}
		owner.SendNetworkUpdate();
		return true;
	}

```

## OnSignalBroadcast(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a signal is broadcasted from a base entity.
/// </summary>
/// <param name="entity">The base entity that is broadcasting the signal.</param>
/// <returns>
/// Returns `null` to allow the signal broadcast to proceed, or a non-null value to prevent the broadcast. (object)
/// </returns>
object OnSignalBroadcast(BaseEntity entity)
{
    Puts($"Signal broadcast from entity: {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SignalBroadcast(Signal signal, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", this) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("SignalFromServer", this, SendMethod.Unreliable, Priority.Immediate), (int)signal, sourceConnection?.userid ?? 0);
		}
	}

```

## OnAdventGiftAward(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an advent gift is awarded to a player.
/// </summary>
/// <param name="calendar">The advent calendar instance managing the gifts.</param>
/// <param name="player">The player receiving the gift.</param>
/// <returns>
/// Returns a non-null value to prevent the gift from being awarded. If null is returned, the gift is awarded as normal. (object)
/// </returns>
object OnAdventGiftAward(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Awarding advent gift to player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AwardGift(BasePlayer player)
	{
		if (Interface.CallHook("OnAdventGiftAward", this, player) != null)
		{
			return;
		}
		DateTime now = DateTime.Now;
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) == startMonth && num >= 0 && num < days.Length)
		{
			if (!playerRewardHistory.ContainsKey(player.userID))
			{
				playerRewardHistory.Add(player.userID, new List<int>());
			}
			playerRewardHistory[player.userID].Add(num);
			Effect.server.Run(giftEffect.resourcePath, player.transform.position);
			if (num >= 0 && num < crosses.Length)
			{
				Effect.server.Run(boxCloseEffect.resourcePath, base.transform.position + Vector3.up * 1.5f);
			}
			DayReward dayReward = days[num];
			for (int i = 0; i < dayReward.rewards.Length; i++)
			{
				ItemAmount itemAmount = dayReward.rewards[i];
				player.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);
			}
			Interface.CallHook("OnAdventGiftAwarded", this, player);
		}
	}

```

## CanUnlock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a key lock.
/// </summary>
/// <param name="player">The player attempting to unlock the key lock.</param>
/// <param name="keyLock">The key lock that is being unlocked.</param>
/// <returns>
/// Returns `null` to allow the unlocking, or a non-null value to prevent it. (object)
/// </returns>
object CanUnlock(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player} is attempting to unlock {keyLock}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnNearbyTurretsScan(AutoTurret,System.Collections.Generic.List<AutoTurret>,bool)

```csharp
```csharp
/// <summary>
/// Called to scan for nearby turrets and update their relationships based on the scan results.
/// </summary>
/// <param name="turret">The turret that is performing the scan.</param>
/// <param name="nearbyTurrets">A list of nearby turrets found during the scan.</param>
/// <param name="created">Indicates whether the turrets were just created or are being removed.</param>
/// <returns>No return behavior.</returns>
void OnNearbyTurretsScan(AutoTurret turret, List<AutoTurret> nearbyTurrets, bool created)
{
    Puts($"Scanning for nearby turrets around {turret}.");
}
```
```

### Source Code from the Library

```csharp

	public void UpdateNearbyTurrets(bool created)
	{
		List<AutoTurret> obj = Facepunch.Pool.Get<List<AutoTurret>>();
		if (Interface.CallHook("OnNearbyTurretsScan", this, obj, created) == null)
		{
			Vis.Entities(base.transform.position, Sentry.interferenceradius, obj, 256, QueryTriggerInteraction.Ignore);
		}
		foreach (AutoTurret item in obj)
		{
			if (!(item == this))
			{
				if (created)
				{
					nearbyTurrets.Add(item);
					item.nearbyTurrets.Add(this);
				}
				else
				{
					item.nearbyTurrets.Remove(this);
				}
			}
		}
		if (!created)
		{
			nearbyTurrets.Clear();
		}
		Facepunch.Pool.FreeUnmanaged(ref obj);
	}

```

## OnEntityDestroy(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the CH47 helicopter AI controller is destroyed.
/// </summary>
/// <param name="helicopter">The helicopter that is being destroyed.</param>
/// <returns>No return behavior.</returns>
void OnEntityDestroy(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter} is being destroyed.");
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

```

## OnExperimentEnded(Workbench)

```csharp
```csharp
/// <summary>
/// Called when an experiment at the workbench has ended.
/// </summary>
/// <param name="workbench">The workbench where the experiment was conducted.</param>
/// <returns>No return behavior.</returns>
void OnExperimentEnded(Workbench workbench)
{
    Puts($"Experiment ended at workbench: {workbench}.");
}
```
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnFishCatch(Item,BaseFishingRod,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a fish is caught by a player using a fishing rod.
/// </summary>
/// <param name="item">The item representing the caught fish.</param>
/// <param name="rod">The fishing rod used to catch the fish.</param>
/// <param name="player">The player who caught the fish.</param>
/// <returns>
/// Returns a modified item if the hook alters the default behavior; otherwise, returns the original item. (Item)
/// </returns>
object OnFishCatch(Item item, BaseFishingRod rod, BasePlayer player)
{
    Puts($"Player {player} caught a fish: {item} using {rod}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## OnWildlifeTrap(WildlifeTrap,TrappableWildlife)

```csharp
```csharp
/// <summary>
/// Called when a wildlife trap successfully traps an animal.
/// </summary>
/// <param name="trap">The wildlife trap that is used.</param>
/// <param name="wildlife">The wildlife that has been trapped.</param>
/// <returns>
/// Returns a non-null value to prevent the trapping action; otherwise, returns null to allow the default behavior. (object)
/// </returns>
object OnWildlifeTrap(WildlifeTrap trap, TrappableWildlife wildlife)
{
    Puts($"Wildlife trap {trap} has trapped {wildlife}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TrapWildlife(TrappableWildlife trapped)
	{
		if (Interface.CallHook("OnWildlifeTrap", this, trapped) == null)
		{
			Item item = ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Remove();
				OnTrappedWildlife(setFlag: false);
			}
			else
			{
				OnTrappedWildlife(setFlag: true);
			}
		}
	}

```

## OnNpcEquipWeapon(ScientistNPC,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon, allowing for modifications or additional actions.
/// </summary>
/// <param name="npc">The NPC that is equipping the weapon.</param>
/// <param name="item">The item being equipped as a weapon.</param>
/// <returns>
/// Returns a non-null value to prevent the NPC from equipping the weapon, or `null` to allow the default behavior. (object)
/// </returns>
object OnNpcEquipWeapon(ScientistNPC npc, Item item)
{
    Puts($"NPC {npc} is attempting to equip weapon: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
		HeldEntity heldEntity = GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		Item item = heldEntity.GetItem();
		if (item == null || item.contents == null || Interface.CallHook("OnNpcEquipWeapon", this, item) != null)
		{
			return;
		}
		if (UnityEngine.Random.Range(0, 3) == 0)
		{
			Item item2 = ItemManager.CreateByName("weapon.mod.flashlight", 1, 0uL);
			if (!item2.MoveToContainer(item.contents))
			{
				item2.Remove();
				return;
			}
			lightsOn = false;
			InvokeRandomized(base.LightCheck, 0f, 30f, 5f);
			LightCheck();
		}
		else
		{
			Item item3 = ItemManager.CreateByName("weapon.mod.lasersight", 1, 0uL);
			if (!item3.MoveToContainer(item.contents))
			{
				item3.Remove();
			}
			LightToggle();
			lightsOn = true;
		}
	}

```

## CanBeRecycled(Item,Recycler)

```csharp
```csharp
/// <summary>
/// Determines whether the specified item can be recycled at the recycler.
/// </summary>
/// <param name="item">The item to check for recyclability.</param>
/// <param name="recycler">The recycler that is attempting to recycle the item.</param>
/// <returns>
/// Returns `true` if the item can be recycled; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the item can be recycled. (bool)
/// </returns>
object CanBeRecycled(Item item, Recycler recycler)
{
    Puts($"Checking if item {item} can be recycled at {recycler}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanBeRecycled(Item item)
	{
		object obj = Interface.CallHook("CanBeRecycled", item, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item != null)
		{
			return item.info.Blueprint != null;
		}
		return false;
	}

```

## OnQuarryConsumeFuel(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when the quarry consumes fuel to check if it can continue operating.
/// </summary>
/// <param name="quarry">The mining quarry that is consuming fuel.</param>
/// <param name="fuelItem">The item being used as fuel.</param>
/// <returns>
/// Returns the fuel item if it has been modified by the hook; otherwise, returns the original item. 
/// If the item is null or insufficient, the quarry cannot continue operating. (Item)
/// </returns>
object OnQuarryConsumeFuel(MiningQuarry quarry, Item fuelItem)
{
    Puts($"Quarry {quarry} is attempting to consume fuel: {fuelItem}.");
    return fuelItem;
}
```
```

### Source Code from the Library

```csharp

	public bool FuelCheck()
	{
		if (pendingWork > 0f)
		{
			return true;
		}
		Item item = fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemByItemName("diesel_barrel");
		object obj = Interface.CallHook("OnQuarryConsumeFuel", this, item);
		if (obj is Item)
		{
			item = (Item)obj;
		}
		if (item != null && item.amount >= 1)
		{
			pendingWork += workPerFuel;
			Facepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);
			item.UseItem();
			return true;
		}
		return false;
	}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an admin opens the vending machine interface.
/// </summary>
/// <param name="vendingMachine">The vending machine being accessed by the admin.</param>
/// <param name="adminPlayer">The player who is an admin and is opening the vending machine.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer adminPlayer)
{
    Puts($"Admin {adminPlayer} opened the vending machine: {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			OpenShop(player);
			ClientRPC(RpcTarget.Player("CLIENT_OpenAdminMenu", player));
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## CanReceiveCall(PhoneController)

```csharp
```csharp
/// <summary>
/// Determines whether the phone can receive a call based on its current state and conditions.
/// </summary>
/// <param name="phoneController">The phone controller attempting to receive a call.</param>
/// <returns>
/// Returns `true` if the phone can receive a call; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the phone can receive calls. (bool)
/// </returns>
object CanReceiveCall(PhoneController phoneController)
{
    Puts($"Checking if phone controlled by {phoneController} can receive calls.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanReceiveCall()
	{
		object obj = Interface.CallHook("CanReceiveCall", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequirePower && !IsPowered())
		{
			return false;
		}
		if (RequireParent && !base.baseEntity.HasParent())
		{
			return false;
		}
		return true;
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when an auto turret acquires a new target.
/// </summary>
/// <param name="turret">The auto turret that is acquiring the target.</param>
/// <param name="target">The target entity that the turret is aiming at.</param>
/// <returns>No return behavior.</returns>
void OnTurretTarget(AutoTurret turret, BaseCombatEntity target)
{
    Puts($"Turret {turret} has targeted {target}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);
				MarkDirtyForceUpdateOutputs();
				nextShotTime += 0.1f;
				authDirty = true;
			}
			target = targ;
		}
	}

```

## OnEntityActiveCheck(BaseEntity,BasePlayer,uint,string)

```csharp
```csharp
/// <summary>
/// Called to check if a player can interact with a specific entity based on activity conditions.
/// </summary>
/// <param name="entity">The entity being checked for activity.</param>
/// <param name="player">The player attempting to interact with the entity.</param>
/// <param name="id">An identifier for the check.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <returns>
/// Returns `true` if the player can interact with the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine the interaction validity. (bool)
/// </returns>
object OnEntityActiveCheck(BaseEntity entity, BasePlayer player, uint id, string debugName)
{
    Puts($"Checking activity for entity {entity} by player {player} with ID {id} and debug name {debugName}.");
    return null;
}
```
```

### Source Code from the Library

```csharp
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityActiveCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				Item activeItem = player.GetActiveItem();
				if (activeItem == null)
				{
					return false;
				}
				if (activeItem.GetHeldEntity() != ent)
				{
					return false;
				}
				return true;
			}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Determines whether the patrol helicopter can use napalm.
/// </summary>
/// <param name="helicopter">The patrol helicopter AI instance checking for napalm usage.</param>
/// <returns>
/// Returns `true` if the helicopter can use napalm; otherwise, returns `false`.
/// If the method returns `null`, the default cooldown logic will be applied. (bool)
/// </returns>
object CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter {helicopter} can use napalm.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= UnityEngine.Random.Range(25f, 35f);
	}

```

## OnPhoneCallStarted(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone call is successfully started between two phone controllers.
/// </summary>
/// <param name="caller">The phone controller initiating the call.</param>
/// <param name="receiver">The phone controller receiving the call.</param>
/// <param name="player">The player associated with the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneCallStarted(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone call started from {caller} to {receiver} by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", this, activeCallTo, currentPlayer) == null)
		{
			if (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)
			{
				_ = currentPlayer != null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			Invoke(TimeOutCall, TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", this, activeCallTo, currentPlayer);
		}
	}

```

## OnSignUpdated(CarvablePumpkin,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated by a player.
/// </summary>
/// <param name="pumpkin">The CarvablePumpkin that contains the sign being updated.</param>
/// <param name="player">The player who is updating the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(CarvablePumpkin pumpkin, BasePlayer player)
{
    Puts($"Sign updated by player {player} on pumpkin {pumpkin}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			UnityEngine.Debug.LogWarning($"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", this, msg.player);
	}

```

## OnVendingShopOpen(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to open a vending shop.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player attempting to open the vending shop.</param>
/// <returns>
/// Returns `null` to allow the shop to open, or any non-null value to prevent it from opening. (object)
/// </returns>
object OnVendingShopOpen(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player} is attempting to open the vending shop: {vendingMachine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", this, msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", this, msg.player);
		}
	}

```

## OnExcavatorMiningToggled(ExcavatorArm)

```csharp
```csharp
/// <summary>
/// Called when the mining state of the excavator is toggled.
/// </summary>
/// <param name="excavator">The excavator arm that is being toggled for mining.</param>
/// <returns>No return behavior.</returns>
void OnExcavatorMiningToggled(ExcavatorArm excavator)
{
    Puts($"Excavator mining toggled for {excavator}.");
}
```
```

### Source Code from the Library

```csharp

	public void BeginMining()
	{
		if (!IsPowered())
		{
			return;
		}
		SetFlag(Flags.On, b: true);
		InvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);
		if (UnityEngine.Time.time > nextNotificationTime)
		{
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				if (!activePlayer.IsNpc && activePlayer.IsConnected && !activePlayer.IsInTutorial)
				{
					activePlayer.ShowToast(GameTip.Styles.Server_Event, excavatorPhrase, false);
				}
			}
			nextNotificationTime = UnityEngine.Time.time + 60f;
		}
		ExcavatorServerEffects.SetMining(isMining: true);
		Facepunch.Rust.Analytics.Server.ExcavatorStarted();
		excavatorStartTime = GetNetworkTime();
		Interface.CallHook("OnExcavatorMiningToggled", this);
	}

```

## OnClientProjectileEffectCreate(Network.Connection,BaseProjectile,string)

```csharp
```csharp
/// <summary>
/// Called when a projectile effect is created on the client side.
/// </summary>
/// <param name="connection">The network connection of the client creating the projectile effect.</param>
/// <param name="projectile">The projectile associated with the effect.</param>
/// <param name="prefabName">The name of the prefab for the projectile effect.</param>
/// <returns>
/// Returns `null` to allow the default effect creation, or a non-null value to prevent it. (object)
/// </returns>
object OnClientProjectileEffectCreate(Network.Connection connection, BaseProjectile projectile, string prefabName)
{
    Puts($"Client {connection} is creating projectile effect: {prefabName} for projectile {projectile}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false, List<Connection> targets = null)
	{
		if (Interface.CallHook("OnClientProjectileEffectCreate", sourceConnection, this, prefabName) == null)
		{
			Effect effect = reusableInstance;
			effect.Clear();
			effect.Init(Effect.Type.Projectile, pos, velocity, sourceConnection);
			effect.scale = (silenced ? 0f : 1f);
			if (forceClientsideEffects)
			{
				effect.scale = 2f;
			}
			effect.pooledString = prefabName;
			effect.number = seed;
			effect.targets = targets;
			EffectNetwork.Send(effect);
		}
	}

```

## OnHorseLead(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to lead a horse.
/// </summary>
/// <param name="horse">The horse that is being led.</param>
/// <param name="player">The player attempting to lead the horse.</param>
/// <returns>
/// Returns `null` to allow the leading action, or any non-null value to prevent it. (object)
/// </returns>
object OnHorseLead(BaseRidableAnimal horse, BasePlayer player)
{
    Puts($"Player {player} is attempting to lead horse {horse}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Lead(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && !AnyMounted() && !IsForSale())
		{
			bool num = IsLeading();
			bool flag = msg.read.Bit();
			if (num != flag && Interface.CallHook("OnHorseLead", this, player) == null)
			{
				SetLeading(flag ? player : null);
				LeadingChanged();
			}
		}
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base combat entity is hurt.
/// </summary>
/// <param name="entity">The base combat entity that is being hurt.</param>
/// <param name="hitInfo">Information about the hit, including damage and source.</param>
/// <returns>
/// Returns a non-null value to override the default damage handling behavior. If null is returned, the default behavior will proceed. (object)
/// </returns>
object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} is being hurt with damage: {hitInfo.damageTypes.Total()}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead() || IsTransferProtected())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (!(this is BasePlayer))
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			float num2 = info.damageTypes.Total();
			health = num - num2;
			SendNetworkUpdate();
			LogEntry(RustLog.EntryType.Combat, 2, "hurt {0}/{1} - {2} health left", info.damageTypes.GetMajorityDamageType(), num2, health.ToString("0"));
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
					baseCombatEntity.lastDealtDamageTo = this;
				}
				if (this.IsValid() && lastAttacker is BasePlayer basePlayer)
				{
					basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.HURT_ENTITY, net.ID, num2);
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (markAttackerHostile && baseCombatEntity2 != null && baseCombatEntity2 != this)
			{
				baseCombatEntity2.MarkHostileFor();
			}
			if (lastDamage.IsConsideredAnAttack())
			{
				SetJustAttacked();
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;
				}
			}
			bool flag = Health() <= 0f;
			Facepunch.Rust.Analytics.Azure.OnEntityTakeDamage(info, flag);
			if (flag)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.LogAttack(info, "killed", num);
				}
				else
				{
					initiatorPlayer.stats.combat.LogAttack(info, "", num);
				}
			}
		}
	}

```

## OnAddVendingOffer(VendingMachine,ProtoBuf.VendingMachine.SellOrder)

```csharp
```csharp
/// <summary>
/// Called when a new selling offer is added to a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine to which the offer is being added.</param>
/// <param name="sellOrder">The sell order being added, containing details about the item and currency.</param>
/// <returns>No return behavior.</returns>
void OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"Adding sell order: {sellOrder.itemToSellID} x{sellOrder.itemToSellAmount} for {sellOrder.currencyAmountPerItem} {sellOrder.currencyID}.");
}
```
```

### Source Code from the Library

```csharp

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = itemToSellID;
			sellOrder.itemToSellAmount = itemToSellAmount;
			sellOrder.currencyID = currencyToUseID;
			sellOrder.currencyAmountPerItem = currencyAmount;
			sellOrder.currencyIsBP = bpState == 3 || bpState == 2;
			sellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", this, sellOrder);
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## OnHelicopterRetire(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called when a patrol helicopter is set to retire.
/// </summary>
/// <param name="helicopter">The patrol helicopter that is retiring.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterRetire(PatrolHelicopterAI helicopter)
{
    Puts($"Patrol helicopter {helicopter} is retiring.");
}
```
```

### Source Code from the Library

```csharp

	public void Retire()
	{
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", this) == null)
		{
			Invoke(DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 newPos = Vector3Ex.Range(-1f, 1f);
			newPos.y = 0f;
			newPos.Normalize();
			newPos *= x * 20f;
			newPos.y = y;
			ExitCurrentState();
			isRetiring = true;
			State_Move_Enter(newPos);
		}
	}

```

## CanElevatorLiftMove(ElevatorLift)

```csharp
```csharp
/// <summary>
/// Determines whether the elevator lift can move based on current conditions and hooks.
/// </summary>
/// <param name="elevator">The elevator lift being checked for movement capability.</param>
/// <returns>
/// Returns `true` if the elevator lift can move; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the elevator can move. (bool)
/// </returns>
object CanElevatorLiftMove(ElevatorLift elevator)
{
    Puts($"Checking if elevator lift {elevator} can move.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanMove()
	{
		object obj = Interface.CallHook("CanElevatorLiftMove", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (VehicleTrigger.HasContents && VehicleTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in VehicleTrigger.entityContents)
			{
				if (!vehiclePrefabWhitelist.Contains(entityContent.prefabID))
				{
					return false;
				}
			}
		}
		return true;
	}

```

## OnOvenStart(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when the oven starts cooking.
/// </summary>
/// <param name="oven">The oven that is starting to cook.</param>
/// <returns>
/// Returns `null` to allow the oven to start cooking, or any non-null value to prevent it from starting. (object)
/// </returns>
object OnOvenStart(BaseOven oven)
{
    Puts($"Oven {oven} is attempting to start cooking.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			InvokeRepeating(Cook, 0.5f, 0.5f);
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", this);
		}
	}

```

## OnMapImageUpdated()

```csharp
```csharp
/// <summary>
/// Called when a map image is updated, either fog or paint.
/// </summary>
/// <returns>No return behavior.</returns>
void OnMapImageUpdated()
{
    Puts("Map image has been updated.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.FromOwner]
	public void ImageUpdate(RPCMessage msg)
	{
		if (msg.player == null)
		{
			return;
		}
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}

```

## IOnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine how much an NPC wants to attack a given target entity.
/// </summary>
/// <param name="npc">The NPC that is considering the attack.</param>
/// <param name="target">The target entity that may be attacked.</param>
/// <returns>
/// Returns a float representing the NPC's desire to attack the target. 
/// If the method returns `null`, the default attack logic will be used. (float)
/// </returns>
object IOnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc} is evaluating attack on target: {target}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

```

## OnSignLocked(PhotoFrame,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The photo frame sign that is being locked.</param>
/// <param name="player">The player who is locking the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(PhotoFrame sign, BasePlayer player)
{
    Puts($"Sign {sign} has been locked by player {player} (ID: {player.userID}).");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the looter can loot the target player; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine looting permissions. (bool)
/// </returns>
object CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter} is attempting to loot {target}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		if ((IsWounded() || IsSleeping() || CurrentGestureIsSurrendering || IsRestrainedOrSurrendering) && !IsLoadingAfterTransfer())
		{
			return !IsTransferring();
		}
		return false;
	}

```

## CanLootEntity(BasePlayer,BaseRidableAnimal)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="animal">The ridable animal that is being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity. (bool)
/// </returns>
object CanLootEntity(BasePlayer player, BaseRidableAnimal animal)
{
    Puts($"Player {player} is attempting to loot entity: {animal}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (storageInventory == null)
		{
			return;
		}
		BasePlayer player = rpc.player;
		string text = rpc.read.String();
		if ((bool)player && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			ItemContainer container = equipmentInventory;
			string arg = lootPanelName;
			if (text == "storage")
			{
				arg = storagePanelName;
				container = storageInventory;
			}
			player.inventory.loot.AddContainer(container);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), arg);
			SendNetworkUpdate();
		}
	}

```

## OnWorldPrefabSpawned(UnityEngine.GameObject,string)

```csharp
```csharp
/// <summary>
/// Called when a prefab is spawned in the world.
/// </summary>
/// <param name="spawnedObject">The GameObject that was spawned.</param>
/// <param name="category">The category of the prefab that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnWorldPrefabSpawned(UnityEngine.GameObject spawnedObject, string category)
{
    Puts($"Prefab of category '{category}' has been spawned: {spawnedObject.name}");
}
```
```

### Source Code from the Library

```csharp

	private static void SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		if (prefab != null && (bool)prefab.Object)
		{
			spawnTimer.Restart();
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject gameObject = prefab.Spawn(position, rotation, scale);
			if ((bool)gameObject)
			{
				Interface.CallHook("OnWorldPrefabSpawned", gameObject, category);
				GameObjectEx.SetHierarchyGroup(gameObject, category);
			}
			spawnTimer.Stop();
			spawnTimings.Add(new SpawnTiming
			{
				category = category,
				prefab = prefab,
				position = position,
				rotation = rotation,
				scale = scale,
				time = spawnTimer.Elapsed
			});
		}
	}

```

## OnItemStacked(Item,Item,ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are stacked in a container.
/// </summary>
/// <param name="stackedItem">The item that is being stacked.</param>
/// <param name="sourceItem">The item that is being added to the stack.</param>
/// <param name="container">The container where the stacking is occurring.</param>
/// <returns>No return behavior.</returns>
void OnItemStacked(Item stackedItem, Item sourceItem, ItemContainer container)
{
    Puts($"Item {sourceItem} stacked onto {stackedItem} in container {container}.");
}
```
```

### Source Code from the Library

```csharp

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		using (TimeWarning.New("MoveToContainer"))
		{
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					foreach (Item item3 in from x in newcontainer.FindItemsByItemID(info.itemid)
						orderby x.position
						select x)
					{
						if (item3.CanStack(this) && (ignoreStackLimit || item3.amount < item3.MaxStackable()))
						{
							iTargetPos = item3.position;
						}
					}
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", slot2, this, newcontainer, num2);
						MarkDirty();
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", item2, this, newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
	}

```

## OnInputUpdate(IOEntity,int,int)

```csharp
```csharp
/// <summary>
/// Called to update the input state of an IOEntity based on the provided input amount and slot.
/// </summary>
/// <param name="entity">The IOEntity receiving the input update.</param>
/// <param name="inputAmount">The amount of input received.</param>
/// <param name="inputSlot">The specific input slot that received the input.</param>
/// <returns>No return behavior.</returns>
void OnInputUpdate(IOEntity entity, int inputAmount, int inputSlot)
{
    Puts($"Input updated for entity {entity} with amount {inputAmount} on slot {inputSlot}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (Interface.CallHook("OnInputUpdate", this, inputAmount, inputSlot) != null)
		{
			return;
		}
		if (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)
		{
			IOStateChanged(inputAmount, inputSlot);
			return;
		}
		UpdateHasPower(inputAmount, inputSlot);
		lastEnergy = currentEnergy;
		currentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);
		int passthroughAmount = GetPassthroughAmount();
		bool flag = lastPassthroughEnergy != passthroughAmount;
		lastPassthroughEnergy = passthroughAmount;
		if (currentEnergy != lastEnergy || flag)
		{
			IOStateChanged(inputAmount, inputSlot);
			ensureOutputsUpdated = true;
		}
		_processQueues[GetQueueType()].Enqueue(this);
	}

```

## OnWireConnect(BasePlayer,IOEntity,int,IOEntity,int,System.Collections.Generic.List<UnityEngine.Vector3>,System.Collections.Generic.List<float>)

```csharp
```csharp
/// <summary>
/// Called when a player connects two IO entities with a wire.
/// </summary>
/// <param name="player">The player making the connection.</param>
/// <param name="inputEntity">The input IO entity being connected.</param>
/// <param name="inputIndex">The index of the input on the input entity.</param>
/// <param name="outputEntity">The output IO entity being connected.</param>
/// <param name="outputIndex">The index of the output on the output entity.</param>
/// <param name="linePoints">The points that define the wire's path.</param>
/// <param name="slackLevels">The slack levels for the wire connection.</param>
/// <returns>Returns `null` to allow the connection, or a non-null value to prevent it.</returns>
object OnWireConnect(BasePlayer player, IOEntity inputEntity, int inputIndex, IOEntity outputEntity, int outputIndex, List<Vector3> linePoints, List<float> slackLevels)
{
    Puts($"Player {player} is attempting to connect {inputEntity} (Input Index: {inputIndex}) to {outputEntity} (Output Index: {outputIndex}).");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RPC_MakeConnection(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		WireConnectionMessage wireConnectionMessage = WireConnectionMessage.Deserialize(rpc.read);
		List<Vector3> linePoints = wireConnectionMessage.linePoints;
		int inputIndex = wireConnectionMessage.inputIndex;
		int outputIndex = wireConnectionMessage.outputIndex;
		IOEntity iOEntity = new EntityRef<IOEntity>(wireConnectionMessage.inputID).Get(serverside: true);
		IOEntity iOEntity2 = new EntityRef<IOEntity>(wireConnectionMessage.outputID).Get(serverside: true);
		if (iOEntity == null || iOEntity2 == null || !ValidateLine(linePoints, iOEntity, iOEntity2, player, outputIndex) || inputIndex >= iOEntity.inputs.Length || outputIndex >= iOEntity2.outputs.Length || iOEntity.inputs[inputIndex].connectedTo.Get() != null || iOEntity2.outputs[outputIndex].connectedTo.Get() != null || (iOEntity.inputs[inputIndex].rootConnectionsOnly && !iOEntity2.IsRootEntity()) || !CanModifyEntity(player, iOEntity) || !CanModifyEntity(player, iOEntity2))
		{
			return;
		}
		List<float> slackLevels = wireConnectionMessage.slackLevels;
		IOEntity.LineAnchor[] array = new IOEntity.LineAnchor[wireConnectionMessage.lineAnchors.Count];
		for (int i = 0; i < wireConnectionMessage.lineAnchors.Count; i++)
		{
			WireLineAnchorInfo wireLineAnchorInfo = wireConnectionMessage.lineAnchors[i];
			array[i].entityRef = new EntityRef<Door>(wireLineAnchorInfo.parentID);
			array[i].boneName = wireLineAnchorInfo.boneName;
			array[i].index = (int)wireLineAnchorInfo.index;
			array[i].position = wireLineAnchorInfo.position;
		}
		WireColour wireColour = IntToColour(wireConnectionMessage.wireColor);
		if (Interface.CallHook("OnWireConnect", player, iOEntity, inputIndex, iOEntity2, outputIndex, wireConnectionMessage.linePoints, slackLevels) == null)
		{
			if (wireColour == WireColour.Invisible && !player.IsInCreativeMode)
			{
				wireColour = DefaultColor;
			}
			iOEntity2.ConnectTo(iOEntity, outputIndex, inputIndex, linePoints, slackLevels, array, wireColour);
			if (wireType == IOEntity.IOType.Industrial)
			{
				iOEntity.NotifyIndustrialNetworkChanged();
				iOEntity2.NotifyIndustrialNetworkChanged();
			}
		}
	}

```

## OnScientistInitialized(BradleyAPC,ScientistNPC,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when a scientist NPC is initialized and spawned in the game world.
/// </summary>
/// <param name="apc">The Bradley APC associated with the scientist.</param>
/// <param name="scientist">The scientist NPC that is being initialized.</param>
/// <param name="spawnPosition">The position where the scientist is spawned.</param>
/// <returns>No return behavior.</returns>
void OnScientistInitialized(BradleyAPC apc, ScientistNPC scientist, Vector3 spawnPosition)
{
    Puts($"Scientist {scientist} initialized at position {spawnPosition} associated with APC {apc}.");
}
```
```

### Source Code from the Library

```csharp

	private void InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)
	{
		if (scientist == null)
		{
			return;
		}
		scientist.transform.position = spawnPos;
		if (!scientist.Brain.Navigator.PlaceOnNavMesh(0.2f))
		{
			activeScientists.Remove(scientist);
			scientist.Kill();
			return;
		}
		if (triggerPlayer != null)
		{
			scientist.Brain.Events.Memory.Entity.Set(triggerPlayer, 0);
			scientist.Brain.Senses.Memory.SetKnown(triggerPlayer, scientist, null);
			scientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 7);
			scientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 4);
			scientist.Brain.Events.Memory.Entity.Set(this, 7);
			AttackEntity attackEntity = scientist.GetAttackEntity();
			if (SetScientistChaseBasedOnWeapon && attackEntity != null && !attackEntity.CanUseAtLongRange)
			{
				startChasing = true;
			}
			scientist.Brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint = startChasing;
			scientist.Brain.Navigator.CanUseRandomMovePointIfNonFound = !startChasing;
			if (startChasing)
			{
				scientist.Brain.SwitchToState(AIState.Chase, 6);
			}
			else
			{
				scientist.Brain.SwitchToState(AIState.TakeCover, 4);
			}
			scientist.Brain.Think(0f);
		}
		Interface.CallHook("OnScientistInitialized", this, scientist, spawnPos);
	}

```

## OnPayForUpgrade(BasePlayer,BuildingBlock,ConstructionGrade)

```csharp
```csharp
/// <summary>
/// Called when a player pays for an upgrade to a building block.
/// </summary>
/// <param name="player">The player who is paying for the upgrade.</param>
/// <param name="block">The building block being upgraded.</param>
/// <param name="grade">The construction grade to which the block is being upgraded.</param>
/// <returns>No return behavior.</returns>
void OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade grade)
{
    Puts($"Player {player} is paying for an upgrade to {block} with grade {grade}.");
}
```
```

### Source Code from the Library

```csharp

	public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
	{
		if (Interface.CallHook("OnPayForUpgrade", player, this, g) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in g.CostToBuild(grade))
		{
			player.inventory.Take(list, item.itemid, (int)item.amount);
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemid);
			Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "upgrade_block", itemDefinition.shortname, (int)item.amount, this, null, safezone: false, null, player.userID);
			player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## OnServerRestart(string,int)

```csharp
```csharp
/// <summary>
/// Called when the server is about to restart.
/// </summary>
/// <param name="notice">The notice message to display to players about the restart.</param>
/// <param name="seconds">The number of seconds until the server restarts.</param>
/// <returns>
/// Returns a non-null value to interrupt the server restart process; otherwise, returns null to allow the restart to proceed. (object)
/// </returns>
object OnServerRestart(string notice, int seconds)
{
    Puts($"Server is scheduled to restart in {seconds} seconds. Notice: {notice}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (SingletonComponent<ServerMgr>.Instance == null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
			SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", strNotice, iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

```

## OnPhoneAnswer(PhoneController,PhoneController)

```csharp
```csharp
/// <summary>
/// Called when a phone call is answered by a player.
/// </summary>
/// <param name="caller">The phone controller that is answering the call.</param>
/// <param name="receiver">The phone controller that is being answered.</param>
/// <returns>No return behavior.</returns>
void OnPhoneAnswer(PhoneController caller, PhoneController receiver)
{
    Puts($"Phone answered: Caller {caller}, Receiver {receiver}.");
}
```
```

### Source Code from the Library

```csharp

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (IsInvoking(TimeOutDialing))
		{
			CancelInvoke(TimeOutDialing);
		}
		if (!(activeCallTo == null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", this, activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", this, activeCallTo);
			}
		}
	}

```

## OnOvenTemperature(BaseOven,int)

```csharp
```csharp
/// <summary>
/// Called to retrieve the current temperature of the oven for a specific slot.
/// </summary>
/// <param name="oven">The oven instance for which the temperature is being queried.</param>
/// <param name="slot">The slot number for which the temperature is requested.</param>
/// <returns>
/// Returns the temperature of the specified slot as a float. If the hook returns a float, that value is used; otherwise, the default temperature is returned. (float)
/// </returns>
object OnOvenTemperature(BaseOven oven, int slot)
{
    Puts($"Retrieving temperature for oven {oven} at slot {slot}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public float GetTemperature(int slot)
	{
		object obj = Interface.CallHook("OnOvenTemperature", this, slot);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!HasFlag(Flags.On))
		{
			return 15f;
		}
		return cookingTemperature;
	}

```

## OnCoalingTowerStart(CoalingTower,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts using a coaling tower.
/// </summary>
/// <param name="tower">The coaling tower being used.</param>
/// <param name="player">The player interacting with the coaling tower.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or a non-null value to prevent the action. (object)
/// </returns>
object OnCoalingTowerStart(CoalingTower tower, BasePlayer player)
{
    Puts($"Player {player} has started using the coaling tower: {tower}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Unload(RPCMessage msg)
	{
		if (Interface.CallHook("OnCoalingTowerStart", this, msg.player) == null && !TryUnloadActiveWagon(out var attemptStatus) && msg.player != null)
		{
			ClientRPC(RpcTarget.Player("ActionFailed", msg.player), (byte)attemptStatus, arg2: true);
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a patrol helicopter can target a specific player.
/// </summary>
/// <param name="helicopter">The patrol helicopter attempting to target the player.</param>
/// <param name="player">The player being evaluated as a target.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player, or `false` if it cannot.
/// If the method returns `null`, the default targeting logic will be applied. (bool)
/// </returns>
object CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Evaluating targeting for player {player} by helicopter {helicopter}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (ply.eyes.position.y < WaterSystem.OceanLevel && Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) > oceanDepthTargetCutoff)
		{
			return false;
		}
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## CanDestroyLock(BasePlayer,ModularCar,BaseVehicleModule)

```csharp
```csharp
/// <summary>
/// Determines whether a player can destroy a lock on a modular car using a specific vehicle module.
/// </summary>
/// <param name="player">The player attempting to destroy the lock.</param>
/// <param name="car">The modular car that has the lock.</param>
/// <param name="viaModule">The vehicle module being used to attempt the destruction.</param>
/// <returns>
/// Returns `true` if the player can destroy the lock; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can destroy the lock. (bool)
/// </returns>
object CanDestroyLock(BasePlayer player, ModularCar car, BaseVehicleModule viaModule)
{
    Puts($"Player {player} is attempting to destroy the lock on car {car} using module {viaModule}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
	{
		object obj = Interface.CallHook("CanDestroyLock", player, this, viaModule);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CarLock.PlayerCanDestroyLock(viaModule);
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldValue">The player's health before the change.</param>
/// <param name="newValue">The player's health after the change.</param>
/// <returns>No return behavior.</returns>
void OnPlayerHealthChange(BasePlayer player, float oldValue, float newValue)
{
    Puts($"Player {player} health changed from {oldValue} to {newValue}.");
}
```
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) != null)
		{
			return;
		}
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer)
		{
			if (oldvalue > newvalue)
			{
				LifeStoryHurt(oldvalue - newvalue);
			}
			else
			{
				LifeStoryHeal(newvalue - oldvalue);
			}
			metabolism.isDirty = true;
		}
	}

```

## OnDemoRecordingStart(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is about to start for a player.
/// </summary>
/// <param name="filePath">The file path where the demo will be saved.</param>
/// <param name="player">The player who is starting the demo recording.</param>
/// <returns>
/// Returns `null` to allow the recording to start, or any non-null value to prevent it from starting. (object)
/// </returns>
object OnDemoRecordingStart(string filePath, BasePlayer player)
{
    Puts($"Demo recording for player {player} will be saved to: {filePath}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnItemSubmit(Item,Mailbox,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is submitted to a mailbox by a player.
/// </summary>
/// <param name="item">The item being submitted.</param>
/// <param name="mailbox">The mailbox receiving the item.</param>
/// <param name="fromPlayer">The player submitting the item.</param>
/// <returns>
/// Returns a non-null value to prevent the item submission; otherwise, returns null to allow it. (object)
/// </returns>
object OnItemSubmit(Item item, Mailbox mailbox, BasePlayer fromPlayer)
{
    Puts($"Player {fromPlayer} submitted item {item} to mailbox {mailbox}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SubmitInputItems(BasePlayer fromPlayer)
	{
		Item slot = base.inventory.GetSlot(mailInputSlot);
		if (IsFull() || slot == null || Interface.CallHook("OnItemSubmit", slot, this, fromPlayer) != null)
		{
			return;
		}
		if (MoveItemToStorage(slot))
		{
			if (slot.position != mailInputSlot)
			{
				Effect.server.Run(mailDropSound.resourcePath, GetDropPosition());
				if (fromPlayer != null && !PlayerIsOwner(fromPlayer))
				{
					SetFlag(Flags.On, b: true);
				}
			}
		}
		else
		{
			slot.Drop(GetDropPosition(), GetDropVelocity());
		}
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is being repaired by a player.
/// </summary>
/// <param name="structure">The structure that is being repaired.</param>
/// <param name="player">The player attempting to repair the structure.</param>
/// <returns>
/// Returns `null` to allow the repair to proceed, or any non-null value to prevent the repair action. (object)
/// </returns>
object OnStructureRepair(BaseCombatEntity structure, BasePlayer player)
{
    Puts($"Player {player} is attempting to repair structure {structure}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		float num = 30f;
		if (player2.IsInCreativeMode && Creative.freeRepair)
		{
			num = 0f;
		}
		if (SecondsSinceAttacked <= num)
		{
			OnRepairFailed(player2, RecentlyDamagedError, (num - SecondsSinceAttacked).ToString("N0"));
			return;
		}
		float num2 = MaxHealth() - Health();
		float num3 = num2 / MaxHealth();
		if (num2 <= 0f || num3 <= 0f)
		{
			OnRepairFailed(player2, NotDamagedError);
			return;
		}
		List<ItemAmount> list = RepairCost(num3);
		if (list == null)
		{
			return;
		}
		float num4 = list.Sum((ItemAmount x) => x.amount);
		float healthBefore = health;
		if (player2.IsInCreativeMode && Creative.freeRepair)
		{
			num4 = 0f;
		}
		if (num4 > 0f)
		{
			float num5 = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			if (float.IsNaN(num5))
			{
				num5 = 0f;
			}
			num5 = Mathf.Min(num5, 50f / num2);
			if (num5 <= 0f)
			{
				OnRepairFailedResources(player2, list);
				return;
			}
			int num6 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(num5 * item.amount);
				int num7 = player2.inventory.Take(null, item.itemid, amount);
				Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "repair_entity", item.itemDef.shortname, num7, this, null, safezone: false, null, player2.userID);
				if (num7 > 0)
				{
					num6 += num7;
					player2.Command("note.inv", item.itemid, num7 * -1);
				}
			}
			float num8 = (float)num6 / num4;
			health += num2 * num8;
			SendNetworkUpdate();
		}
		else
		{
			health += num2;
			SendNetworkUpdate();
		}
		Facepunch.Rust.Analytics.Azure.OnEntityRepaired(player2, this, healthBefore, health);
		if (Health() >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player can be targeted for strafing by the helicopter.
/// </summary>
/// <param name="helicopter">The patrol helicopter attempting to strafe.</param>
/// <param name="player">The player being evaluated as a target.</param>
/// <returns>
/// Returns `true` if the player can be targeted for strafing; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will be used to determine if the player can be targeted. (bool)
/// </returns>
object CanHelicopterStrafeTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Evaluating if player {player} can be targeted by helicopter {helicopter} for strafing.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidRocketTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ply == null)
		{
			return false;
		}
		return !ply.IsNearEnemyBase();
	}

```

## OnStashExposed(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a stash container is exposed to a player.
/// </summary>
/// <param name="stash">The stash container that has been exposed.</param>
/// <param name="player">The player who exposed the stash.</param>
/// <returns>No return behavior.</returns>
void OnStashExposed(StashContainer stash, BasePlayer player)
{
    Puts($"Stash {stash} has been exposed to player {player}.");
}
```
```

### Source Code from the Library

```csharp

	private void CheckStashRevealInvoke()
	{
		for (int i = 0; i < nearbyStashes.Count; i++)
		{
			NearbyStash nearbyStash = nearbyStashes[i];
			if (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)
			{
				nearbyStashes.RemoveAt(i);
			}
			else if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))
			{
				nearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;
				if (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)
				{
					if (Interface.CallHook("CanSeeStash", this, nearbyStash.Entity) != null)
					{
						break;
					}
					nearbyStash.Entity.SetHidden(isHidden: false);
					Facepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);
					Interface.CallHook("OnStashExposed", nearbyStash.Entity, this);
				}
			}
			else
			{
				nearbyStash.LookingAtTime = 0f;
			}
		}
	}

```

## CanLootEntity(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a storage container.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="container">The storage container being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity; otherwise, returns `false`. 
/// If the method returns a non-null value, it prevents the player from looting. (bool)
/// </returns>
object CanLootEntity(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player} is attempting to loot container {container}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (IsLocked() || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, LockedMessage, false);
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, InUseMessage, false);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = panelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			AddContainers(player.inventory.loot);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnPhoneDialTimeout(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing attempt times out.
/// </summary>
/// <param name="caller">The phone controller that initiated the call.</param>
/// <param name="receiver">The phone controller that was being called.</param>
/// <param name="player">The player associated with the call.</param>
/// <returns>
/// Returns `null` to allow the default timeout behavior, or a non-null value to override it. (object)
/// </returns>
object OnPhoneDialTimeout(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone dialing timeout: Caller {caller}, Receiver {receiver}, Player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", activeCallTo, this, activeCallTo.currentPlayer) == null)
		{
			if (activeCallTo != null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", activeCallTo, this, activeCallTo.currentPlayer);
		}
	}

```

## OnVendingShopOpen(NPCVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to open a vending shop managed by an NPC.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine being accessed.</param>
/// <param name="player">The player attempting to open the vending shop.</param>
/// <returns>
/// Returns `null` to allow the shop to open, or any non-null value to prevent the shop from opening. (object)
/// </returns>
object OnVendingShopOpen(NPCVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player} is attempting to open the vending shop: {vendingMachine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if (vendingMachine == null)
		{
			vendingMachine = GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", vendingMachine, msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", vendingMachine, msg.player);
		}
	}

```

## CanRecycle(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled by a recycler.
/// </summary>
/// <param name="recycler">The recycler attempting to recycle the item.</param>
/// <param name="item">The item being checked for recyclability.</param>
/// <returns>
/// Returns `true` if the item can be recycled; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the item can be recycled. (bool)
/// </returns>
object CanRecycle(Recycler recycler, Item item)
{
    Puts($"Checking recyclability for item {item} in recycler {recycler}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## OnCCTVDirectionChange(CCTV_RC,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the direction of a CCTV camera is changed by a player.
/// </summary>
/// <param name="cctv">The CCTV camera whose direction is being changed.</param>
/// <param name="player">The player changing the CCTV direction.</param>
/// <returns>
/// Returns `null` to allow the direction change, or a non-null value to prevent it. (object)
/// </returns>
object OnCCTVDirectionChange(CCTV_RC cctv, BasePlayer player)
{
    Puts($"Player {player} is changing the direction of CCTV {cctv}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void Server_SetDir(RPCMessage msg)
	{
		if (!IsStatic())
		{
			BasePlayer player = msg.player;
			if (player.CanBuild() && player.IsBuildingAuthed() && Interface.CallHook("OnCCTVDirectionChange", this, player) == null)
			{
				Vector3 direction = Vector3Ex.Direction(player.eyes.position, yaw.transform.position);
				direction = base.transform.InverseTransformDirection(direction);
				Vector3 vector = BaseMountable.ConvertVector(Quaternion.LookRotation(direction).eulerAngles);
				pitchAmount = Mathf.Clamp(vector.x, pitchClamp.x, pitchClamp.y);
				yawAmount = Mathf.Clamp(vector.y, yawClamp.x, yawClamp.y);
				SendNetworkUpdate();
			}
		}
	}

```

## OnWaterCollect(WaterCatcher)

```csharp
```csharp
/// <summary>
/// Called when attempting to collect water from a water catcher.
/// </summary>
/// <param name="catcher">The water catcher that is collecting water.</param>
/// <returns>
/// Returns `null` to allow the default water collection behavior, or any non-null value to prevent collection.
/// </returns>
object OnWaterCollect(WaterCatcher catcher)
{
    Puts($"Water collection attempted by catcher at position: {catcher.transform.position}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CollectWater()
	{
		if (!IsFull() && Interface.CallHook("OnWaterCollect", this) == null)
		{
			float baseRate = collectionRates.baseRate;
			baseRate += Climate.GetFog(base.transform.position) * collectionRates.fogRate;
			if (TestIsOutside())
			{
				baseRate += Climate.GetRain(base.transform.position) * collectionRates.rainRate;
				baseRate += Climate.GetSnow(base.transform.position) * collectionRates.snowRate;
			}
			AddResource(Mathf.CeilToInt(maxItemToCreate * baseRate));
		}
	}

```

## OnTeamPromote(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is promoted within their team.
/// </summary>
/// <param name="team">The team to which the player belongs.</param>
/// <param name="player">The player being promoted to team leader.</param>
/// <returns>
/// Returns `null` to allow the promotion, or any non-null value to prevent the promotion. (object)
/// </returns>
object OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player} has been promoted in team {team}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void promote(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);
		if (!(lookingAtPlayer == null) && !lookingAtPlayer.IsDead() && !(lookingAtPlayer == basePlayer) && lookingAtPlayer.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == (ulong)basePlayer.userID && Interface.CallHook("OnTeamPromote", playerTeam, lookingAtPlayer) == null)
			{
				playerTeam.SetTeamLeader(lookingAtPlayer.userID);
			}
		}
	}

```

## OnMapMarkersClear(BasePlayer,System.Collections.Generic.List<ProtoBuf.MapNote>)

```csharp
```csharp
/// <summary>
/// Called when a player requests to clear their map markers.
/// </summary>
/// <param name="player">The player requesting to clear their map markers.</param>
/// <param name="mapNotes">The list of map notes that are currently set for the player.</param>
/// <returns>
/// Returns a non-null value to prevent the clearing of map markers; otherwise, returns null to allow the action. (object)
/// </returns>
object OnMapMarkersClear(BasePlayer player, List<ProtoBuf.MapNote> mapNotes)
{
    Puts($"Player {player} is attempting to clear map markers.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, State.pointsOfInterest) != null)
		{
			return;
		}
		ServerCurrentDeathNote?.Dispose();
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				item?.Dispose();
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", this);
	}

```

## OnFuelCheck(EntityFuelSystem)

```csharp
```csharp
/// <summary>
/// Called to check if the entity has fuel available for operation.
/// </summary>
/// <param name="fuelSystem">The fuel system of the entity being checked.</param>
/// <returns>
/// Returns `true` if the entity has fuel; otherwise, returns `false`. 
/// If the method returns `null`, the default fuel check logic will be used. (bool)
/// </returns>
object OnFuelCheck(EntityFuelSystem fuelSystem)
{
    Puts($"Checking fuel status for entity: {fuelSystem}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool HasFuel(bool forceCheck = false)
	{
		if (Time.time > nextFuelCheckTime || forceCheck)
		{
			object obj = Interface.CallHook("OnFuelCheck", this);
			if (obj is bool)
			{
				return (bool)obj;
			}
			cachedHasFuel = (float)GetFuelAmount() > 0f;
			nextFuelCheckTime = Time.time + UnityEngine.Random.Range(1f, 2f);
		}
		return cachedHasFuel;
	}

```

## OnSamSiteTargetScan(SamSite,System.Collections.Generic.List<SamSite.ISamSiteTarget>)

```csharp
```csharp
/// <summary>
/// Called to scan for potential targets for the SAM site.
/// </summary>
/// <param name="samSite">The SAM site performing the target scan.</param>
/// <param name="targets">A list to populate with potential targets detected during the scan.</param>
/// <returns>No return behavior.</returns>
void OnSamSiteTargetScan(SamSite samSite, List<SamSite.ISamSiteTarget> targets)
{
    Puts($"Scanning for targets at SAM site: {samSite}.");
}
```
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (UnityEngine.Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> obj = Facepunch.Pool.Get<List<ISamSiteTarget>>();
		if (Interface.CallHook("OnSamSiteTargetScan", this, obj) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(obj, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(obj, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in obj)
		{
			if (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!ObjectEx.IsUnityNull(samSiteTarget) && currentTarget != samSiteTarget)
		{
			lockOnTime = UnityEngine.Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!ObjectEx.IsUnityNull(currentTarget))
		{
			lastTargetVisibleTime = UnityEngine.Time.time;
		}
		Facepunch.Pool.FreeUnmanaged(ref obj);
		if (ObjectEx.IsUnityNull(currentTarget))
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

```

## OnBookmarkInput(ComputerStation,BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player provides input to a computer station's bookmark feature.
/// </summary>
/// <param name="station">The computer station receiving the input.</param>
/// <param name="player">The player providing the input.</param>
/// <param name="inputState">The state of the input from the player.</param>
/// <returns>
/// Returns `null` to allow the default input handling, or a non-null value to override the default behavior. (object)
/// </returns>
object OnBookmarkInput(ComputerStation station, BasePlayer player, InputState inputState)
{
    Puts($"Player {player} provided input to bookmark on station {station}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (HasFlag(Flags.Reserved2) && currentlyControllingEnt.IsValid(serverside: true) && Interface.CallHook("OnBookmarkInput", this, player, inputState) == null)
		{
			currentlyControllingEnt.Get(serverside: true).GetComponent<IRemoteControllable>().UserInput(inputState, new CameraViewerId(player.userID, 0L));
		}
	}

```

## OnItemSkinChange(int,Item,RepairBench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player changes the skin of an item at a repair bench.
/// </summary>
/// <param name="skinId">The ID of the skin being applied.</param>
/// <param name="item">The item whose skin is being changed.</param>
/// <param name="repairBench">The repair bench where the skin change is taking place.</param>
/// <param name="player">The player changing the skin.</param>
/// <returns>
/// Returns a non-null value to prevent the skin change, or `null` to allow it. (object)
/// </returns>
object OnItemSkinChange(int skinId, Item item, RepairBench repairBench, BasePlayer player)
{
    Puts($"Player {player} is changing skin of item {item} to skin ID {skinId}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void ChangeSkin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		ItemId itemId = new ItemId(msg.read.UInt64());
		bool isValid = itemId.IsValid;
		bool flag = !isValid || UnityEngine.Time.realtimeSinceStartup > nextSkinChangeAudioTime;
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || Interface.CallHook("OnItemSkinChange", num, slot, this, player) != null || (isValid && slot.uid != itemId))
		{
			return;
		}
		bool flag2 = false;
		if (msg.player.UnlockAllSkins)
		{
			flag2 = true;
		}
		if (num != 0 && !flag2 && !player.blueprints.CheckSkinOwnership(num, player.userID))
		{
			debugprint("RepairBench.ChangeSkin player does not have item :" + num + ":");
			return;
		}
		ulong Skin = ItemDefinition.FindSkin(slot.info.itemid, num);
		if (Skin == slot.skin && slot.info.isRedirectOf == null)
		{
			debugprint("RepairBench.ChangeSkin cannot apply same skin twice : " + Skin + ": " + slot.skin);
			return;
		}
		if (flag)
		{
			nextSkinChangeAudioTime = UnityEngine.Time.realtimeSinceStartup + 0.75f;
		}
		ItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		if (slot.info.isRedirectOf != null)
		{
			Skin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, num);
			skin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		}
		ItemSkin itemSkin = ((skin.id == 0) ? null : (skin.invItem as ItemSkin));
		if (((bool)itemSkin && (itemSkin.Redirect != null || slot.info.isRedirectOf != null)) || (!itemSkin && slot.info.isRedirectOf != null))
		{
			ItemDefinition template = ((itemSkin != null) ? itemSkin.Redirect : slot.info.isRedirectOf);
			bool flag3 = false;
			if (itemSkin != null && itemSkin.Redirect == null && slot.info.isRedirectOf != null)
			{
				template = slot.info.isRedirectOf;
				flag3 = num != 0;
			}
			float condition = slot.condition;
			float maxCondition = slot.maxCondition;
			int amount = slot.amount;
			int ammoCount = 0;
			ItemDefinition ammoType = null;
			if (slot.GetHeldEntity() != null && slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
			{
				ammoCount = baseProjectile.primaryMagazine.contents;
				ammoType = baseProjectile.primaryMagazine.ammoType;
			}
			List<Item> obj = Facepunch.Pool.Get<List<Item>>();
			if (slot.contents != null && slot.contents.itemList != null && slot.contents.itemList.Count > 0)
			{
				if (slot.contents.itemList.Count > obj.Capacity)
				{
					obj.Capacity = slot.contents.itemList.Count;
				}
				foreach (Item item2 in slot.contents.itemList)
				{
					obj.Add(item2);
				}
				foreach (Item item3 in obj)
				{
					item3.RemoveFromContainer();
				}
			}
			slot.Remove();
			ItemManager.DoRemoves();
			Item item = ItemManager.Create(template, 1, 0uL);
			item.MoveToContainer(base.inventory, 0, allowStack: false);
			item.maxCondition = maxCondition;
			item.condition = condition;
			item.amount = amount;
			if (item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile baseProjectile2)
			{
				if (baseProjectile2.primaryMagazine != null)
				{
					baseProjectile2.SetAmmoCount(ammoCount);
					baseProjectile2.primaryMagazine.ammoType = ammoType;
				}
				baseProjectile2.ForceModsChanged();
			}
			if (obj.Count > 0 && item.contents != null)
			{
				foreach (Item item4 in obj)
				{
					item4.MoveToContainer(item.contents);
				}
			}
			Facepunch.Pool.Free(ref obj, freeElements: false);
			if (flag3)
			{
				ApplySkinToItem(item, Skin);
			}
			Facepunch.Rust.Analytics.Server.SkinUsed(item.info.shortname, num);
			Facepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, item, Skin);
		}
		else
		{
			ApplySkinToItem(slot, Skin);
			Facepunch.Rust.Analytics.Server.SkinUsed(slot.info.shortname, num);
			Facepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, slot, Skin);
		}
		if (flag && skinchangeEffect.isValid)
		{
			Effect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);
		}
	}

```

## OnSupplyDropDropped(BaseEntity,CargoPlane)

```csharp
```csharp
/// <summary>
/// Called when a supply drop is dropped from the cargo plane.
/// </summary>
/// <param name="entity">The entity representing the supply drop.</param>
/// <param name="cargoPlane">The cargo plane that dropped the supply.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropDropped(BaseEntity entity, CargoPlane cargoPlane)
{
    Puts($"Supply drop {entity} has been dropped from cargo plane {cargoPlane}.");
}
```
```

### Source Code from the Library

```csharp

	private void Update()
	{
		if (!base.isServer)
		{
			return;
		}
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);
			if ((bool)baseEntity)
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
				Interface.CallHook("OnSupplyDropDropped", baseEntity, this);
			}
		}
		base.transform.position = Vector3.Lerp(startPos, endPos, num);
		base.transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
	}

```

## CanUseFuel(EntityFuelSystem,StorageContainer,float,float)

```csharp
```csharp
/// <summary>
/// Called to determine if fuel can be used from a storage container for a specified duration.
/// </summary>
/// <param name="fuelSystem">The fuel system attempting to use the fuel.</param>
/// <param name="fuelContainer">The storage container holding the fuel.</param>
/// <param name="seconds">The duration for which fuel is requested.</param>
/// <param name="fuelUsedPerSecond">The amount of fuel consumed per second.</param>
/// <returns>
/// Returns the amount of fuel that can be used. If the method returns `0`, no fuel can be used. 
/// If a non-zero integer is returned, that amount of fuel will be consumed. (int)
/// </returns>
object CanUseFuel(EntityFuelSystem fuelSystem, StorageContainer fuelContainer, float seconds, float fuelUsedPerSecond)
{
    Puts($"Checking fuel usage for {fuelSystem} from container {fuelContainer} for {seconds} seconds at {fuelUsedPerSecond} per second.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanUseFuel", this, fuelContainer, seconds, fuelUsedPerSecond);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelContainer == null)
		{
			return 0;
		}
		Item slot = fuelContainer.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		pendingFuel += seconds * fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Facepunch.Rust.Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, "fuel_system");
			pendingFuel -= num;
			return num;
		}
		return 0;
	}

```

## OnLootSpawn(LootContainer)

```csharp
```csharp
/// <summary>
/// Called when loot is spawned in a loot container.
/// </summary>
/// <param name="lootContainer">The loot container where loot is being spawned.</param>
/// <returns>
/// Returns `null` to allow the default loot spawning behavior, or a non-null value to override it. (object)
/// </returns>
object OnLootSpawn(LootContainer lootContainer)
{
    Puts($"Loot is being spawned in container: {lootContainer}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				Invoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

```

## OnPlayerAssist(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player assists another player who is wounded.
/// </summary>
/// <param name="assistedPlayer">The player who is being assisted.</param>
/// <param name="assistingPlayer">The player who is providing assistance.</param>
/// <returns>
/// Returns `null` to allow the assistance action, or any non-null value to prevent it. (object)
/// </returns>
object OnPlayerAssist(BasePlayer assistedPlayer, BasePlayer assistingPlayer)
{
    Puts($"Player {assistingPlayer} is assisting wounded player {assistedPlayer}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Assist(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerAssist", this, msg.player) == null)
		{
			StopWounded(msg.player);
			msg.player.stats.Add("wounded_assisted", 1, (Stats)5);
			stats.Add("wounded_healed", 1);
		}
	}

```

## IOnServerInitialized()

```csharp
```csharp
/// <summary>
/// Called when the server has been fully initialized and is ready to accept connections.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnServerInitialized()
{
    Puts("Server has been initialized and is ready for connections.");
}
```
```

### Source Code from the Library

```csharp

	public void OpenConnection(bool useSteamServer = true)
	{
		if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
		{
			ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
		}
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		if (useSteamServer)
		{
			StartSteamServer();
		}
		else
		{
			PlatformService.Instance.Initialize(RustPlatformHooks.Instance);
		}
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			CloseConnection();
			return;
		}
		Network.Net.sv.callbackHandler = this;
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		EACServer.DoStartup();
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
		if (ConVar.Server.autoUploadMap)
		{
			MapUploader.UploadMap();
		}
		Interface.CallHook("IOnServerInitialized");
	}

```

## OnDecayDamage(DecayEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is subjected to decay damage.
/// </summary>
/// <param name="decayEntity">The entity that is decaying.</param>
/// <returns>
/// Returns `null` to allow the default decay damage behavior, or a non-null value to override it. (object)
/// </returns>
object OnDecayDamage(DecayEntity decayEntity)
{
    Puts($"Decay damage check for entity: {decayEntity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnDecay(Decay decay, float decayDeltaTime)
	{
		lastDecayTick = UnityEngine.Time.time;
		if (HasParent() || !decay.ShouldDecay(this))
		{
			return;
		}
		float num = decayDeltaTime * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if (buildingPrivilege != null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", this) == null)
				{
					float num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();
					Heal(MaxHealth() * num2);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num;
		if (decayTimer < GetEntityDecayDelay())
		{
			return;
		}
		using (TimeWarning.New("DecayTick"))
		{
			float num3 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num3 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num3 -= decayPoint.protection;
					}
				}
			}
			if (Interface.CallHook("OnDecayDamage", this) == null && num3 > 0f)
			{
				float num4 = num / GetEntityDecayDuration() * MaxHealth();
				Hurt(num4 * num3 * decayVariance, DamageType.Decay);
			}
		}
	}

```

## OnActiveItemChange(BasePlayer,Item,ItemId)

```csharp
```csharp
/// <summary>
/// Called when a player's active item changes.
/// </summary>
/// <param name="player">The player whose active item is changing.</param>
/// <param name="previousItem">The item that was previously active.</param>
/// <param name="newItemId">The ID of the new active item.</param>
/// <returns>
/// Returns a non-null value to prevent the active item change; otherwise, returns null to allow the change. (object)
/// </returns>
object OnActiveItemChange(BasePlayer player, Item previousItem, ItemId newItemId)
{
    Puts($"Player {player} changed active item from {previousItem} to item ID {newItemId}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(ItemId itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnOvenStarted(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when the oven starts cooking.
/// </summary>
/// <param name="oven">The oven that has started cooking.</param>
/// <returns>No return behavior.</returns>
void OnOvenStarted(BaseOven oven)
{
    Puts($"Oven {oven} has started cooking.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			InvokeRepeating(Cook, 0.5f, 0.5f);
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", this);
		}
	}

```

## OnSupplyDropLanded(SupplyDrop)

```csharp
```csharp
/// <summary>
/// Called when a supply drop has landed in the game world.
/// </summary>
/// <param name="supplyDrop">The supply drop that has landed.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropLanded(SupplyDrop supplyDrop)
{
    Puts($"Supply drop landed at position: {supplyDrop.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	private void OnCollisionEnter(Collision collision)
	{
		bool flag = ((1 << collision.collider.gameObject.layer) & 0x40A10111) > 0;
		if (((1 << collision.collider.gameObject.layer) & 0x8000000) > 0 && CollisionEx.GetEntity(collision) is Tugboat)
		{
			flag = true;
		}
		if (flag)
		{
			RemoveParachute();
			MakeLootable();
		}
		Interface.CallHook("OnSupplyDropLanded", this);
	}

```

## OnSignalBroadcast(BaseEntity,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a signal is broadcasted from the server to connected clients.
/// </summary>
/// <param name="entity">The entity that is broadcasting the signal.</param>
/// <param name="connection">The connection from which the signal is being sent.</param>
/// <returns>
/// Returns `null` to allow the signal to be broadcasted; any non-null value will prevent the broadcast. (object)
/// </returns>
object OnSignalBroadcast(BaseEntity entity, Network.Connection connection)
{
    Puts($"Broadcasting signal from entity {entity} to connection {connection}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", this, sourceConnection) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("SignalFromServerEx", this, SendMethod.Unreliable, Priority.Immediate), (int)signal, arg, sourceConnection?.userid ?? 0);
		}
	}

```

## OnOvenCooked(BaseOven,Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item has finished cooking in the oven.
/// </summary>
/// <param name="oven">The oven that cooked the item.</param>
/// <param name="item">The item that was cooked.</param>
/// <param name="entity">The entity associated with the cooking process.</param>
/// <returns>No return behavior.</returns>
void OnOvenCooked(BaseOven oven, Item item, BaseEntity entity)
{
    Puts($"Oven {oven} has finished cooking item {item} for entity {entity}.");
}
```
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		if (HasFlag(Flags.Reserved8))
		{
			return;
		}
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		if (item != null)
		{
			ItemModBurnable itemModBurnable = item.info.ItemModBurnable;
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, itemModBurnable);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnConstructionPlace(BaseEntity,Construction,Construction.Target,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a construction is placed in the game world.
/// </summary>
/// <param name="entity">The entity being placed.</param>
/// <param name="component">The construction component being used.</param>
/// <param name="placement">The target location for the construction.</param>
/// <param name="player">The player who is placing the construction.</param>
/// <returns>
/// Returns `null` to allow the construction to be placed, or any non-null value to prevent placement. (object)
/// </returns>
object OnConstructionPlace(BaseEntity entity, Construction component, Construction.Target placement, BasePlayer player)
{
    Puts($"Player {player} is attempting to place {entity} at {placement}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public GameObject DoPlacement(Construction.Target placement, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		BaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);
		if (!baseEntity)
		{
			return null;
		}
		float num = 1f;
		float num2 = 0f;
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			baseEntity.skinID = ownerItem.skin;
			if (ownerItem.hasCondition)
			{
				num = ownerItem.conditionNormalized;
			}
		}
		PoolableEx.AwakeFromInstantiate(baseEntity.gameObject);
		BuildingBlock buildingBlock = baseEntity as BuildingBlock;
		if ((bool)buildingBlock)
		{
			buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
			if (!buildingBlock.blockDefinition)
			{
				Debug.LogError("Placing a building block that has no block definition!");
				return null;
			}
			buildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);
			num2 = buildingBlock.currentGrade.maxHealth;
		}
		BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
		if ((bool)baseCombatEntity)
		{
			num2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);
			baseCombatEntity.ResetLifeStateOnSpawn = false;
			baseCombatEntity.InitializeHealth(num2 * num, num2);
		}
		if (Interface.CallHook("OnConstructionPlace", baseEntity, component, placement, ownerPlayer) != null)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.KillMessage();
			}
			else
			{
				GameManager.Destroy(baseEntity);
			}
			return null;
		}
		baseEntity.OnPlaced(ownerPlayer);
		baseEntity.OwnerID = ownerPlayer.userID;
		baseEntity.Spawn();
		if ((bool)buildingBlock)
		{
			Effect.server.Run("assets/bundled/prefabs/fx/build/frame_place.prefab", baseEntity, 0u, Vector3.zero, Vector3.zero);
		}
		StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
		if ((bool)stabilityEntity)
		{
			stabilityEntity.UpdateSurroundingEntities();
		}
		return baseEntity.gameObject;
	}

```

## OnGrowableStateChange(GrowableEntity,PlantProperties.State)

```csharp
```csharp
/// <summary>
/// Called when the state of a growable entity changes.
/// </summary>
/// <param name="growable">The growable entity whose state is changing.</param>
/// <param name="newState">The new state that the growable entity is transitioning to.</param>
/// <returns>
/// Returns a non-null value to prevent the state change; otherwise, returns null to allow the change. (object)
/// </returns>
object OnGrowableStateChange(GrowableEntity growable, PlantProperties.State newState)
{
    Puts($"Growable entity {growable} is changing state to {newState}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)
	{
		if (Interface.CallHook("OnGrowableStateChange", this, state) != null || (base.isServer && State == state))
		{
			return;
		}
		State = state;
		if (!base.isServer)
		{
			return;
		}
		if (!loading)
		{
			if (currentStage.resources > 0f)
			{
				yieldPool = currentStage.yield;
			}
			if (state == PlantProperties.State.Crossbreed)
			{
				if (Properties.CrossBreedEffect.isValid)
				{
					Effect.server.Run(Properties.CrossBreedEffect.resourcePath, base.transform.position, Vector3.up);
				}
				GrowableGenetics.CrossBreed(this);
			}
			SendNetworkUpdate();
		}
		if (resetAge)
		{
			stageAge = 0f;
		}
	}

```

## OnLootEntityEnd(BasePlayer,ContainerIOEntity)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="entity">The entity that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ContainerIOEntity entity)
{
    Puts($"Player {player} has stopped looting entity {entity}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Determines whether a potential target can be targeted by the helicopter turret.
/// </summary>
/// <param name="target">The potential target entity.</param>
/// <param name="turret">The helicopter turret attempting to target the entity.</param>
/// <returns>
/// Returns `true` if the target can be engaged; otherwise, returns `false`. 
/// If the method returns `null`, the default targeting logic will be applied. (bool)
/// </returns>
object CanBeTargeted(BaseCombatEntity target, HelicopterTurret turret)
{
    Puts($"Checking if target {target} can be engaged by turret {turret}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## OnRackedWeaponLoad(Item,ItemDefinition,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is loaded onto a weapon rack.
/// </summary>
/// <param name="item">The item being loaded onto the weapon rack.</param>
/// <param name="itemDefinition">The definition of the item being loaded.</param>
/// <param name="player">The player loading the weapon.</param>
/// <param name="weaponRack">The weapon rack where the item is being loaded.</param>
/// <returns>
/// Returns a non-null value to prevent the loading action; otherwise, returns null to allow it. (object)
/// </returns>
object OnRackedWeaponLoad(Item item, ItemDefinition itemDefinition, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Player {player} is loading {item} (ID: {itemDefinition.itemid}) onto the weapon rack.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!player)
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (heldEntity == null)
		{
			return;
		}
		BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
		if (component == null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null || Interface.CallHook("OnRackedWeaponLoad", slot, itemDefinition, player, this) != null)
		{
			return;
		}
		if (itemDefinition == SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!(itemDefinition != null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component2 = itemDefinition.GetComponent<ItemModProjectile>();
		if (!(component2 == null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", slot, itemDefinition, player, this);
		}
	}

```

## OnTeamUpdated(ulong,ProtoBuf.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's team information is updated.
/// </summary>
/// <param name="teamId">The ID of the team that has been updated.</param>
/// <param name="teamData">The updated team data containing members and their statuses.</param>
/// <param name="updatingPlayer">The player who initiated the team update.</param>
/// <returns>
/// Returns a non-null value to override the default team update behavior; otherwise, returns null. (object)
/// </returns>
object OnTeamUpdated(ulong teamId, ProtoBuf.PlayerTeam teamData, BasePlayer updatingPlayer)
{
    Puts($"Team {teamId} updated by player {updatingPlayer} with {teamData.members.Count} members.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TeamUpdate(bool fullTeamUpdate)
	{
		if (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)
		{
			return;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(currentTeam);
		if (playerTeam == null)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		using PlayerTeam playerTeam2 = Facepunch.Pool.Get<PlayerTeam>();
		playerTeam2.teamLeader = playerTeam.teamLeader;
		playerTeam2.teamID = playerTeam.teamID;
		playerTeam2.teamName = playerTeam.teamName;
		playerTeam2.members = Facepunch.Pool.Get<List<PlayerTeam.TeamMember>>();
		playerTeam2.teamLifetime = playerTeam.teamLifetime;
		playerTeam2.teamPings = Facepunch.Pool.Get<List<MapNote>>();
		foreach (ulong member in playerTeam.members)
		{
			BasePlayer basePlayer = RelationshipManager.FindByID(member);
			if ((bool)basePlayer && basePlayer.IsInTutorial)
			{
				continue;
			}
			PlayerTeam.TeamMember teamMember = Facepunch.Pool.Get<PlayerTeam.TeamMember>();
			teamMember.displayName = ((basePlayer != null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
			teamMember.healthFraction = ((basePlayer != null && basePlayer.IsAlive()) ? basePlayer.healthFraction : 0f);
			teamMember.position = ((basePlayer != null) ? basePlayer.transform.position : Vector3.zero);
			teamMember.online = basePlayer != null && !basePlayer.IsSleeping();
			teamMember.wounded = basePlayer != null && basePlayer.IsWounded();
			if ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) && basePlayer != null)
			{
				if ((bool)basePlayer.GetHeldEntity() && basePlayer.GetHeldEntity().IsInstrument())
				{
					num++;
				}
				if (basePlayer.isMounted)
				{
					if (basePlayer.GetMounted().IsInstrument())
					{
						num++;
					}
					if (basePlayer.GetMounted().IsSummerDlcVehicle)
					{
						num2++;
					}
				}
				if (num >= 4 && !sentInstrumentTeamAchievement)
				{
					GiveAchievement("TEAM_INSTRUMENTS");
					sentInstrumentTeamAchievement = true;
				}
				if (num2 >= 4)
				{
					GiveAchievement("SUMMER_INFLATABLE");
					sentSummerTeamAchievement = true;
				}
			}
			teamMember.userID = member;
			playerTeam2.members.Add(teamMember);
			if (basePlayer != null)
			{
				if (basePlayer.State.pings != null && basePlayer.State.pings.Count > 0 && basePlayer != this)
				{
					playerTeam2.teamPings.AddRange(basePlayer.State.pings);
				}
				if (fullTeamUpdate && basePlayer != this)
				{
					basePlayer.TeamUpdate(fullTeamUpdate: false);
				}
			}
		}
		playerTeam2.leaderMapNotes = Facepunch.Pool.Get<List<MapNote>>();
		PlayerState playerState = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(playerTeam.teamLeader);
		if (playerState?.pointsOfInterest != null)
		{
			foreach (MapNote item in playerState.pointsOfInterest)
			{
				playerTeam2.leaderMapNotes.Add(item);
			}
		}
		if (Interface.CallHook("OnTeamUpdated", currentTeam, playerTeam2, this) == null)
		{
			ClientRPC(RpcTarget.PlayerAndSpectators("CLIENT_ReceiveTeamInfo", this), playerTeam2);
			if (playerTeam2.leaderMapNotes != null)
			{
				playerTeam2.leaderMapNotes.Clear();
			}
			if (playerTeam2.teamPings != null)
			{
				playerTeam2.teamPings.Clear();
			}
			BasePlayer basePlayer2 = FindByID(playerTeam.teamLeader);
			if (fullTeamUpdate && basePlayer2 != null && basePlayer2 != this)
			{
				basePlayer2.TeamUpdate(fullTeamUpdate: false);
			}
		}
	}

```

## OnRconConnection(System.Net.IPAddress)

```csharp
```csharp
/// <summary>
/// Called when a new RCON connection is attempted.
/// </summary>
/// <param name="ipAddress">The IP address of the connecting client.</param>
/// <returns>
/// Returns a non-null value to reject the connection; otherwise, returns null to allow the connection. (object)
/// </returns>
object OnRconConnection(System.Net.IPAddress ipAddress)
{
    Puts($"RCON connection attempt from IP: {ipAddress}");
    return null;
}
```
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", iPEndPoint.Address) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					UnityEngine.Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnEntityTakeDamage(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The resource entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit, including damage details.</param>
/// <returns>
/// Returns a non-null value to prevent the default damage handling; otherwise, returns null to allow it. (object)
/// </returns>
object OnEntityTakeDamage(ResourceEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} is taking damage: {hitInfo.damageTypes.Total()}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", this, info) != null)
		{
			return;
		}
		if (resourceDispenser != null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if ((bool)baseProtection)
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnKilled(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

```

## OnOutputUpdate(IOEntity)

```csharp
```csharp
/// <summary>
/// Called to update the outputs of an IO entity.
/// </summary>
/// <param name="entity">The IO entity whose outputs are being updated.</param>
/// <returns>No return behavior.</returns>
void OnOutputUpdate(IOEntity entity)
{
    Puts($"Updating outputs for IOEntity: {entity}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void UpdateOutputs()
	{
		if (Interface.CallHook("OnOutputUpdate", this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		ensureOutputsUpdated = false;
		using (TimeWarning.New("ProcessIOOutputs"))
		{
			for (int i = 0; i < outputs.Length; i++)
			{
				IOSlot iOSlot = outputs[i];
				bool flag = true;
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if (!(iOEntity != null))
				{
					continue;
				}
				if (ioType == IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)
				{
					using (TimeWarning.New("FluidOutputProcessing"))
					{
						if (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))
						{
							flag = false;
						}
					}
				}
				int passthroughAmount = GetPassthroughAmount(i);
				iOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);
			}
		}
	}

```

## OnExcavatorResourceSet(ExcavatorArm,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the resource target for an excavator is set by a player.
/// </summary>
/// <param name="excavator">The excavator arm that is being configured.</param>
/// <param name="resourceType">The type of resource being targeted (e.g., "HQM", "Sulfur", "Stone", "Metal").</param>
/// <param name="player">The player who set the resource target.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or a non-null value to override it. (object)
/// </returns>
object OnExcavatorResourceSet(ExcavatorArm excavator, string resourceType, BasePlayer player)
{
    Puts($"Player {player} set resource target to {resourceType} for excavator {excavator}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_SetResourceTarget(RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnExcavatorResourceSet", this, text, msg.player) == null)
		{
			switch (text)
			{
			case "HQM":
				resourceMiningIndex = 0;
				break;
			case "Sulfur":
				resourceMiningIndex = 1;
				break;
			case "Stone":
				resourceMiningIndex = 2;
				break;
			case "Metal":
				resourceMiningIndex = 3;
				break;
			}
			if (!IsOn())
			{
				BeginMining();
			}
		}
	}

```

## OnPlayerPveDamage(BaseEntity,HitInfo,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to deal damage to a building block in a PvE environment.
/// </summary>
/// <param name="attacker">The entity initiating the damage (usually a player).</param>
/// <param name="hitInfo">Information about the hit, including damage types and amounts.</param>
/// <param name="buildingBlock">The building block that is being damaged.</param>
/// <returns>
/// Returns `null` to allow the default damage behavior, or any non-null value to prevent damage from occurring. (object)
/// </returns>
object OnPlayerPveDamage(BaseEntity attacker, HitInfo hitInfo, BuildingBlock buildingBlock)
{
    Puts($"Player {attacker} attempted to damage building block {buildingBlock} with hit info: {hitInfo}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer)
		{
			if (Interface.CallHook("OnPlayerPveDamage", info.Initiator, info, this) == null)
			{
				(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			}
		}
		else
		{
			if ((bool)info.Initiator && info.Initiator is BasePlayer { IsInTutorial: not false })
			{
				return;
			}
			if (HasWallpaper())
			{
				DamageType majorityDamageType = info.damageTypes.GetMajorityDamageType();
				bool flag = info.damageTypes.Contains(DamageType.Explosion);
				DamageTypeList damageTypeList = info.damageTypes.Clone();
				if (wallpaperProtection != null)
				{
					wallpaperProtection.Scale(damageTypeList);
				}
				float totalDamage = damageTypeList.Total();
				if (majorityDamageType == DamageType.Decay || flag || majorityDamageType == DamageType.Heat)
				{
					DamageWallpaper(totalDamage);
					DamageWallpaper(totalDamage, 1);
				}
				else
				{
					bool flag2 = false;
					for (int i = 0; i < propDirection.Length; i++)
					{
						if (propDirection[i].IsWeakspot(base.transform, info))
						{
							flag2 = true;
							break;
						}
					}
					DamageWallpaper(totalDamage, (!flag2) ? 1 : 0);
				}
			}
			base.Hurt(info);
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The item container from which items are being dropped.</param>
/// <returns>
/// Returns a non-null value to prevent items from being dropped, or `null` to allow the default drop behavior.
/// </returns>
object OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping items from container: {container}.");
    return null;
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			float num2 = UnityEngine.Random.Range(0f, 2f);
			item.RemoveFromContainer();
			BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
			if (baseEntity == null)
			{
				item.Remove();
				continue;
			}
			if (baseEntity is DroppedItem droppedItem && container.entityOwner is LootContainer)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;
			}
			if (num2 > 0f)
			{
				baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
				baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
			}
		}
	}

```

## OnGrowableGathered(GrowableEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a growable entity is gathered by a player.
/// </summary>
/// <param name="growable">The growable entity that was gathered.</param>
/// <param name="item">The item that was gathered from the growable entity.</param>
/// <param name="player">The player who gathered the item.</param>
/// <returns>No return behavior.</returns>
void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
{
    Puts($"Player {player} gathered {item.amount} of {item.info.shortname} from {growable}.");
}
```
```

### Source Code from the Library

```csharp

	public void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)
	{
		Item item = ItemManager.Create(Properties.pickupItem, amount, 0uL);
		if (applyCondition)
		{
			item.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);
		}
		if (eat && player != null && IsFood())
		{
			ItemModConsume component = item.info.GetComponent<ItemModConsume>();
			if (component != null)
			{
				component.DoAction(item, player);
				return;
			}
		}
		if (player != null)
		{
			Interface.CallHook("OnGrowableGathered", this, item, player);
			Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
		}
		else
		{
			item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
		}
	}

```

## OnItemDeployed(Deployer,BaseEntity,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is deployed by a player.
/// </summary>
/// <param name="deployer">The player who is deploying the item.</param>
/// <param name="baseEntity">The entity that the item is being deployed onto.</param>
/// <param name="deployedEntity">The entity that has been deployed.</param>
/// <returns>No return behavior.</returns>
void OnItemDeployed(BasePlayer deployer, BaseEntity baseEntity, BaseEntity deployedEntity)
{
    Puts($"Item deployed by {deployer} onto {baseEntity}. Deployed entity: {deployedEntity}.");
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		if (ownerPlayer.Distance(baseEntity) > 3f)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);
			return;
		}
		if (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		if (ownerPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = ownerPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null && !currentTutorialIsland.CheckPlacement(ownerPlayer, deployable, baseEntity.transform.position, baseEntity.transform.rotation))
			{
				return;
			}
		}
		Item ownerItem = GetOwnerItem();
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			baseEntity2.skinID = ownerItem.skin;
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity, ownerPlayer, ownerItem);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
			if (ownerPlayer.IsInTutorial)
			{
				TutorialIsland currentTutorialIsland2 = ownerPlayer.GetCurrentTutorialIsland();
				if (currentTutorialIsland2 != null)
				{
					currentTutorialIsland2.OnPlayerBuiltConstruction(ownerPlayer);
				}
			}
			if (GetOwnerItemDefinition() != null)
			{
				ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
				{
					WorldPosition = baseEntity2.transform.position,
					UintIdentifier = baseEntity2.prefabID,
					IntIdentifier = GetOwnerItemDefinition().itemid
				}, 1f);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity, baseEntity2);
		Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);
		if (!ownerPlayer.IsInCreativeMode || !Creative.freeBuild)
		{
			UseItemAmount(1);
		}
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a new grade.
/// </summary>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="newGrade">The new grade to which the structure is being upgraded.</param>
/// <param name="skinId">The skin ID associated with the new grade.</param>
/// <returns>No return behavior.</returns>
void OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum newGrade, ulong skinId)
{
    Puts($"Player {player} upgraded {buildingBlock} to grade {newGrade} with skin ID {skinId}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void DoUpgradeToGrade(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		ConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());
		if (constructionGrade == null)
		{
			return;
		}
		if (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
		{
			if (!(DeployVolume.LastDeployHit != null))
			{
				return;
			}
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(DeployVolume.LastDeployHit);
			if (baseEntity != null && baseEntity is BasePlayer basePlayer)
			{
				ulong currentTeam = msg.player.currentTeam;
				if (currentTeam != 0L && currentTeam == basePlayer.currentTeam)
				{
					string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
					msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);
				}
			}
		}
		else
		{
			if (Interface.CallHook("OnStructureUpgrade", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin) != null || !CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
			{
				return;
			}
			if (base.SecondsSinceAttacked < 30f)
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
				return;
			}
			if (!constructionGrade.gradeBase.alwaysUnlock && constructionGrade.gradeBase.skin != 0L && !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);
				return;
			}
			PayForUpgrade(constructionGrade, msg.player);
			if (msg.player != null)
			{
				playerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);
			}
			ClientRPC(RpcTarget.NetworkGroup("DoUpgradeEffect"), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			BuildingGrade.Enum @enum = grade;
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);
			OnSkinChanged(skinID, constructionGrade.gradeBase.skin);
			ChangeGrade(constructionGrade.gradeBase.type, playEffect: true);
			if (msg.player != null && @enum != constructionGrade.gradeBase.type)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload
				{
					NetworkIdentifier = net.ID,
					IntIdentifier = (int)constructionGrade.gradeBase.type
				}, 1f);
			}
			Interface.CallHook("OnStructureUpgraded", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
		}
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player can use the mailbox, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can use the mailbox. (bool)
/// </returns>
object CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Checking mailbox access for player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine is rotated by a player.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="player">The player who is attempting to rotate the vending machine.</param>
/// <returns>
/// Returns `null` to allow the rotation, or any non-null value to prevent the rotation from occurring. (object)
/// </returns>
object OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player} is attempting to rotate vending machine {vendingMachine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_RotateVM(RPCMessage msg)
	{
		if (Interface.CallHook("OnRotateVendingMachine", this, msg.player) == null && CanRotate())
		{
			UpdateEmptyFlag();
			if (msg.player.CanBuild() && IsInventoryEmpty())
			{
				base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
				SendNetworkUpdate();
			}
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting a lootable entity or corpse.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="corpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse corpse)
{
    Puts($"Player {player} has stopped looting the corpse {corpse}.");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to disarm a landmine trap.
/// </summary>
/// <param name="landmine">The landmine that is being disarmed.</param>
/// <param name="player">The player attempting to disarm the trap.</param>
/// <returns>
/// Returns `null` to allow the disarm action, or any non-null value to prevent it. (object)
/// </returns>
object OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts($"Player {player} is attempting to disarm landmine {landmine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if ((ulong)rpc.player.userID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			if (UnityEngine.Random.Range(0, 100) < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## OnTurretRotate(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an auto turret rotates, typically in response to player interaction.
/// </summary>
/// <param name="turret">The auto turret that is rotating.</param>
/// <param name="player">The player who triggered the rotation.</param>
/// <returns>
/// Returns `null` to allow the turret to rotate as normal, or a non-null value to prevent the rotation. (object)
/// </returns>
object OnTurretRotate(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret} is rotating due to player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void FlipAim(RPCMessage rpc)
	{
		if (!IsOnline() && IsAuthed(rpc.player) && !booting && Interface.CallHook("OnTurretRotate", this, rpc.player) == null)
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnBookmarkControlEnded(ComputerStation,BasePlayer,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a player ends control of a remote controllable entity via a bookmark.
/// </summary>
/// <param name="station">The computer station that facilitated the control.</param>
/// <param name="player">The player who ended the control.</param>
/// <param name="remoteControllable">The remote controllable entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, IRemoteControllable remoteControllable)
{
    Puts($"Player {player} has ended control of {remoteControllable} at station {station}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## CanUseGesture(BasePlayer,GestureConfig)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a specific gesture.
/// </summary>
/// <param name="player">The player attempting to use the gesture.</param>
/// <param name="gestureConfig">The configuration of the gesture being used.</param>
/// <returns>
/// Returns `true` if the player can use the gesture; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the gesture can be used. (bool)
/// </returns>
object CanUseGesture(BasePlayer player, GestureConfig gestureConfig)
{
    Puts($"Player {player} is attempting to use gesture: {gestureConfig}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool IsOwnedBy(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseGesture", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (gestureType == GestureType.NPC)
		{
			return player.IsNpc;
		}
		if (gestureType == GestureType.Cinematic)
		{
			return player.IsAdmin;
		}
		if (dlcItem != null && dlcItem.CanUse(player))
		{
			return true;
		}
		if (inventoryItem != null && player.blueprints.steamInventory.HasItem(inventoryItem.id))
		{
			return true;
		}
		return false;
	}

```

## OnClientDisconnect(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The network connection of the client that disconnected.</param>
/// <param name="reason">The reason for the client's disconnection.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnect(Network.Connection connection, string reason)
{
    Puts($"Client {connection} has disconnected. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void ReadDisconnectReason(Message packet)
	{
		string text = packet.read.String(4096);
		string text2 = packet.connection.ToString();
		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
		{
			Interface.CallHook("OnClientDisconnect", packet.connection, text);
			DebugEx.Log(text2 + " disconnecting: " + text);
		}
	}

```

## OnEntityMarkHostile(BaseCombatEntity,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile for a specified duration.
/// </summary>
/// <param name="entity">The entity that is being marked as hostile.</param>
/// <param name="duration">The duration for which the entity is marked hostile, in seconds.</param>
/// <returns>No return behavior.</returns>
void OnEntityMarkHostile(BaseCombatEntity entity, float duration)
{
    Puts($"Entity {entity} marked as hostile for {duration} seconds.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			float b = UnityEngine.Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, b);
		}
	}

```

## OnSprayRemove(SprayCanSpray,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a spray is removed from the game.
/// </summary>
/// <param name="spray">The spray can spray that is being removed.</param>
/// <param name="player">The player who initiated the removal of the spray.</param>
/// <returns>
/// Returns `null` to allow the spray to be removed, or any non-null value to prevent the removal. (object)
/// </returns>
object OnSprayRemove(SprayCanSpray spray, BasePlayer player)
{
    Puts($"Spray {spray} is being removed by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void Server_RequestWaterClear(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && Menu_WaterClear_ShowIf(player) && Interface.CallHook("OnSprayRemove", this, player) == null)
		{
			Kill();
		}
	}

```

## OnServerRestartInterrupt()

```csharp
```csharp
/// <summary>
/// Called when a server restart is interrupted by an external event or player action.
/// </summary>
/// <returns>
/// Returns a non-null value to prevent the server from being interrupted. If `null` is returned, the interruption proceeds as normal. (object)
/// </returns>
object OnServerRestartInterrupt()
{
    Puts("Server restart has been interrupted.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (SingletonComponent<ServerMgr>.Instance == null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
			SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", strNotice, iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

```

## OnPlayerRevive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is revived by another player or an item.
/// </summary>
/// <param name="reviver">The player who is reviving another player.</param>
/// <param name="revived">The player being revived.</param>
/// <returns>
/// Returns a non-null value to prevent the default revival behavior; otherwise, returns null to allow the revival. (object)
/// </returns>
object OnPlayerRevive(BasePlayer reviver, BasePlayer revived)
{
    Puts($"Player {revived} has been revived by {reviver}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Facepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if (player != ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
					player.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}

```

## OnNpcRadioChatter(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC plays radio chatter.
/// </summary>
/// <param name="npc">The NPC that is playing the radio chatter.</param>
/// <returns>
/// Returns `null` to allow the default radio chatter behavior, or a non-null value to prevent it. (object)
/// </returns>
object OnNpcRadioChatter(ScientistNPC npc)
{
    Puts($"NPC {npc} is attempting to play radio chatter.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PlayRadioChatter()
	{
		if (RadioChatterEffects.Length != 0)
		{
			if (base.IsDestroyed || base.transform == null)
			{
				CancelInvoke(PlayRadioChatter);
			}
			else if (Interface.CallHook("OnNpcRadioChatter", this) == null)
			{
				Effect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				QueueRadioChatter();
			}
		}
	}

```

## OnTechTreeNodeUnlocked(Workbench,TechTreeData.NodeInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a technology tree node is unlocked by a player at a workbench.
/// </summary>
/// <param name="workbench">The workbench where the node is being unlocked.</param>
/// <param name="node">The technology tree node that has been unlocked.</param>
/// <param name="player">The player who unlocked the node.</param>
/// <returns>
/// Returns `null` to allow the default unlocking behavior, or a non-null value to prevent the unlock. (object)
/// </returns>
object OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
{
    Puts($"Player {player} unlocked tech tree node: {node.id} at workbench: {workbench}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if (techTreeForLevel == null)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log("Node for unlock not found :" + id);
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && byID2.itemDef != null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log("Player unlocked group :" + byID.groupName);
			}
			else if (byID.itemDef != null && Interface.CallHook("OnTechTreeNodeUnlock", this, byID, player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", this, byID, player);
					Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

```

## OnAmmoUnload(BaseProjectile,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player unloads ammo from a projectile weapon.
/// </summary>
/// <param name="projectile">The projectile weapon from which ammo is being unloaded.</param>
/// <param name="item">The item representing the ammo being unloaded.</param>
/// <param name="player">The player performing the unload action.</param>
/// <returns>
/// Returns a non-null value to prevent the ammo from being unloaded, or `null` to allow the action. (object)
/// </returns>
object OnAmmoUnload(BaseProjectile projectile, Item item, BasePlayer player)
{
    Puts($"Player {player} is attempting to unload ammo from {projectile}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UnloadAmmo(Item item, BasePlayer player)
	{
		BaseProjectile component = item.GetHeldEntity().GetComponent<BaseProjectile>();
		if (!component.canUnloadAmmo || Interface.CallHook("OnAmmoUnload", component, item, player) != null || !component)
		{
			return;
		}
		int num = component.primaryMagazine.contents;
		if (num <= 0)
		{
			return;
		}
		component.SetAmmoCount(0);
		item.MarkDirty();
		SendNetworkUpdateImmediate();
		int stackable = component.primaryMagazine.ammoType.stackable;
		if (num > stackable)
		{
			int num2 = Mathf.FloorToInt(num / component.primaryMagazine.ammoType.stackable);
			num %= stackable;
			for (int i = 0; i < num2; i++)
			{
				Item item2 = ItemManager.Create(component.primaryMagazine.ammoType, stackable, 0uL);
				player.GiveItem(item2);
			}
		}
		if (num > 0)
		{
			Item item3 = ItemManager.Create(component.primaryMagazine.ammoType, num, 0uL);
			player.GiveItem(item3);
		}
	}

```

## OnPlayerRecovered(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player has recovered from a wounded state.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecovered(BasePlayer player)
{
    Puts($"Player {player} has recovered from being wounded.");
}
```
```

### Source Code from the Library

```csharp

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			if (IsCrawling())
			{
				base.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if ((bool)BaseGameMode.GetActiveGameMode(base.isServer))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", this);
		}
	}

```

## OnLiquidWeaponFired(LiquidWeapon,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a liquid weapon is fired by a player.
/// </summary>
/// <param name="liquidWeapon">The liquid weapon that is being fired.</param>
/// <param name="player">The player who fired the weapon.</param>
/// <returns>No return behavior.</returns>
void OnLiquidWeaponFired(LiquidWeapon liquidWeapon, BasePlayer player)
{
    Puts($"Liquid weapon {liquidWeapon} fired by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartFiring(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (OnCooldown())
		{
			return;
		}
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		if (CanFire(player))
		{
			CancelInvoke(FireTick);
			InvokeRepeating(FireTick, 0f, FireRate);
			SetFlag(Flags.On, b: true);
			StartCooldown(FireRate);
			if (base.isServer)
			{
				SendNetworkUpdateImmediate();
			}
			Interface.CallHook("OnLiquidWeaponFired", this, player);
		}
	}

```

## OnNetworkGroupEntered(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when an entity enters a network visibility group.
/// </summary>
/// <param name="entity">The entity that has entered the network group.</param>
/// <param name="group">The network visibility group that the entity has entered.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupEntered(BaseNetworkable entity, Network.Visibility.Group group)
{
    Puts($"Entity {entity} has entered network group: {group}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", this, group);
	}

```

## CanStackItem(Item,Item)

```csharp
```csharp
/// <summary>
/// Determines whether two items can be stacked together in the inventory.
/// </summary>
/// <param name="item">The item to check for stacking compatibility.</param>
/// <returns>
/// Returns `true` if the items can be stacked; otherwise, returns `false`.
/// If the method returns `null`, the default stacking logic will be applied. (bool)
/// </returns>
object CanStackItem(Item item)
{
    Puts($"Checking if item {this} can stack with item {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (MaxStackable() <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != item.info.condition.max)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.info.condition.max)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		if (item.skin != skin)
		{
			return false;
		}
		if (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			int num2 = ((instanceData != null) ? instanceData.dataInt : (-1));
			if (num != num2)
			{
				return false;
			}
		}
		if (item.instanceData != null && instanceData != null && (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt && item.info.Blueprint != null && item.info.Blueprint.workbenchLevelRequired == 3)))
		{
			return false;
		}
		if (instanceData != null && instanceData.subEntity.IsValid && (bool)info.GetComponent<ItemModSign>())
		{
			return false;
		}
		if (item.instanceData != null && item.instanceData.subEntity.IsValid && (bool)item.info.GetComponent<ItemModSign>())
		{
			return false;
		}
		return true;
	}

```

## OnDieselEngineToggled(DieselEngine)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled off.
/// </summary>
/// <param name="engine">The diesel engine that has been toggled.</param>
/// <returns>No return behavior.</returns>
void OnDieselEngineToggled(DieselEngine engine)
{
    Puts($"Diesel engine {engine} has been toggled off.");
}
```
```

### Source Code from the Library

```csharp

	public void EngineOff()
	{
		SetFlag(Flags.On, b: false);
		BroadcastEntityMessage("DieselEngineOff");
		Interface.CallHook("OnDieselEngineToggled", this);
	}

```

## OnPhoneDial(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone is dialed to initiate a call.
/// </summary>
/// <param name="caller">The phone controller initiating the call.</param>
/// <param name="receiver">The phone controller being called.</param>
/// <param name="player">The player making the call.</param>
/// <returns>
/// Returns `null` to allow the call to proceed, or a non-null value to prevent the call from being established. (object)
/// </returns>
object OnPhoneDial(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Player {player} is dialing from {caller} to {receiver}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CallPhone(int number)
	{
		if (number == PhoneNumber)
		{
			OnDialFailed(Telephone.DialFailReason.CallSelf);
			return;
		}
		if (TelephoneManager.GetCurrentActiveCalls() + 1 > TelephoneManager.MaxConcurrentCalls)
		{
			OnDialFailed(Telephone.DialFailReason.NetworkBusy);
			return;
		}
		PhoneController telephone = TelephoneManager.GetTelephone(number);
		if (telephone != null)
		{
			if (Interface.CallHook("OnPhoneDial", this, telephone, currentPlayer) == null)
			{
				if (telephone.serverState == Telephone.CallState.Idle && telephone.CanReceiveCall())
				{
					SetPhoneState(Telephone.CallState.Dialing);
					lastDialedNumber = number;
					activeCallTo = telephone;
					activeCallTo.ReceiveCallFrom(this);
				}
				else
				{
					OnDialFailed(Telephone.DialFailReason.Engaged);
					telephone.OnIncomingCallWhileBusy();
				}
			}
		}
		else
		{
			OnDialFailed(Telephone.DialFailReason.WrongNumber);
		}
	}

```

## OnLootEntityEnd(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="container">The dropped item container that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, DroppedItemContainer container)
{
    Puts($"Player {player} has stopped looting the container: {container}.");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		if (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)
		{
			Kill();
		}
		else
		{
			ResetRemovalTime();
			SetFlag(Flags.Open, b: false);
			SendNetworkUpdate();
		}
		EvaluateBagConditions();
	}

```

## OnInventoryItemsTake(PlayerInventory,System.Collections.Generic.List<Item>,int,int)

```csharp
```csharp
/// <summary>
/// Called when items are taken from the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory from which items are being taken.</param>
/// <param name="collect">The list of items being collected.</param>
/// <param name="itemId">The ID of the item to take.</param>
/// <param name="amount">The amount of the item to take.</param>
/// <returns>
/// Returns the number of items successfully taken from the inventory. 
/// If the hook returns a non-null integer, that value will be used instead. (int)
/// </returns>
object OnInventoryItemsTake(PlayerInventory inventory, List<Item> collect, int itemId, int amount)
{
    Puts($"Taking {amount} of item ID {itemId} from inventory.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int Take(List<Item> collect, int itemid, int amount)
	{
		object obj = Interface.CallHook("OnInventoryItemsTake", this, collect, itemid, amount);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			int num2 = containerMain.Take(collect, itemid, amount);
			num += num2;
			amount -= num2;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerBelt != null)
		{
			int num3 = containerBelt.Take(collect, itemid, amount);
			num += num3;
			amount -= num3;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerWear != null)
		{
			int num4 = containerWear.Take(collect, itemid, amount);
			num += num4;
			amount -= num4;
		}
		return num;
	}

```

## OnCargoShipHarborApproach(CargoShip,CargoNotifier)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship approaches a harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that is approaching the harbor.</param>
/// <param name="notifier">The notifier that provides information about the cargo ship's approach.</param>
/// <returns>
/// Returns a non-null value to prevent the default harbor approach behavior; otherwise, returns null to allow the approach to proceed. (object)
/// </returns>
object OnCargoShipHarborApproach(CargoShip cargoShip, CargoNotifier notifier)
{
    Puts($"Cargo ship {cargoShip} is approaching the harbor with notifier {notifier}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartHarborApproach(CargoNotifier cn)
	{
		if (Interface.CallHook("OnCargoShipHarborApproach", this, cn) != null)
		{
			return;
		}
		PlayHorn();
		isDoingHarborApproach = true;
		dockCount++;
		shouldLookAhead = false;
		if (proxManager != null)
		{
			proxManager.StartMovement();
		}
		ClearAllHarborEntitiesOnShip();
		foreach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)
		{
			if (!(allCrane == null) && !allCrane.isClient && !(allCrane.Distance2D(harborApproachPath.nodes[harborApproachPath.nodes.Count / 2].Position) > 150f))
			{
				allCrane.ReplenishContainers();
			}
		}
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
```csharp
/// <summary>
/// Called to determine if two dropped items can be combined into one.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>
/// Returns `true` if the items can be combined; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the items can be combined. (bool)
/// </returns>
object CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts($"Checking if items {item1} and {item2} can be combined.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.DestroyItem();
			di.Kill();
			Interface.CallHook("OnDroppedItemCombined", this);
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(base.transform.position, Vector3.zero, base.transform.rotation);
			}
		}
	}

```

## OnDefaultItemsReceived(PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when default items are received by a player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory receiving the default items.</param>
/// <returns>No return behavior.</returns>
void OnDefaultItemsReceived(PlayerInventory inventory)
{
    Puts($"Default items have been received for inventory: {inventory}.");
}
```
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);
			}
		}
	}

```

## OnEntityLeave(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger area.
/// </summary>
/// <param name="entity">The entity that has left the trigger area.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity} has left the trigger area.");
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityLeave(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			_players.Remove(basePlayer);
		}
	}

```

## CanBeHomingTargeted(PatrolHelicopter)

```csharp
```csharp
/// <summary>
/// Determines whether the specified patrol helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The patrol helicopter to check.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the helicopter can be targeted. (bool)
/// </returns>
object CanBeHomingTargeted(PatrolHelicopter helicopter)
{
    Puts($"Checking homing target for Patrol Helicopter ID: {helicopter.net.ID}, Position: {helicopter.transform.position}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is about to patrol its designated path.
/// </summary>
/// <param name="apc">The Bradley APC that is patrolling.</param>
/// <returns>
/// Returns a non-null value to override the default patrol behavior, or `null` to allow the patrol to proceed as normal. (object)
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC {apc} is preparing to patrol.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		IAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		IAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);
		bool flag = false;
		List<IAIPathNode> nodes = Facepunch.Pool.Get<List<IAIPathNode>>();
		IAIPathNode iAIPathNode;
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			iAIPathNode = nodes[nodes.Count - 1];
		}
		else
		{
			iAIPathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.Position) > 2f))
		{
			return;
		}
		if (closestToPoint == iAIPathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.Position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
		else
		{
			if (!AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].Position);
				}
			}
			foreach (IAIPathNode item in path)
			{
				currentPath.Add(item.Position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
	}

```

## OnAdventGiftAwarded(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an advent gift is awarded to a player.
/// </summary>
/// <param name="calendar">The advent calendar instance managing the gifts.</param>
/// <param name="player">The player receiving the gift.</param>
/// <returns>No return behavior.</returns>
void OnAdventGiftAwarded(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Gift awarded to player {player} from advent calendar {calendar}.");
}
```
```

### Source Code from the Library

```csharp

	public void AwardGift(BasePlayer player)
	{
		if (Interface.CallHook("OnAdventGiftAward", this, player) != null)
		{
			return;
		}
		DateTime now = DateTime.Now;
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) == startMonth && num >= 0 && num < days.Length)
		{
			if (!playerRewardHistory.ContainsKey(player.userID))
			{
				playerRewardHistory.Add(player.userID, new List<int>());
			}
			playerRewardHistory[player.userID].Add(num);
			Effect.server.Run(giftEffect.resourcePath, player.transform.position);
			if (num >= 0 && num < crosses.Length)
			{
				Effect.server.Run(boxCloseEffect.resourcePath, base.transform.position + Vector3.up * 1.5f);
			}
			DayReward dayReward = days[num];
			for (int i = 0; i < dayReward.rewards.Length; i++)
			{
				ItemAmount itemAmount = dayReward.rewards[i];
				player.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);
			}
			Interface.CallHook("OnAdventGiftAwarded", this, player);
		}
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player ends their sleep state.
/// </summary>
/// <param name="player">The player who has ended their sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player} has ended their sleep.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", this) == null)
		{
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: true);
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if ((ulong)userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			CancelInvoke(ScheduledDeath);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
			}
			InvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				RemoveFromTriggers();
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", this);
			EACServer.LogPlayerSpawn(this);
			if (TotalPingCount > 0)
			{
				SendPingsToClient();
			}
			if (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))
			{
				ClientRPC(RpcTarget.Player("PromptToStartTutorial", this));
			}
		}
	}

```

## OnAmmoSwitch(BaseProjectile,BasePlayer,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when a player switches the ammunition type for a projectile weapon.
/// </summary>
/// <param name="projectile">The projectile weapon that is having its ammo switched.</param>
/// <param name="player">The player who is switching the ammo.</param>
/// <param name="newAmmo">The new ammunition type being switched to.</param>
/// <returns>
/// Returns `null` to allow the ammo switch, or a non-null value to prevent it. (object)
/// </returns>
object OnAmmoSwitch(BaseProjectile projectile, BasePlayer player, ItemDefinition newAmmo)
{
    Puts($"Player {player} is switching ammo to {newAmmo} for projectile {projectile}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnAmmoSwitch", this, ownerPlayer, itemDefinition) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				SetAmmoCount(0);
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnInterferenceOthersUpdate(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to update interference status for other auto turrets in the vicinity.
/// </summary>
/// <param name="turret">The auto turret that is updating its interference status.</param>
/// <returns>No return behavior.</returns>
void OnInterferenceOthersUpdate(AutoTurret turret)
{
    Puts($"Updating interference status for turret: {turret}.");
}
```
```

### Source Code from the Library

```csharp

	public void UpdateInterferenceOnOthers()
	{
		if (Interface.CallHook("OnInterferenceOthersUpdate", this) != null)
		{
			return;
		}
		foreach (AutoTurret nearbyTurret in nearbyTurrets)
		{
			if (nearbyTurret != null)
			{
				nearbyTurret.TryRegisterForInterferenceUpdate();
			}
		}
	}

```

## OnEntityDeath(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The resource entity that has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(ResourceEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} has been killed. Hit info: {hitInfo}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnKilled(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", this, info);
		Kill();
	}

```

## OnFireworkExhausted(BaseFirework)

```csharp
```csharp
/// <summary>
/// Called when a firework has exhausted its fuel and finished its display.
/// </summary>
/// <param name="firework">The firework that has been exhausted.</param>
/// <returns>No return behavior.</returns>
void OnFireworkExhausted(BaseFirework firework)
{
    Puts($"Firework {firework} has exhausted its fuel and is now finished.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnExhausted()
	{
		SetFlag(Flags.Reserved8, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.OnFire, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		EnableGlobalBroadcast(wants: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkExhausted", this);
		Invoke(Cleanup, corpseDuration);
		_activeFireworks.Remove(this);
	}

```

## OnVehicleLockRequest(ModularCarGarage,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player requests to add a lock to a vehicle.
/// </summary>
/// <param name="garage">The modular car garage where the lock is being requested.</param>
/// <param name="player">The player making the lock request.</param>
/// <param name="lockCode">The code for the lock being requested.</param>
/// <returns>
/// Returns `null` to allow the lock to be added, or any non-null value to prevent the action. (object)
/// </returns>
object OnVehicleLockRequest(ModularCarGarage garage, BasePlayer player, string lockCode)
{
    Puts($"Player {player} requested to add a lock with code '{lockCode}' to the vehicle in garage {garage}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_RequestAddLock(RPCMessage msg)
	{
		if (!HasOccupant || carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (player == null)
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("OnVehicleLockRequest", this, player, text) == null)
		{
			ItemAmount itemAmount = lockResourceCost;
			if ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && carOccupant.CarLock.TryAddALock(text, player.userID))
			{
				player.inventory.Take(null, itemAmount.itemDef.itemid, Mathf.CeilToInt(itemAmount.amount));
				Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnServerInformationUpdated()

```csharp
```csharp
/// <summary>
/// Called when the server information is updated, allowing for external hooks to modify or respond to the update.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerInformationUpdated()
{
    Puts("Server information has been updated.");
}
```
```

### Source Code from the Library

```csharp

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		using (TimeWarning.New("UpdateServerInformation"))
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.GetServerBrowserMapName();
			string value = "stok";
			if (Restarting)
			{
				value = "strst";
			}
			string text = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text2 = $"gm{GamemodeName()}";
			string text3 = (ConVar.Server.pve ? ",pve" : string.Empty);
			string text4 = ConVar.Server.tags?.Trim(',') ?? "";
			string text5 = ((!string.IsNullOrWhiteSpace(text4)) ? ("," + text4) : "");
			string text6 = BuildInfo.Current?.Scm?.ChangeId ?? "0";
			string text7 = PingEstimater.GetCachedClosestRegion().Code;
			if (!string.IsNullOrEmpty(ConVar.Server.ping_region_code_override))
			{
				text7 = ConVar.Server.ping_region_code_override;
			}
			SteamServer.GameTags = ServerTagCompressor.CompressTags($"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},$r{text7},v{2564}{text3}{text5},{text},{text2},cs{text6}");
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = ConVar.Server.description.SplitToChunks(100).ToArray();
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			SteamServer.SetKey("status", value);
			string value2 = World.Seed.ToString();
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			if (activeGameMode != null && !activeGameMode.ingameMap)
			{
				value2 = "0";
			}
			SteamServer.SetKey("world.seed", value2);
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("logoimage", ConVar.Server.logoimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			if (!string.IsNullOrWhiteSpace(ConVar.Server.favoritesEndpoint))
			{
				SteamServer.SetKey("favendpoint", ConVar.Server.favoritesEndpoint);
			}
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("uptime", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("ram_sys", (Performance.report.memoryUsageSystem / 1000000).ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
		Interface.CallHook("OnServerInformationUpdated");
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when a quarry gathers resources and produces items.
/// </summary>
/// <param name="quarry">The mining quarry that is gathering resources.</param>
/// <param name="item">The item that has been produced by the quarry.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being added to the container. 
/// If `null` is returned, the item will be processed normally. (object)
/// </returns>
object OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts($"Quarry {quarry} has gathered item: {item.info.shortname} (Amount: {item.amount}).");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
		float num = Mathf.Min(workToAdd, pendingWork);
		pendingWork -= num;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			float workNeeded = resource.workNeeded;
			int num2 = Mathf.FloorToInt(resource.workDone / workNeeded);
			resource.workDone += num;
			int num3 = Mathf.FloorToInt(resource.workDone / workNeeded);
			if (resource.workDone > workNeeded)
			{
				resource.workDone %= workNeeded;
			}
			if (num2 != num3)
			{
				int iAmount = num3 - num2;
				Item item = ItemManager.Create(resource.type, iAmount, 0uL);
				Facepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);
				if (Interface.CallHook("OnQuarryGather", this, item) != null)
				{
					item.Remove();
				}
				else if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
	}

```

## OnVehicleModuleSelect(Item,ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player selects a vehicle module from the garage.
/// </summary>
/// <param name="item">The item representing the vehicle module being selected.</param>
/// <param name="garage">The modular car garage from which the module is being selected.</param>
/// <param name="player">The player who is selecting the module.</param>
/// <returns>
/// Returns a non-null value to prevent the selection action; otherwise, returns null to allow it. (object)
/// </returns>
object OnVehicleModuleSelect(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player} selected vehicle module: {item} from garage: {garage}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!ObjectEx.IsUnityNull(container))
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!ObjectEx.IsUnityNull(container2))
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## OnRackedWeaponTaken(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is taken from a weapon rack by a player.
/// </summary>
/// <param name="item">The item that represents the weapon being taken.</param>
/// <param name="player">The player who is taking the weapon.</param>
/// <param name="rack">The weapon rack from which the weapon is being taken.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponTaken(Item item, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player} has taken weapon {item} from rack {rack}.");
}
```
```

### Source Code from the Library

```csharp

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", slot, player, this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		if (slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex))
		{
			if ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1)
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", slot, player, this);
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford to upgrade a building block to a specified grade.
/// </summary>
/// <param name="player">The player attempting to perform the upgrade.</param>
/// <param name="block">The building block being upgraded.</param>
/// <param name="grade">The target grade for the upgrade.</param>
/// <param name="skin">The skin ID for the upgrade.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can afford the upgrade. (bool)
/// </returns>
object CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade, ulong skin)
{
    Puts($"Player {player} is attempting to upgrade {block} to grade {grade} with skin {skin}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade, iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player != null && player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		foreach (ItemAmount item in blockDefinition.GetGrade(iGrade, iSkin).CostToBuild(grade))
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## CanLootEntity(BasePlayer,ContainerIOEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity that is being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity; otherwise, returns `false`. 
/// If the method returns a non-null value, it indicates that looting is not allowed. (bool)
/// </returns>
object CanLootEntity(BasePlayer player, ContainerIOEntity entity)
{
    Puts($"Player {player} is attempting to loot entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (needsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if ((onlyOneUser && IsOpen()) || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, StorageContainer.LockedMessage, false);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = lootPanelName;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(_inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnEntityFromOwnerCheck(BaseEntity,BasePlayer,uint,string)

```csharp
```csharp
/// <summary>
/// Called to check if an entity belongs to a specific player based on ownership rules.
/// </summary>
/// <param name="entity">The entity being checked for ownership.</param>
/// <param name="player">The player whose ownership is being verified.</param>
/// <param name="id">An identifier for the check operation.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <returns>
/// Returns `true` if the entity belongs to the player, `false` otherwise. 
/// If the method returns `null`, the default ownership logic will be applied. (bool)
/// </returns>
object OnEntityFromOwnerCheck(BaseEntity entity, BasePlayer player, uint id, string debugName)
{
    Puts($"Checking ownership for entity {entity} by player {player} with ID {id}.");
    return null;
}
```
```

### Source Code from the Library

```csharp
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityFromOwnerCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				return true;
			}

```

## OnCupboardAuthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is authorized to a cupboard (Building Privilege).
/// </summary>
/// <param name="cupboard">The cupboard being authorized.</param>
/// <param name="player">The player being authorized to the cupboard.</param>
/// <returns>
/// Returns a non-null value to prevent the player from being authorized; otherwise, returns null to allow authorization. (object)
/// </returns>
object OnCupboardAuthorize(BuildingPrivlidge cupboard, BasePlayer player)
{
    Puts($"Player {player} is attempting to authorize to cupboard {cupboard}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal void OnDeployed(BaseEntity ent, BasePlayer player)
	{
		if (player.IsValid() && !string.IsNullOrEmpty(UnlockAchievement))
		{
			player.GiveAchievement(UnlockAchievement);
		}
		if (ent is BuildingPrivlidge buildingPrivlidge && Interface.CallHook("OnCupboardAuthorize", buildingPrivlidge, player) == null)
		{
			buildingPrivlidge.AddPlayer(player, player.userID);
		}
	}

```

## OnEntityMarkHostile(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile for a specified duration.
/// </summary>
/// <param name="player">The player entity being marked as hostile.</param>
/// <param name="duration">The duration in seconds for which the entity is marked hostile.</param>
/// <returns>
/// Returns `null` to allow the default hostile marking behavior, or any non-null value to override it. (object)
/// </returns>
object OnEntityMarkHostile(BasePlayer player, float duration)
{
    Puts($"Entity {player} marked as hostile for {duration} seconds.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			double currentTimestamp = TimeEx.currentTimestamp;
			double val = currentTimestamp + (double)duration;
			State.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);
			DirtyPlayerState();
			double num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);
			ClientRPC(RpcTarget.Player("SetHostileLength", this), (float)num);
		}
	}

```

## OnMagazineReload(BaseProjectile,IAmmoContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when attempting to reload the magazine of a projectile weapon.
/// </summary>
/// <param name="projectile">The projectile weapon that is being reloaded.</param>
/// <param name="ammoSource">The source of the ammunition for reloading.</param>
/// <param name="player">The player who owns the weapon.</param>
/// <returns>
/// Returns `true` if the magazine was successfully reloaded; otherwise, returns `false`. 
/// If the method returns `null`, the default reload logic will be applied. (bool)
/// </returns>
object OnMagazineReload(BaseProjectile projectile, IAmmoContainer ammoSource, BasePlayer player)
{
    Puts($"Attempting to reload magazine for {projectile} by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount = -1)
	{
		object obj = Interface.CallHook("OnMagazineReload", this, ammoSource, GetOwnerPlayer());
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!TryReload(ammoSource, desiredAmount))
		{
			return false;
		}
		SendNetworkUpdateImmediate();
		ItemManager.DoRemoves();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer != null)
		{
			ownerPlayer.inventory.ServerUpdate(0f);
		}
		return true;
	}

```

## OnSendModelState(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when sending the model state of a player to clients.
/// </summary>
/// <param name="player">The player whose model state is being sent.</param>
/// <returns>
/// Returns `null` to allow the default model state to be sent. If a non-null value is returned, it overrides the default behavior. (object)
/// </returns>
object OnSendModelState(BasePlayer player)
{
    Puts($"Sending model state for player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendModelState(bool force = false)
	{
		if (!force && (!wantsSendModelState || nextModelStateUpdate > UnityEngine.Time.time))
		{
			return;
		}
		wantsSendModelState = false;
		nextModelStateUpdate = UnityEngine.Time.time + 0.1f;
		if (!IsDead() && !IsSpectating())
		{
			modelState.sleeping = IsSleeping();
			modelState.mounted = isMounted;
			modelState.relaxed = IsRelaxed();
			modelState.onPhone = HasActiveTelephone && !activeTelephone.IsMobile;
			modelState.crawling = IsCrawling();
			if (!base.limitNetworking && Interface.CallHook("OnSendModelState", this) == null)
			{
				modelState.loading = IsLoadingAfterTransfer();
				ClientRPC(RpcTarget.NetworkGroup("OnModelState"), modelState);
			}
		}
	}

```

## OnFireworkDesignChange(PatternFirework,ProtoBuf.PatternFirework.Design,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the design of a firework is changed by a player.
/// </summary>
/// <param name="firework">The firework whose design is being changed.</param>
/// <param name="design">The new design for the firework.</param>
/// <param name="player">The player making the change.</param>
/// <returns>
/// Returns a non-null value to prevent the design change, or `null` to allow it. (object)
/// </returns>
object OnFireworkDesignChange(PatternFirework firework, ProtoBuf.PatternFirework.Design design, BasePlayer player)
{
    Puts($"Player {player} is changing the design of firework {firework}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		ProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);
		if (Interface.CallHook("OnFireworkDesignChange", this, design, rpc.player) != null)
		{
			return;
		}
		if (design?.stars != null)
		{
			while (design.stars.Count > MaxStars)
			{
				int index = design.stars.Count - 1;
				design.stars[index].Dispose();
				design.stars.RemoveAt(index);
			}
			foreach (ProtoBuf.PatternFirework.Star star in design.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			design.editedBy = rpc.player.userID;
		}
		Design?.Dispose();
		Design = design;
		Interface.CallHook("OnFireworkDesignChanged", this, design, rpc.player);
		SendNetworkUpdateImmediate();
	}

```

## CanVendingAcceptItem(VendingMachine,Item,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a vending machine can accept a specific item for a given slot.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being offered to the vending machine.</param>
/// <param name="targetSlot">The slot in the vending machine where the item is to be placed.</param>
/// <returns>
/// Returns `true` if the item can be accepted by the vending machine; otherwise, returns `false`. 
/// If the method returns `null`, the default acceptance logic will be applied. (bool)
/// </returns>
object CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)
{
    Puts($"Checking if vending machine can accept item {item} in slot {targetSlot}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (transactionActive || industrialItemIncoming)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (base.inventory.itemList.Contains(item))
		{
			return true;
		}
		if (basePlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(basePlayer);
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container to which the item is being added.</param>
/// <param name="item">The item that is being added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item} has been added to container {container}.");
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## OnFeedbackReported(BasePlayer,string,string,Facepunch.Models.ReportType)

```csharp
```csharp
/// <summary>
/// Called when feedback is reported by a player.
/// </summary>
/// <param name="player">The player who reported the feedback.</param>
/// <param name="subject">The subject of the feedback report.</param>
/// <param name="message">The detailed message of the feedback report.</param>
/// <param name="reportType">The type of report being submitted.</param>
/// <returns>
/// Returns a non-null value to override the default feedback reporting behavior. 
/// If `null` is returned, the feedback will be processed as normal. (object)
/// </returns>
object OnFeedbackReported(BasePlayer player, string subject, string message, Facepunch.Models.ReportType reportType)
{
    Puts($"Feedback reported by {player.displayName}: {subject} - {message} (Type: {reportType})");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnFeedbackReport(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		ReportType reportType = (ReportType)Mathf.Clamp(msg.read.Int32(), 0, 5);
		if (ConVar.Server.printReportsToConsole)
		{
			DebugEx.Log($"[FeedbackReport] {this} reported {reportType} - \"{text}\" \"{text2}\"");
			RCon.Broadcast(RCon.LogType.Report, new
			{
				PlayerId = UserIDString,
				PlayerName = displayName,
				Subject = text,
				Message = text2,
				Type = reportType
			});
		}
		if (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))
		{
			string image = msg.read.StringMultiLine(60000);
			Facepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);
			feedback.Type = reportType;
			feedback.Message = text2;
			feedback.Subject = text;
			Facepunch.Models.Feedback feedback2 = feedback;
			feedback2.AppInfo.Image = image;
			Facepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2);
			Interface.CallHook("OnFeedbackReported", this, text, text2, reportType);
		}
	}

```

## OnQueueCycle(int)

```csharp
```csharp
/// <summary>
/// Called to handle the cycling of a queue, allowing players to join the game if slots are available.
/// </summary>
/// <param name="availableSlots">The number of slots available for players to join.</param>
/// <returns>No return behavior.</returns>
void OnQueueCycle(int availableSlots)
{
    Puts($"Queue cycle initiated with {availableSlots} available slots.");
}
```
```

### Source Code from the Library

```csharp

	public void Cycle(int availableSlots)
	{
		if (Interface.CallHook("OnQueueCycle", availableSlots) != null)
		{
			return;
		}
		if (UnityEngine.Time.realtimeSinceStartup > nextCleanupReservedSlots)
		{
			nextCleanupReservedSlots = UnityEngine.Time.realtimeSinceStartup + 1f;
			CleanupExpiredReservedSlots();
		}
		if (queue.Count != 0)
		{
			if (availableSlots - Joining > 0)
			{
				JoinGame(queue[0]);
			}
			SendMessages();
		}
	}

```

## CanMoveItem(Item,PlayerInventory,ItemContainerId,int,int,ItemMoveModifier)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be moved from one container to another by a player.
/// </summary>
/// <param name="item">The item being moved.</param>
/// <param name="playerInventory">The inventory of the player attempting to move the item.</param>
/// <param name="itemContainerId">The ID of the container the item is being moved to.</param>
/// <param name="slot">The slot in the target container where the item will be placed.</param>
/// <param name="amount">The amount of the item to move.</param>
/// <param name="modifier">Any modifiers affecting the item move operation.</param>
/// <returns>
/// Returns `true` if the item can be moved; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the item can be moved. (bool)
/// </returns>
object CanMoveItem(Item item, PlayerInventory playerInventory, ItemContainerId itemContainerId, int slot, int amount, ItemMoveModifier modifier)
{
    Puts($"Checking if item {item} can be moved to container {itemContainerId} at slot {slot}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	public void MoveItem(BaseEntity.RPCMessage msg)
	{
		if (base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		ItemContainerId itemContainerId = msg.read.ItemContainerID();
		int num = msg.read.Int8();
		int num2 = (int)msg.read.UInt32();
		ItemMoveModifier itemMoveModifier = (ItemMoveModifier)msg.read.Int32();
		Item item = FindItemByUID(id);
		if (item == null)
		{
			msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidItem, false);
			ConstructionErrors.Log(msg.player, id.ToString());
		}
		else
		{
			if (Interface.CallHook("CanMoveItem", item, this, itemContainerId, num, num2, itemMoveModifier) != null)
			{
				return;
			}
			BaseEntity entityOwner = item.GetEntityOwner();
			if (entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering)
			{
				return;
			}
			if (!CanMoveItemsFrom(entityOwner, item))
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.CannotMoveItem, true);
				return;
			}
			if (num2 <= 0)
			{
				num2 = item.amount;
			}
			num2 = Mathf.Clamp(num2, 1, item.MaxStackable());
			if (msg.player.GetActiveItem() == item)
			{
				msg.player.UpdateActiveItem(default(ItemId));
			}
			if (!itemContainerId.IsValid)
			{
				BaseEntity baseEntity = entityOwner;
				if (loot.containers.Count > 0)
				{
					if (entityOwner == base.baseEntity)
					{
						if (!itemMoveModifier.HasFlag(ItemMoveModifier.Alt))
						{
							baseEntity = loot.entitySource;
						}
					}
					else
					{
						baseEntity = base.baseEntity;
					}
				}
				if (baseEntity is IIdealSlotEntity idealSlotEntity)
				{
					itemContainerId = idealSlotEntity.GetIdealContainer(base.baseEntity, item, itemMoveModifier);
					if (itemContainerId == ItemContainerId.Invalid)
					{
						return;
					}
				}
				ItemContainer parent = item.parent;
				if (parent != null && parent.IsLocked())
				{
					msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
					return;
				}
				if (!itemContainerId.IsValid)
				{
					if (baseEntity == loot.entitySource)
					{
						foreach (ItemContainer container in loot.containers)
						{
							if (!container.PlayerItemInputBlocked() && !container.IsLocked() && item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))
							{
								break;
							}
						}
						return;
					}
					if (!GiveItem(item, itemMoveModifier))
					{
						msg.player.ShowToast(GameTip.Styles.Error, "GiveItem failed!", true);
					}
					return;
				}
			}
			ItemContainer itemContainer = FindContainer(itemContainerId);
			if (itemContainer == null)
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidContainer, false);
				ConstructionErrors.Log(msg.player, itemContainerId.ToString());
				return;
			}
			if (itemContainer.IsLocked())
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
				return;
			}
			if (itemContainer.PlayerItemInputBlocked())
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.DoesntAcceptPlayerItems, false);
				return;
			}
			if (itemContainer.maxStackSize > 0)
			{
				num2 = Mathf.Clamp(num2, 1, itemContainer.maxStackSize);
			}
			using (TimeWarning.New("Split"))
			{
				if (item.amount > num2)
				{
					int split_Amount = num2;
					Item item2 = item.SplitItem(split_Amount);
					Item slot = itemContainer.GetSlot(num);
					if (slot != null && !item.CanStack(slot) && item.parent != null && !item2.MoveToContainer(item.parent, -1, allowStack: false, ignoreStackLimit: false, base.baseEntity, allowSwap: false))
					{
						item.amount += item2.amount;
						item2.Remove();
						ItemManager.DoRemoves();
						ServerUpdate(0f);
						return;
					}
					if (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))
					{
						item.amount += item2.amount;
						item2.Remove();
					}
					else
					{
						item.parent.onItemRemovedFromStack?.Invoke(item, num2);
					}
					ItemManager.DoRemoves();
					ServerUpdate(0f);
					return;
				}
			}
			if (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))
			{
				ItemManager.DoRemoves();
				ServerUpdate(0f);
			}
		}
	}

```

## OnBuildingMerge(ServerBuildingManager,BuildingManager.Building,BuildingManager.Building)

```csharp
```csharp
/// <summary>
/// Called when two buildings are merged in the server's building manager.
/// </summary>
/// <param name="manager">The server building manager handling the merge.</param>
/// <param name="building1">The first building involved in the merge.</param>
/// <param name="building2">The second building involved in the merge.</param>
/// <returns>No return behavior.</returns>
void OnBuildingMerge(ServerBuildingManager manager, BuildingManager.Building building1, BuildingManager.Building building2)
{
    Puts($"Merging buildings: {building1.ID} and {building2.ID}.");
}
```
```

### Source Code from the Library

```csharp

	private void Merge(Building building1, Building building2)
	{
		Interface.CallHook("OnBuildingMerge", this, building1, building2);
		while (building2.HasDecayEntities())
		{
			building2.decayEntities[0].AttachToBuilding(building1.ID);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building1.isNavMeshCarvingDirty = true;
			building2.isNavMeshCarvingDirty = true;
			int ticks = 3;
			UpdateNavMeshCarver(building1, ref ticks, 0);
			UpdateNavMeshCarver(building1, ref ticks, 0);
		}
	}

```

## CanLock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can lock a code lock.
/// </summary>
/// <param name="player">The player attempting to lock the code lock.</param>
/// <param name="codeLock">The code lock being interacted with.</param>
/// <returns>
/// Returns `null` to allow the locking action, or a non-null value to prevent it. (object)
/// </returns>
object CanLock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player} is attempting to lock the code lock: {codeLock}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", rpc.player, this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnCrateDropped(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate is dropped in the game world.
/// </summary>
/// <param name="crate">The hackable locked crate that has been dropped.</param>
/// <returns>No return behavior.</returns>
void OnCrateDropped(HackableLockedCrate crate)
{
    Puts($"Hackable locked crate {crate} has been dropped.");
}
```
```

### Source Code from the Library

```csharp

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", this);
	}

```

## OnConnectionDequeue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a connection is dequeued from the server's connection queue.
/// </summary>
/// <param name="connection">The connection that is being dequeued.</param>
/// <returns>
/// Returns a non-null value to prevent the connection from being removed from the queue. 
/// If `null` is returned, the connection will be removed as normal. (object)
/// </returns>
object OnConnectionDequeue(Network.Connection connection)
{
    Puts($"Connection {connection} is being dequeued.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RemoveConnection(Connection connection)
	{
		if (Interface.CallHook("OnConnectionDequeue", connection) == null)
		{
			if (queue.Remove(connection))
			{
				nextMessageTime = 0f;
			}
			joining.Remove(connection);
		}
	}

```

## OnSendCommand(Network.Connection,string,object[])

```csharp
```csharp
/// <summary>
/// Called when a command is sent to a client.
/// </summary>
/// <param name="connection">The network connection of the client receiving the command.</param>
/// <param name="command">The command being sent.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>
/// Returns `null` to allow the command to be sent, or any non-null value to prevent the command from being sent. (object)
/// </returns>
object OnSendCommand(Network.Connection connection, string command, object[] args)
{
    Puts($"Sending command '{command}' to connection {connection} with arguments: {string.Join(", ", args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(Connection cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnSendCommand", cn, strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			string val = ConsoleSystem.BuildCommand(strCommand, args);
			netWrite.String(val);
			netWrite.Send(new SendInfo(cn));
		}
	}

```

## OnLootNetworkUpdate(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called to update the loot network state for a player.
/// </summary>
/// <param name="loot">The player loot instance that is being updated.</param>
/// <returns>
/// Returns `null` to allow the default update behavior, or any non-null value to prevent the update. (object)
/// </returns>
object OnLootNetworkUpdate(PlayerLoot loot)
{
    Puts($"Updating loot network for player loot: {loot}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SendUpdate()
	{
		isInvokingSendUpdate = false;
		if (!base.baseEntity.IsValid() || Interface.CallHook("OnLootNetworkUpdate", this) != null)
		{
			return;
		}
		using PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		if ((bool)entitySource && entitySource.net != null)
		{
			playerUpdateLoot.entityID = entitySource.net.ID;
		}
		if (itemSource != null)
		{
			playerUpdateLoot.itemID = itemSource.uid;
		}
		if (containers.Count > 0)
		{
			playerUpdateLoot.containers = Pool.Get<List<ProtoBuf.ItemContainer>>();
			foreach (ItemContainer container in containers)
			{
				playerUpdateLoot.containers.Add(container.Save());
			}
		}
		base.baseEntity.ClientRPC(RpcTarget.Player("UpdateLoot", base.baseEntity), playerUpdateLoot);
	}

```

## CanUnlockTechTreeNode(BasePlayer,TechTreeData.NodeInstance,TechTreeData)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a specific node in the tech tree.
/// </summary>
/// <param name="player">The player attempting to unlock the tech tree node.</param>
/// <param name="node">The tech tree node that the player wants to unlock.</param>
/// <param name="techTree">The tech tree containing the node.</param>
/// <returns>
/// Returns `true` if the player can unlock the node, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can unlock the node. (bool)
/// </returns>
object CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
{
    Puts($"Player {player} is attempting to unlock tech tree node: {node}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerCanUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNode", player, node, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerHasPathForUnlock(player, node))
		{
			return !HasPlayerUnlocked(player, node);
		}
		return false;
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
```csharp
/// <summary>
/// Determines whether a specified combat entity can be targeted by an auto turret.
/// </summary>
/// <param name="target">The combat entity that is being checked for targeting.</param>
/// <param name="turret">The auto turret attempting to target the entity.</param>
/// <returns>
/// Returns `true` if the entity can be targeted; otherwise, returns `false`. 
/// If the method returns `null`, the default targeting logic will be applied. (bool)
/// </returns>
object CanBeTargeted(BaseCombatEntity target, AutoTurret turret)
{
    Puts($"Checking if {target} can be targeted by turret {turret}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.Get<List<RaycastHit>>();
		Vector3 position = eyePos.transform.position;
		if (GamePhysics.CheckSphere(position, 0.1f, 2097152))
		{
			return false;
		}
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);
		for (int i = 0; (float)i < (CheckPeekers() ? 3f : 1f); i++)
		{
			Vector3 normalized = (vector + vector2 * visibilityOffsets[i] - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);
			for (int j = 0; j < obj3.Count; j++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);
				if ((!(entity != null) || !entity.isClient) && (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) && (!(entity != null) || !entity.EqualNetID(this)))
				{
					if (entity != null && (entity == obj || entity.EqualNetID(obj)))
					{
						Facepunch.Pool.FreeUnmanaged(ref obj3);
						peekIndex = i;
						return true;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj3);
		return false;
	}

```

## OnCollectiblePickup(CollectibleEntity,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a collectible entity is picked up by a player.
/// </summary>
/// <param name="collectible">The collectible entity being picked up.</param>
/// <param name="player">The player who is picking up the collectible.</param>
/// <param name="eat">Indicates whether the item should be consumed immediately if it's food.</param>
/// <returns>
/// Returns `null` to allow the pickup, or any non-null value to prevent it. (object)
/// </returns>
object OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player, bool eat)
{
    Puts($"Player {player} is attempting to pick up collectible {collectible} with eat flag set to {eat}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoPickup(BasePlayer reciever, bool eat = false)
	{
		if (itemList == null || Interface.CallHook("OnCollectiblePickup", this, reciever, eat) != null)
		{
			return;
		}
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			if (reciever != null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)
			{
				continue;
			}
			Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
			if (item == null)
			{
				continue;
			}
			if (eat && item.info.category == ItemCategory.Food && reciever != null)
			{
				ItemModConsume component = item.info.GetComponent<ItemModConsume>();
				if (component != null)
				{
					component.DoAction(item, reciever);
					continue;
				}
			}
			if ((bool)reciever)
			{
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);
				Interface.CallHook("OnCollectiblePickedup", this, reciever, item);
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
		}
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(reciever, base.transform.position);
		}
		Kill();
	}

```

## OnBoomboxStationUpdate(BoomBox,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the Boombox station's IP is updated.
/// </summary>
/// <param name="boombox">The Boombox entity that is being updated.</param>
/// <param name="ip">The new IP address for the Boombox station.</param>
/// <param name="player">The player who initiated the update.</param>
/// <returns>No return behavior.</returns>
void OnBoomboxStationUpdate(BoomBox boombox, string ip, BasePlayer player)
{
    Puts($"Boombox {boombox} updated to new IP: {ip} by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnBoomboxStationUpdate", this, text, msg.player) == null && IsStationValid(text))
		{
			if (msg.player != null)
			{
				ulong assignedRadioBy = msg.player.userID.Get();
				AssignedRadioBy = assignedRadioBy;
			}
			CurrentRadioIp = text;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnRadioIPChanged"), CurrentRadioIp);
			Interface.CallHook("OnBoomboxStationUpdated", this, text, msg.player);
			if (IsOn())
			{
				ServerTogglePlay(play: false);
			}
		}
	}

```

## OnDispenserBonusReceived(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player receives a bonus item from a resource dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser providing the bonus.</param>
/// <param name="player">The player receiving the bonus item.</param>
/// <param name="item">The item that is being given as a bonus.</param>
/// <returns>No return behavior.</returns>
void OnDispenserBonusReceived(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player} received bonus item: {item} from dispenser: {dispenser}.");
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", this, player, item);
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base player is attacked.
/// </summary>
/// <param name="player">The player that is being attacked.</param>
/// <param name="info">Information about the hit, including damage and initiator.</param>
/// <returns>
/// Returns a non-null value to prevent the default attack behavior; otherwise, returns null to allow it. (object)
/// </returns>
object IOnBasePlayerAttacked(BasePlayer player, HitInfo info)
{
    Puts($"Player {player} was attacked with info: {info}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float oldHealth = base.health;
		if (InSafeZone() && !IsHostile() && info.Initiator != null && info.Initiator != this)
		{
			info.damageTypes.ScaleAll(0f);
		}
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.Get<List<Item>>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.Free(ref obj, freeElements: false);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortalTo(info))
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			if (isMounted)
			{
				GetMounted().MounteeTookDamage(this, info);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				ClientRPC(RpcTarget.Player("TakeDamageHit", this));
			}
			string text = StringPool.Get(info.HitBone);
			bool flag = Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) > 0.4f;
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer && !info.damageTypes.IsMeleeType())
			{
				initiatorPlayer.LifeStoryShotHit(info.Weapon);
			}
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				if (!initiatorPlayer || !initiatorPlayer.limitNetworking)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new Vector3(0f, 2f, 0f), Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);
				}
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1, (Stats)5);
					if (initiatorPlayer.IsBeingSpectated)
					{
						foreach (BaseEntity child in initiatorPlayer.children)
						{
							if (child is BasePlayer basePlayer)
							{
								basePlayer.ClientRPC(RpcTarget.Player("SpectatedPlayerHeadshot", basePlayer));
							}
						}
					}
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.LogAttack(info, "wounded", oldHealth);
			}
			else if (IsDead())
			{
				stats.combat.LogAttack(info, "killed", oldHealth);
			}
			else
			{
				stats.combat.LogAttack(info, "", oldHealth);
			}
		}
		if (ConVar.Global.cinematicGingerbreadCorpses)
		{
			info.HitMaterial = ConVar.Global.GingerbreadMaterialID();
		}
	}

```

## OnMlrsFire(MLRS,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the MLRS (Multiple Launch Rocket System) is fired.
/// </summary>
/// <param name="mlrs">The MLRS instance that is firing.</param>
/// <param name="owner">The player who owns the MLRS and is firing it.</param>
/// <returns>
/// Returns `null` to allow the firing action, or any non-null value to prevent it. (object)
/// </returns>
object OnMlrsFire(MLRS mlrs, BasePlayer owner)
{
    Puts($"MLRS fired by player {owner}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !(_mounted == null) && Interface.CallHook("OnMlrsFire", this, owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			InvokeRepeating(FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", this, owner);
		}
	}

```

## OnFlameThrowerBurn(FlameThrower,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a flame thrower burns an entity.
/// </summary>
/// <param name="flameThrower">The flame thrower that is causing the burn.</param>
/// <param name="target">The entity that is being burned.</param>
/// <returns>No return behavior.</returns>
void OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity target)
{
    Puts($"FlameThrower {flameThrower} is burning target: {target}.");
}
```
```

### Source Code from the Library

```csharp

	public void FlameTick()
	{
		float num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;
		lastFlameTick = UnityEngine.Time.realtimeSinceStartup;
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		ReduceAmmo(num);
		SendNetworkUpdate();
		Ray ray = ownerPlayer.eyes.BodyRay();
		Vector3 origin = ray.origin;
		RaycastHit hitInfo;
		bool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);
		if (!num2)
		{
			hitInfo.point = origin + ray.direction * flameRange;
		}
		float num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);
		float amount = damagePerSec[0].amount;
		damagePerSec[0].amount = amount * num * num3;
		int num4 = 2146305;
		int layers = 133376;
		if (!ownerPlayer.IsNpc)
		{
			num4 |= 0x800;
		}
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, num4, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true);
		damagePerSec[0].amount = damagePerSec[0].amount * playerDamageMultiplier;
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, layers, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true);
		damagePerSec[0].amount = amount;
		if (num2 && UnityEngine.Time.realtimeSinceStartup >= nextFlameTime && hitInfo.distance > 1.1f)
		{
			nextFlameTime = UnityEngine.Time.realtimeSinceStartup + (ownerPlayer.IsNpc ? 0.25f : 0.45f);
			Vector3 point = hitInfo.point;
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, point - ray.direction * 0.25f);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnFlameThrowerBurn", this, baseEntity);
				baseEntity.creatorEntity = ownerPlayer;
				FireBall fireBall = baseEntity as FireBall;
				if (fireBall != null && ownerPlayer.IsNpc)
				{
					fireBall.ignoreNPC = true;
				}
				baseEntity.Spawn();
			}
		}
		if (ammo == 0)
		{
			SetFlameState(wantsOn: false);
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null && !base.UsingInfiniteAmmoCheat && !ownerPlayer.IsNpc)
		{
			ownerItem.LoseCondition(num);
		}
	}

```

## OnPlayerPingsSend(BasePlayer,ProtoBuf.MapNoteList)

```csharp
```csharp
/// <summary>
/// Called when sending player pings to the client.
/// </summary>
/// <param name="player">The player whose pings are being sent.</param>
/// <param name="mapNoteList">The list of map notes containing the pings.</param>
/// <returns>No return behavior.</returns>
void OnPlayerPingsSend(BasePlayer player, ProtoBuf.MapNoteList mapNoteList)
{
    Puts($"Sending pings to player {player} with {mapNoteList.notes.Count} notes.");
}
```
```

### Source Code from the Library

```csharp

	public void SendPingsToClient()
	{
		using MapNoteList mapNoteList = Facepunch.Pool.Get<MapNoteList>();
		mapNoteList.notes = Facepunch.Pool.Get<List<MapNote>>();
		mapNoteList.notes.AddRange(State.pings);
		Interface.CallHook("OnPlayerPingsSend", this, mapNoteList);
		ClientRPC(RpcTarget.Player("Client_ReceivePings", this), mapNoteList);
		mapNoteList.notes.Clear();
	}

```

## OnTimedExplosiveExplode(TimedExplosive,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when a timed explosive detonates.
/// </summary>
/// <param name="explosive">The timed explosive that has exploded.</param>
/// <param name="explosionPosition">The position where the explosion occurred.</param>
/// <returns>No return behavior.</returns>
void OnTimedExplosiveExplode(TimedExplosive explosive, Vector3 explosionPosition)
{
    Puts($"Timed explosive {explosive} exploded at position {explosionPosition}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Explode(Vector3 explosionFxPos)
	{
		Facepunch.Rust.Analytics.Azure.OnExplosion(this);
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(explosionFxPos - new Vector3(0f, 0.25f, 0f), waves: true, volumes: true);
		if (underwaterExplosionEffect.isValid && waterInfo.isValid && waterInfo.currentDepth >= underwaterExplosionDepth)
		{
			Effect.server.Run(underwaterExplosionEffect.resourcePath, explosionFxPos, GetExplosionNormal(), null, broadcast: true);
		}
		else if (explosionEffect.isValid)
		{
			Vector3 posWorld = explosionFxPos;
			if (explosionOffsetMode == ExplosionEffectOffsetMode.Local)
			{
				Vector3 vector = base.transform.TransformPoint(explosionEffectOffset) - base.transform.position;
				posWorld += vector;
			}
			if (explosionOffsetMode == ExplosionEffectOffsetMode.World)
			{
				posWorld += explosionEffectOffset;
			}
			Effect.server.Run(explosionEffect.resourcePath, posWorld, GetExplosionNormal(), null, broadcast: true);
		}
		if (watersurfaceExplosionEffect.isValid && waterInfo.isValid && waterInfo.overallDepth >= watersurfaceExplosionDepth.x && waterInfo.currentDepth <= watersurfaceExplosionDepth.y)
		{
			Effect.server.Run(watersurfaceExplosionEffect.resourcePath, explosionFxPos.WithY(waterInfo.surfaceLevel), GetExplosionNormal(), null, broadcast: true);
		}
		if (damageTypes.Count > 0)
		{
			if (Interface.CallHook("OnTimedExplosiveExplode", this, explosionFxPos) != null)
			{
				return;
			}
			Vector3 vector2 = ExplosionCenter();
			if (onlyDamageParent)
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), vector2, minExplosionRadius, explosionRadius, damageTypes, 166144, useLineOfSight: true, IgnoreAI);
				BaseEntity baseEntity = GetParentEntity();
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				while (baseCombatEntity == null && baseEntity != null && baseEntity.HasParent())
				{
					baseEntity = baseEntity.GetParentEntity();
					baseCombatEntity = baseEntity as BaseCombatEntity;
				}
				if (baseEntity == null || !GameObjectEx.IsOnLayer(baseEntity.gameObject, Layer.Construction))
				{
					List<BuildingBlock> obj = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(vector2, explosionRadius, obj, 2097152, QueryTriggerInteraction.Ignore);
					BuildingBlock buildingBlock = null;
					float num = float.PositiveInfinity;
					foreach (BuildingBlock item in obj)
					{
						if (!item.isClient && !item.IsDestroyed && !(item.healthFraction <= 0f))
						{
							float num2 = Vector3.Distance(item.ClosestPoint(vector2), vector2);
							if (num2 < num && item.IsVisible(vector2, explosionRadius))
							{
								buildingBlock = item;
								num = num2;
							}
						}
					}
					if ((bool)buildingBlock)
					{
						HitInfo hitInfo = new HitInfo();
						hitInfo.Initiator = creatorEntity;
						hitInfo.WeaponPrefab = LookupPrefab();
						hitInfo.damageTypes.Add(damageTypes);
						hitInfo.PointStart = vector2;
						hitInfo.PointEnd = buildingBlock.transform.position;
						float amount = 1f - Mathf.Clamp01((num - minExplosionRadius) / (explosionRadius - minExplosionRadius));
						hitInfo.damageTypes.ScaleAll(amount);
						buildingBlock.Hurt(hitInfo);
					}
					Pool.FreeUnmanaged(ref obj);
				}
				if ((bool)baseCombatEntity)
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.Initiator = creatorEntity;
					hitInfo2.WeaponPrefab = LookupPrefab();
					hitInfo2.damageTypes.Add(damageTypes);
					baseCombatEntity.Hurt(hitInfo2);
				}
				else if (baseEntity != null)
				{
					HitInfo hitInfo3 = new HitInfo();
					hitInfo3.Initiator = creatorEntity;
					hitInfo3.WeaponPrefab = LookupPrefab();
					hitInfo3.damageTypes.Add(damageTypes);
					hitInfo3.PointStart = vector2;
					hitInfo3.PointEnd = baseEntity.transform.position;
					baseEntity.OnAttacked(hitInfo3);
				}
			}
			else
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), vector2, minExplosionRadius, explosionRadius, damageTypes, 1210222849, useLineOfSight: true, IgnoreAI);
			}
			SeismicSensor.Notify(vector2, vibrationLevel);
			BlindAnyAI();
		}
		if (!base.IsDestroyed && !HasFlag(Flags.Broken))
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity, such as a corpse.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="corpse">The lootable corpse being accessed.</param>
/// <returns>
/// Returns `true` if the player can loot the entity; otherwise, returns `false`. 
/// If the method returns a non-null value, it overrides the default looting behavior. (bool)
/// </returns>
object CanLootEntity(BasePlayer player, LootableCorpse corpse)
{
    Puts($"Player {player} is attempting to loot corpse {corpse}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!player || !player.CanInteract() || !CanLoot() || containers == null || Interface.CallHook("CanLootEntity", player, this) != null || !player.inventory.loot.StartLootingEntity(this))
		{
			return;
		}
		SetFlag(Flags.Open, b: true);
		for (int i = 0; i < containers.Length; i++)
		{
			ItemContainer itemContainer = containers[i];
			if (CanLootContainer(itemContainer, i))
			{
				player.inventory.loot.AddContainer(itemContainer);
			}
		}
		player.inventory.loot.SendImmediate();
		player.RadioactiveLootCheck(player.inventory.loot.containers);
		ClientRPC(RpcTarget.Player("RPC_ClientLootCorpse", player));
		SendNetworkUpdate();
	}

```

## OnTeamUpdate(ulong,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's team is updated.
/// </summary>
/// <param name="oldTeam">The player's previous team ID.</param>
/// <param name="newTeam">The player's new team ID.</param>
/// <param name="player">The player whose team is being updated.</param>
/// <returns>
/// Returns `null` to allow the team update, or any non-null value to prevent the update. (object)
/// </returns>
object OnTeamUpdate(ulong oldTeam, ulong newTeam, BasePlayer player)
{
    Puts($"Player {player} is changing team from {oldTeam} to {newTeam}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateTeam(ulong newTeam)
	{
		if (Interface.CallHook("OnTeamUpdate", currentTeam, newTeam, this) == null)
		{
			currentTeam = newTeam;
			SendNetworkUpdate();
			if (RelationshipManager.ServerInstance.FindTeam(newTeam) == null)
			{
				ClearTeam();
			}
			else
			{
				TeamUpdate();
			}
		}
	}

```

## IOnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player successfully connects to the server.
/// </summary>
/// <param name="player">The player that has connected.</param>
/// <returns>No return behavior.</returns>
void IOnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.displayName} with ID {player.userID} has connected to the server.");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerInit(Network.Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			bots.Remove(this);
			userID = c.userid;
			UserIDString = userID.Get().ToString();
			displayName = c.username;
			c.player = this;
			secondsConnected = 0;
			currentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;
			SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(userID, displayName);
			tickInterpolator.Reset(base.transform.position);
			tickHistory.Reset(base.transform.position);
			eyeHistory.Clear();
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			InvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			GlobalNetworkHandler.server.StartSendingSnapshot(this);
			ClientRPC(RpcTarget.Player("StartLoading", this));
			if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);
			}
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			Interface.CallHook("IOnPlayerConnected", this);
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
			}
			inventory.crafting.SendToOwner();
			if (TerrainMeta.Path != null && TerrainMeta.Path.OceanPatrolFar != null)
			{
				SendCargoPatrolPath();
			}
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable amount for an item.
/// </summary>
/// <param name="item">The item for which the maximum stackable amount is being queried.</param>
/// <returns>
/// Returns the maximum stackable amount for the item. If the hook returns a value, that value will be used instead. (int)
/// </returns>
object OnMaxStackable(Item item)
{
    Puts($"Calculating max stackable for item: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## OnFireworkDesignChanged(PatternFirework,ProtoBuf.PatternFirework.Design,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the design of a firework is changed by a player.
/// </summary>
/// <param name="firework">The firework whose design is being changed.</param>
/// <param name="design">The new design for the firework.</param>
/// <param name="player">The player who is changing the design.</param>
/// <returns>
/// Returns a non-null value to prevent the design change, or `null` to allow it. (object)
/// </returns>
object OnFireworkDesignChanged(PatternFirework firework, ProtoBuf.PatternFirework.Design design, BasePlayer player)
{
    Puts($"Firework design changed by {player} for firework {firework}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		ProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);
		if (Interface.CallHook("OnFireworkDesignChange", this, design, rpc.player) != null)
		{
			return;
		}
		if (design?.stars != null)
		{
			while (design.stars.Count > MaxStars)
			{
				int index = design.stars.Count - 1;
				design.stars[index].Dispose();
				design.stars.RemoveAt(index);
			}
			foreach (ProtoBuf.PatternFirework.Star star in design.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			design.editedBy = rpc.player.userID;
		}
		Design?.Dispose();
		Design = design;
		Interface.CallHook("OnFireworkDesignChanged", this, design, rpc.player);
		SendNetworkUpdateImmediate();
	}

```

## OnVendingShopOpen(InvisibleVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to open a vending shop.
/// </summary>
/// <param name="vendingMachine">The invisible vending machine being accessed.</param>
/// <param name="player">The player attempting to open the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpen(InvisibleVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player} is attempting to open the vending shop at {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", vendingMachine, player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!(conversingPlayer == player) && !(conversingPlayer == null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			List<Item> list = player.inventory.FindItemsByItemID(itemDefinition.itemid);
			foreach (Item item in list)
			{
				num -= item.amount;
			}
			if (num > 0)
			{
				int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
				ForceSpeechNode(player, speechNodeIndex2);
				break;
			}
			Facepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
			num = nPCConversationResultAction.scrapCost;
			foreach (Item item2 in list)
			{
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			lastActionPlayer = player;
			BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
			lastActionPlayer = null;
			break;
		}
	}

```

## OnDemoRecordingStarted(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when demo recording has started for a player.
/// </summary>
/// <param name="filePath">The file path where the demo is being recorded.</param>
/// <param name="player">The player who started the demo recording.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStarted(string filePath, BasePlayer player)
{
    Puts($"Demo recording started for player {player} at {filePath}.");
}
```
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a healing item is used on a player.
/// </summary>
/// <param name="healingItem">The medical tool being used.</param>
/// <param name="targetPlayer">The player receiving the healing effects.</param>
/// <returns>
/// Returns `null` to allow the healing effects to proceed, or any non-null value to prevent the healing. (object)
/// </returns>
object OnHealingItemUse(MedicalTool healingItem, BasePlayer targetPlayer)
{
    Puts($"Healing item {healingItem} used on player {targetPlayer}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Facepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if (player != ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
					player.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}

```

## OnSleepingBagDestroy(SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is about to be destroyed.
/// </summary>
/// <param name="sleepingBag">The sleeping bag that is being destroyed.</param>
/// <param name="userId">The ID of the user who owns the sleeping bag.</param>
/// <returns>
/// Returns `null` to allow the destruction of the sleeping bag, or any non-null value to prevent it. (object)
/// </returns>
object OnSleepingBagDestroy(SleepingBag sleepingBag, ulong userId)
{
    Puts($"Attempting to destroy sleeping bag {sleepingBag} for user {userId}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) => x.net.ID == sleepingBag);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, userID) != null)
		{
			return false;
		}
		RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
		sleepingBag2.deployerUserID = 0uL;
		sleepingBag2.SendNetworkUpdate();
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if (basePlayer != null)
		{
			basePlayer.SendRespawnOptions();
			Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, userID);
			Facepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
		}
		return true;
	}

```

## OnBoatPathGenerate()

```csharp
```csharp
/// <summary>
/// Called to generate a patrol path for boats in the ocean.
/// </summary>
/// <returns>
/// Returns a list of <c>Vector3</c> points representing the generated patrol path. 
/// If the hook returns a non-null value, that value will be used instead of the generated path. (List<Vector3>)
/// </returns>
object OnBoatPathGenerate()
{
    Puts("Generating boat patrol path.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float y = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num5 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num5 * (MathF.PI / 180f)) * num4, y, Mathf.Cos(num5 * (MathF.PI / 180f)) * num4));
		}
		float num6 = 4f;
		float num7 = 200f;
		bool flag = true;
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 vector = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 b = list[index2];
				Vector3 b2 = list[index];
				Vector3 origin = vector;
				Vector3 normalized = (Vector3.zero - vector).normalized;
				Vector3 vector2 = vector + normalized * num6;
				if (Vector3.Distance(vector2, b) > num7 || Vector3.Distance(vector2, b2) > num7)
				{
					continue;
				}
				bool flag2 = true;
				int num8 = 16;
				for (int l = 0; l < num8; l++)
				{
					float num9 = (float)l / (float)num8 * 360f;
					Vector3 normalized2 = new Vector3(Mathf.Sin(num9 * (MathF.PI / 180f)), y, Mathf.Cos(num9 * (MathF.PI / 180f))).normalized;
					Vector3 vector3 = vector2 + normalized2 * 1f;
					Vector3 direction = normalized;
					if (vector3 != Vector3.zero)
					{
						direction = (vector3 - vector2).normalized;
					}
					if (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1084293377))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = vector2;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning("Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log("Generated ocean patrol path with node count: " + list.Count);
		return list;
	}

```

## CanUseWires(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use wires in the game.
/// </summary>
/// <param name="player">The player attempting to use wires.</param>
/// <returns>
/// Returns `true` if the player can use wires; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the player can use wires. (bool)
/// </returns>
object CanUseWires(BasePlayer player)
{
    Puts($"Checking if player {player} can use wires.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool CanPlayerUseWires(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseWires", player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player != null && player.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		List<Collider> obj2 = Facepunch.Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);
		bool result = true;
		foreach (Collider item in obj2)
		{
			if (!item.gameObject.CompareTag("IgnoreWireCheck"))
			{
				result = false;
				break;
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj2);
		return result;
	}

```

## OnRackedWeaponUnload(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is unloaded from a weapon rack.
/// </summary>
/// <param name="item">The item representing the weapon being unloaded.</param>
/// <param name="player">The player who is unloading the weapon.</param>
/// <param name="weaponRack">The weapon rack from which the weapon is being unloaded.</param>
/// <returns>
/// Returns a non-null value to prevent the weapon from being unloaded; otherwise, returns null to allow the action. (object)
/// </returns>
object OnRackedWeaponUnload(Item item, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Player {player} is unloading weapon: {item} from weapon rack: {weaponRack}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", slot, player, this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity == null))
		{
			BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
			if (!(component == null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", slot, player, this);
			}
		}
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters a trigger area.
/// </summary>
/// <param name="trigger">The trigger that the entity has entered.</param>
/// <param name="entity">The entity that has entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity} has entered the trigger {trigger}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			if (Interface.CallHook("OnEntityEnter", this, ent) == null)
			{
				entityContents.Add(ent);
				OnEntityEnterTrigger?.Invoke(ent);
			}
		}
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player is authorized to control the turret.
/// </summary>
/// <param name="turret">The turret that the player is attempting to authorize.</param>
/// <param name="player">The player attempting to authorize themselves.</param>
/// <returns>
/// Returns `null` to allow authorization, or a non-null value to prevent it. (object)
/// </returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to authorize on turret {turret}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AddSelfAuthorize(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!IsOnline() && player2.CanBuild() && !AtMaxAuthCapacity() && Interface.CallHook("OnTurretAuthorize", this, player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)player2.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = player2.userID;
			playerNameID.username = player2.displayName;
			authorizedPlayers.Add(playerNameID);
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, player2, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", player2.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity that is being killed.</param>
/// <returns>
/// Returns a non-null value to prevent the entity from being killed; otherwise, returns null to allow the default kill behavior. (object)
/// </returns>
object OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity} is being killed.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
		}
		else if (Interface.CallHook("OnEntityKill", this) == null)
		{
			EntityProfiler.killed++;
			if (EntityProfiler.mode >= 2)
			{
				EntityProfiler.OnKilled(this);
			}
			OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

```

## OnClothingItemChanged(PlayerInventory,Item,bool)

```csharp
```csharp
/// <summary>
/// Called when a clothing item is added or removed from a player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory that is being modified.</param>
/// <param name="item">The clothing item that has been changed.</param>
/// <param name="bAdded">Indicates whether the item was added (<c>true</c>) or removed (<c>false</c>).</param>
/// <returns>No return behavior.</returns>
void OnClothingItemChanged(PlayerInventory inventory, Item item, bool bAdded)
{
    Puts($"Clothing item changed: {item} was {(bAdded ? "added" : "removed")}.");
}
```
```

### Source Code from the Library

```csharp

	public void OnClothingChanged(Item item, bool bAdded)
	{
		base.baseEntity.SV_ClothingChanged();
		if (ItemManager.EnablePooling)
		{
			if (!IsInvoking(DeferredServerUpdateAction))
			{
				Invoke(DeferredServerUpdateAction, 0f);
			}
		}
		else
		{
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
		if (item.position == 7)
		{
			item.RecalulateParentEntity(children: true);
			Invoke(UpdatedVisibleHolsteredItems, 0.1f);
			item?.contents?.onItemAddedRemoved?.Invoke(item, bAdded);
		}
		base.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.CLOTHINGCHANGED, 0, 0f);
		Interface.CallHook("OnClothingItemChanged", this, item, bAdded);
	}

```

## CanCatchFish(BasePlayer,BaseFishingRod,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can catch a fish with the given fishing rod and item.
/// </summary>
/// <param name="player">The player attempting to catch the fish.</param>
/// <param name="fishingRod">The fishing rod being used.</param>
/// <param name="fishItem">The item representing the fish being caught.</param>
/// <returns>
/// Returns `true` if the player can catch the fish; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the fish can be caught. (bool)
/// </returns>
object CanCatchFish(BasePlayer player, BaseFishingRod fishingRod, Item fishItem)
{
    Puts($"Player {player} is attempting to catch a fish with rod {fishingRod}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## OnPhoneNameUpdate(PhoneController,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the name of a phone is updated.
/// </summary>
/// <param name="phone">The phone controller that is being updated.</param>
/// <param name="newName">The new name for the phone.</param>
/// <param name="player">The player who initiated the name update.</param>
/// <returns>
/// Returns `null` to allow the name update, or any non-null value to prevent the update. (object)
/// </returns>
object OnPhoneNameUpdate(PhoneController phone, string newName, BasePlayer player)
{
    Puts($"Phone name update requested by {player}: New Name = {newName}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!(msg.player != currentPlayer))
		{
			string text = msg.read.String();
			if (text.Length > 20)
			{
				text = text.Substring(0, 20);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", this, text, msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", this, PhoneName, msg.player);
			}
		}
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="container">The dropped item container being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity. (bool)
/// </returns>
object CanLootEntity(BasePlayer player, DroppedItemContainer container)
{
    Puts($"Player {player} is attempting to loot container {container}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## OnCargoShipHarborLeave(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship leaves the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that is leaving the harbor.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipHarborLeave(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip} is leaving the harbor.");
}
```
```

### Source Code from the Library

```csharp

	private void LeaveHarbor()
	{
		if (docking_debug)
		{
			Debug.Log("Cargo is leaving harbor.");
		}
		PlayHorn();
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: true);
		currentHarborApproachNode++;
		Interface.CallHook("OnCargoShipHarborLeave", this);
	}

```

## OnXmasStockingFill(Stocking)

```csharp
```csharp
/// <summary>
/// Called when filling an Xmas stocking with loot.
/// </summary>
/// <param name="stocking">The Xmas stocking that is being filled.</param>
/// <returns>
/// Returns `null` to allow the default filling behavior, or a non-null value to override it. (object)
/// </returns>
object OnXmasStockingFill(Stocking stocking)
{
    Puts($"Filling Xmas stocking: {stocking}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! " + base.name);
		}
		else if (IsEmpty() && Interface.CallHook("OnXmasStockingFill", this) == null)
		{
			base.SpawnLoot();
			SetFlag(Flags.On, b: true);
			Hurt(MaxHealth() * 0.1f, DamageType.Generic, null, useProtection: false);
		}
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player can network to this entity.
/// </summary>
/// <param name="entity">The networkable entity.</param>
/// <param name="player">The player attempting to connect to the entity.</param>
/// <returns>
/// Returns `true` if the player can network to the entity; otherwise, returns `false`.
/// If the method returns `null`, the default networking logic will be applied. (bool)
/// </returns>
object CanNetworkTo(BaseNetworkable entity, BasePlayer player)
{
    Puts($"Checking network access for player {player} to entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (net.group == null)
		{
			return true;
		}
		return player.net.subscriber.IsSubscribed(net.group);
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player toggles the state of a recycler (on/off).
/// </summary>
/// <param name="recycler">The recycler being toggled.</param>
/// <param name="player">The player who is toggling the recycler.</param>
/// <returns>
/// Returns `null` to allow the toggle action, or any non-null value to prevent it. (object)
/// </returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts($"Player {player} toggled the recycler: {recycler}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || msg.player == null || Interface.CallHook("OnRecyclerToggle", this, msg.player) != null || (!flag && onlyOneUser && msg.player.inventory.loot.entitySource != this) || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

```

## OnThreatLevelUpdate(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to update the threat level of a player based on their current state and inventory.
/// </summary>
/// <param name="player">The player whose threat level is being updated.</param>
/// <returns>
/// Returns a non-null value to override the default threat level calculation. If `null` is returned, the default logic will be applied. (object)
/// </returns>
object OnThreatLevelUpdate(BasePlayer player)
{
    Puts($"Updating threat level for player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void EnsureUpdated()
	{
		if (UnityEngine.Time.realtimeSinceStartup - lastUpdateTime < 30f)
		{
			return;
		}
		lastUpdateTime = UnityEngine.Time.realtimeSinceStartup;
		cachedThreatLevel = 0f;
		if (IsSleeping() || Interface.CallHook("OnThreatLevelUpdate", this) != null)
		{
			return;
		}
		if (inventory.containerWear.itemList.Count > 2)
		{
			cachedThreatLevel += 1f;
		}
		foreach (Item item in inventory.containerBelt.itemList)
		{
			BaseEntity heldEntity = item.GetHeldEntity();
			if ((bool)heldEntity && heldEntity is BaseProjectile && !(heldEntity is BowWeapon))
			{
				cachedThreatLevel += 2f;
				break;
			}
		}
	}

```

## CanBeHomingTargeted(BaseHelicopter)

```csharp
```csharp
/// <summary>
/// Determines whether the specified helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The helicopter to check for homing missile targeting.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the helicopter can be targeted. (bool)
/// </returns>
object CanBeHomingTargeted(BaseHelicopter helicopter)
{
    Puts($"Checking if helicopter {helicopter} can be targeted by homing missiles.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## CanEntityBeHostile(BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the specified combat entity can be considered hostile.
/// </summary>
/// <param name="entity">The combat entity to check for hostility.</param>
/// <returns>
/// Returns `true` if the entity is considered hostile; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine the hostility status. (bool)
/// </returns>
object CanEntityBeHostile(BaseCombatEntity entity)
{
    Puts($"Checking hostility for entity: {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnPlayerStudyBlueprint(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player studies a blueprint item.
/// </summary>
/// <param name="player">The player studying the blueprint.</param>
/// <param name="item">The blueprint item being studied.</param>
/// <returns>
/// Returns a non-null value to prevent the default study behavior, or `null` to allow it. (object)
/// </returns>
object OnPlayerStudyBlueprint(BasePlayer player, Item item)
{
    Puts($"Player {player} is studying blueprint: {item.info.shortname}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command != "study" || !item.IsBlueprint())
		{
			return;
		}
		if (item.GetOwnerPlayer() != player && player.inventory.GetBackpackWithInventory()?.contents != item.parent)
		{
			bool flag = false;
			foreach (ItemContainer container in player.inventory.loot.containers)
			{
				if (item.GetRootContainer() == container)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (IsBlueprintUnlocked(item, player, out var blueprintTargetDef, out var blueprint) || Interface.CallHook("OnPlayerStudyBlueprint", player, item) != null)
		{
			return;
		}
		Item item2 = item;
		if (item.amount > 1)
		{
			item2 = item.SplitItem(1);
		}
		item2.UseItem();
		player.blueprints.Unlock(blueprintTargetDef);
		Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, "blueprint", ResearchTable.ScrapForResearch(blueprintTargetDef), player);
		if (blueprint != null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				player.blueprints.Unlock(additionalUnlock);
				Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, additionalUnlock, "blueprint", 0, player);
			}
		}
		if (studyEffect.isValid)
		{
			Effect.server.Run(studyEffect.resourcePath, player, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
	}

```

## OnDigitalClockAlarmsSet(DigitalClock,ProtoBuf.DigitalClockMessage)

```csharp
```csharp
/// <summary>
/// Called when alarms are set on a digital clock.
/// </summary>
/// <param name="clock">The digital clock instance where alarms are being set.</param>
/// <param name="message">The message containing the alarm settings.</param>
/// <returns>
/// Returns a non-null value to prevent the default behavior of setting alarms. 
/// If `null` is returned, the alarms will be set as specified in the message. (object)
/// </returns>
object OnDigitalClockAlarmsSet(DigitalClock clock, ProtoBuf.DigitalClockMessage message)
{
    Puts($"Setting alarms for Digital Clock: {clock} with message: {message}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_SetAlarms(RPCMessage msg)
	{
		if (!CanPlayerAdmin(msg.player))
		{
			return;
		}
		DigitalClockMessage digitalClockMessage = DigitalClockMessage.Deserialize(msg.read);
		if (Interface.CallHook("OnDigitalClockAlarmsSet", this, digitalClockMessage) != null)
		{
			return;
		}
		List<DigitalClockAlarm> list = digitalClockMessage.alarms;
		alarms.Clear();
		foreach (DigitalClockAlarm item2 in list)
		{
			Alarm item = new Alarm(DigitalClockEx.ToTimeSpan(item2.time), item2.active);
			alarms.Add(item);
		}
		muted = digitalClockMessage.muted;
		MarkDirty();
		SendNetworkUpdate();
	}

```

## OnSensorDetect(HBHFSensor,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sensor detects a player entity within its range.
/// </summary>
/// <param name="sensor">The sensor that detected the player.</param>
/// <param name="player">The player that was detected by the sensor.</param>
/// <returns>
/// Returns `null` to allow the default detection behavior, or a non-null value to override it. (object)
/// </returns>
object OnSensorDetect(HBHFSensor sensor, BasePlayer player)
{
    Puts($"Sensor {sensor} detected player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePassthroughAmount()
	{
		if (base.isClient)
		{
			return;
		}
		int num = detectedPlayers;
		detectedPlayers = 0;
		if (myTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in myTrigger.entityContents)
			{
				if (entityContent == null || !entityContent.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f))
				{
					continue;
				}
				BasePlayer component = entityContent.GetComponent<BasePlayer>();
				if (Interface.CallHook("OnSensorDetect", this, component) == null)
				{
					bool flag = component.CanBuild();
					if ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && component != null && component.IsAlive() && !component.IsSleeping() && component.isServer)
					{
						detectedPlayers++;
					}
				}
			}
		}
		if (num != detectedPlayers && IsPowered())
		{
			MarkDirty();
			if (detectedPlayers > num)
			{
				Effect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);
			}
			else if (detectedPlayers < num)
			{
				Effect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnWallpaperRemove(BuildingBlock,int)

```csharp
```csharp
/// <summary>
/// Called when a wallpaper is removed from a building block.
/// </summary>
/// <param name="block">The building block from which the wallpaper is being removed.</param>
/// <param name="side">The side of the building block from which the wallpaper is removed (0 for one side, 1 for the other).</param>
/// <returns>No return behavior.</returns>
void OnWallpaperRemove(BuildingBlock block, int side)
{
    Puts($"Wallpaper removed from side {side} of building block {block}.");
}
```
```

### Source Code from the Library

```csharp

	public void RemoveWallpaper(int side)
	{
		if (Interface.CallHook("OnWallpaperRemove", this, side) == null)
		{
			switch (side)
			{
			case 0:
				wallpaperHealth = -1f;
				wallpaperID = 0uL;
				break;
			case 1:
				wallpaperHealth2 = -1f;
				wallpaperID2 = 0uL;
				break;
			}
			if (base.isServer)
			{
				SetConditionalModel(currentSkin.DetermineConditionalModelState(this));
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
			}
		}
	}

```

## OnOvenCook(BaseOven,Item)

```csharp
```csharp
/// <summary>
/// Called when an oven is cooking an item.
/// </summary>
/// <param name="oven">The oven that is performing the cooking.</param>
/// <param name="item">The item being cooked in the oven.</param>
/// <returns>
/// Returns a non-null value to prevent the cooking process; otherwise, returns null to allow it to proceed. (object)
/// </returns>
object OnOvenCook(BaseOven oven, Item item)
{
    Puts($"Oven {oven} is attempting to cook item: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		if (HasFlag(Flags.Reserved8))
		{
			return;
		}
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		if (item != null)
		{
			ItemModBurnable itemModBurnable = item.info.ItemModBurnable;
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, itemModBurnable);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnVendingShopOpened(InvisibleVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player opens a vending shop.
/// </summary>
/// <param name="vendingMachine">The invisible vending machine that is being opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpened(InvisibleVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player} has opened the vending shop: {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", vendingMachine, player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!(conversingPlayer == player) && !(conversingPlayer == null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			List<Item> list = player.inventory.FindItemsByItemID(itemDefinition.itemid);
			foreach (Item item in list)
			{
				num -= item.amount;
			}
			if (num > 0)
			{
				int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
				ForceSpeechNode(player, speechNodeIndex2);
				break;
			}
			Facepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
			num = nPCConversationResultAction.scrapCost;
			foreach (Item item2 in list)
			{
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			lastActionPlayer = player;
			BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
			lastActionPlayer = null;
			break;
		}
	}

```

## OnCodeChange(ModularCar,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player requests to change the lock code of a modular car.
/// </summary>
/// <param name="car">The modular car whose code is being changed.</param>
/// <param name="player">The player requesting the code change.</param>
/// <param name="newCode">The new code that the player wants to set.</param>
/// <returns>
/// Returns `null` to allow the code change, or a non-null value to prevent it. (object)
/// </returns>
object OnCodeChange(ModularCar car, BasePlayer player, string newCode)
{
    Puts($"Player {player} is attempting to change the code of car {car} to {newCode}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestNewCode(RPCMessage msg)
	{
		if (!HasOccupant || !carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!(player == null))
		{
			string text = msg.read.String();
			if (Interface.CallHook("OnCodeChange", carOccupant, player, text) == null && carOccupant.CarLock.TrySetNewCode(text, player.userID))
			{
				Effect.server.Run(changeLockCodeEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnPatrolHelicopterTakeDamage(PatrolHelicopter,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a patrol helicopter takes damage.
/// </summary>
/// <param name="helicopter">The patrol helicopter that is taking damage.</param>
/// <param name="hitInfo">Information about the hit, including damage details.</param>
/// <returns>
/// Returns a non-null value to override the default damage behavior; otherwise, returns null to allow normal processing. (object)
/// </returns>
object OnPatrolHelicopterTakeDamage(PatrolHelicopter helicopter, HitInfo hitInfo)
{
    Puts($"Patrol helicopter {helicopter} is taking damage: {hitInfo.damageTypes.Total()}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnPatrolHelicopterTakeDamage", this, info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			if (Interface.CallHook("OnPatrolHelicopterKill", this, info) != null)
			{
				return;
			}
			base.health = 10000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		myAI.OtherDamaged(info);
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Determines whether the patrol helicopter can perform a strafe maneuver.
/// </summary>
/// <param name="helicopter">The patrol helicopter AI instance.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if strafing is allowed. (bool)
/// </returns>
object CanHelicopterStrafe(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter {helicopter} can strafe.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= UnityEngine.Random.Range(15f, 25f))
		{
			return CanInterruptState();
		}
		return false;
	}

```

## OnWindmillUpdate(ElectricWindmill)

```csharp
```csharp
/// <summary>
/// Called to update the state of the electric windmill based on current wind conditions.
/// </summary>
/// <param name="windmill">The electric windmill being updated.</param>
/// <returns>No return behavior.</returns>
void OnWindmillUpdate(ElectricWindmill windmill)
{
    Puts($"Updating windmill state: {windmill} with current wind speed.");
}
```
```

### Source Code from the Library

```csharp

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", this);
		}
	}

```

## OnHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter drops a crate.
/// </summary>
/// <param name="helicopter">The helicopter that is dropping the crate.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter} is dropping a crate.");
}
```
```

### Source Code from the Library

```csharp

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

```

## OnItemResearch(ResearchTable,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is being researched at a research table.
/// </summary>
/// <param name="researchTable">The research table where the item is being researched.</param>
/// <param name="item">The item that is being researched.</param>
/// <param name="player">The player who is conducting the research.</param>
/// <returns>
/// Returns a non-null value to prevent the research from proceeding, or `null` to allow it. (object)
/// </returns>
object OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player)
{
    Puts($"Player {player} is researching item {item} at {researchTable}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Facepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnCargoShipEgress(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when the cargo ship is starting to egress from the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that is egressing.</param>
/// <returns>
/// Returns `null` to allow the default egress behavior, or any non-null value to prevent the egress from occurring. (object)
/// </returns>
object OnCargoShipEgress(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip} is starting to egress.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartEgress()
	{
		if (!isDoingHarborApproach && !egressing)
		{
			egressing = true;
			if (Interface.CallHook("OnCargoShipEgress", this) == null)
			{
				CancelInvoke(PlayHorn);
				radiation.SetActive(value: true);
				SetFlag(Flags.Reserved8, b: true);
				InvokeRepeating(UpdateRadiation, 10f, 1f);
				Invoke(DelayedDestroy, 60f * egress_duration_minutes);
			}
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
```csharp
/// <summary>
/// Determines whether a player can be targeted by a gun trap.
/// </summary>
/// <param name="player">The player being checked for targeting.</param>
/// <param name="trap">The gun trap attempting to target the player.</param>
/// <returns>
/// Returns `true` if the player can be targeted by the gun trap; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can be targeted. (bool)
/// </returns>
object CanBeTargeted(BasePlayer player, GunTrap trap)
{
    Puts($"Checking if player {player} can be targeted by trap {trap}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		if (entityContents == null || entityContents.Count == 0)
		{
			return false;
		}
		List<RaycastHit> obj = Pool.Get<List<RaycastHit>>();
		BuildingPrivlidge cachedTc = GetCachedTc();
		bool flag = false;
		foreach (BaseEntity item in entityContents)
		{
			BasePlayer component = item.GetComponent<BasePlayer>();
			if (component.IsSleeping() || !component.IsAlive())
			{
				continue;
			}
			object obj2 = Interface.CallHook("CanBeTargeted", component, this);
			if (obj2 is bool)
			{
				Pool.FreeUnmanaged(ref obj);
				return (bool)obj2;
			}
			if (!(cachedTc == null) && cachedTc.IsAuthed(component))
			{
				continue;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
			for (int i = 0; i < obj.Count; i++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeUnmanaged(ref obj);
		return flag;
	}

```

## CanSamSiteShoot(SamSite)

```csharp
```csharp
/// <summary>
/// Called to determine if a SAM site can shoot at its current target.
/// </summary>
/// <param name="samSite">The SAM site attempting to shoot.</param>
/// <returns>
/// Returns `true` if the SAM site is allowed to shoot; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the SAM site can shoot. (bool)
/// </returns>
object CanSamSiteShoot(SamSite samSite)
{
    Puts($"Checking if SAM site {samSite} can shoot.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void WeaponTick()
	{
		if (IsDead() || UnityEngine.Time.time < lockOnTime || UnityEngine.Time.time < nextBurstTime)
		{
			return;
		}
		if (!IsPowered())
		{
			firedCount = 0;
			return;
		}
		if (firedCount >= 6)
		{
			float timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;
			nextBurstTime = UnityEngine.Time.time + timeBetweenBursts;
			firedCount = 0;
			return;
		}
		EnsureReloaded();
		if (Interface.CallHook("CanSamSiteShoot", this) == null && HasAmmo())
		{
			bool num = ammoItem != null && ammoItem.amount == lowAmmoThreshold;
			if (!staticRespawn && ammoItem != null)
			{
				ammoItem.UseItem();
			}
			firedCount++;
			float speedMultiplier = 1f;
			if (!ObjectEx.IsUnityNull(currentTarget))
			{
				speedMultiplier = currentTarget.SAMTargetType.speedMultiplier;
			}
			FireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);
			Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
			currentTubeIndex++;
			if (currentTubeIndex >= tubes.Length)
			{
				currentTubeIndex = 0;
			}
			if (num)
			{
				MarkIODirty();
			}
		}
	}

```

## OnDispenserGathered(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player gathers resources from a dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser being gathered from.</param>
/// <param name="player">The player who is gathering the resources.</param>
/// <param name="item">The item that is being gathered.</param>
/// <returns>No return behavior.</returns>
void OnDispenserGathered(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player} gathered {item.amount} of {item.info.shortname} from dispenser {dispenser}.");
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		f = Mathf.Round(f);
		float num3 = f * destroyFraction * 2f;
		if (itemAmt.amount <= f + num3)
		{
			float num4 = (f + num3) / itemAmt.amount;
			f /= num4;
			num3 /= num4;
		}
		itemAmt.amount -= Mathf.Floor(f);
		itemAmt.amount -= Mathf.Floor(num3);
		if (f < 1f)
		{
			f = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (f >= 1f)
		{
			int num5 = CalculateGatherBonus(entity, itemAmt, f);
			int iAmount = Mathf.FloorToInt(f) + num5;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (Interface.CallHook("OnDispenserGather", this, entity, item) == null && item != null)
			{
				OverrideOwnership(item, attackWeapon);
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
				Interface.CallHook("OnDispenserGathered", this, entity, item);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can bypass the connection queue.
/// </summary>
/// <param name="connection">The network connection of the player attempting to join.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue; otherwise, returns `false`.
/// If the method returns `null`, the default queue behavior will be applied. (bool)
/// </returns>
object CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if connection {connection.userid} can bypass the queue.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.SkipQueue)
		{
			return true;
		}
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			if (reservedSlots[i].UserId == connection.userid && reservedSlots[i].Expiry > UnityEngine.Time.realtimeSinceStartup)
			{
				return true;
			}
		}
		return false;
	}

```

## OnNpcConversationRespond(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
```csharp
/// <summary>
/// Called when a player responds to an NPC conversation.
/// </summary>
/// <param name="npc">The NPC that the player is conversing with.</param>
/// <param name="player">The player responding to the conversation.</param>
/// <param name="conversation">The conversation data associated with the interaction.</param>
/// <param name="response">The specific response node chosen by the player.</param>
/// <returns>
/// Returns `null` to allow the default response behavior, or any non-null value to override it. (object)
/// </returns>
object OnNpcConversationRespond(NPCTalking npc, BasePlayer player, ConversationData conversation, ConversationData.ResponseNode response)
{
    Puts($"Player {player} responded to NPC {npc} with response: {response}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode == null || Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) != null)
		{
			return;
		}
		if (responseNode.conditions.Length != 0)
		{
			UpdateFlags();
		}
		bool flag = responseNode.PassesConditions(player, this);
		if (flag)
		{
			string actionString = responseNode.GetActionString();
			if (!string.IsNullOrEmpty(actionString))
			{
				OnConversationAction(player, actionString);
			}
		}
		int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
		if (speechNodeIndex == -1)
		{
			ForceEndConversation(player);
			return;
		}
		ForceSpeechNode(player, speechNodeIndex);
		Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
	}

```

## OnCrateLaptopAttack(HackableLockedCrate,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when the laptop on a hackable locked crate is attacked.
/// </summary>
/// <param name="crate">The hackable locked crate being attacked.</param>
/// <param name="hitInfo">Information about the hit, including damage and position.</param>
/// <returns>
/// Returns a non-null value to override the default attack behavior; otherwise, returns null to allow normal processing. (object)
/// </returns>
object OnCrateLaptopAttack(HackableLockedCrate crate, HitInfo hitInfo)
{
    Puts($"Laptop on crate {crate} was attacked with damage: {hitInfo.damageTypes.Total()}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer)
		{
			if (StringPool.Get(info.HitBone) == "laptopcollision")
			{
				if (Interface.CallHook("OnCrateLaptopAttack", this, info) != null)
				{
					return;
				}
				Effect.server.Run(shockEffect.resourcePath, info.HitPositionWorld, Vector3.up);
				hackSeconds -= 8f * (info.damageTypes.Total() / 50f);
				if (hackSeconds < 0f)
				{
					hackSeconds = 0f;
				}
			}
			RefreshDecay();
		}
		base.OnAttacked(info);
	}

```

## OnFindSpawnPoint(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to find a suitable spawn point for a player.
/// </summary>
/// <param name="player">The player for whom the spawn point is being found.</param>
/// <returns>
/// Returns a <c>BasePlayer.SpawnPoint</c> object representing the chosen spawn point. 
/// If the hook returns a non-null value, that value will be used as the spawn point. (BasePlayer.SpawnPoint)
/// </returns>
object OnFindSpawnPoint(BasePlayer player)
{
    Puts($"Finding spawn point for player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null)
	{
		object obj = Interface.CallHook("OnFindSpawnPoint", forPlayer);
		if (obj is BasePlayer.SpawnPoint)
		{
			return (BasePlayer.SpawnPoint)obj;
		}
		bool flag = false;
		if (forPlayer != null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null)
			{
				BasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();
				if (forPlayer.CurrentTutorialAllowance > BasePlayer.TutorialItemAllowance.Level1_HatchetPickaxe)
				{
					spawnPoint.pos = currentTutorialIsland.MidMissionSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.MidMissionSpawnPoint.rotation;
				}
				else
				{
					spawnPoint.pos = currentTutorialIsland.InitialSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.InitialSpawnPoint.rotation;
				}
				return spawnPoint;
			}
		}
		BaseGameMode baseGameMode = Gamemode();
		if ((bool)baseGameMode && baseGameMode.useCustomSpawns)
		{
			BasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);
			if (playerSpawn != null)
			{
				return playerSpawn;
			}
		}
		if (SingletonComponent<SpawnHandler>.Instance != null && !flag)
		{
			BasePlayer.SpawnPoint spawnPoint2 = SpawnHandler.GetSpawnPoint();
			if (spawnPoint2 != null)
			{
				return spawnPoint2;
			}
		}
		BasePlayer.SpawnPoint spawnPoint3 = new BasePlayer.SpawnPoint();
		if (forPlayer != null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland2 = forPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland2 != null)
			{
				spawnPoint3.pos = currentTutorialIsland2.InitialSpawnPoint.position;
				spawnPoint3.rot = currentTutorialIsland2.InitialSpawnPoint.rotation;
				return spawnPoint3;
			}
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (array.Length != 0)
		{
			GameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];
			spawnPoint3.pos = gameObject.transform.position;
			spawnPoint3.rot = gameObject.transform.rotation;
		}
		else
		{
			UnityEngine.Debug.Log("Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
			if (MainCamera.mainCamera != null)
			{
				spawnPoint3.pos = MainCamera.position;
				spawnPoint3.rot = MainCamera.rotation;
			}
		}
		if (UnityEngine.Physics.Raycast(new Ray(spawnPoint3.pos, Vector3.down), out var hitInfo, 32f, 1537286401))
		{
			spawnPoint3.pos = hitInfo.point;
		}
		return spawnPoint3;
	}

```

## OnEventTrigger(TriggeredEventPrefab)

```csharp
```csharp
/// <summary>
/// Called when an event is triggered to handle the spawning of associated entities.
/// </summary>
/// <param name="eventPrefab">The prefab associated with the triggered event.</param>
/// <returns>
/// Returns a non-null value to prevent the default event behavior from executing; otherwise, returns null to allow it. (object)
/// </returns>
object OnEventTrigger(TriggeredEventPrefab eventPrefab)
{
    Puts($"Event triggered for prefab: {eventPrefab.resourcePath}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void RunEvent()
	{
		if (Interface.CallHook("OnEventTrigger", this) != null)
		{
			return;
		}
		Debug.Log("[event] " + targetPrefab.resourcePath);
		BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
		if (!baseEntity)
		{
			return;
		}
		baseEntity.SendMessage("TriggeredEventSpawn", SendMessageOptions.DontRequireReceiver);
		baseEntity.Spawn();
		spawnedEntity = baseEntity;
		if (!shouldBroadcastSpawn)
		{
			return;
		}
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if ((bool)activePlayer && activePlayer.IsConnected && !activePlayer.IsInTutorial)
			{
				activePlayer.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);
			}
		}
	}

```

## OnFuelConsume(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The fuel item being consumed.</param>
/// <param name="burnable">The burnable item modifier associated with the fuel.</param>
/// <returns>
/// Returns a non-null value to prevent the default fuel consumption behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel consumption event for oven {oven} with fuel {fuel} and burnable {burnable}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Facepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## CanPickupEntity(BasePlayer,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether a player can pick up the specified entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity that is being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can pick it up. (bool)
/// </returns>
object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
{
    Puts($"Checking if player {player} can pick up entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (pickup.enabled && (!pickup.requireBuildingPrivilege || player.CanBuild()) && (!pickup.requireHammer || player.IsHoldingEntity<Hammer>()))
		{
			if (player != null)
			{
				return !player.IsInTutorial;
			}
			return false;
		}
		return false;
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to buy an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the item is being purchased.</param>
/// <param name="player">The player attempting to buy the item.</param>
/// <param name="itemId">The ID of the item being purchased.</param>
/// <param name="amount">The amount of the item being purchased.</param>
/// <returns>
/// Returns `null` to allow the purchase to proceed, or a non-null value to prevent the purchase. (object)
/// </returns>
object OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer player, int itemId, int amount)
{
    Puts($"Player {player} is attempting to buy item {itemId} (Amount: {amount}) from vending machine {vendingMachine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void BuyItem(RPCMessage rpc)
	{
		if (OccupiedCheck(rpc.player))
		{
			int num = rpc.read.Int32();
			int num2 = rpc.read.Int32();
			if (IsVending())
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage, false);
			}
			else if (Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2) == null)
			{
				SetPendingOrder(rpc.player, num, num2);
				Invoke(CompletePendingOrder, GetBuyDuration());
			}
		}
	}

```

## OnTurretAssign(AutoTurret,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is assigned to a player.
/// </summary>
/// <param name="turret">The turret being assigned.</param>
/// <param name="playerId">The ID of the player to whom the turret is being assigned.</param>
/// <param name="assigner">The player who is assigning the turret.</param>
/// <returns>
/// Returns `null` to allow the assignment, or any non-null value to prevent the assignment. (object)
/// </returns>
object OnTurretAssign(AutoTurret turret, ulong playerId, BasePlayer assigner)
{
    Puts($"Turret {turret} is being assigned to player ID: {playerId} by {assigner}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", this, num, msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = num;
			playerNameID.username = username;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(playerNameID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", this, num, msg.player);
		}
	}

```

## CanCastFishingRod(BasePlayer,BaseFishingRod,Item,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can cast their fishing rod at a specified position with a given lure.
/// </summary>
/// <param name="player">The player attempting to cast the fishing rod.</param>
/// <param name="fishingRod">The fishing rod being used for the cast.</param>
/// <param name="lure">The lure item being used for the cast.</param>
/// <param name="castPosition">The position where the player intends to cast the fishing rod.</param>
/// <returns>
/// Returns `true` if the player can cast the fishing rod; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the cast is valid. (bool)
/// </returns>
object CanCastFishingRod(BasePlayer player, BaseFishingRod fishingRod, Item lure, Vector3 castPosition)
{
    Puts($"Player {player} is attempting to cast fishing rod at position {castPosition} using lure {lure}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_RequestCast(RPCMessage msg)
	{
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		ItemModCompostable component = (ItemModCompostable)Interface.CallHook("CanCastFishingRod", ownerPlayer, this, currentLure, pos);
		if (!(component is bool) || (bool)(object)component)
		{
			FishingBobber component2 = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();
			component2.transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component2.Spawn();
			component2.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);
			int usedLureAmount = 0;
			if (FishLookup.Instance != null)
			{
				currentFishTarget = FishLookup.Instance.GetFish(component2.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);
			}
			lureUsed = currentLure.info;
			currentLure.UseItem(usedLureAmount);
			lastFish = fishableModifier;
			currentBobber.Set(component2);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReceiveCastPoint"), component2.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));
			catchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;
			float val = (lureUsed.TryGetComponent<ItemModCompostable>(out component) ? component.BaitValue : 0f);
			val = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);
			catchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);
			playerStartPosition = ownerPlayer.transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			InvokeRepeating(CatchProcess, 0f, 0f);
			inQueue = false;
			Interface.CallHook("OnFishingRodCast", this, ownerPlayer, currentLure);
		}
	}

```

## OnFindBurnable(BaseOven)

```csharp
```csharp
/// <summary>
/// Called to find a burnable item in the oven's inventory.
/// </summary>
/// <param name="oven">The oven instance that is searching for a burnable item.</param>
/// <returns>
/// Returns a burnable item if found; otherwise, returns `null`. 
/// If the hook returns a non-null item, that item will be used instead of the default search result. (Item | null)
/// </returns>
object OnFindBurnable(BaseOven oven)
{
    Puts($"Searching for burnable item in oven {oven}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (base.inventory == null)
		{
			return null;
		}
		foreach (Item item in base.inventory.itemList)
		{
			if (IsBurnableItem(item))
			{
				return item;
			}
		}
		return null;
	}

```

## OnVehicleModuleDeselected(ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is deselected by a player in the garage.
/// </summary>
/// <param name="garage">The garage containing the vehicle module.</param>
/// <param name="player">The player who deselected the vehicle module.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModuleDeselected(ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player} has deselected a module in garage {garage}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DeselectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.inventory.loot.IsLooting() && !(player.inventory.loot.entitySource != this))
		{
			if (player.inventory.loot.RemoveContainerAt(3))
			{
				player.inventory.loot.SendImmediate();
			}
			Interface.CallHook("OnVehicleModuleDeselected", this, player);
		}
	}

```

## OnMapMarkersCleared(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the map markers for a player are cleared.
/// </summary>
/// <param name="player">The player whose map markers have been cleared.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkersCleared(BasePlayer player)
{
    Puts($"Map markers cleared for player {player}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, State.pointsOfInterest) != null)
		{
			return;
		}
		ServerCurrentDeathNote?.Dispose();
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				item?.Dispose();
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", this);
	}

```

## OnTurretClearList(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the authorization list of a turret is cleared.
/// </summary>
/// <param name="turret">The turret whose authorization list is being cleared.</param>
/// <param name="player">The player who initiated the clear action.</param>
/// <returns>
/// Returns `null` to allow the list to be cleared, or any non-null value to prevent the action. (object)
/// </returns>
object OnTurretClearList(AutoTurret turret, BasePlayer player)
{
    Puts($"Authorization list cleared for turret {turret} by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			authDirty = true;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "clear", rpc.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnTeamCreated(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a new team is created by a player.
/// </summary>
/// <param name="player">The player who created the team.</param>
/// <param name="team">The team that was created.</param>
/// <returns>No return behavior.</returns>
void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
{
    Puts($"Team created by player {player} with Team ID: {team.teamID}.");
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Facepunch.Rust.Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is initiated.
/// </summary>
/// <param name="task">The crafting task that is being created.</param>
/// <param name="owner">The player who is crafting the item.</param>
/// <param name="item">The item being crafted, if applicable.</param>
/// <returns>
/// Returns `true` if the crafting can proceed, or `false` if it cannot. 
/// If the method returns `null`, the default crafting logic will be used. (bool)
/// </returns>
object OnItemCraft(ItemCraftTask task, BasePlayer owner, Item item)
{
    Puts($"Crafting initiated by {owner} for item: {item} with task UID: {task.taskUID}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)
	{
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		if (!CanCraft(bp, amount, free))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		if (!free)
		{
			CollectIngredients(bp, itemCraftTask, amount, owner);
		}
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			if (fromTempBlueprint != null && itemCraftTask.instanceData != null)
			{
				fromTempBlueprint.instanceData = itemCraftTask.instanceData;
			}
			return (bool)obj;
		}
		queue.AddLast(itemCraftTask);
		if (owner != null)
		{
			owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## OnTerrainInitialized()

```csharp
```csharp
/// <summary>
/// Called when the terrain has been initialized and all components are set up.
/// </summary>
/// <returns>No return behavior.</returns>
void OnTerrainInitialized()
{
    Puts("Terrain has been initialized and components are set up.");
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

```

## CanPurchaseItem(BasePlayer,Item,System.Action<BasePlayer, Item>,VendingMachine,ItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can purchase an item from a vending machine.
/// </summary>
/// <param name="buyer">The player attempting to purchase the item.</param>
/// <param name="item">The item being purchased.</param>
/// <param name="onItemPurchased">Callback action to invoke when the item is successfully purchased.</param>
/// <param name="vendingMachine">The vending machine from which the item is being purchased.</param>
/// <param name="targetContainer">The container where the item will be placed, if applicable.</param>
/// <returns>
/// Returns `true` if the player can afford to purchase the item; otherwise, returns `false`. 
/// If the method returns a non-null value, it overrides the default purchase behavior. (bool)
/// </returns>
object CanPurchaseItem(BasePlayer buyer, Item item, Action<BasePlayer, Item> onItemPurchased, VendingMachine vendingMachine, ItemContainer targetContainer)
{
    Puts($"Player {buyer} is attempting to purchase item {item} from vending machine {vendingMachine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions, targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> obj2 = Facepunch.Pool.Get<List<Item>>();
		GetItemsToSell(sellOrder, obj2);
		if (obj2 == null || obj2.Count == 0)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = obj2.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		List<Item> source = buyer.inventory.FindItemsByItemID(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = (from x in source
			where !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)
			where x.GetItemVolume() <= maxCurrencyVolume
			select x).ToList();
		if (source.Count == 0)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;
		if (num3 < num4)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			TakeCurrencyItem(item);
			onCurrencyRemoved?.Invoke(buyer, item);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		Facepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, num4, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);
		int num7 = 0;
		foreach (Item item4 in obj2)
		{
			int num8 = num - num7;
			Item item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);
			if (item2 == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item2.amount;
				object obj3 = Interface.CallHook("CanPurchaseItem", buyer, item2, onItemPurchased, this, targetContainer);
				if (obj3 != null)
				{
					if (!(obj3 is bool))
					{
						return false;
					}
					return (bool)obj3;
				}
				RecordSaleAnalytics(item2, sellOrderId);
				if (targetContainer == null)
				{
					GiveSoldItem(item2, buyer);
				}
				else if (!item2.MoveToContainer(targetContainer))
				{
					item2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
				}
				onItemPurchased?.Invoke(buyer, item2);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj2);
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## CanDismountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can dismount from an entity.
/// </summary>
/// <param name="player">The player attempting to dismount.</param>
/// <param name="mountable">The entity from which the player is dismounting.</param>
/// <returns>
/// Returns `null` to allow the dismount, or any non-null value to prevent the dismount. (object)
/// </returns>
object CanDismountEntity(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player} is attempting to dismount from {mountable}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.transform.rotation = Quaternion.identity;
			_mounted.ClientRPC(RpcTarget.Player("ForcePositionTo", _mounted), res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID.Get() + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
		}
		else
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.SendModelState(force: true);
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), res);
			}
			Facepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnSprinklerSplashed(Sprinkler)

```csharp
```csharp
/// <summary>
/// Called when the sprinkler has splashed water on nearby entities.
/// </summary>
/// <param name="sprinkler">The sprinkler that performed the splash action.</param>
/// <returns>No return behavior.</returns>
void OnSprinklerSplashed(Sprinkler sprinkler)
{
    Puts($"Sprinkler {sprinkler} has splashed water.");
}
```
```

### Source Code from the Library

```csharp

	private void DoSplash()
	{
		using (TimeWarning.New("SprinklerSplash"))
		{
			int num = WaterPerSplash;
			if ((float)updateSplashableCache > SplashFrequency * 4f || forceUpdateSplashables)
			{
				cachedSplashables.Clear();
				forceUpdateSplashables = false;
				updateSplashableCache = 0f;
				Vector3 position = Eyes.position;
				Vector3 up = base.transform.up;
				float sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;
				float value = Vector3.Angle(up, Vector3.up) / 180f;
				value = Mathf.Clamp(value, 0.2f, 1f);
				sprinklerEyeHeightOffset *= value;
				Vector3 startPosition = position + up * (Server.sprinklerRadius * 0.5f);
				Vector3 endPosition = position + up * sprinklerEyeHeightOffset;
				List<BaseEntity> obj = Facepunch.Pool.Get<List<BaseEntity>>();
				Vis.Entities(startPosition, endPosition, Server.sprinklerRadius, obj, 1237003025);
				if (obj.Count > 0)
				{
					foreach (BaseEntity item in obj)
					{
						if (!item.isClient && item is ISplashable splashable && !cachedSplashables.Contains(splashable) && splashable.WantsSplash(currentFuelType, num) && item.IsVisible(position) && (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)) && (!(item is BasePlayer) || !(currentFuelType.baseRadioactivity > 0f)))
						{
							cachedSplashables.Add(splashable);
						}
					}
				}
				Facepunch.Pool.FreeUnmanaged(ref obj);
			}
			if (cachedSplashables.Count > 0)
			{
				int num2 = num / cachedSplashables.Count;
				float num3 = (float)(num % cachedSplashables.Count) / (float)cachedSplashables.Count;
				foreach (ISplashable cachedSplashable in cachedSplashables)
				{
					int amount = num2 + ((UnityEngine.Random.value < num3) ? 1 : 0);
					if (!ObjectEx.IsUnityNull(cachedSplashable) && cachedSplashable.WantsSplash(currentFuelType, amount))
					{
						int num4 = cachedSplashable.DoSplash(currentFuelType, amount);
						num -= num4;
						if (num <= 0)
						{
							break;
						}
					}
				}
			}
			if (DecayPerSplash > 0f)
			{
				Hurt(DecayPerSplash);
			}
		}
		Interface.CallHook("OnSprinklerSplashed", this);
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The Bradley APC that is being initialized.</param>
/// <returns>No return behavior.</returns>
void OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Initializing Bradley APC with ID: {apc.net.ID}.");
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## CanDeployItem(BasePlayer,Deployer,NetworkableId)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can deploy a specific item.
/// </summary>
/// <param name="player">The player attempting to deploy the item.</param>
/// <param name="deployer">The deployable item being placed.</param>
/// <param name="networkableId">The networkable ID of the item being deployed.</param>
/// <returns>
/// Returns `null` to allow the deployment, or a non-null value to prevent it. (object)
/// </returns>
object CanDeployItem(BasePlayer player, Deployer deployer, NetworkableId networkableId)
{
    Puts($"Player {player} is attempting to deploy item with ID {networkableId}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDeploy(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Deployable deployable = GetDeployable();
		if (deployable == null)
		{
			return;
		}
		Ray ray = msg.read.Ray();
		NetworkableId networkableId = msg.read.EntityID();
		if (Interface.CallHook("CanDeployItem", msg.player, this, networkableId) == null)
		{
			if (deployable.toSlot)
			{
				DoDeploy_Slot(deployable, ray, networkableId);
			}
			else
			{
				DoDeploy_Regular(deployable, ray);
			}
		}
	}

```

## OnMapMarkerAdd(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player adds a new marker to the map.
/// </summary>
/// <param name="player">The player who is adding the map marker.</param>
/// <param name="mapNote">The details of the map marker being added.</param>
/// <returns>
/// Returns `null` to allow the marker to be added, or a non-null value to prevent the addition of the marker. (object)
/// </returns>
object OnMapMarkerAdd(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player} is adding a map marker: {mapNote}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 13L;
			if (State.pointsOfInterest == null)
			{
				State.pointsOfInterest = Facepunch.Pool.Get<List<MapNote>>();
			}
			if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
			{
				msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());
				return;
			}
			MapNote mapNote = MapNote.Deserialize(msg.read);
			ValidateMapNote(mapNote);
			mapNote.colourIndex = FindUnusedPointOfInterestColour();
			State.pointsOfInterest.Add(mapNote);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, mapNote);
		}
	}

```

## CanMountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can mount a specific entity.
/// </summary>
/// <param name="player">The player attempting to mount the entity.</param>
/// <param name="mountable">The entity that is being mounted.</param>
/// <returns>
/// Returns `true` if the player can mount the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will be used to determine if the player can mount the entity. (bool)
/// </returns>
object CanMountEntity(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player} is attempting to mount entity {mountable}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform transform = mountAnchor;
			player.SetMounted(this);
			player.MovePosition(transform.position);
			player.transform.rotation = transform.rotation;
			player.ServerRotation = transform.rotation;
			player.OverrideViewAngles(transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(transform.rotation);
			player.SendNetworkUpdateImmediate();
			Facepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
			if (this.IsValid() && player.IsValid())
			{
				player.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);
			}
		}
	}

```

## OnWaterCollect(WaterPump,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when water is collected from a water pump.
/// </summary>
/// <param name="pump">The water pump that is collecting water.</param>
/// <param name="itemDefinition">The item definition of the water being collected.</param>
/// <returns>
/// Returns a non-null value to prevent the water collection, or `null` to allow it. (object)
/// </returns>
object OnWaterCollect(WaterPump pump, ItemDefinition itemDefinition)
{
    Puts($"Water collected from pump {pump} for item {itemDefinition}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CreateWater()
	{
		if (!IsFull())
		{
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(WaterResourceLocation.position);
			if (itemDefinition != null && Interface.CallHook("OnWaterCollect", this, itemDefinition) == null)
			{
				base.inventory.AddItem(itemDefinition, AmountPerPump, 0uL);
				UpdateOnFlag();
			}
		}
	}

```

## OnEngineStarted(MotorRowboat,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the engine of the motorized rowboat has started.
/// </summary>
/// <param name="rowboat">The motorized rowboat whose engine has started.</param>
/// <param name="driver">The player who is driving the rowboat.</param>
/// <returns>No return behavior.</returns>
void OnEngineStarted(MotorRowboat rowboat, BasePlayer driver)
{
    Puts($"Engine started for rowboat driven by {driver}.");
}
```
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.On, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
			if (wantsOn)
			{
				rigidBody.WakeUp();
				buoyancy.Wake();
			}
		}
	}

```

## CanWaterBallSplash(ItemDefinition,UnityEngine.Vector3,float,int)

```csharp
```csharp
/// <summary>
/// Determines if a water splash can occur at a specified position with given parameters.
/// </summary>
/// <param name="liquidDef">The item definition of the liquid being splashed.</param>
/// <param name="position">The position where the splash occurs.</param>
/// <param name="radius">The radius of the splash effect.</param>
/// <param name="amount">The amount of liquid to splash.</param>
/// <returns>
/// Returns `true` if the splash can occur, or `false` if it cannot. 
/// If the method returns `null`, the default game logic will be used to determine if the splash can occur. (bool)
/// </returns>
object CanWaterBallSplash(ItemDefinition liquidDef, Vector3 position, float radius, int amount)
{
    Puts($"Checking if water splash can occur with {liquidDef} at {position} with radius {radius} and amount {amount}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)
	{
		object obj = Interface.CallHook("CanWaterBallSplash", liquidDef, position, radius, amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		List<BaseEntity> obj2 = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, radius, obj2, 1220225811);
		int num = 0;
		int num2 = amount;
		while (amount > 0 && num < 3)
		{
			List<ISplashable> obj3 = Pool.Get<List<ISplashable>>();
			foreach (BaseEntity item in obj2)
			{
				if (!item.isClient && item is ISplashable splashable && !obj3.Contains(splashable) && splashable.WantsSplash(liquidDef, amount))
				{
					bool flag = true;
					if (item is PlanterBox && !GamePhysics.LineOfSight(item.transform.position + new Vector3(0f, 1f, 0f), position, 2097152))
					{
						flag = false;
					}
					if (flag)
					{
						obj3.Add(splashable);
					}
				}
			}
			if (obj3.Count == 0)
			{
				break;
			}
			int b = Mathf.CeilToInt(amount / obj3.Count);
			foreach (ISplashable item2 in obj3)
			{
				int num3 = item2.DoSplash(liquidDef, Mathf.Min(amount, b));
				amount -= num3;
				if (amount <= 0)
				{
					break;
				}
			}
			Pool.FreeUnmanaged(ref obj3);
			num++;
		}
		Pool.FreeUnmanaged(ref obj2);
		return amount < num2;
	}

```

## OnNpcGiveSoldItem(NPCVendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC vending machine gives an item to a player.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that is selling the item.</param>
/// <param name="soldItem">The item that is being sold.</param>
/// <param name="buyer">The player who is buying the item.</param>
/// <returns>No return behavior.</returns>
void OnNpcGiveSoldItem(NPCVendingMachine vendingMachine, Item soldItem, BasePlayer buyer)
{
    Puts($"NPC Vending Machine {vendingMachine} sold item {soldItem} to player {buyer}.");
}
```
```

### Source Code from the Library

```csharp

	public override void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnNpcGiveSoldItem", this, soldItem, buyer) == null)
		{
			base.GiveSoldItem(soldItem, buyer);
		}
	}

```

## OnItemLock(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is locked or unlocked.
/// </summary>
/// <param name="item">The item that is being locked or unlocked.</param>
/// <returns>
/// Returns `null` to allow the locking/unlocking action, or any non-null value to prevent it. (object)
/// </returns>
object OnItemLock(Item item)
{
    Puts($"Item {item} is being locked.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## OnTeamRejectInvite(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a player rejects an invitation to join a team.
/// </summary>
/// <param name="player">The player who rejected the team invite.</param>
/// <param name="team">The team that the player was invited to join.</param>
/// <returns>
/// Returns `null` to allow the default rejection behavior, or a non-null value to override it. (object)
/// </returns>
object OnTeamRejectInvite(BasePlayer player, RelationshipManager.PlayerTeam team)
{
    Puts($"Player {player} has rejected the invite to team {team}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void rejectinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamRejectInvite", basePlayer, playerTeam) == null)
			{
				playerTeam.RejectInvite(basePlayer);
			}
		}
	}

```

## OnLiquidWeaponFiringStopped(LiquidWeapon)

```csharp
```csharp
/// <summary>
/// Called when the firing of a liquid weapon has stopped.
/// </summary>
/// <param name="weapon">The liquid weapon that has stopped firing.</param>
/// <returns>No return behavior.</returns>
void OnLiquidWeaponFiringStopped(LiquidWeapon weapon)
{
    Puts($"Liquid weapon {weapon} has stopped firing.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StopFiring()
	{
		CancelInvoke(FireTick);
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		SetFlag(Flags.On, b: false);
		if (base.isServer)
		{
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnLiquidWeaponFiringStopped", this);
	}

```

## OnFireworkStarted(BaseFirework)

```csharp
```csharp
/// <summary>
/// Called when a firework is started and begins its display.
/// </summary>
/// <param name="firework">The firework that has been started.</param>
/// <returns>No return behavior.</returns>
void OnFireworkStarted(BaseFirework firework)
{
    Puts($"Firework {firework} has started.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Begin()
	{
		SetFlag(Flags.OnFire, b: false);
		SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkStarted", this);
		Invoke(OnExhausted, activityLength);
	}

```

## OnWildlifeTrap(SurvivalFishTrap,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when a wildlife trap successfully catches an item.
/// </summary>
/// <param name="trap">The survival fish trap that caught the item.</param>
/// <param name="itemDefinition">The definition of the item that was caught.</param>
/// <returns>
/// Returns `null` to allow the default behavior of item spawning, or a non-null value to prevent it. (object)
/// </returns>
object OnWildlifeTrap(SurvivalFishTrap trap, ItemDefinition itemDefinition)
{
    Puts($"Wildlife trap {trap} caught item: {itemDefinition}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void TrapThink()
	{
		ItemDefinition itemDefinition = null;
		Item item = null;
		int usedLureAmount = 0;
		using (List<Item>.Enumerator enumerator = base.inventory.itemList.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				if ((current.info.TryGetComponent<ItemModCompostable>(out var component) ? component.BaitValue : 0f) > 0f)
				{
					item = current;
					itemDefinition = FishLookup.Instance.GetFish(base.transform.position, cachedWaterBody, current, out var _, current.info.GetComponent<ItemModFishable>(), out usedLureAmount, 5f);
				}
			}
		}
		item?.UseItem(usedLureAmount);
		if (UnityEngine.Random.Range(0f, 1f) <= trapSuccessRate || !(itemDefinition != null))
		{
			return;
		}
		try
		{
			bypassItemFilter = true;
			if (Interface.CallHook("OnWildlifeTrap", this, itemDefinition) == null)
			{
				Item item2 = ItemManager.Create(itemDefinition, 1, 0uL);
				if (!item2.MoveToContainer(base.inventory))
				{
					item2.Drop(base.transform.position, Vector3.zero, Quaternion.identity);
				}
				OnTrappedWildlife(setFlag: true);
			}
		}
		finally
		{
			bypassItemFilter = false;
		}
	}

```

## OnMissionSucceeded(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is successfully completed by a player.
/// </summary>
/// <param name="mission">The mission that was completed.</param>
/// <param name="instance">The specific instance of the mission that was accomplished.</param>
/// <param name="player">The player who completed the mission.</param>
/// <returns>No return behavior.</returns>
void OnMissionSucceeded(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer player)
{
    Puts($"Mission {mission} succeeded for player {player}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)
	{
		instance.status = MissionStatus.Accomplished;
		MissionEnded(instance, assignee);
		MissionComplete(instance, assignee);
		Interface.CallHook("OnMissionSucceeded", this, instance, assignee);
	}

```

## OnVehicleModuleMove(BaseVehicleModule,BaseModularVehicle,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a vehicle module can be moved by a player.
/// </summary>
/// <param name="module">The vehicle module that is being moved.</param>
/// <param name="vehicle">The vehicle that contains the module.</param>
/// <param name="player">The player attempting to move the module.</param>
/// <returns>
/// Returns `true` if the module can be moved, or `false` if it cannot. 
/// If the method returns `null`, the default game logic will determine if the module can be moved. (bool)
/// </returns>
object OnVehicleModuleMove(BaseVehicleModule module, BaseModularVehicle vehicle, BasePlayer player)
{
    Puts($"Player {player} is attempting to move module {module} from vehicle {vehicle}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		BaseVehicleModule moduleForItem = GetModuleForItem(item);
		if (moduleForItem != null)
		{
			object obj = Interface.CallHook("OnVehicleModuleMove", moduleForItem, this, player);
			if (obj != null)
			{
				if (!(obj is bool))
				{
					return false;
				}
				return (bool)obj;
			}
			return moduleForItem.CanBeMovedNow();
		}
		return true;
	}

```

## CanNetworkTo(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether this player can network to another player.
/// </summary>
/// <param name="sourcePlayer">The player attempting to network.</param>
/// <param name="targetPlayer">The player to which the networking is being checked.</param>
/// <returns>
/// Returns `true` if the source player can network to the target player; otherwise, returns `false`.
/// If the method returns `null`, the default networking logic will be applied. (bool)
/// </returns>
object CanNetworkTo(BasePlayer sourcePlayer, BasePlayer targetPlayer)
{
    Puts($"Checking network capability from {sourcePlayer} to {targetPlayer}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return true;
		}
		if (IsSpectating() && player != this)
		{
			return false;
		}
		bool flag = base.ShouldNetworkTo(player);
		if (ServerOcclusion.OcclusionEnabled && flag)
		{
			flag = OcclusionLineOfSight(player);
		}
		return flag;
	}

```

## OnTerrainCreate(TerrainGenerator)

```csharp
```csharp
/// <summary>
/// Called when creating a new terrain in the game world.
/// </summary>
/// <param name="generator">The terrain generator responsible for creating the terrain.</param>
/// <returns>No return behavior.</returns>
void OnTerrainCreate(TerrainGenerator generator)
{
    Puts($"Creating terrain with generator: {generator}.");
}
```
```

### Source Code from the Library

```csharp

	public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
	{
		Interface.CallHook("OnTerrainCreate", this);
		Terrain component = Terrain.CreateTerrainGameObject(new TerrainData
		{
			baseMapResolution = GetBaseMapRes(),
			heightmapResolution = heightmapResolution,
			alphamapResolution = alphamapResolution,
			size = new Vector3(World.Size, 1000f, World.Size)
		}).GetComponent<Terrain>();
		component.transform.position = base.transform.position + new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);
		component.drawInstanced = false;
		component.castShadows = config.CastShadows;
		component.materialType = Terrain.MaterialType.Custom;
		component.materialTemplate = config.Material;
		component.gameObject.tag = base.gameObject.tag;
		component.gameObject.layer = base.gameObject.layer;
		component.gameObject.GetComponent<TerrainCollider>().sharedMaterial = config.GenericMaterial;
		TerrainMeta terrainMeta = component.gameObject.AddComponent<TerrainMeta>();
		component.gameObject.AddComponent<TerrainPhysics>();
		component.gameObject.AddComponent<TerrainColors>();
		component.gameObject.AddComponent<TerrainCollision>();
		component.gameObject.AddComponent<TerrainBiomeMap>();
		component.gameObject.AddComponent<TerrainAlphaMap>();
		component.gameObject.AddComponent<TerrainHeightMap>();
		component.gameObject.AddComponent<TerrainSplatMap>();
		component.gameObject.AddComponent<TerrainTopologyMap>();
		component.gameObject.AddComponent<TerrainWaterMap>();
		component.gameObject.AddComponent<TerrainPlacementMap>();
		component.gameObject.AddComponent<TerrainPath>();
		component.gameObject.AddComponent<TerrainTexturing>();
		terrainMeta.terrain = component;
		terrainMeta.config = config;
		Object.DestroyImmediate(base.gameObject);
		return component.gameObject;
	}

```

## OnCupboardProtectionCalculated(BuildingPrivlidge,float)

```csharp
```csharp
/// <summary>
/// Called when calculating the protection time provided by a cupboard.
/// </summary>
/// <param name="cupboard">The building privilege associated with the cupboard.</param>
/// <param name="protectedMinutes">The calculated protected minutes for the cupboard.</param>
/// <returns>
/// Returns a modified float value if the hook alters the default protection time; otherwise, returns the original protected minutes. (float)
/// </returns>
object OnCupboardProtectionCalculated(BuildingPrivlidge cupboard, float protectedMinutes)
{
    Puts($"Calculating protection for cupboard {cupboard} with initial protected minutes: {protectedMinutes}.");
    return protectedMinutes; // Allowing the default value to be returned
}
```
```

### Source Code from the Library

```csharp

	public float GetProtectedMinutes(bool force = false)
	{
		if (base.isServer)
		{
			if (!force && UnityEngine.Time.realtimeSinceStartup < nextProtectedCalcTime)
			{
				return cachedProtectedMinutes;
			}
			nextProtectedCalcTime = UnityEngine.Time.realtimeSinceStartup + 60f;
			List<ItemAmount> obj = Facepunch.Pool.Get<List<ItemAmount>>();
			CalculateUpkeepCostAmounts(obj);
			float num = CalculateUpkeepPeriodMinutes();
			float num2 = -1f;
			if (base.inventory != null)
			{
				foreach (ItemAmount item in obj)
				{
					int num3 = base.inventory.FindItemsByItemID(item.itemid).Sum((Item x) => x.amount);
					if (num3 > 0 && item.amount > 0f)
					{
						float num4 = (float)num3 / item.amount * num;
						if (num2 == -1f || num4 < num2)
						{
							num2 = num4;
						}
					}
					else
					{
						num2 = 0f;
					}
				}
				if (num2 == -1f)
				{
					num2 = 0f;
				}
			}
			Facepunch.Pool.FreeUnmanaged(ref obj);
			cachedProtectedMinutes = num2;
			Interface.CallHook("OnCupboardProtectionCalculated", this, cachedProtectedMinutes);
			return cachedProtectedMinutes;
		}
		return 0f;
	}

```

## OnBonusItemDrop(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is about to be dropped for a player.
/// </summary>
/// <param name="item">The bonus item that is being dropped.</param>
/// <param name="player">The player receiving the bonus item.</param>
/// <returns>
/// Returns `null` to allow the item to be dropped as normal. If a non-null value is returned, the drop is canceled. (object)
/// </returns>
object OnBonusItemDrop(Item item, BasePlayer player)
{
    Puts($"Dropping bonus item {item} for player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnFireBallDamage(FireBall,BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a fireball inflicts damage on a target entity.
/// </summary>
/// <param name="fireball">The fireball that is causing the damage.</param>
/// <param name="target">The target entity that is being damaged.</param>
/// <param name="hitInfo">Information about the hit, including damage type and position.</param>
/// <returns>No return behavior.</returns>
void OnFireBallDamage(FireBall fireball, BaseCombatEntity target, HitInfo hitInfo)
{
    Puts($"Fireball from {fireball} hit {target} at position {hitInfo.HitPositionWorld}.");
}
```
```

### Source Code from the Library

```csharp

	public void DoRadialDamage()
	{
		List<BaseCombatEntity> obj = Pool.Get<List<BaseCombatEntity>>();
		Vector3 position = base.transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Entities(position, radius, obj, AttackLayers, QueryTriggerInteraction.Ignore);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = ((creatorEntity == null) ? GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);
		hitInfo.PointStart = base.transform.position;
		foreach (BaseCombatEntity item in obj)
		{
			if (!(item == null) && item.isServer && item.IsAlive() && (!ignoreNPC || !item.IsNpc) && item.IsVisible(position))
			{
				if (item is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", item, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = item.transform.position;
				hitInfo.HitPositionWorld = item.transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", this, item, hitInfo);
				item.OnAttacked(hitInfo);
			}
		}
		Pool.FreeUnmanaged(ref obj);
	}

```

## OnPhoneNameUpdated(PhoneController,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the name of a phone is updated.
/// </summary>
/// <param name="phone">The phone controller whose name is being updated.</param>
/// <param name="newName">The new name for the phone.</param>
/// <param name="player">The player who initiated the name update.</param>
/// <returns>No return behavior.</returns>
void OnPhoneNameUpdated(PhoneController phone, string newName, BasePlayer player)
{
    Puts($"Phone name updated to '{newName}' by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!(msg.player != currentPlayer))
		{
			string text = msg.read.String();
			if (text.Length > 20)
			{
				text = text.Substring(0, 20);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", this, text, msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", this, PhoneName, msg.player);
			}
		}
	}

```

## OnLiquidVesselFill(BaseLiquidVessel,BasePlayer,LiquidContainer)

```csharp
```csharp
/// <summary>
/// Called when a liquid vessel is filled by a player or from the world.
/// </summary>
/// <param name="vessel">The liquid vessel being filled.</param>
/// <param name="player">The player attempting to fill the vessel.</param>
/// <param name="liquidContainer">The liquid container being used to fill the vessel.</param>
/// <returns>
/// Returns a non-null value to prevent the filling action, or `null` to allow it. (object)
/// </returns>
object OnLiquidVesselFill(BaseLiquidVessel vessel, BasePlayer player, LiquidContainer liquidContainer)
{
    Puts($"Player {player} is attempting to fill the liquid vessel {vessel} from {liquidContainer}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FillCheck()
	{
		if (base.isClient)
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		float f = (UnityEngine.Time.realtimeSinceStartup - lastFillTime) * fillMlPerSec;
		Vector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);
		LiquidContainer facingLiquidContainer = GetFacingLiquidContainer();
		if (Interface.CallHook("OnLiquidVesselFill", this, ownerPlayer, facingLiquidContainer) != null)
		{
			return;
		}
		if (facingLiquidContainer == null && CanFillFromWorld())
		{
			Item contents = GetContents();
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(pos);
			if (contents != null && contents.info.itemid != itemDefinition.itemid)
			{
				if ((float)timeSinceLastToast > 5f)
				{
					Debug.Log("pushing toast");
					timeSinceLastToast = 0f;
					ownerPlayer.ShowToast(GameTip.Styles.Red_Normal, DifferentLiquidType, false);
				}
				return;
			}
			AddLiquid(itemDefinition, Mathf.FloorToInt(f));
		}
		else if (facingLiquidContainer != null && facingLiquidContainer.HasLiquidItem())
		{
			int num = Mathf.CeilToInt((1f - HeldFraction()) * (float)MaxHoldable());
			if (num > 0)
			{
				GetContents();
				Item liquidItem = facingLiquidContainer.GetLiquidItem();
				int num2 = Mathf.Min(Mathf.CeilToInt(f), Mathf.Min(liquidItem.amount, num));
				AddLiquid(liquidItem.info, num2);
				liquidItem.UseItem(num2);
				facingLiquidContainer.OpenTap(2f);
			}
		}
		lastFillTime = UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnTurretModeToggle(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the turret mode is toggled by a player.
/// </summary>
/// <param name="turret">The auto turret that is having its mode toggled.</param>
/// <param name="player">The player who is toggling the turret mode.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or a non-null value to prevent the mode toggle. (object)
/// </returns>
object OnTurretModeToggle(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret mode toggled by player {player} for turret {turret}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SERVER_Peacekeeper(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player) && Interface.CallHook("OnTurretModeToggle", this, rpc.player) == null)
		{
			SetPeacekeepermode(isOn: true);
		}
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player performs a melee attack.
/// </summary>
/// <param name="player">The player initiating the melee attack.</param>
/// <param name="hitInfo">Information about the hit, including target and damage details.</param>
/// <returns>
/// Returns `null` to allow the attack to proceed, or any non-null value to prevent the attack from happening. (object)
/// </returns>
object OnMeleeAttack(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player} initiated a melee attack with hit info: {hitInfo}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo obj = Facepunch.Pool.Get<HitInfo>();
			obj.LoadFromAttack(playerAttack.attack, serverSide: true);
			obj.Initiator = player;
			obj.Weapon = this;
			obj.WeaponPrefab = this;
			obj.Predicted = msg.connection;
			obj.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, obj) != null)
			{
				return;
			}
			if (obj.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.LogInvalid(obj, "melee_nan");
				return;
			}
			BaseEntity hitEntity = obj.HitEntity;
			BasePlayer basePlayer = obj.HitEntity as BasePlayer;
			bool flag = basePlayer != null;
			bool flag2 = flag && basePlayer.IsSleeping();
			bool flag3 = flag && basePlayer.IsWounded();
			bool flag4 = flag && basePlayer.isMounted;
			bool flag5 = flag && basePlayer.HasParent();
			bool flag6 = hitEntity != null;
			bool flag7 = flag6 && hitEntity.IsNpc;
			bool flag8;
			int num5;
			Vector3 center;
			Vector3 position;
			Vector3 pointStart;
			Vector3 hitPositionWorld;
			Vector3 vector;
			int num16;
			if (ConVar.AntiHack.melee_protection > 0)
			{
				flag8 = true;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTimeClamped + num2 + num3) * num;
				num5 = 1075904512;
				if (ConVar.AntiHack.melee_terraincheck)
				{
					num5 |= 0x800000;
				}
				if (ConVar.AntiHack.melee_vehiclecheck)
				{
					num5 |= 0x8000000;
				}
				if (flag && obj.boneArea == (HitArea)(-1))
				{
					string shortPrefabName2 = base.ShortPrefabName;
					string shortPrefabName3 = basePlayer.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.MeleeHack, "Bone is invalid  (" + shortPrefabName2 + " on " + shortPrefabName3 + " bone " + obj.HitBone + ")");
					player.stats.combat.LogInvalid(obj, "melee_bone");
					flag8 = false;
				}
				if (ConVar.AntiHack.melee_protection >= 2)
				{
					if (flag6)
					{
						float num6 = hitEntity.MaxVelocity() + hitEntity.GetParentVelocity().magnitude;
						float num7 = hitEntity.BoundsPadding() + num4 * num6;
						float num8 = hitEntity.Distance(obj.HitPositionWorld);
						if (num8 > num7)
						{
							string shortPrefabName4 = base.ShortPrefabName;
							string shortPrefabName5 = hitEntity.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num8 + "m > " + num7 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(obj, "melee_target");
							flag8 = false;
						}
					}
					if (ConVar.AntiHack.melee_protection >= 4 && flag8 && flag && !flag7 && !flag2 && !flag3 && !flag4 && !flag5)
					{
						float magnitude = basePlayer.GetParentVelocity().magnitude;
						float num9 = basePlayer.BoundsPadding() + num4 * magnitude + ConVar.AntiHack.tickhistoryforgiveness;
						float num10 = basePlayer.tickHistory.Distance(basePlayer, obj.HitPositionWorld);
						if (num10 > num9)
						{
							string shortPrefabName6 = base.ShortPrefabName;
							string shortPrefabName7 = basePlayer.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.MeleeHack, "Player too far away (" + shortPrefabName6 + " on " + shortPrefabName7 + " with " + num10 + "m > " + num9 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(obj, "player_distance");
							flag8 = false;
						}
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					if (ConVar.AntiHack.melee_protection >= 4)
					{
						float magnitude2 = player.GetParentVelocity().magnitude;
						float num11 = player.BoundsPadding() + num4 * magnitude2 + num * maxDistance;
						float num12 = player.tickHistory.Distance(player, obj.HitPositionWorld);
						if (num12 > num11)
						{
							string shortPrefabName8 = base.ShortPrefabName;
							string text = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName8 + " on " + text + " with " + num12 + "m > " + num11 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(obj, "melee_initiator");
							flag8 = false;
						}
					}
					else
					{
						float num13 = player.MaxVelocity() + player.GetParentVelocity().magnitude;
						float num14 = player.BoundsPadding() + num4 * num13 + num * maxDistance;
						float num15 = player.Distance(obj.HitPositionWorld);
						if (num15 > num14)
						{
							string shortPrefabName9 = base.ShortPrefabName;
							string text2 = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName9 + " on " + text2 + " with " + num15 + "m > " + num14 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(obj, "melee_initiator");
							flag8 = false;
						}
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					if (flag6)
					{
						center = player.eyes.center;
						position = player.eyes.position;
						pointStart = obj.PointStart;
						hitPositionWorld = obj.HitPositionWorld;
						hitPositionWorld -= (hitPositionWorld - pointStart).normalized * 0.001f;
						vector = obj.PositionOnRay(hitPositionWorld);
						Vector3 vector2 = Vector3.zero;
						Vector3 vector3 = Vector3.zero;
						Vector3 vector4 = Vector3.zero;
						if (ConVar.AntiHack.melee_backtracking > 0f)
						{
							vector2 = (position - center).normalized * ConVar.AntiHack.melee_backtracking;
							vector3 = (pointStart - position).normalized * ConVar.AntiHack.melee_backtracking;
							vector4 = (vector - pointStart).normalized * ConVar.AntiHack.melee_backtracking;
						}
						if (GamePhysics.LineOfSight(center - vector2, position + vector2, num5) && GamePhysics.LineOfSight(position - vector3, pointStart + vector3, num5) && GamePhysics.LineOfSight(pointStart - vector4, vector, num5) && GamePhysics.LineOfSight(vector, hitPositionWorld, num5))
						{
							num16 = (GamePhysics.LineOfSight(position, hitPositionWorld, num5) ? 1 : 0);
							if (num16 != 0)
							{
								player.stats.Add("hit_" + hitEntity.Categorize() + "_direct_los", 1, Stats.Server);
								goto IL_07d5;
							}
						}
						else
						{
							num16 = 0;
						}
						player.stats.Add("hit_" + hitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
						goto IL_07d5;
					}
					goto IL_08c3;
				}
				goto IL_0a2a;
			}
			goto IL_0a3c;
			IL_08c3:
			if (flag8 && flag && !flag7)
			{
				Vector3 hitPositionWorld2 = obj.HitPositionWorld;
				Vector3 position2 = basePlayer.eyes.position;
				Vector3 vector5 = basePlayer.CenterPoint();
				float melee_losforgiveness = ConVar.AntiHack.melee_losforgiveness;
				bool flag9 = GamePhysics.LineOfSight(hitPositionWorld2, position2, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(position2, hitPositionWorld2, num5, melee_losforgiveness, 0f);
				if (!flag9)
				{
					flag9 = GamePhysics.LineOfSight(hitPositionWorld2, vector5, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(vector5, hitPositionWorld2, num5, melee_losforgiveness, 0f);
				}
				if (!flag9)
				{
					string shortPrefabName10 = base.ShortPrefabName;
					string shortPrefabName11 = basePlayer.ShortPrefabName;
					string[] obj2 = new string[12]
					{
						"Line of sight (", shortPrefabName10, " on ", shortPrefabName11, ") ", null, null, null, null, null,
						null, null
					};
					Vector3 vector6 = hitPositionWorld2;
					obj2[5] = vector6.ToString();
					obj2[6] = " ";
					vector6 = position2;
					obj2[7] = vector6.ToString();
					obj2[8] = " or ";
					vector6 = hitPositionWorld2;
					obj2[9] = vector6.ToString();
					obj2[10] = " ";
					vector6 = vector5;
					obj2[11] = vector6.ToString();
					AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj2));
					player.stats.combat.LogInvalid(obj, "melee_los");
					flag8 = false;
				}
			}
			goto IL_0a2a;
			IL_0a2a:
			if (!flag8)
			{
				AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
				return;
			}
			goto IL_0a3c;
			IL_07d5:
			if (num16 == 0)
			{
				string shortPrefabName12 = base.ShortPrefabName;
				string shortPrefabName13 = hitEntity.ShortPrefabName;
				string[] obj3 = new string[14]
				{
					"Line of sight (", shortPrefabName12, " on ", shortPrefabName13, ") ", null, null, null, null, null,
					null, null, null, null
				};
				Vector3 vector6 = center;
				obj3[5] = vector6.ToString();
				obj3[6] = " ";
				vector6 = position;
				obj3[7] = vector6.ToString();
				obj3[8] = " ";
				vector6 = pointStart;
				obj3[9] = vector6.ToString();
				obj3[10] = " ";
				vector6 = vector;
				obj3[11] = vector6.ToString();
				obj3[12] = " ";
				vector6 = hitPositionWorld;
				obj3[13] = vector6.ToString();
				AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj3));
				player.stats.combat.LogInvalid(obj, "melee_los");
				flag8 = false;
			}
			goto IL_08c3;
			IL_0a3c:
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50))
			{
				DoAttackShared(obj);
			}
			Facepunch.Pool.Free(ref obj);
		}
	}

```

## OnTeamLeave(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player leaves a team.
/// </summary>
/// <param name="team">The team that the player is leaving.</param>
/// <param name="player">The player who is leaving the team.</param>
/// <returns>
/// Returns `null` to allow the player to leave the team, or any non-null value to prevent the action. (object)
/// </returns>
object OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player} is leaving team {team}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void leaveteam(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam != 0L)
		{
			PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
			if (playerTeam != null && Interface.CallHook("OnTeamLeave", playerTeam, basePlayer) == null)
			{
				playerTeam.RemovePlayer(basePlayer.userID);
				basePlayer.ClearTeam();
			}
		}
	}

```

## OnMapMarkerRemove(BasePlayer,System.Collections.Generic.List<ProtoBuf.MapNote>,int)

```csharp
```csharp
/// <summary>
/// Called when a player removes a map marker from their points of interest.
/// </summary>
/// <param name="player">The player who is removing the map marker.</param>
/// <param name="markers">The list of current map markers.</param>
/// <param name="index">The index of the marker to be removed.</param>
/// <returns>
/// Returns `null` to allow the removal of the marker, or a non-null value to prevent it. (object)
/// </returns>
object OnMapMarkerRemove(BasePlayer player, List<ProtoBuf.MapNote> markers, int index)
{
    Puts($"Player {player} is attempting to remove map marker at index {index}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	[RPC_Server.FromOwner]
	public void Server_RemovePointOfInterest(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (State.pointsOfInterest != null && State.pointsOfInterest.Count > num && num >= 0 && Interface.CallHook("OnMapMarkerRemove", this, State.pointsOfInterest, num) == null)
		{
			State.pointsOfInterest[num].Dispose();
			State.pointsOfInterest.RemoveAt(num);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
		}
	}

```

## OnEntityControl(AutoTurret,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can control the specified auto turret.
/// </summary>
/// <param name="turret">The auto turret being controlled.</param>
/// <param name="playerId">The ID of the player attempting to control the turret.</param>
/// <returns>
/// Returns `true` if the player can control the turret; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine control eligibility. (bool)
/// </returns>
object OnEntityControl(AutoTurret turret, ulong playerId)
{
    Puts($"Player {playerId} is attempting to control turret {turret}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", this, playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (booting)
		{
			return false;
		}
		if (IsPowered())
		{
			return !PeacekeeperMode();
		}
		return false;
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base player is hurt by an attack.
/// </summary>
/// <param name="player">The player that is being hurt.</param>
/// <param name="info">Information about the hit, including damage types and initiator.</param>
/// <returns>
/// Returns a non-null value to prevent further processing of the hurt event. If null is returned, the default hurt logic will proceed. (object)
/// </returns>
object IOnBasePlayerHurt(BasePlayer player, HitInfo info)
{
    Puts($"Player {player} has been hurt with damage info: {info}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || IsTransferProtected() || (IsImmortalTo(info) && info.damageTypes.Total() >= 0f) || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && !IsNpc && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		if (info.damageTypes.Has(DamageType.Fun_Water))
		{
			bool flag = true;
			Item activeItem = GetActiveItem();
			if (activeItem != null && (activeItem.info.shortname == "gun.water" || activeItem.info.shortname == "pistol.water"))
			{
				float value = metabolism.wetness.value;
				metabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);
				bool flag2 = metabolism.wetness.value >= ConVar.Server.funWaterDamageThreshold;
				flag = !flag2;
				if (info.InitiatorPlayer != null)
				{
					if (flag2 && value < ConVar.Server.funWaterDamageThreshold)
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_SOAKED");
					}
					if (metabolism.radiation_level.Fraction() > 0.2f && !string.IsNullOrEmpty("SUMMER_RADICAL"))
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_RADICAL");
					}
				}
			}
			if (flag)
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
		}
		if (info.damageTypes.Get(DamageType.Drowned) > 5f && drownEffect.isValid)
		{
			Effect.server.Run(drownEffect.resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
		if (modifiers != null)
		{
			if (info.damageTypes.Has(DamageType.Radiation))
			{
				info.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));
			}
			if (info.damageTypes.Has(DamageType.RadiationExposure))
			{
				info.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));
			}
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((bool)initiatorPlayer && initiatorPlayer != this)
		{
			if (initiatorPlayer.InSafeZone() || InSafeZone())
			{
				initiatorPlayer.MarkHostileFor(300f);
			}
			if (initiatorPlayer.InSafeZone() && !initiatorPlayer.IsNpc)
			{
				info.damageTypes.ScaleAll(0f);
				return;
			}
			if (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(DamageType.Explosion) > 0f)
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);
			}
		}
		base.Hurt(info);
		if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
		{
			BasePlayer instigator = info?.InitiatorPlayer;
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerHurt(instigator, this, info);
		}
		if (IsRestrained && info.damageTypes.GetMajorityDamageType().InterruptsRestraintMinigame())
		{
			Handcuffs handcuffs = GetHeldEntity() as Handcuffs;
			if (handcuffs != null)
			{
				handcuffs.InterruptUnlockMiniGame(wasPushedOrDamaged: true);
			}
		}
		EACServer.LogPlayerTakeDamage(this, info);
		metabolism.SendChangesToClient();
		if (info.PointStart != Vector3.zero && (info.damageTypes.Total() >= 0f || IsGod()))
		{
			int arg = (int)info.damageTypes.GetMajorityDamageType();
			if (info.Weapon != null && info.damageTypes.Has(DamageType.Bullet))
			{
				BaseProjectile component = info.Weapon.GetComponent<BaseProjectile>();
				if (component != null && component.IsSilenced())
				{
					arg = 12;
				}
			}
			ClientRPC(RpcTarget.PlayerAndSpectators("DirectionalDamage", this), info.PointStart, arg, Mathf.CeilToInt(info.damageTypes.Total()));
		}
		DeathBlow.From(info, out cachedNonSuicideHit);
	}

```

## OnResearchCostDetermine(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the research cost for a given item.
/// </summary>
/// <param name="item">The item for which the research cost is being determined.</param>
/// <returns>
/// Returns the amount of scrap required for research. If the method returns `null`, the default research cost will be used. (int)
/// </returns>
object OnResearchCostDetermine(Item item)
{
    Puts($"Determining research cost for item: {item} (ID: {item.info.itemid})");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", item);
		if (obj is int)
		{
			return (int)obj;
		}
		return ScrapForResearch(item.info);
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves a trigger area.
/// </summary>
/// <param name="entity">The entity that has left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity} has left the trigger {trigger}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			entityContents.Remove(ent);
			OnEntityLeaveTrigger?.Invoke(ent);
		}
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="block">The building block being modified.</param>
/// <param name="newGrade">The new grade to which the block is being changed.</param>
/// <param name="skinId">The skin ID associated with the new grade.</param>
/// <returns>
/// Returns `true` if the player can change the grade, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the grade change is allowed. (bool)
/// </returns>
object CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum newGrade, ulong skinId)
{
    Puts($"Player {player} is attempting to change the grade of {block} to {newGrade}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade, iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (HasUpgradePrivilege(iGrade, iSkin, player))
		{
			return !IsUpgradeBlocked();
		}
		return false;
	}

```

## OnVehicleModulesAssign(ModularCar,Rust.Modular.ItemModVehicleModule[])

```csharp
```csharp
/// <summary>
/// Called when assigning modules to a modular vehicle.
/// </summary>
/// <param name="vehicle">The modular car to which modules are being assigned.</param>
/// <param name="modules">An array of vehicle modules to be assigned to the vehicle.</param>
/// <returns>
/// Returns a non-null value to prevent the assignment of modules, or `null` to allow the assignment to proceed. (object)
/// </returns>
object OnVehicleModulesAssign(ModularCar vehicle, ItemModVehicleModule[] modules)
{
    Puts($"Assigning modules to vehicle {vehicle} with {modules.Length} modules.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", this, modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				Item item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);
				float num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", this, modularCarPresetConfig.socketItemDefs);
		Invoke(HandleAdminBonus, 0f);
	}

```

## CanBeHomingTargeted(RoadFlare)

```csharp
```csharp
/// <summary>
/// Determines whether the specified road flare can be targeted by homing missiles.
/// </summary>
/// <param name="flare">The road flare to check for homing missile targeting.</param>
/// <returns>
/// Returns `true` if the road flare can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the flare can be targeted. (bool)
/// </returns>
object CanBeHomingTargeted(RoadFlare flare)
{
    Puts($"Checking homing target for Road Flare ID: {flare.net.ID}, Position: {flare.transform.position}.");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## IOnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to approve a user's connection to the server.
/// </summary>
/// <param name="connection">The network connection of the user attempting to connect.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. If `null` is returned, the user is approved to connect. (object)
/// </returns>
object IOnUserApprove(Network.Connection connection)
{
    Puts($"Approving connection for user with ID: {connection.userid} and token: {connection.token}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0L)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2564)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)");
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			ServerUsers.User user = ServerUsers.Get(connection.userid);
			string text = user?.notes ?? "no reason given";
			string text2 = ((user != null && user.expiry > 0) ? (" for " + (user.expiry - Epoch.Current).FormatSecondsLong()) : "");
			Reject(connection, "You are banned from this server" + text2 + " (" + text + ")");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log(connection.ToString() + " has auth level 1");
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log(connection.ToString() + " has auth level 2");
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log(connection.ToString() + " is a developer");
			connection.authLevel = 3u;
		}
		if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used, allowing for custom behavior or adjustments to the amount consumed.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amount">The amount to consume from the item.</param>
/// <returns>
/// Returns the adjusted amount to consume. If the hook returns a non-integer value, the default amount will be used. (int)
/// </returns>
object OnItemUse(Item item, int amount)
{
    Puts($"Using item {item} with initial amount: {amount}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", this, amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## CanLootEntity(BasePlayer,IndustrialCrafter)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="crafter">The industrial crafter being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity; otherwise, returns `false`. 
/// If the method returns a non-null value, it indicates that looting is not allowed. (bool)
/// </returns>
object CanLootEntity(BasePlayer player, IndustrialCrafter crafter)
{
    Puts($"Player {player} is attempting to loot entity {crafter}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (NeedsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if (OnlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(_inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), LootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to loot another player.
/// </summary>
/// <param name="looter">The player who is looting.</param>
/// <param name="target">The player being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"{looter} is attempting to loot {target}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_LootPlayer(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))
		{
			player.inventory.loot.AddContainer(inventory.containerMain);
			player.inventory.loot.AddContainer(inventory.containerWear);
			player.inventory.loot.AddContainer(inventory.containerBelt);
			Interface.CallHook("OnLootPlayer", this, player);
			player.inventory.loot.SendImmediate();
			player.RadioactiveLootCheck(player.inventory.loot.containers);
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "player_corpse");
		}
	}

```

## OnTurretAssigned(AutoTurret,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is assigned to a player.
/// </summary>
/// <param name="turret">The turret that is being assigned.</param>
/// <param name="playerId">The unique identifier of the player to whom the turret is assigned.</param>
/// <param name="player">The player who is being assigned to the turret.</param>
/// <returns>No return behavior.</returns>
void OnTurretAssigned(AutoTurret turret, ulong playerId, BasePlayer player)
{
    Puts($"Turret {turret} assigned to player {player} with ID {playerId}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", this, num, msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = num;
			playerNameID.username = username;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(playerNameID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", this, num, msg.player);
		}
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when an auto turret is shutting down.
/// </summary>
/// <param name="turret">The auto turret that is shutting down.</param>
/// <returns>No return behavior.</returns>
void OnTurretShutdown(AutoTurret turret)
{
    Puts($"Auto turret {turret} is shutting down.");
}
```
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if ((!IsOffline() || booting) && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			CancelInvoke(SetOnline);
			booting = false;
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## OnSurveyGather(SurveyCharge,Item)

```csharp
```csharp
/// <summary>
/// Called when resources are gathered from a survey charge explosion.
/// </summary>
/// <param name="surveyCharge">The survey charge that triggered the gathering.</param>
/// <param name="item">The item that was gathered as a result of the survey.</param>
/// <returns>No return behavior.</returns>
void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts($"Survey charge at {surveyCharge.transform.position} gathered item: {item.info.shortname}.");
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		base.Explode();
		if (WaterLevel.Test(base.transform.position, waves: true, volumes: true, this))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))
		{
			return;
		}
		Vector3 point = hitOut.point;
		_ = hitOut.normal;
		List<SurveyCrater> obj = Pool.Get<List<SurveyCrater>>();
		Vis.Entities(base.transform.position, 10f, obj, 1);
		bool num = obj.Count > 0;
		Pool.FreeUnmanaged(ref obj);
		if (num)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag = true;
				if (resource.isLiquid)
				{
					flag2 = true;
				}
				for (int i = 0; i < num2; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", this, item);
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);
					item.Drop(base.transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
				}
			}
		}
		if (flag)
		{
			string strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);
			BaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if ((bool)baseEntity)
			{
				baseEntity.Spawn();
			}
		}
	}

```

## OnPlayerMarkersSend(BasePlayer,ProtoBuf.MapNoteList)

```csharp
```csharp
/// <summary>
/// Called when sending player markers to the client.
/// </summary>
/// <param name="player">The player receiving the markers.</param>
/// <param name="mapNoteList">The list of map notes to be sent to the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerMarkersSend(BasePlayer player, ProtoBuf.MapNoteList mapNoteList)
{
    Puts($"Sending markers to player {player} with {mapNoteList.notes.Count} notes.");
}
```
```

### Source Code from the Library

```csharp

	public void SendMarkersToClient()
	{
		using MapNoteList mapNoteList = Facepunch.Pool.Get<MapNoteList>();
		mapNoteList.notes = Facepunch.Pool.Get<List<MapNote>>();
		if (ServerCurrentDeathNote != null)
		{
			mapNoteList.notes.Add(ServerCurrentDeathNote);
		}
		if (State.pointsOfInterest != null)
		{
			mapNoteList.notes.AddRange(State.pointsOfInterest);
		}
		Interface.CallHook("OnPlayerMarkersSend", this, mapNoteList);
		ClientRPC(RpcTarget.Player("Client_ReceiveMarkers", this), mapNoteList);
		mapNoteList.notes.Clear();
	}

```

## OnInventoryAmmoFind(PlayerInventory,System.Collections.Generic.List<Item>,Rust.AmmoTypes)

```csharp
```csharp
/// <summary>
/// Called to find ammunition of a specified type in the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory from which to find ammo.</param>
/// <param name="ammoList">A list to populate with found ammunition items.</param>
/// <param name="ammoType">The type of ammunition to search for.</param>
/// <returns>No return behavior.</returns>
void OnInventoryAmmoFind(PlayerInventory inventory, List<Item> ammoList, AmmoTypes ammoType)
{
    Puts($"Searching for {ammoType} ammo in inventory.");
}
```
```

### Source Code from the Library

```csharp

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		if (Interface.CallHook("OnInventoryAmmoFind", this, list, ammoType) == null)
		{
			containerMain?.FindAmmo(list, ammoType);
			containerBelt?.FindAmmo(list, ammoType);
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player disconnects from the server.
/// </summary>
/// <param name="player">The player who has disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player} has disconnected. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void OnDisconnected(string strReason, Network.Connection connection)
	{
		Facepunch.Rust.Analytics.Azure.OnPlayerDisconnected(connection, strReason);
		GlobalNetworkHandler.server.OnClientDisconnected(connection);
		connectionQueue.TryAddReservedSlot(connection);
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		if (connection.authStatusSteam == "ok")
		{
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
		if (connection.authStatusNexus == "ok")
		{
			NexusServer.Logout(connection.userid);
		}
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player toggles the vending machine's broadcast status.
/// </summary>
/// <param name="vendingMachine">The vending machine whose broadcast status is being toggled.</param>
/// <param name="player">The player who toggled the broadcast status.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player} toggled the broadcast status for vending machine {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## OnPhoneDialFail(PhoneController,Telephone.DialFailReason,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing attempt fails.
/// </summary>
/// <param name="phone">The phone controller that initiated the call.</param>
/// <param name="reason">The reason for the dialing failure.</param>
/// <param name="player">The player who attempted to make the call.</param>
/// <returns>
/// Returns a non-null value to override the default failure behavior. If `null` is returned, the default behavior will proceed. (object)
/// </returns>
object OnPhoneDialFail(PhoneController phone, Telephone.DialFailReason reason, BasePlayer player)
{
    Puts($"Phone dialing failed for player {player} due to reason: {reason}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", this, reason, currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientOnDialFailed"), (int)reason);
			activeCallTo = null;
			if (IsInvoking(TimeOutCall))
			{
				CancelInvoke(TimeOutCall);
			}
			if (IsInvoking(TriggerTimeOut))
			{
				CancelInvoke(TriggerTimeOut);
			}
			if (IsInvoking(TimeOutDialing))
			{
				CancelInvoke(TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", this, reason, currentPlayer);
		}
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player has respawned in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player} has respawned.");
}
```
```

### Source Code from the Library

```csharp

	public void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity = null)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((bool)activeGameMode && !activeGameMode.CanPlayerRespawn(this))
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		respawnId = Guid.NewGuid().ToString("N");
		ServerPerformance.spawns++;
		SetParent(null, worldPositionStays: true);
		base.transform.SetPositionAndRotation(position, rotation);
		tickInterpolator.Reset(position);
		tickHistory.Reset(position);
		eyeHistory.Clear();
		estimatedVelocity = Vector3.zero;
		estimatedSpeed = 0f;
		estimatedSpeed2D = 0f;
		lastTickTime = 0f;
		StopWounded();
		ResetWoundingVars();
		StopSpectating();
		UpdateNetworkGroup();
		EnablePlayerCollider();
		RemovePlayerRigidbody();
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		if (modifiers != null)
		{
			modifiers.RemoveAll();
		}
		InitializeHealth(StartHealth(), StartMaxHealth());
		bool flag = false;
		if (ConVar.Server.respawnWithLoadout)
		{
			string infoString = GetInfoString("client.respawnloadout", string.Empty);
			if (!string.IsNullOrEmpty(infoString) && Inventory.LoadLoadout(infoString, out var so))
			{
				so.LoadItemsOnTo(this);
				flag = true;
			}
		}
		if (!flag)
		{
			inventory.GiveDefaultItems();
		}
		SendNetworkUpdateImmediate();
		ClientRPC(RpcTarget.Player("StartLoading", this));
		Facepunch.Rust.Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);
		if ((bool)activeGameMode)
		{
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);
		}
		if (IsConnected)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", this);
		ProcessMissionEvent(BaseMission.MissionEventType.RESPAWN, 0, 0f);
	}

```

## OnHelicopterStrafeEnter(PatrolHelicopterAI,UnityEngine.Vector3,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a helicopter begins a strafing run on a target player.
/// </summary>
/// <param name="helicopter">The helicopter initiating the strafe.</param>
/// <param name="targetPosition">The position of the target player.</param>
/// <param name="targetPlayer">The player being targeted for the strafe.</param>
/// <returns>
/// Returns `null` to allow the strafe to proceed, or a non-null value to prevent the strafe from occurring. (object)
/// </returns>
object OnHelicopterStrafeEnter(PatrolHelicopterAI helicopter, Vector3 targetPosition, BasePlayer targetPlayer)
{
    Puts($"Helicopter {helicopter} is attempting to strafe player {targetPlayer} at position {targetPosition}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		if (Interface.CallHook("OnHelicopterStrafeEnter", this, strafeTarget.transform.position, strafeTarget) == null)
		{
			strafe_target = strafeTarget;
			get_out_of_strafe_distance = UnityEngine.Random.Range(13f, 17f);
			if (CanUseNapalm() && shouldUseNapalm)
			{
				passNapalm = shouldUseNapalm;
				useNapalm = true;
				lastNapalmTime = UnityEngine.Time.realtimeSinceStartup;
			}
			lastStrafeTime = UnityEngine.Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			RefreshTargetPosition();
			numRocketsLeft = 12 + UnityEngine.Random.Range(-1, 1);
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafe_target_position, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

```

## OnFireworkDamage(BaseFirework,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a firework is damaged.
/// </summary>
/// <param name="firework">The firework that has been damaged.</param>
/// <param name="hitInfo">Information about the hit, including damage type and amount.</param>
/// <returns>
/// Returns `null` to allow the default damage behavior, or a non-null value to override it. (object)
/// </returns>
object OnFireworkDamage(BaseFirework firework, HitInfo hitInfo)
{
    Puts($"Firework {firework} was damaged with hit info: {hitInfo}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Interface.CallHook("OnFireworkDamage", this, info) == null && info.damageTypes.Has(DamageType.Heat))
		{
			StaggeredTryLightFuse();
		}
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is hunting for a target.
/// </summary>
/// <param name="apc">The Bradley APC that is hunting.</param>
/// <returns>
/// Returns a non-null value to override the default hunting behavior. If `null` is returned, the APC will proceed with its normal hunting logic. (object)
/// </returns>
object OnBradleyApcHunt(BradleyAPC apc)
{
    Puts($"Bradley APC {apc} is initiating a hunt.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			IAIPathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<IAIPathNode> nodes = Facepunch.Pool.Get<List<IAIPathNode>>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			IAIPathNode iAIPathNode = null;
			List<IAIPathNode> nearNodes = Facepunch.Pool.Get<List<IAIPathNode>>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<IAIPathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (IAIPathNode item2 in nearNodes)
			{
				Stack<IAIPathNode> path = new Stack<IAIPathNode>();
				if (targetInfo.entity.IsVisible(item2.Position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					iAIPathNode = item2;
				}
			}
			if (stack == null && nearNodes.Count > 0)
			{
				Stack<IAIPathNode> path2 = new Stack<IAIPathNode>();
				IAIPathNode iAIPathNode2 = nearNodes[UnityEngine.Random.Range(0, nearNodes.Count)];
				if (AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) && pathCost2 < num)
				{
					stack = path2;
					iAIPathNode = iAIPathNode2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].Position);
					}
				}
				foreach (IAIPathNode item3 in stack)
				{
					currentPath.Add(item3.Position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = iAIPathNode.Position;
			}
			Facepunch.Pool.FreeUnmanaged(ref nearNodes);
			Facepunch.Pool.FreeUnmanaged(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## OnRackedWeaponMount(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is mounted on a weapon rack.
/// </summary>
/// <param name="item">The weapon item being mounted.</param>
/// <param name="player">The player who is mounting the weapon.</param>
/// <param name="rack">The weapon rack where the weapon is being mounted.</param>
/// <returns>
/// Returns `true` if the weapon was successfully mounted, or `false` if it could not be mounted.
/// If the method returns a non-null value, it overrides the default mounting behavior. (bool)
/// </returns>
object OnRackedWeaponMount(Item item, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player} is attempting to mount weapon {item} on rack {rack}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", item, player, this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			Debug.LogWarning("no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if (player != null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", item, player, this);
		return true;
	}

```

## OnPlayerWantsMount(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player expresses a desire to mount a vehicle or object.
/// </summary>
/// <param name="player">The player who wants to mount.</param>
/// <param name="mountable">The mountable object the player wants to interact with.</param>
/// <returns>No return behavior.</returns>
void OnPlayerWantsMount(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player} wants to mount {mountable}.");
}
```
```

### Source Code from the Library

```csharp

	public void WantsMount(BasePlayer player)
	{
		if (!player.IsValid() || !player.CanInteract() || Interface.CallHook("OnPlayerWantsMount", player, this) != null)
		{
			return;
		}
		if (!DirectlyMountable())
		{
			BaseVehicle baseVehicle = VehicleParent();
			if (baseVehicle != null)
			{
				baseVehicle.WantsMount(player);
				return;
			}
		}
		AttemptMount(player);
	}

```

## OnDigitalClockRingStop(DigitalClock)

```csharp
```csharp
/// <summary>
/// Called when the digital clock stops ringing.
/// </summary>
/// <param name="clock">The digital clock that has stopped ringing.</param>
/// <returns>No return behavior.</returns>
void OnDigitalClockRingStop(DigitalClock clock)
{
    Puts($"Digital clock {clock} has stopped ringing.");
}
```
```

### Source Code from the Library

```csharp

	private void StopRinging()
	{
		if (Interface.CallHook("OnDigitalClockRingStop", this) == null)
		{
			isRinging = false;
			ClientRPC(RpcTarget.NetworkGroup("RPC_StopRinging"));
			MarkDirty();
		}
	}

```

## OnEntityLoaded(BaseNetworkable,BaseNetworkable.LoadInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is loaded from a save file or network.
/// </summary>
/// <param name="entity">The entity that is being loaded.</param>
/// <param name="loadInfo">The information related to the loading process.</param>
/// <returns>No return behavior.</returns>
void OnEntityLoaded(BaseNetworkable entity, BaseNetworkable.LoadInfo loadInfo)
{
    Puts($"Entity {entity} is being loaded with prefab ID: {loadInfo.msg.baseNetworkable.prefabID}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Load(LoadInfo info)
	{
		if (info.msg.baseNetworkable != null)
		{
			LoadInfo loadInfo = info;
			Interface.CallHook("OnEntityLoaded", this, info);
			ProtoBuf.BaseNetworkable baseNetworkable = loadInfo.msg.baseNetworkable;
			if (prefabID != baseNetworkable.prefabID)
			{
				Debug.LogError("Prefab IDs don't match! " + prefabID + "/" + baseNetworkable.prefabID + " -> " + base.gameObject, base.gameObject);
			}
		}
	}

```

## OnBuildingSplit(BuildingManager.Building,uint)

```csharp
```csharp
/// <summary>
/// Called when a building is split into separate parts.
/// </summary>
/// <param name="building">The building that is being split.</param>
/// <param name="newBuildingID">The new unique identifier for the split building.</param>
/// <returns>No return behavior.</returns>
void OnBuildingSplit(BuildingManager.Building building, uint newBuildingID)
{
    Puts($"Building {building} has been split. New Building ID: {newBuildingID}.");
}
```
```

### Source Code from the Library

```csharp

	private void Split(Building building)
	{
		while (building.HasBuildingBlocks())
		{
			BuildingBlock buildingBlock = building.buildingBlocks[0];
			uint newID = BuildingManager.server.NewBuildingID();
			Interface.CallHook("OnBuildingSplit", building, newID);
			buildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)
			{
				b.AttachToBuilding(newID);
			});
		}
		while (building.HasBuildingPrivileges())
		{
			BuildingPrivlidge buildingPrivlidge = building.buildingPrivileges[0];
			BuildingBlock nearbyBuildingBlock = buildingPrivlidge.GetNearbyBuildingBlock();
			buildingPrivlidge.AttachToBuilding(nearbyBuildingBlock ? nearbyBuildingBlock.buildingID : 0u);
		}
		while (building.HasDecayEntities())
		{
			DecayEntity decayEntity = building.decayEntities[0];
			BuildingBlock nearbyBuildingBlock2 = decayEntity.GetNearbyBuildingBlock();
			decayEntity.AttachToBuilding(nearbyBuildingBlock2 ? nearbyBuildingBlock2.buildingID : 0u);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(building, ref ticks, 0);
		}
	}

```

## OnPortalUsed(BasePlayer,BasePortal)

```csharp
```csharp
/// <summary>
/// Called when a player uses a portal to teleport to another location.
/// </summary>
/// <param name="player">The player using the portal.</param>
/// <param name="portal">The portal being used.</param>
/// <returns>No return behavior.</returns>
void OnPortalUsed(BasePlayer player, BasePortal portal)
{
    Puts($"Player {player} has used the portal {portal}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void UsePortal(BasePlayer player)
	{
		if (Interface.CallHook("OnPortalUse", player, this) != null)
		{
			return;
		}
		LinkPortal();
		if (targetPortal != null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			Vector3 position = player.transform.position;
			Vector3 vector = targetPortal.GetLocalEntryExitPosition();
			Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 vector3 = vector2;
			if (isMirrored)
			{
				Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);
				vector = targetPortal.relativeAnchor.transform.TransformPoint(position2);
				vector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);
			}
			else
			{
				vector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, vector, Vector3.up);
			}
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(vector);
			player.ForceUpdateTriggers();
			player.ClientRPC(RpcTarget.Player("ForceViewAnglesTo", player), vector3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			player.ClientRPC(RpcTarget.Player("StartLoading_Quick", player), arg1: true);
			Interface.CallHook("OnPortalUsed", player, this);
		}
		else
		{
			Debug.Log("No portal...");
		}
	}

```

## CanHackCrate(BasePlayer,HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hack a locked crate.
/// </summary>
/// <param name="player">The player attempting to hack the crate.</param>
/// <param name="crate">The hackable locked crate being targeted.</param>
/// <returns>
/// Returns `true` if the player can hack the crate, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can hack the crate. (bool)
/// </returns>
object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
{
    Puts($"Player {player} is attempting to hack crate {crate}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", msg.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);
			originalHackerPlayerId = msg.player.userID;
			originalHackerPlayer = msg.player;
			StartHacking();
		}
	}

```

## OnTurretToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the state of an auto turret is toggled (online/offline).
/// </summary>
/// <param name="turret">The auto turret whose state is being toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret} has been toggled. Current state: {(turret.IsOn() ? "Online" : "Offline")}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != IsOn() && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			if (online)
			{
				TryRegisterForInterferenceUpdate();
			}
			else
			{
				SetFlag(Flags.OnFire, b: false);
				UpdateInterferenceOnOthers();
			}
			booting = false;
			GetAttachedWeapon()?.SetLightsOn(online);
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
				authDirty = true;
			}
		}
	}

```

## OnPlayerInput(BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player provides input during their tick update.
/// </summary>
/// <param name="player">The player providing the input.</param>
/// <param name="inputState">The current state of the player's input.</param>
/// <returns>
/// Returns `null` to allow default input processing, or a non-null value to override the default behavior. (object)
/// </returns>
object OnPlayerInput(BasePlayer player, InputState inputState)
{
    Puts($"Player {player} input received: {inputState}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		if (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)
		{
			UpdateActiveItem(restraintItemId.Value);
		}
		else
		{
			UpdateActiveItem(msg.activeItem);
		}
		UpdateModelStateFromTick(msg);
		if (IsIncapacitated())
		{
			return;
		}
		if (isMounted)
		{
			GetMounted().PlayerServerInput(serverInput, this);
		}
		UpdatePositionFromTick(msg, wasPlayerStalled);
		UpdateRotationFromTick(msg);
		int activeMission = GetActiveMission();
		if (activeMission >= 0 && activeMission < missions.Count)
		{
			BaseMission.MissionInstance missionInstance = missions[activeMission];
			if (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())
			{
				ProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);
			}
		}
		if (TutorialIsland.EnforceTrespassChecks && !IsAdmin && !IsNpc && net != null && net.group != null)
		{
			if (net.group.restricted)
			{
				bool flag = false;
				if (!IsInTutorial)
				{
					flag = true;
				}
				else
				{
					TutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();
					if (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)
					{
						flag = true;
					}
				}
				if (flag)
				{
					tutorialKickTime += UnityEngine.Time.deltaTime;
					if (tutorialKickTime > 3f)
					{
						Debug.LogWarning($"Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn't belong them");
						Hurt(999f);
						tutorialKickTime = 0f;
					}
				}
				else
				{
					tutorialKickTime = 0f;
				}
			}
			else if (IsInTutorial && !net.group.restricted)
			{
				bool flag2 = false;
				TutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();
				if (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)
				{
					flag2 = true;
				}
				if (flag2)
				{
					tutorialKickTime += UnityEngine.Time.deltaTime;
					if (tutorialKickTime > 3f)
					{
						Debug.LogWarning($"Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial");
						Hurt(999f);
						tutorialKickTime = 0f;
					}
				}
				else
				{
					tutorialKickTime = 0f;
				}
			}
		}
		using (TimeWarning.New("AnalyticsTick"))
		{
			Facepunch.Rust.Analytics.Azure.OnPlayerTick(this);
		}
	}

```

## CanTrainCarCouple(TrainCar,TrainCar)

```csharp
```csharp
/// <summary>
/// Called to determine if two train cars can couple together.
/// </summary>
/// <param name="trainCarA">The first train car attempting to couple.</param>
/// <param name="trainCarB">The second train car attempting to couple.</param>
/// <returns>
/// Returns `true` if the train cars can couple, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the coupling is allowed. (bool)
/// </returns>
object CanTrainCarCouple(TrainCar trainCarA, TrainCar trainCarB)
{
    Puts($"Checking if TrainCar {trainCarA} can couple with TrainCar {trainCarB}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool TryCouple(TrainCoupling theirCoupling, bool reflect)
	{
		if (!isValid)
		{
			return false;
		}
		if (CoupledTo == theirCoupling)
		{
			return true;
		}
		if (IsCoupled)
		{
			return false;
		}
		object obj = Interface.CallHook("CanTrainCarCouple", owner, theirCoupling.owner);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (reflect && !theirCoupling.TryCouple(this, reflect: false))
		{
			return false;
		}
		CoupledTo = theirCoupling;
		owner.SetFlag(flag, b: true, recursive: false, networkupdate: false);
		owner.SendNetworkUpdate();
		return true;
	}

```

## OnFlameExplosion(FlameExplosive,UnityEngine.Collider)

```csharp
```csharp
/// <summary>
/// Called when a flame explosion occurs, allowing for additional effects or modifications.
/// </summary>
/// <param name="explosive">The flame explosive that triggered the explosion.</param>
/// <param name="collider">The collider associated with the explosion.</param>
/// <returns>No return behavior.</returns>
void OnFlameExplosion(FlameExplosive explosive, UnityEngine.Collider collider)
{
    Puts($"Flame explosion triggered by {explosive} with collider {collider}.");
}
```
```

### Source Code from the Library

```csharp

	public void FlameExplode(Vector3 surfaceNormal)
	{
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = base.transform.position;
		if (blockCreateUnderwater && WaterLevel.Test(position, waves: true, volumes: false))
		{
			base.Explode();
			return;
		}
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);
			if ((bool)baseEntity)
			{
				float num = (float)i / numToCreate;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);
				float y = UnityEngine.Random.Range(0f, 360f);
				Quaternion rotation = Quaternion.Euler(0f, y, 0f);
				baseEntity.transform.SetPositionAndRotation(position, rotation);
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				baseEntity.Spawn();
				Interface.CallHook("OnFlameExplosion", this, component);
				Vector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * UnityEngine.Random.Range(1f, 1.1f));
				FireBall component2 = baseEntity.GetComponent<FireBall>();
				if (component2 != null)
				{
					component2.SetDelayedVelocity(vector);
				}
				else
				{
					baseEntity.SetVelocity(vector);
				}
			}
		}
		base.Explode();
	}

```

## OnEntityMounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player mounts an entity.
/// </summary>
/// <param name="mountable">The mountable entity being mounted.</param>
/// <param name="player">The player who is mounting the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityMounted(BaseMountable mountable, BasePlayer player)
{
    Puts($"Player {player} has mounted the entity {mountable}.");
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform transform = mountAnchor;
			player.SetMounted(this);
			player.MovePosition(transform.position);
			player.transform.rotation = transform.rotation;
			player.ServerRotation = transform.rotation;
			player.OverrideViewAngles(transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(transform.rotation);
			player.SendNetworkUpdateImmediate();
			Facepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
			if (this.IsValid() && player.IsValid())
			{
				player.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);
			}
		}
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that is being locked.</param>
/// <param name="player">The player who is locking the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign} has been locked by player {player} (ID: {player.userID}).");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## CanUpdateSign(BasePlayer,PhotoFrame)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update the sign associated with this photo frame.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="photoFrame">The photo frame being updated.</param>
/// <returns>
/// Returns `true` if the player can update the sign; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can update the sign. (bool)
/// </returns>
object CanUpdateSign(BasePlayer player, PhotoFrame photoFrame)
{
    Puts($"Player {player} is attempting to update the sign on photo frame {photoFrame}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

```

## CanHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Determines whether the helicopter can drop a crate.
/// </summary>
/// <param name="helicopter">The helicopter AI controller attempting to drop a crate.</param>
/// <returns>
/// Returns `true` if the helicopter can drop a crate; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will be used to determine if a crate can be dropped. (bool)
/// </returns>
object CanHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Checking if helicopter {helicopter} can drop a crate.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an oven is toggled on or off by a player.
/// </summary>
/// <param name="oven">The oven that is being toggled.</param>
/// <param name="player">The player who is toggling the oven.</param>
/// <returns>No return behavior.</returns>
void OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts($"Player {player} toggled the oven {oven}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	protected virtual void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnOvenToggle", this, msg.player) != null || flag == IsOn() || (needsBuildingPrivilegeToUse && !msg.player.CanBuild()))
		{
			return;
		}
		if (flag)
		{
			StartCooking();
			if (msg.player != null)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.STARTOVEN, new BaseMission.MissionEventPayload
				{
					UintIdentifier = prefabID,
					NetworkIdentifier = net.ID
				}, 1f);
			}
		}
		else
		{
			StopCooking();
		}
	}

```

## OnExplosiveDud(DudTimedExplosive)

```csharp
```csharp
/// <summary>
/// Called when a timed explosive becomes a dud and fails to detonate.
/// </summary>
/// <param name="explosive">The dud timed explosive that failed to detonate.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or any non-null value to override the dud behavior. (object)
/// </returns>
object OnExplosiveDud(DudTimedExplosive explosive)
{
    Puts($"Explosive {explosive} has become a dud and will not detonate.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		if (creatorEntity != null && creatorEntity.IsNpc)
		{
			base.Explode();
		}
		else if (UnityEngine.Random.Range(0f, 1f) < dudChance && Interface.CallHook("OnExplosiveDud", this) == null)
		{
			BecomeDud();
		}
		else
		{
			base.Explode();
		}
	}

```

## OnGiveSoldItem(VendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is given to a player from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine dispensing the item.</param>
/// <param name="soldItem">The item being sold.</param>
/// <param name="buyer">The player purchasing the item.</param>
/// <returns>No return behavior.</returns>
void OnGiveSoldItem(VendingMachine vendingMachine, Item soldItem, BasePlayer buyer)
{
    Puts($"Item {soldItem} given to player {buyer} from vending machine {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", this, soldItem, buyer) == null)
		{
			while (soldItem.amount > soldItem.MaxStackable())
			{
				Item item = soldItem.SplitItem(soldItem.MaxStackable());
				buyer.GiveItem(item, GiveItemReason.PickedUp);
			}
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

```

## OnPlayerCorpseSpawned(BasePlayer,PlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player's corpse is spawned after death.
/// </summary>
/// <param name="player">The player whose corpse is being spawned.</param>
/// <param name="corpse">The corpse that has been created.</param>
/// <returns>
/// Returns a modified corpse if the hook alters the default behavior; otherwise, returns the original corpse. (BaseCorpse)
/// </returns>
object OnPlayerCorpseSpawned(BasePlayer player, PlayerCorpse corpse)
{
    Puts($"Corpse spawned for player {player} with SteamID {player.userID}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? "assets/prefabs/player/player_corpse.prefab" : "assets/prefabs/player/player_corpse_new.prefab");
			bool flag = false;
			if (ConVar.Global.cinematicGingerbreadCorpses)
			{
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);
						flag = component.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.streamerName = RandomUsernames.Get(userID);
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				if (!CollectionEx.IsNullOrEmpty(triggersOnDeath))
				{
					foreach (TriggerBase item2 in triggersOnDeath)
					{
						if (item2 is TriggerParent triggerParent)
						{
							triggerParent.ForceParentEarly(playerCorpse);
						}
					}
				}
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			UnityEngine.Random.State state = UnityEngine.Random.state;
			UnityEngine.Random.InitState((int)(seed + steamid));
			float result = UnityEngine.Random.Range(0f, 1f);
			UnityEngine.Random.state = state;
			return result;
		}
	}

```

## OnNpcTargetSense(BaseEntity,BaseEntity,AIBrainSenses)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses a target entity.
/// </summary>
/// <param name="target">The entity that is being sensed.</param>
/// <param name="owner">The NPC that is sensing the target.</param>
/// <param name="brainSenses">The AI brain senses associated with the NPC.</param>
/// <returns>
/// Returns a non-null value to override the default sensing behavior. If `null` is returned, the default logic will apply. (object)
/// </returns>
object OnNpcTargetSense(BaseEntity target, BaseEntity owner, AIBrainSenses brainSenses)
{
    Puts($"NPC {owner} senses target {target}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)
	{
		if (Interface.CallHook("OnNpcTargetSense", owner, ent, brainSenses) != null)
		{
			return;
		}
		IAISenses iAISenses = owner as IAISenses;
		BasePlayer basePlayer = ent as BasePlayer;
		if (basePlayer != null && PlayerIgnoreList.Contains(basePlayer))
		{
			return;
		}
		bool flag = false;
		if (iAISenses != null && iAISenses.IsThreat(ent))
		{
			flag = true;
			if (brainSenses != null)
			{
				brainSenses.LastThreatTimestamp = UnityEngine.Time.realtimeSinceStartup;
			}
		}
		for (int i = 0; i < All.Count; i++)
		{
			if (All[i].Entity == ent)
			{
				SeenInfo value = All[i];
				value.Position = ent.transform.position;
				value.Timestamp = Mathf.Max(UnityEngine.Time.realtimeSinceStartup, value.Timestamp);
				All[i] = value;
				return;
			}
		}
		if (basePlayer != null)
		{
			if (ConVar.AI.ignoreplayers && !basePlayer.IsNpc)
			{
				return;
			}
			Players.Add(ent);
		}
		if (iAISenses != null)
		{
			if (iAISenses.IsTarget(ent))
			{
				Targets.Add(ent);
			}
			if (iAISenses.IsFriendly(ent))
			{
				Friendlies.Add(ent);
			}
			if (flag)
			{
				Threats.Add(ent);
			}
		}
		All.Add(new SeenInfo
		{
			Entity = ent,
			Position = ent.transform.position,
			Timestamp = UnityEngine.Time.realtimeSinceStartup
		});
	}

```

## OnCorpsePopulate(NPCPlayer,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when populating a corpse with items and data after an NPC player dies.
/// </summary>
/// <param name="npc">The NPC player that has died.</param>
/// <param name="corpse">The corpse that is being populated.</param>
/// <returns>
/// Returns a modified corpse if the hook alters the default behavior; otherwise, returns the original corpse. (BaseCorpse)
/// </returns>
object OnCorpsePopulate(NPCPlayer npc, NPCPlayerCorpse corpse)
{
    Puts($"Populating corpse for NPC {npc} with SteamID {npc.userID}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse(CorpsePath, flagsOnDeath, modelState) as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				if (NavAgent != null)
				{
					nPCPlayerCorpse.transform.position += Vector3.down * NavAgent.baseOffset;
				}
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				if (CopyInventoryToCorpse)
				{
					nPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);
				}
				else
				{
					nPCPlayerCorpse.CreateEmptyContainer(base.inventory.containerMain.capacity);
				}
				nPCPlayerCorpse.playerName = OverrideCorpseName;
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				if (ShouldCorpseTakeChildren)
				{
					nPCPlayerCorpse.TakeChildren(this);
				}
				for (int i = 0; i < nPCPlayerCorpse.containers.Length; i++)
				{
					ItemContainer itemContainer = nPCPlayerCorpse.containers[i];
					if (!KeepCorpseClothingIntact || i != 1)
					{
						itemContainer.Clear();
					}
				}
				object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
				if (obj is BaseCorpse)
				{
					return (BaseCorpse)obj;
				}
				ApplyLoot(nPCPlayerCorpse);
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnSleepingBagValidCheck(SleepingBag,ulong,bool)

```csharp
```csharp
/// <summary>
/// Called to check if a sleeping bag is valid for a specific player.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being checked.</param>
/// <param name="playerId">The ID of the player attempting to use the sleeping bag.</param>
/// <param name="ignoreTimers">Whether to ignore any timers associated with the sleeping bag.</param>
/// <returns>
/// Returns `true` if the sleeping bag is valid for the player, or `false` if it is not.
/// If the method returns `null`, the default game logic will determine the validity. (bool)
/// </returns>
object OnSleepingBagValidCheck(SleepingBag sleepingBag, ulong playerId, bool ignoreTimers)
{
    Puts($"Checking validity of sleeping bag for player ID: {playerId}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		object obj = Interface.CallHook("OnSleepingBagValidCheck", this, playerID, ignoreTimers);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (deployerUserID == playerID)
		{
			if (!ignoreTimers)
			{
				return unlockTime < UnityEngine.Time.realtimeSinceStartup;
			}
			return true;
		}
		return false;
	}

```

## CanTakeCutting(BasePlayer,GrowableEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can take a cutting from a growable entity.
/// </summary>
/// <param name="player">The player attempting to take a cutting.</param>
/// <param name="growable">The growable entity from which the cutting is being taken.</param>
/// <returns>
/// Returns `null` to allow the action, or any non-null value to prevent the player from taking a cutting. (object)
/// </returns>
object CanTakeCutting(BasePlayer player, GrowableEntity growable)
{
    Puts($"Player {player} is attempting to take a cutting from {growable}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TakeClones(BasePlayer player)
	{
		if (player == null || !CanClone() || Interface.CallHook("CanTakeCutting", player, this) != null)
		{
			return;
		}
		int num = Properties.BaseCloneCount + Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;
		if (num > 0)
		{
			Item item = ItemManager.Create(Properties.CloneItem, num, 0uL);
			GrowableGeneEncoding.EncodeGenesToItem(this, item);
			Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
			if (Properties.pickEffect.isValid)
			{
				Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
			}
			TellPlanter();
			Die();
		}
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC can eat a specified entity.
/// </summary>
/// <param name="npc">The NPC that is considering eating.</param>
/// <param name="entity">The entity that may be eaten.</param>
/// <returns>
/// Returns `true` if the NPC can eat the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the NPC can eat the entity. (bool)
/// </returns>
object CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc} is evaluating whether to eat entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnMlrsTargetSet(MLRS,UnityEngine.Vector3,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a target position is set for the Multiple Launch Rocket System (MLRS).
/// </summary>
/// <param name="mlrs">The MLRS instance that is setting the target.</param>
/// <param name="targetPosition">The world position being set as the target.</param>
/// <param name="player">The player who set the target position.</param>
/// <returns>No return behavior.</returns>
void OnMlrsTargetSet(MLRS mlrs, Vector3 targetPosition, BasePlayer player)
{
    Puts($"MLRS target set by {player} at position {targetPosition}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 vector = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", this, worldPos, _mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Vector3 center = allSafeZone.triggerCollider.bounds.center;
				center.y = 0f;
				float num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 vector2 = trueTargetHitPos - center;
					trueTargetHitPos = center + vector2.normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", this, trueTargetHitPos, _mounted);
	}

```

## OnBookmarkDelete(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a bookmark is deleted from a computer station.
/// </summary>
/// <param name="station">The computer station from which the bookmark is being deleted.</param>
/// <param name="player">The player who is deleting the bookmark.</param>
/// <param name="bookmarkId">The identifier of the bookmark being deleted.</param>
/// <returns>
/// Returns `null` to allow the deletion, or a non-null value to prevent it. (object)
/// </returns>
object OnBookmarkDelete(ComputerStation station, BasePlayer player, string bookmarkId)
{
    Puts($"Player {player} is attempting to delete bookmark: {bookmarkId} from station {station}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DeleteBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		string text = msg.read.String();
		if (IsValidIdentifier(text) && controlBookmarks.Contains(text) && Interface.CallHook("OnBookmarkDelete", this, player, text) == null)
		{
			controlBookmarks.Remove(text);
			SendControlBookmarks(player);
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if (baseEntity != null && baseEntity.TryGetComponent<IRemoteControllable>(out var component) && component.GetIdentifier() == text)
			{
				StopControl(player);
			}
		}
	}

```

## OnStashHidden(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a stash container is hidden by a player.
/// </summary>
/// <param name="stash">The stash container that is being hidden.</param>
/// <param name="player">The player who is hiding the stash.</param>
/// <returns>No return behavior.</returns>
void OnStashHidden(StashContainer stash, BasePlayer player)
{
    Puts($"Stash {stash} has been hidden by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", rpc.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", this, rpc.player);
		}
	}

```

## OnExperimentEnd(Workbench)

```csharp
```csharp
/// <summary>
/// Called when an experiment at the workbench has completed.
/// </summary>
/// <param name="workbench">The workbench where the experiment was conducted.</param>
/// <returns>
/// Returns a non-null value to override the default experiment completion behavior. 
/// If `null` is returned, the experiment completes as normal. (object)
/// </returns>
object OnExperimentEnd(Workbench workbench)
{
    Puts($"Experiment completed at workbench: {workbench}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after a fall, allowing for custom fall damage calculations.
/// </summary>
/// <param name="player">The player who has landed.</param>
/// <param name="fallVelocity">The velocity at which the player landed.</param>
/// <returns>
/// Returns `null` to allow the default fall damage calculation, or a non-null value to override it. (object)
/// </returns>
object OnPlayerLand(BasePlayer player, float fallVelocity)
{
    Puts($"Player {player} has landed with a fall velocity of {fallVelocity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		if (IsGod())
		{
			return;
		}
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Facepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned in the game world.
/// </summary>
/// <param name="entity">The entity that has been spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity {entity} has been spawned.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		EntityProfiler.spawned++;
		if (EntityProfiler.mode >= 2)
		{
			EntityProfiler.OnSpawned(this);
		}
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		ServerInitPostNetworkGroupAssign();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		Invoke(SendGlobalNetworkUpdate, 0f);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies, allowing for additional processing upon death.
/// </summary>
/// <param name="entity">The entity that has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} has died due to {hitInfo}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		LogEntry(RustLog.EntryType.Combat, 2, "died");
		health = 0f;
		lifestate = LifeState.Dead;
		Interface.CallHook("OnEntityDeath", this, info);
		if (info != null && (bool)info.InitiatorPlayer)
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)
			{
				initiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, prefabID, 1f);
			}
		}
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## CanResearchItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can research a specific item.
/// </summary>
/// <param name="player">The player attempting to research the item.</param>
/// <param name="item">The item that the player wants to research.</param>
/// <returns>
/// Returns `true` if the player can research the item, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the item can be researched. (bool)
/// </returns>
object CanResearchItem(BasePlayer player, Item item)
{
    Puts($"Player {player} is attempting to research item: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Facepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnBonusItemDropped(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is dropped for a player after an event or action.
/// </summary>
/// <param name="item">The bonus item that is being dropped.</param>
/// <param name="player">The player who will receive the bonus item.</param>
/// <returns>No return behavior.</returns>
void OnBonusItemDropped(Item item, BasePlayer player)
{
    Puts($"Bonus item {item} dropped for player {player}.");
}
```
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player hits an entity with a hammer.
/// </summary>
/// <param name="player">The player who performed the hammer hit.</param>
/// <param name="hitInfo">Information about the hit, including the target entity and damage details.</param>
/// <returns>
/// Returns a non-null value to prevent the default hammer hit behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnHammerHit(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player} hit an entity with a hammer. Target: {hitInfo.HitEntity}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null && ownerPlayer != null && base.isServer)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			using (TimeWarning.New("DoRepair", 50))
			{
				baseCombatEntity.DoRepair(ownerPlayer);
			}
		}
		info.DoDecals = false;
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## OnBuildingPrivilege(BaseEntity,OBB)

```csharp
```csharp
/// <summary>
/// Called to retrieve the building privilege associated with a specific bounding box (OBB).
/// </summary>
/// <param name="entity">The entity requesting the building privilege.</param>
/// <param name="obb">The OBB representing the area to check for building privileges.</param>
/// <returns>
/// Returns a <c>BuildingPrivlidge</c> if one is found; otherwise, returns <c>null</c> if no privilege is associated with the given OBB.
/// </returns>
BuildingPrivlidge OnBuildingPrivilege(BaseEntity entity, OBB obb)
{
    Puts($"Checking building privilege for entity {entity} in area defined by OBB: {obb}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
	{
		object obj = Interface.CallHook("OnBuildingPrivilege", this, obb);
		if (obj is BuildingPrivlidge)
		{
			return (BuildingPrivlidge)obj;
		}
		BuildingBlock other = null;
		BuildingPrivlidge result = null;
		List<BuildingBlock> obj2 = Facepunch.Pool.Get<List<BuildingBlock>>();
		Vis.Entities(obb.position, 16f + obb.extents.magnitude, obj2, 2097152);
		for (int i = 0; i < obj2.Count; i++)
		{
			BuildingBlock buildingBlock = obj2[i];
			if (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) > 16f)
			{
				continue;
			}
			BuildingManager.Building building = buildingBlock.GetBuilding();
			if (building != null)
			{
				BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
				if (!(dominatingBuildingPrivilege == null))
				{
					other = buildingBlock;
					result = dominatingBuildingPrivilege;
				}
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj2);
		return result;
	}

```

## OnTeamAcceptInvite(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player accepts an invitation to join a team.
/// </summary>
/// <param name="team">The team that the player is invited to join.</param>
/// <param name="player">The player who accepted the invitation.</param>
/// <returns>
/// Returns `null` to allow the player to join the team, or any non-null value to prevent the action. (object)
/// </returns>
object OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player} accepted invite to team {team}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void acceptinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamAcceptInvite", playerTeam, basePlayer) == null)
			{
				playerTeam.AcceptInvite(basePlayer);
			}
		}
	}

```

## OnBradleyApcThink(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called periodically to update the AI behavior of the Bradley APC.
/// </summary>
/// <param name="apc">The Bradley APC instance that is being updated.</param>
/// <returns>
/// Returns `null` to allow the default AI behavior to proceed, or a non-null value to override it. (object)
/// </returns>
object OnBradleyApcThink(BradleyAPC apc)
{
    Puts($"Updating AI for Bradley APC at position: {apc.transform.position}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoSimpleAI()
	{
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
		if (Interface.CallHook("OnBradleyApcThink", this) != null || !DoAI)
		{
			return;
		}
		SetTarget();
		if (mountingScientists || inDeployedState)
		{
			ClearPath();
		}
		else if (!IsOnSpline())
		{
			if (targetList.Count > 0)
			{
				UpdateMovement_Hunt();
			}
			else
			{
				UpdateMovement_Patrol();
			}
		}
		if (!IsOnSpline())
		{
			AdvancePathMovement(force: false);
			float num = Vector3.Distance(base.transform.position, destination);
			float value = Vector3.Distance(base.transform.position, finalDestination);
			if (num > stoppingDist)
			{
				Vector3 lhs = Direction2D(destination, base.transform.position);
				float num2 = Vector3.Dot(lhs, base.transform.right);
				float num3 = Vector3.Dot(lhs, base.transform.right);
				float num4 = Vector3.Dot(lhs, -base.transform.right);
				if (Vector3.Dot(lhs, -base.transform.forward) > num2)
				{
					if (num3 >= num4)
					{
						turning = 1f;
					}
					else
					{
						turning = -1f;
					}
				}
				else
				{
					turning = Mathf.Clamp(num2 * 3f, -1f, 1f);
				}
				float throttleScaleFromTurn = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));
				AvoidObstacles(ref throttleScaleFromTurn);
				float num5 = Vector3.Dot(myRigidBody.velocity, base.transform.forward);
				if (!(throttle > 0f) || !(num5 < 0.5f))
				{
					timeSinceSeemingStuck = 0f;
				}
				else if ((float)timeSinceSeemingStuck > 10f)
				{
					timeSinceStuckReverseStart = 0f;
					timeSinceSeemingStuck = 0f;
				}
				float num6 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(base.transform.forward, Vector3.up));
				if ((float)timeSinceStuckReverseStart < 3f)
				{
					throttle = -0.75f;
					turning = 1f;
				}
				else
				{
					throttle = (0.1f + Mathf.InverseLerp(0f, 20f, value) * 1f) * throttleScaleFromTurn + num6;
				}
			}
		}
		DoWeaponAiming();
		SendNetworkUpdate();
	}

```

## OnPlayerDeath(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player dies, allowing for custom behavior upon death.
/// </summary>
/// <param name="player">The player that has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death.</param>
/// <returns>
/// Returns `null` to allow the default death behavior, or a non-null value to override it. (object)
/// </returns>
object OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player} has died due to: {hitInfo}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead())
			{
				Handcuffs restraintItem = Belt.GetRestraintItem();
				if (restraintItem != null)
				{
					restraintItem.HeldWhenOwnerDied(this);
				}
				if (InGesture)
				{
					Server_CancelGesture();
				}
				if (Belt != null && ShouldDropActiveItem())
				{
					Vector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + vector.normalized * 3f);
					inventory.DropBackpackOnDeath();
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDeath", this, info) == null)
				{
					SleepingBag.OnPlayerDeath(this);
					base.Die(info);
				}
			}
		}
	}

```

## OnVendingShopOpened(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop is opened by a player.
/// </summary>
/// <param name="vendingMachine">The vending machine that is being opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpened(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending shop opened by player {player} at machine {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", this, msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", this, msg.player);
		}
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to loot an entity.
/// </summary>
/// <param name="player">The player who is looting the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntity(BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player} is attempting to loot entity {entity}.");
}
```
```

### Source Code from the Library

```csharp

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!targetEntity)
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		MarkDirty();
		if (targetEntity is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = base.baseEntity.userID;
		}
		return true;
	}

```

## OnMissionFailed(BaseMission,BaseMission.MissionInstance,BasePlayer,BaseMission.MissionFailReason)

```csharp
```csharp
/// <summary>
/// Called when a mission fails, allowing for additional processing or notifications.
/// </summary>
/// <param name="mission">The mission that has failed.</param>
/// <param name="instance">The instance of the mission that was assigned to the player.</param>
/// <param name="assignee">The player who was assigned the mission.</param>
/// <param name="failReason">The reason for the mission failure.</param>
/// <returns>No return behavior.</returns>
void OnMissionFailed(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee, BaseMission.MissionFailReason failReason)
{
    Puts($"Mission {mission} failed for player {assignee} due to {failReason}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
	{
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have failed the mission : " + missionName.english);
		}
		DoMissionEffect(failedEffect.resourcePath, assignee);
		Facepunch.Rust.Analytics.Server.MissionFailed(this, failReason);
		Facepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, failReason);
		instance.status = MissionStatus.Failed;
		MissionEnded(instance, assignee);
		Interface.CallHook("OnMissionFailed", this, instance, assignee, failReason);
	}

```

## OnReactiveTargetReset(ReactiveTarget)

```csharp
```csharp
/// <summary>
/// Called when a reactive target is reset to its initial state.
/// </summary>
/// <param name="target">The reactive target that is being reset.</param>
/// <returns>No return behavior.</returns>
void OnReactiveTargetReset(ReactiveTarget target)
{
    Puts($"Reactive target {target} has been reset.");
}
```
```

### Source Code from the Library

```csharp

	public void ResetTarget()
	{
		if (IsLowered() && CanToggle() && CanReset())
		{
			CancelInvoke(ResetTarget);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			knockdownHealth = 100f;
			SendPowerBurst();
			Interface.CallHook("OnReactiveTargetReset", this);
		}
	}

```

## CanDeployScientists(BradleyAPC,BaseEntity,System.Collections.Generic.List<GameObjectRef>,System.Collections.Generic.List<UnityEngine.Vector3>)

```csharp
```csharp
/// <summary>
/// Determines whether scientists can be deployed from the specified attacker entity.
/// </summary>
/// <param name="attacker">The entity attempting to deploy the scientists.</param>
/// <param name="scientistPrefabs">A list of scientist prefab references to be deployed.</param>
/// <param name="spawnPositions">A list to populate with valid spawn positions for the scientists.</param>
/// <returns>
/// Returns `true` if scientists can be deployed; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if deployment is possible. (bool)
/// </returns>
object CanDeployScientists(BradleyAPC attacker, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
{
    Puts($"Attempting to deploy scientists from {attacker}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanDeployScientists(BaseEntity attacker, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
	{
		object obj = Interface.CallHook("CanDeployScientists", this, attacker, scientistPrefabs, spawnPositions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int count = scientistPrefabs.Count;
		if (!inDeployedState && Vector3.Distance(attacker.transform.position, base.transform.position) > DeployAttackDistanceMax)
		{
			return false;
		}
		spawnPositions.Clear();
		bool flag = false;
		int num = 0;
		int num2 = 0;
		int layerMask = 8454144;
		while (!flag)
		{
			if (UnityEngine.Physics.Raycast(ScientistSpawnPoints[num2 % ScientistSpawnPoints.Count].transform.position + Vector3.up * 1f, Vector3.down, out var hitInfo, 2f, layerMask) && NavMesh.SamplePosition(hitInfo.point + Vector3.up * 0.3f, out var _, 6f, walkableAreaMask))
			{
				spawnPositions.Add(hitInfo.point + Vector3.up * 0.1f);
				num2++;
				if (num2 >= count)
				{
					break;
				}
			}
			else
			{
				num++;
				if (num > count * 2)
				{
					flag = true;
				}
			}
		}
		return !flag;
	}

```

## OnTeamInvite(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player invites another player to join their team.
/// </summary>
/// <param name="inviter">The player who is sending the team invite.</param>
/// <param name="invitee">The player being invited to join the team.</param>
/// <returns>
/// Returns `null` to allow the invite to proceed, or a non-null value to prevent the invite. (object)
/// </returns>
object OnTeamInvite(BasePlayer inviter, BasePlayer invitee)
{
    Puts($"Player {inviter} is inviting {invitee} to join their team.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void sendinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer)
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			return;
		}
		BasePlayer basePlayer2 = BaseNetworkable.serverEntities.Find(new NetworkableId(uLong)) as BasePlayer;
		if ((bool)basePlayer2 && basePlayer2 != basePlayer && !basePlayer2.IsNpc && basePlayer2.currentTeam == 0L)
		{
			float num = 7f;
			if (!(Vector3.Distance(basePlayer2.transform.position, basePlayer.transform.position) > num) && Interface.CallHook("OnTeamInvite", basePlayer, basePlayer2) == null)
			{
				playerTeam.SendInvite(basePlayer2);
			}
		}
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after a fall, allowing for additional effects or modifications to fall damage.
/// </summary>
/// <param name="player">The player who has landed.</param>
/// <param name="fallDamage">The calculated fall damage based on the player's velocity.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanded(BasePlayer player, float fallDamage)
{
    Puts($"Player {player} has landed with fall damage: {fallDamage}.");
}
```
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		if (IsGod())
		{
			return;
		}
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Facepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnPlayerSetInfo(Network.Connection,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player sets their information, such as username or other attributes.
/// </summary>
/// <param name="connection">The network connection of the player setting the information.</param>
/// <param name="key">The key representing the information being set.</param>
/// <param name="val">The value being assigned to the key.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSetInfo(Network.Connection connection, string key, string val)
{
    Puts($"Player {connection} set info: {key} = {val}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void SetInfo(string key, string val)
	{
		if (IsConnected)
		{
			Interface.CallHook("OnPlayerSetInfo", net.connection, key, val);
			net.connection.info.Set(key, val);
		}
	}

```

## OnStructureDemolish(StabilityEntity,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a structure is being demolished by a player.
/// </summary>
/// <param name="structure">The structure that is being demolished.</param>
/// <param name="player">The player who is demolishing the structure.</param>
/// <param name="isInstant">Indicates whether the demolition is instant.</param>
/// <returns>
/// Returns `null` to allow the demolition, or a non-null value to prevent it. (object)
/// </returns>
object OnStructureDemolish(StabilityEntity structure, BasePlayer player, bool isInstant)
{
    Puts($"Player {player} is attempting to demolish structure {structure}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);
			Kill(DestroyMode.Gib);
		}
	}

```

## OnEntityStabilityCheck(StabilityEntity)

```csharp
```csharp
/// <summary>
/// Called to check the stability of an entity in the game world.
/// </summary>
/// <param name="entity">The stability entity being checked.</param>
/// <returns>
/// Returns a non-null value to override the default stability check behavior. 
/// If `null` is returned, the default stability logic will be applied. (object)
/// </returns>
object OnEntityStabilityCheck(StabilityEntity entity)
{
    Puts($"Stability check initiated for entity: {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StabilityCheck()
	{
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			cachedDistanceFromGround = num;
			flag = true;
		}
		float num2 = SupportValue();
		if (Mathf.Abs(cachedStability - num2) > Stability.accuracy)
		{
			cachedStability = num2;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability();
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num2 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				UpdateStability();
				stabilityStrikes++;
			}
			else
			{
				Kill(DestroyMode.Gib);
			}
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

```

## CanSetBedPublic(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can set a sleeping bag to public.
/// </summary>
/// <param name="player">The player attempting to set the sleeping bag public.</param>
/// <param name="sleepingBag">The sleeping bag being modified.</param>
/// <returns>
/// Returns `null` to allow the action, or any non-null value to prevent the sleeping bag from being set to public. (object)
/// </returns>
object CanSetBedPublic(BasePlayer player, SleepingBag sleepingBag)
{
    Puts($"Player {player} is attempting to set sleeping bag {sleepingBag} to public.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public virtual void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != (ulong)msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag == IsPublic() || Interface.CallHook("CanSetBedPublic", msg.player, this) != null)
		{
			return;
		}
		SetPublic(flag);
		if (!IsPublic())
		{
			if (ConVar.Server.max_sleeping_bags > 0)
			{
				CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
				if (canAssignBedResult.HasValue)
				{
					if (canAssignBedResult.Value.Result == BagResultType.Ok)
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					else
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					if (canAssignBedResult.Value.Result != 0)
					{
						return;
					}
				}
			}
			ulong num = deployerUserID;
			deployerUserID = msg.player.userID;
			NotifyPlayer(num);
			NotifyPlayer(deployerUserID);
			OnBagChangedOwnership(this, num);
			Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);
		}
		else
		{
			Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);
		}
		SendNetworkUpdate();
	}

```

## OnPatrolHelicopterKill(PatrolHelicopter,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a patrol helicopter is killed.
/// </summary>
/// <param name="helicopter">The patrol helicopter that has been killed.</param>
/// <param name="hitInfo">Information about the hit that caused the kill.</param>
/// <returns>
/// Returns a non-null value to override the default kill behavior, or `null` to allow the default behavior to proceed. (object)
/// </returns>
object OnPatrolHelicopterKill(PatrolHelicopter helicopter, HitInfo hitInfo)
{
    Puts($"Patrol helicopter {helicopter} has been killed by hit info: {hitInfo}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnPatrolHelicopterTakeDamage", this, info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			if (Interface.CallHook("OnPatrolHelicopterKill", this, info) != null)
			{
				return;
			}
			base.health = 10000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		myAI.OtherDamaged(info);
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

```

## OnRespawnInformationGiven(BasePlayer,System.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions>)

```csharp
```csharp
/// <summary>
/// Called to provide respawn options to a player after they have died.
/// </summary>
/// <param name="player">The player receiving the respawn options.</param>
/// <param name="spawnOptions">A list of available spawn options for the player.</param>
/// <returns>No return behavior.</returns>
void OnRespawnInformationGiven(BasePlayer player, List<ProtoBuf.RespawnInformation.SpawnOptions> spawnOptions)
{
    Puts($"Providing respawn options to player {player} with {spawnOptions.Count} options available.");
}
```
```

### Source Code from the Library

```csharp

	public void SendRespawnOptions()
	{
		if (NexusServer.Started && ZoneController.Instance.CanRespawnAcrossZones(this))
		{
			CollectExternalAndSend();
			return;
		}
		List<RespawnInformation.SpawnOptions> list = Facepunch.Pool.Get<List<RespawnInformation.SpawnOptions>>();
		GetRespawnOptionsForPlayer(list, userID);
		Interface.CallHook("OnRespawnInformationGiven", this, list);
		SendToPlayer(list, loading: false);
		async void CollectExternalAndSend()
		{
			List<RespawnInformation.SpawnOptions> list2 = Facepunch.Pool.Get<List<RespawnInformation.SpawnOptions>>();
			GetRespawnOptionsForPlayer(list2, userID);
			List<RespawnInformation.SpawnOptions> allSpawnOptions = Facepunch.Pool.Get<List<RespawnInformation.SpawnOptions>>();
			foreach (RespawnInformation.SpawnOptions item in list2)
			{
				allSpawnOptions.Add(item.Copy());
			}
			SendToPlayer(list2, loading: true);
			try
			{
				Request request = Facepunch.Pool.Get<Request>();
				request.spawnOptions = Facepunch.Pool.Get<SpawnOptionsRequest>();
				request.spawnOptions.userId = userID;
				using (NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(request, 10f))
				{
					foreach (KeyValuePair<string, Response> response in nexusRpcResult.Responses)
					{
						string key = response.Key;
						SpawnOptionsResponse spawnOptions2 = response.Value.spawnOptions;
						if (spawnOptions2 != null && spawnOptions2.spawnOptions.Count != 0)
						{
							foreach (RespawnInformation.SpawnOptions spawnOption in spawnOptions2.spawnOptions)
							{
								RespawnInformation.SpawnOptions spawnOptions3 = spawnOption.Copy();
								spawnOptions3.nexusZone = key;
								allSpawnOptions.Add(spawnOptions3);
							}
						}
					}
				}
				SendToPlayer(allSpawnOptions, loading: false);
			}
			catch (Exception exception)
			{
				Debug.LogException(exception);
			}
		}
		void SendToPlayer(List<RespawnInformation.SpawnOptions> spawnOptions, bool loading)
		{
			using RespawnInformation respawnInformation = Facepunch.Pool.Get<RespawnInformation>();
			respawnInformation.spawnOptions = spawnOptions;
			respawnInformation.loading = loading;
			if (ConVar.Server.max_shelters == LegacyShelter.FpShelterDefault && LegacyShelter.SheltersPerPlayer.ContainsKey(userID) && LegacyShelter.SheltersPerPlayer[userID].Count > 0)
			{
				respawnInformation.shelterPositions = Facepunch.Pool.Get<List<Vector3>>();
				foreach (LegacyShelter item2 in LegacyShelter.SheltersPerPlayer[userID])
				{
					respawnInformation.shelterPositions.Add(item2.transform.position);
				}
			}
			if (IsDead())
			{
				respawnInformation.previousLife = previousLifeStory;
				if (!ConVar.Server.skipDeathScreenFade)
				{
					respawnInformation.fadeIn = previousLifeStory != null && previousLifeStory.timeDied > Epoch.Current - 5;
				}
				else
				{
					respawnInformation.fadeIn = false;
				}
			}
			ClientRPC(RpcTarget.Player("OnRespawnInformation", this), respawnInformation);
		}
	}

```

## OnPlayerWantsDismount(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player requests to dismount from a mountable entity.
/// </summary>
/// <param name="player">The player who wants to dismount.</param>
/// <param name="mountable">The mountable entity the player is currently on.</param>
/// <returns>
/// Returns `null` to allow the dismount, or any non-null value to prevent the dismount. (object)
/// </returns>
object OnPlayerWantsDismount(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player} wants to dismount from {mountable}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", player, this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", player, this) == null && (!(player != null) || !player.IsRestrained))
		{
			AttemptDismount(player);
		}
	}

```

## OnFuelAmountCheck(EntityFuelSystem,Item)

```csharp
```csharp
/// <summary>
/// Called to check the amount of fuel available in the fuel system.
/// </summary>
/// <param name="fuelSystem">The entity fuel system being checked.</param>
/// <param name="fuelItem">The item representing the fuel.</param>
/// <returns>
/// Returns the amount of fuel available. If the hook returns a value, that value is used; otherwise, the default amount is returned. (int)
/// </returns>
object OnFuelAmountCheck(EntityFuelSystem fuelSystem, Item fuelItem)
{
    Puts($"Checking fuel amount for {fuelSystem} with fuel item: {fuelItem}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int GetFuelAmount()
	{
		Item fuelItem = GetFuelItem();
		object obj = Interface.CallHook("OnFuelAmountCheck", this, fuelItem);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0;
		}
		return fuelItem.amount;
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
```csharp
/// <summary>
/// Called when a weapon is fired by a player, allowing for additional processing or validation.
/// </summary>
/// <param name="projectile">The projectile being fired.</param>
/// <param name="player">The player who fired the weapon.</param>
/// <param name="itemMod">The item modification associated with the projectile.</param>
/// <param name="projectileShoot">The data related to the projectile shoot action.</param>
/// <returns>
/// Returns `null` to allow the default firing behavior, or a non-null value to override it. (object)
/// </returns>
object OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemMod, ProtoBuf.ProjectileShoot projectileShoot)
{
    Puts($"Weapon fired by {player} with projectile {projectile}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner]
	[RPC_Server]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !base.UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_missing");
			return;
		}
		ItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (primaryMagazineAmmo.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_mismatch");
			return;
		}
		if (!base.UsingInfiniteAmmoCheat)
		{
			ModifyAmmoCount(-1);
		}
		ItemModProjectile component = primaryMagazineAmmo.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		if (player.InGesture)
		{
			return;
		}
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection, GetAttackEffect());
		player.CleanupExpiredProjectiles();
		Guid projectileGroupId = Guid.NewGuid();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.LogInvalid(player, this, "duplicate_id");
				continue;
			}
			Vector3 positionOffset = Vector3.zero;
			if (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))
			{
				if (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))
				{
					continue;
				}
				Vector3 position = player.eyes.position;
				positionOffset = position - projectile.startPos;
				projectile.startPos = position;
			}
			else if (!ValidateEyePos(player, projectile.startPos))
			{
				continue;
			}
			player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId, positionOffset);
			if (!player.limitNetworking)
			{
				CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
			}
		}
		player.MakeNoise(player.transform.position, BaseCombatEntity.ActionVolume.Loud);
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count(), (Stats)5);
		player.LifeStoryShotFired(this);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);
		player.MarkHostileFor();
		UpdateItemCondition();
		DidAttackServerside();
		float num = 0f;
		if (component.projectileObject != null)
		{
			GameObject gameObject = component.projectileObject.Get();
			if (gameObject != null)
			{
				Projectile component2 = gameObject.GetComponent<Projectile>();
				if (component2 != null)
				{
					foreach (DamageTypeEntry damageType in component2.damageTypes)
					{
						num += damageType.amount;
					}
				}
			}
		}
		BaseMountable mounted = player.GetMounted();
		if (mounted != null)
		{
			mounted.OnWeaponFired(this);
		}
		EACServer.LogPlayerUseWeapon(player, this);
	}

```

## OnSamSiteTarget(SamSite,SamSite.ISamSiteTarget)

```csharp
```csharp
/// <summary>
/// Called when scanning for potential targets by the SAM site.
/// </summary>
/// <param name="samSite">The SAM site performing the target scan.</param>
/// <param name="target">The potential target being evaluated.</param>
/// <returns>
/// Returns `null` to allow the default target scanning behavior, or a non-null value to override it. (object)
/// </returns>
object OnSamSiteTarget(SamSite samSite, ISamSiteTarget target)
{
    Puts($"SAM Site {samSite} is scanning for target: {target}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (UnityEngine.Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> obj = Facepunch.Pool.Get<List<ISamSiteTarget>>();
		if (Interface.CallHook("OnSamSiteTargetScan", this, obj) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(obj, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(obj, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in obj)
		{
			if (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!ObjectEx.IsUnityNull(samSiteTarget) && currentTarget != samSiteTarget)
		{
			lockOnTime = UnityEngine.Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!ObjectEx.IsUnityNull(currentTarget))
		{
			lastTargetVisibleTime = UnityEngine.Time.time;
		}
		Facepunch.Pool.FreeUnmanaged(ref obj);
		if (ObjectEx.IsUnityNull(currentTarget))
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

```

## OnItemRemove(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from the game.
/// </summary>
/// <param name="item">The item that is being removed.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being removed; otherwise, returns null to allow removal. (object)
/// </returns>
object OnItemRemove(Item item)
{
    Puts($"Item {item} is being removed from the game.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = UnityEngine.Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		ItemManager.RemoveItem(this, fTime);
	}

```

## OnSignUpdated(Signage,BasePlayer,int)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated by a player.
/// </summary>
/// <param name="sign">The signage that is being updated.</param>
/// <param name="player">The player who is updating the sign.</param>
/// <param name="textureIndex">The index of the texture being updated.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(Signage sign, BasePlayer player, int textureIndex)
{
    Puts($"Sign updated by {player} at texture index {textureIndex}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			UnityEngine.Debug.LogWarning($"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", this, msg.player, num);
	}

```

## OnInventoryAmmoItemFind(PlayerInventory,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to find an ammo item in a player's inventory based on the specified item definition.
/// </summary>
/// <param name="inventory">The player's inventory being searched.</param>
/// <param name="itemDef">The item definition of the ammo type to find.</param>
/// <returns>
/// Returns the found ammo item if it exists; otherwise, returns `null`. 
/// If the hook returns a non-null item, that item will be used instead of the default search result. (Item)
/// </returns>
object OnInventoryAmmoItemFind(PlayerInventory inventory, ItemDefinition itemDef)
{
    Puts($"Searching for ammo item of type: {itemDef.shortname} in inventory.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public Item GetAmmo()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		object obj = Interface.CallHook("OnInventoryAmmoItemFind", ownerPlayer.inventory, fuelType);
		if (obj is Item)
		{
			return (Item)obj;
		}
		return ownerPlayer.inventory.FindItemByItemName(fuelType.shortname);
	}

```

## OnNoGoZoneAdded(PatrolHelicopterAI,PatrolHelicopterAI.DangerZone)

```csharp
```csharp
/// <summary>
/// Called when a new no-go zone is added to the patrol helicopter's awareness.
/// </summary>
/// <param name="helicopter">The patrol helicopter AI that is aware of the no-go zone.</param>
/// <param name="zone">The danger zone that has been added.</param>
/// <returns>No return behavior.</returns>
void OnNoGoZoneAdded(PatrolHelicopterAI helicopter, PatrolHelicopterAI.DangerZone zone)
{
    Puts($"No-go zone added for helicopter {helicopter} at zone: {zone}.");
}
```
```

### Source Code from the Library

```csharp

	private void NoGoZoneAdded(DangerZone zone)
	{
		if (use_danger_zones && Interface.CallHook("OnNoGoZoneAdded", this, zone) == null && zone.IsPointInside(base.transform.position))
		{
			_targetList.Clear();
			ExitCurrentState();
			Vector3 nearestEdge = zone.GetNearestEdge(base.transform.position);
			nearestEdge.y = UnityEngine.Random.Range(35f, 45f);
			State_Flee_Enter(nearestEdge);
		}
	}

```

## OnDieselEngineToggle(DieselEngine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off by a player.
/// </summary>
/// <param name="engine">The diesel engine being toggled.</param>
/// <param name="player">The player who is toggling the engine.</param>
/// <returns>
/// Returns a non-null value to prevent the default toggle behavior; otherwise, returns null to allow the toggle. (object)
/// </returns>
object OnDieselEngineToggle(DieselEngine engine, BasePlayer player)
{
    Puts($"Player {player} toggled the diesel engine: {engine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnDieselEngineToggle", this, msg.player) != null)
		{
			return;
		}
		if (msg.read.Bit())
		{
			if (GetFuelAmount() > 0)
			{
				EngineOn();
				startedByPlayer = msg.player;
				if (Rust.GameInfo.HasAchievements && msg.player != null)
				{
					msg.player.stats.Add("excavator_activated", 1, Stats.All);
					msg.player.stats.Save(forceSteamSave: true);
				}
			}
		}
		else
		{
			EngineOff();
		}
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to loot an item.
/// </summary>
/// <param name="player">The player who is looting the item.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootItem(BasePlayer player, Item item)
{
    Puts($"Player {player} is looting item: {item} (ID: {item.info.itemid}).");
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
			MarkDirty();
		}
	}

```

## OnPlanterBoxFertilize(PlanterBox)

```csharp
```csharp
/// <summary>
/// Called when a planter box is fertilized.
/// </summary>
/// <param name="planterBox">The planter box being fertilized.</param>
/// <returns>
/// Returns a non-null value to prevent the fertilization process; otherwise, returns null to allow it. (object)
/// </returns>
object OnPlanterBoxFertilize(PlanterBox planterBox)
{
    Puts($"Planter box {planterBox} is being fertilized.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FertilizeGrowables()
	{
		if (Interface.CallHook("OnPlanterBoxFertilize", this) != null)
		{
			return;
		}
		int num = GetFertilizerCount();
		if (num <= 0)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			if (child == null)
			{
				continue;
			}
			GrowableEntity growableEntity = child as GrowableEntity;
			if (!(growableEntity == null) && !growableEntity.Fertilized && ConsumeFertilizer())
			{
				growableEntity.Fertilize();
				num--;
				if (num == 0)
				{
					break;
				}
			}
		}
	}

```

## OnVendingShopOpened(NPCVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player opens a vending shop managed by an NPC vending machine.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that is being accessed.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpened(NPCVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player} has opened the vending shop at {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if (vendingMachine == null)
		{
			vendingMachine = GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", vendingMachine, msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", vendingMachine, msg.player);
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
```csharp
/// <summary>
/// Called every tick for a player to process input and game state updates.
/// </summary>
/// <param name="player">The player whose tick is being processed.</param>
/// <param name="msg">The tick message containing input state and other data.</param>
/// <param name="wasPlayerStalled">Indicates if the player was stalled during the last tick.</param>
/// <returns>No return behavior.</returns>
void OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
{
    Puts($"Processing tick for player {player} with input state: {msg.inputState}.");
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		if (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)
		{
			UpdateActiveItem(restraintItemId.Value);
		}
		else
		{
			UpdateActiveItem(msg.activeItem);
		}
		UpdateModelStateFromTick(msg);
		if (IsIncapacitated())
		{
			return;
		}
		if (isMounted)
		{
			GetMounted().PlayerServerInput(serverInput, this);
		}
		UpdatePositionFromTick(msg, wasPlayerStalled);
		UpdateRotationFromTick(msg);
		int activeMission = GetActiveMission();
		if (activeMission >= 0 && activeMission < missions.Count)
		{
			BaseMission.MissionInstance missionInstance = missions[activeMission];
			if (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())
			{
				ProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);
			}
		}
		if (TutorialIsland.EnforceTrespassChecks && !IsAdmin && !IsNpc && net != null && net.group != null)
		{
			if (net.group.restricted)
			{
				bool flag = false;
				if (!IsInTutorial)
				{
					flag = true;
				}
				else
				{
					TutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();
					if (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)
					{
						flag = true;
					}
				}
				if (flag)
				{
					tutorialKickTime += UnityEngine.Time.deltaTime;
					if (tutorialKickTime > 3f)
					{
						Debug.LogWarning($"Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn't belong them");
						Hurt(999f);
						tutorialKickTime = 0f;
					}
				}
				else
				{
					tutorialKickTime = 0f;
				}
			}
			else if (IsInTutorial && !net.group.restricted)
			{
				bool flag2 = false;
				TutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();
				if (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)
				{
					flag2 = true;
				}
				if (flag2)
				{
					tutorialKickTime += UnityEngine.Time.deltaTime;
					if (tutorialKickTime > 3f)
					{
						Debug.LogWarning($"Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial");
						Hurt(999f);
						tutorialKickTime = 0f;
					}
				}
				else
				{
					tutorialKickTime = 0f;
				}
			}
		}
		using (TimeWarning.New("AnalyticsTick"))
		{
			Facepunch.Rust.Analytics.Azure.OnPlayerTick(this);
		}
	}

```

## OnFishingStopped(BaseFishingRod,BaseFishingRod.FailReason)

```csharp
```csharp
/// <summary>
/// Called when fishing is stopped, either successfully or due to a failure.
/// </summary>
/// <param name="rod">The fishing rod that was used for fishing.</param>
/// <param name="reason">The reason for stopping the fishing process.</param>
/// <returns>No return behavior.</returns>
void OnFishingStopped(BaseFishingRod rod, BaseFishingRod.FailReason reason)
{
    Puts($"Fishing stopped on rod {rod} due to reason: {reason}.");
}
```
```

### Source Code from the Library

```csharp

	private void Server_Cancel(FailReason reason)
	{
		if (GetItem() != null)
		{
			GetItem().LoseCondition((reason == FailReason.Success) ? ConditionLossOnSuccess : ConditionLossOnFail);
		}
		SetFlag(Flags.Busy, b: false);
		UpdateFlags();
		CancelInvoke(CatchProcess);
		CurrentState = CatchState.None;
		SetFlag(Flags.Reserved1, b: false);
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		if (fishingBobber != null)
		{
			fishingBobber.Kill();
			currentBobber.Set(null);
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ResetLine"), (int)reason);
		Interface.CallHook("OnFishingStopped", this, reason);
	}

```

## OnBoomboxStationUpdated(BoomBox,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the boombox station is updated with a new IP address.
/// </summary>
/// <param name="boombox">The boombox entity that is being updated.</param>
/// <param name="ip">The new IP address for the boombox station.</param>
/// <param name="player">The player who initiated the update.</param>
/// <returns>No return behavior.</returns>
void OnBoomboxStationUpdated(BoomBox boombox, string ip, BasePlayer player)
{
    Puts($"Boombox {boombox} updated to new IP: {ip} by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnBoomboxStationUpdate", this, text, msg.player) == null && IsStationValid(text))
		{
			if (msg.player != null)
			{
				ulong assignedRadioBy = msg.player.userID.Get();
				AssignedRadioBy = assignedRadioBy;
			}
			CurrentRadioIp = text;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnRadioIPChanged"), CurrentRadioIp);
			Interface.CallHook("OnBoomboxStationUpdated", this, text, msg.player);
			if (IsOn())
			{
				ServerTogglePlay(play: false);
			}
		}
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item is being removed.</param>
/// <param name="item">The item that is being removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item} has been removed from container {container}.");
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		onPreItemRemove?.Invoke(item);
		itemList.Remove(item);
		item.parent = null;
		onItemParentChanged?.Invoke(parent, item);
		onItemAddedRemoved?.Invoke(item, arg2: false);
		MarkDirty();
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## OnMlrsFiringEnded(MLRS)

```csharp
```csharp
/// <summary>
/// Called when the MLRS (Multiple Launch Rocket System) has finished firing.
/// </summary>
/// <param name="mlrs">The MLRS instance that has ended its firing sequence.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFiringEnded(MLRS mlrs)
{
    Puts($"MLRS firing has ended for instance: {mlrs}.");
}
```
```

### Source Code from the Library

```csharp

	public void EndFiring()
	{
		CancelInvoke(FireNextRocket);
		rocketOwnerRef.Set(null);
		if (TryGetAimingModule(out var item))
		{
			item.LoseCondition(1f);
		}
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Broken, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		timeSinceBroken = 0f;
		Interface.CallHook("OnMlrsFiringEnded", this);
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when an item's condition is reduced.
/// </summary>
/// <param name="item">The item whose condition is being reduced.</param>
/// <param name="amount">The amount of condition to lose.</param>
/// <returns>
/// Returns a non-null value to prevent the condition loss; otherwise, returns null to allow the condition to be reduced. (object)
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Condition loss requested for item {item} by amount: {amount}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## OnDroppedItemCombined(DroppedItem)

```csharp
```csharp
/// <summary>
/// Called when two dropped items are combined into one.
/// </summary>
/// <param name="droppedItem">The dropped item that is being combined.</param>
/// <returns>No return behavior.</returns>
void OnDroppedItemCombined(DroppedItem droppedItem)
{
    Puts($"Dropped item {droppedItem} has been combined with {item}.");
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.DestroyItem();
			di.Kill();
			Interface.CallHook("OnDroppedItemCombined", this);
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(base.transform.position, Vector3.zero, base.transform.rotation);
			}
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped in the game world.
/// </summary>
/// <param name="item">The item that is being dropped.</param>
/// <param name="entity">The entity that is responsible for the drop action.</param>
/// <returns>
/// Returns a modified entity if the hook alters the default drop behavior; otherwise, returns the original entity. (BaseEntity)
/// </returns>
object OnItemDropped(Item item, BaseEntity entity)
{
    Puts($"Item {item} has been dropped by {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		ulong droppedBy = GetRootContainer()?.playerOwner?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
		RemoveFromWorld();
		if (info.AlignWorldModelOnDrop)
		{
			rotation = Quaternion.Euler(0f, Quaternion.LookRotation(vVelocity.normalized, Vector3.up).eulerAngles.y, 0f);
			rotation = Quaternion.Euler(info.WorldModelDropOffset) * rotation;
		}
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
			if (baseEntity is DroppedItem droppedItem)
			{
				droppedItem.DroppedBy = droppedBy;
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## OnPhoneDialFailed(PhoneController,Telephone.DialFailReason,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing attempt fails.
/// </summary>
/// <param name="phone">The phone controller that initiated the dialing attempt.</param>
/// <param name="reason">The reason for the dialing failure.</param>
/// <param name="player">The player who attempted to dial.</param>
/// <returns>
/// Returns `null` to allow the default failure handling, or a non-null value to override it. (object)
/// </returns>
object OnPhoneDialFailed(PhoneController phone, Telephone.DialFailReason reason, BasePlayer player)
{
    Puts($"Phone dialing failed for player {player} due to reason: {reason}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", this, reason, currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientOnDialFailed"), (int)reason);
			activeCallTo = null;
			if (IsInvoking(TimeOutCall))
			{
				CancelInvoke(TimeOutCall);
			}
			if (IsInvoking(TriggerTimeOut))
			{
				CancelInvoke(TriggerTimeOut);
			}
			if (IsInvoking(TimeOutDialing))
			{
				CancelInvoke(TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", this, reason, currentPlayer);
		}
	}

```

## IOnPlayerBanned(Network.Connection,AuthResponse)

```csharp
```csharp
/// <summary>
/// Called when a player is banned based on their authentication response from Steam.
/// </summary>
/// <param name="connection">The network connection of the player being banned.</param>
/// <param name="status">The authentication response indicating the reason for the ban.</param>
/// <returns>No return behavior.</returns>
void IOnPlayerBanned(Network.Connection connection, AuthResponse status)
{
    Puts($"Player {connection.username} (ID: {connection.userid}) has been banned due to: {status}.");
}
```
```

### Source Code from the Library

```csharp

	internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
	{
		if (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))
		{
			return;
		}
		Network.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) => x.userid == SteamId);
		if (connection == null)
		{
			UnityEngine.Debug.LogWarning($"Steam gave us a {Status} ticket response for unconnected id {SteamId}");
			return;
		}
		switch (Status)
		{
		case AuthResponse.OK:
			UnityEngine.Debug.LogWarning($"Steam gave us a 'ok' ticket response for already connected id {SteamId}");
			return;
		case AuthResponse.TimedOut:
			return;
		case AuthResponse.VACBanned:
		case AuthResponse.PublisherBanned:
			if (!bannedPlayerNotices.Contains(SteamId))
			{
				Interface.CallHook("IOnPlayerBanned", connection, Status);
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + connection.username.EscapeRichText() + " (banned by anticheat)");
				bannedPlayerNotices.Add(SteamId);
			}
			break;
		}
		UnityEngine.Debug.Log($"Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \"{Status.ToString()}\")");
		connection.authStatusSteam = Status.ToString();
		Network.Net.sv.Kick(connection, "Steam: " + Status);
	}

```

## OnTick()

```csharp
```csharp
/// <summary>
/// Called on each game tick to perform regular updates and checks.
/// </summary>
/// <returns>No return behavior.</returns>
void OnTick()
{
    Puts("OnTick called, performing updates.");
}
```
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		Interface.CallHook("OnTick");
		RCon.Update();
		CompanionServer.Server.Update();
		NexusServer.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Network.Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## OnPayForPlacement(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to pay for the placement of a construction.
/// </summary>
/// <param name="player">The player who is placing the construction.</param>
/// <param name="planner">The planner used for the construction placement.</param>
/// <param name="component">The construction component being placed.</param>
/// <returns>No return behavior.</returns>
void OnPayForPlacement(BasePlayer player, Planner planner, Construction component)
{
    Puts($"Player {player} is attempting to pay for placement of {component}.");
}
```
```

### Source Code from the Library

```csharp

	public void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", player, this, component) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		if (player.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null)
			{
				currentTutorialIsland.OnPlayerBuiltConstruction(player);
			}
		}
		if (isTypeDeployable)
		{
			GetItem().UseItem();
			return;
		}
		List<Item> obj = Facepunch.Pool.Get<List<Item>>();
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			player.inventory.Take(obj, item.itemDef.itemid, (int)item.amount);
			player.Command("note.inv", item.itemDef.itemid, item.amount * -1f);
		}
		foreach (Item item2 in obj)
		{
			item2.Remove();
		}
		Facepunch.Pool.Free(ref obj, freeElements: false);
	}

```

## OnPlayerRecover(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from a wounded state.
/// </summary>
/// <param name="player">The player who is recovering.</param>
/// <returns>
/// Returns `null` to allow the recovery process to continue, or any non-null value to prevent recovery.
/// </returns>
object OnPlayerRecover(BasePlayer player)
{
    Puts($"Player {player} is attempting to recover from a wounded state.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			if (IsCrawling())
			{
				base.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if ((bool)BaseGameMode.GetActiveGameMode(base.isServer))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", this);
		}
	}

```

## CanBeAwardedAdventGift(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines if a player can be awarded today's advent gift.
/// </summary>
/// <param name="calendar">The advent calendar instance.</param>
/// <param name="player">The player being checked for gift eligibility.</param>
/// <returns>
/// Returns `true` if the player can be awarded today's gift; otherwise, returns `false`. 
/// If the method returns `null`, the default logic will be used to determine eligibility. (bool)
/// </returns>
object CanBeAwardedAdventGift(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Checking if player {player} can be awarded today's advent gift.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool WasAwardedTodaysGift(BasePlayer player)
	{
		object obj = Interface.CallHook("CanBeAwardedAdventGift", this, player);
		if (obj is bool)
		{
			return !(bool)obj;
		}
		if (!playerRewardHistory.ContainsKey(player.userID))
		{
			return false;
		}
		DateTime now = DateTime.Now;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) != startMonth)
		{
			return true;
		}
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (num < 0 || num >= days.Length)
		{
			return true;
		}
		if (playerRewardHistory[player.userID].Contains(num))
		{
			return true;
		}
		return false;
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed by a player.
/// </summary>
/// <param name="trap">The bear trap that is being armed.</param>
/// <param name="player">The player who is arming the trap.</param>
/// <returns>No return behavior.</returns>
void OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Bear trap armed by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## OnEntityEnter(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters a trigger zone.
/// </summary>
/// <param name="trigger">The trigger that the entity has entered.</param>
/// <param name="entity">The entity that has entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity} has entered the trigger {trigger}.");
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityEnter(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityEnter", this, ent) == null)
		{
			_players.Add(basePlayer);
		}
	}

```

## OnVehicleHornPressed(VehicleModuleSeating,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the horn of a vehicle is pressed by a player.
/// </summary>
/// <param name="seating">The vehicle seating module where the player is seated.</param>
/// <param name="player">The player who pressed the horn.</param>
/// <returns>No return behavior.</returns>
void OnVehicleHornPressed(VehicleModuleSeating seating, BasePlayer player)
{
    Puts($"Player {player} pressed the vehicle horn in seating module: {seating}.");
}
```
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (hornLoop != null && IsOnThisModule(player))
		{
			bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
			if (flag != HasFlag(Flags.Reserved8))
			{
				SetFlag(Flags.Reserved8, flag);
			}
			if (flag)
			{
				Interface.CallHook("OnVehicleHornPressed", this, player);
				hornPlayer = player;
			}
		}
	}

```

## OnConnectionQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a connection is added to the queue for joining the server.
/// </summary>
/// <param name="connection">The network connection that is being queued.</param>
/// <returns>
/// Returns a non-null value to prevent the connection from being queued. If `null` is returned, the connection is added to the queue. (object)
/// </returns>
object OnConnectionQueue(Network.Connection connection)
{
    Puts($"Connection from {connection} is attempting to join the queue.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal void Join(Connection connection)
	{
		if (Interface.CallHook("OnConnectionQueue", connection) == null)
		{
			connection.state = Connection.State.InQueue;
			queue.Add(connection);
			nextMessageTime = 0f;
			if (CanJumpQueue(connection))
			{
				JoinGame(connection);
			}
		}
	}

```

## OnProjectileRicochet(BasePlayer,ProtoBuf.PlayerProjectileRicochet)

```csharp
```csharp
/// <summary>
/// Called when a projectile ricochets off a surface.
/// </summary>
/// <param name="player">The player who fired the projectile.</param>
/// <param name="ricochetData">The data related to the ricochet event.</param>
/// <returns>
/// Returns `null` to allow the default ricochet behavior, or a non-null value to override it. (object)
/// </returns>
object OnProjectileRicochet(BasePlayer player, ProtoBuf.PlayerProjectileRicochet ricochetData)
{
    Puts($"Projectile ricochet detected for player {player} with ID: {ricochetData.projectileID}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	public void OnProjectileRicochet(RPCMessage msg)
	{
		PlayerProjectileRicochet playerProjectileRicochet = PlayerProjectileRicochet.Deserialize(msg.read);
		if (playerProjectileRicochet != null)
		{
			FiredProjectile value;
			if (playerProjectileRicochet.hitPosition.IsNaNOrInfinity() || playerProjectileRicochet.inVelocity.IsNaNOrInfinity() || playerProjectileRicochet.outVelocity.IsNaNOrInfinity() || playerProjectileRicochet.hitNormal.IsNaNOrInfinity() || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + playerProjectileRicochet.projectileID + ")", logToAnalytics: false);
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (value.firedTime < UnityEngine.Time.realtimeSinceStartup - 8f)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (Interface.CallHook("OnProjectileRicochet", this, playerProjectileRicochet) == null)
			{
				value.ricochets++;
				firedProjectiles[playerProjectileRicochet.projectileID] = value;
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
		}
	}

```

## OnEntityPickedUp(BaseCombatEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is picked up by a player.
/// </summary>
/// <param name="entity">The entity that was picked up.</param>
/// <param name="item">The item that was created from the entity.</param>
/// <param name="player">The player who picked up the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityPickedUp(BaseCombatEntity entity, Item item, BasePlayer player)
{
    Puts($"Entity {entity} picked up by player {player} with item {item}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnPickedUp(Item createdItem, BasePlayer player)
	{
		Interface.CallHook("OnEntityPickedUp", this, createdItem, player);
	}

```

## OnNpcConversationResponded(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
```csharp
/// <summary>
/// Called when a player responds to an NPC conversation.
/// </summary>
/// <param name="npc">The NPC that the player is conversing with.</param>
/// <param name="player">The player who responded to the conversation.</param>
/// <param name="conversation">The conversation data associated with the interaction.</param>
/// <param name="response">The specific response node chosen by the player.</param>
/// <returns>
/// Returns a non-null value to override the default response behavior; otherwise, returns null to proceed with the default logic. (object)
/// </returns>
object OnNpcConversationResponded(NPCTalking npc, BasePlayer player, ConversationData conversation, ConversationData.ResponseNode response)
{
    Puts($"Player {player} responded to NPC {npc} with response: {response}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode == null || Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) != null)
		{
			return;
		}
		if (responseNode.conditions.Length != 0)
		{
			UpdateFlags();
		}
		bool flag = responseNode.PassesConditions(player, this);
		if (flag)
		{
			string actionString = responseNode.GetActionString();
			if (!string.IsNullOrEmpty(actionString))
			{
				OnConversationAction(player, actionString);
			}
		}
		int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
		if (speechNodeIndex == -1)
		{
			ForceEndConversation(player);
			return;
		}
		ForceSpeechNode(player, speechNodeIndex);
		Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
	}

```

## OnWorldProjectileCreate(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="info">The hit information related to the projectile's creation.</param>
/// <param name="item">The item associated with the projectile.</param>
/// <returns>
/// Returns a non-null value to prevent the default projectile creation behavior. 
/// If `null` is returned, the projectile will be created as normal. (object)
/// </returns>
object OnWorldProjectileCreate(HitInfo info, Item item)
{
    Puts($"Creating world projectile with item {item} at position {info.HitPositionWorld}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if (droppedItem != null)
			{
				droppedItem.StickIn();
			}
			else
			{
				baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			Rigidbody component = baseEntity.GetComponent<Rigidbody>();
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## OnCrateLanded(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate has successfully landed.
/// </summary>
/// <param name="crate">The hackable locked crate that has landed.</param>
/// <returns>No return behavior.</returns>
void OnCrateLanded(HackableLockedCrate crate)
{
    Puts($"Hackable locked crate has landed at position: {crate.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public void LandCheck()
	{
		RaycastHit hitInfo;
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", this);
		}
		else if (UnityEngine.Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1084293377))
		{
			Effect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);
			hasLanded = true;
			CancelInvoke(LandCheck);
		}
	}

```

## OnExplosiveFuseSet(TimedExplosive,float)

```csharp
```csharp
/// <summary>
/// Called when the fuse of a timed explosive is set.
/// </summary>
/// <param name="explosive">The timed explosive whose fuse is being set.</param>
/// <param name="fuseLength">The length of the fuse in seconds.</param>
/// <returns>
/// Returns a modified fuse length if the hook alters the default behavior; otherwise, returns the original fuse length. (float)
/// </returns>
object OnExplosiveFuseSet(TimedExplosive explosive, float fuseLength)
{
    Puts($"Setting fuse for explosive {explosive} to {fuseLength} seconds.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			object obj = Interface.CallHook("OnExplosiveFuseSet", this, fuseLength);
			if (obj is float)
			{
				fuseLength = (float)obj;
			}
			Invoke(Explode, fuseLength);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

```

## CanEquipItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether a specific item can be equipped in a given slot of the player's inventory.
/// </summary>
/// <param name="item">The item to be equipped.</param>
/// <param name="targetSlot">The slot in which the item is to be equipped.</param>
/// <returns>
/// Returns `true` if the item can be equipped in the specified slot; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the item can be equipped. (bool)
/// </returns>
object CanEquipItem(Item item, int targetSlot)
{
    Puts($"Checking if item {item} can be equipped in slot {targetSlot}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanEquipItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanEquipItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((item.info.flags & ItemDefinition.Flag.NotAllowedInBelt) != 0)
		{
			return false;
		}
		if (base.baseEntity != null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if (restraintItem != null && restraintItem.GetItem().position == targetSlot)
			{
				return false;
			}
		}
		ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
		if (component == null)
		{
			return true;
		}
		Item[] array = containerBelt.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
				}
			}
		}
		return true;
	}

```

## OnRackedWeaponMounted(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is successfully mounted on a weapon rack.
/// </summary>
/// <param name="item">The weapon item being mounted.</param>
/// <param name="player">The player who is mounting the weapon.</param>
/// <param name="rack">The weapon rack where the weapon is being mounted.</param>
/// <returns>
/// Returns `true` if the weapon was successfully mounted; otherwise, returns `false`. 
/// If the method returns a non-null value, it overrides the default mounting behavior. (bool)
/// </returns>
object OnRackedWeaponMounted(Item item, BasePlayer player, WeaponRack rack)
{
    Puts($"Weapon {item} mounted by player {player} on rack {rack}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", item, player, this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			Debug.LogWarning("no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if (player != null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", item, player, this);
		return true;
	}

```

## CanLootEntity(BasePlayer,ResourceContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific resource container.
/// </summary>
/// <param name="player">The player attempting to loot the container.</param>
/// <param name="container">The resource container that is being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the container, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the container. (bool)
/// </returns>
object CanLootEntity(BasePlayer player, ResourceContainer container)
{
    Puts($"Player {player} is attempting to loot container {container}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server.IsVisible(3f)]
	[BaseEntity.RPC_Server]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}

```

## InitLogging()

```csharp
```csharp
/// <summary>
/// Initializes the logging system for the application.
/// </summary>
/// <returns>No return behavior.</returns>
void InitLogging()
{
    Puts("Logging system initialized.");
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

```

## OnPlayerColliderEnable(BasePlayer,UnityEngine.CapsuleCollider)

```csharp
```csharp
/// <summary>
/// Called when enabling the player's collider.
/// </summary>
/// <param name="player">The player whose collider is being enabled.</param>
/// <param name="collider">The capsule collider associated with the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerColliderEnable(BasePlayer player, UnityEngine.CapsuleCollider collider)
{
    Puts($"Enabling collider for player {player}.");
}
```
```

### Source Code from the Library

```csharp

	public void EnablePlayerCollider()
	{
		if (!playerCollider.enabled && Interface.CallHook("OnPlayerColliderEnable", this, playerCollider) == null)
		{
			RefreshColliderSize(forced: true);
			playerCollider.enabled = true;
		}
	}

```

## OnNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC attacks a target entity.
/// </summary>
/// <param name="npc">The NPC that is performing the attack.</param>
/// <param name="target">The entity that is being attacked.</param>
/// <returns>
/// Returns `null` to allow the attack to proceed, or any non-null value to prevent the attack from happening. (object)
/// </returns>
object OnNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc} is attempting to attack target {target}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if ((bool)AttackTarget && AttackReady() && Interface.CallHook("OnNpcAttack", this, AttackTarget) == null && !((AttackTarget.ServerPosition - ServerPosition).magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(RpcTarget.NetworkGroup("Attack"), AttackTarget.ServerPosition);
			}
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client attempts to authenticate with the server.
/// </summary>
/// <param name="connection">The network connection of the client attempting to authenticate.</param>
/// <returns>
/// Returns a non-null value to override the default authentication behavior. 
/// If `null` is returned, the default authentication process continues. (object)
/// </returns>
object OnClientAuth(Network.Connection connection)
{
    Puts($"Client {connection.username} is attempting to authenticate with ID {connection.userid}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Network.Connection.State.Connecting;
		if (packet.read.UInt8() != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String(128);
		packet.connection.username = packet.read.String();
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.Unread >= 4)
		{
			text = packet.read.String(128);
		}
		Interface.CallHook("OnClientAuth", packet.connection);
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their branch is '" + text + "' not '" + branch + "'");
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2564)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2564);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2564)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2564);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize(512u);
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
				return;
			}
			packet.connection.anticheatId = packet.read.StringRaw(128);
			packet.connection.anticheatToken = packet.read.StringRaw(2048);
			packet.connection.clientChangeset = packet.read.Int32();
			packet.connection.clientBuildTime = packet.read.Int64();
			auth.OnNewConnection(packet.connection);
		}
	}

```

## OnInventoryItemsFind(PlayerInventory,int)

```csharp
```csharp
/// <summary>
/// Called to find items in the player's inventory by their item ID.
/// </summary>
/// <param name="inventory">The player's inventory being searched.</param>
/// <param name="id">The item ID to search for.</param>
/// <returns>
/// Returns a list of items found with the specified item ID. If the hook returns a non-null value, that value will be returned instead. (List<Item>)
/// </returns>
object OnInventoryItemsFind(PlayerInventory inventory, int id)
{
    Puts($"Searching for items with ID {id} in inventory of {inventory}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public List<Item> FindItemsByItemID(int id)
	{
		object obj = Interface.CallHook("OnInventoryItemsFind", this, id);
		if (obj is List<Item>)
		{
			return (List<Item>)obj;
		}
		List<Item> list = new List<Item>();
		if (containerMain != null)
		{
			list.AddRange(containerMain.FindItemsByItemID(id));
		}
		if (containerBelt != null)
		{
			list.AddRange(containerBelt.FindItemsByItemID(id));
		}
		if (containerWear != null)
		{
			list.AddRange(containerWear.FindItemsByItemID(id));
		}
		return list;
	}

```

## OnNpcConversationEnded(NPCTalking,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a conversation with an NPC has ended for a player.
/// </summary>
/// <param name="player">The player who ended the conversation.</param>
/// <returns>No return behavior.</returns>
void OnNpcConversationEnded(BasePlayer player)
{
    Puts($"Conversation ended for player {player} with NPC {this}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnConversationEnded(BasePlayer player)
	{
		Interface.CallHook("OnNpcConversationEnded", this, player);
		if (conversingPlayers.Contains(player))
		{
			conversingPlayers.Remove(player);
		}
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
```csharp
/// <summary>
/// Called when a new resource deposit is created in the world.
/// </summary>
/// <param name="deposit">The resource deposit that has been created.</param>
/// <returns>No return behavior.</returns>
void OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit deposit)
{
    Puts($"Resource deposit created at position: {deposit.origin} with contents: {deposit.GetContents()}");
}
```
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		UnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)
		};
		if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else
		{
			bool flag = false;
			float num = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)
				{
					num += 0.25f;
				}
			}
			else
			{
				num += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(8f, 10f), ResourceDeposit.surveySpawnType.ITEM, liquid: true);
				flag = true;
			}
			if (!flag)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
				float num2 = 0f;
				num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num3 = 0f;
				num3 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num3)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num4 = 0f;
				if (World.Procedural)
				{
					if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
					{
						num4 += 0.25f;
					}
				}
				else
				{
					num4 += 0.15f;
				}
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num4)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
				}
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnHuntEventEnd(EggHuntEvent)

```csharp
```csharp
/// <summary>
/// Called when an egg hunt event ends, allowing for cleanup and awarding of prizes.
/// </summary>
/// <param name="event">The egg hunt event that has ended.</param>
/// <returns>
/// Returns `null` to allow the default end behavior, or a non-null value to override it. (object)
/// </returns>
object OnHuntEventEnd(EggHuntEvent event)
{
    Puts($"Egg hunt event {event} has ended.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Update()
	{
		timeAlive += UnityEngine.Time.deltaTime;
		if (base.isServer && !base.IsDestroyed)
		{
			if (timeAlive - warmupTime > durationSeconds - warnTime)
			{
				SetFlag(Flags.Reserved1, b: true);
			}
			if (timeAlive - warmupTime > durationSeconds && !IsInvoking(Cooldown) && Interface.CallHook("OnHuntEventEnd", this) == null)
			{
				SetFlag(Flags.Reserved2, b: true);
				CleanupEggs();
				PrintWinnersAndAward();
				Invoke(Cooldown, 10f);
			}
		}
	}

```

## OnItemRepair(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is being repaired by a player.
/// </summary>
/// <param name="player">The player attempting to repair the item.</param>
/// <param name="item">The item that is being repaired.</param>
/// <returns>
/// Returns a non-null value to prevent the repair from occurring, or `null` to allow the repair to proceed. (object)
/// </returns>
object OnItemRepair(BasePlayer player, Item item)
{
    Puts($"Player {player} is attempting to repair item: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
	{
		if (itemToRepair == null)
		{
			return;
		}
		ItemDefinition info = itemToRepair.info;
		ItemBlueprint component = info.GetComponent<ItemBlueprint>();
		if (!component)
		{
			return;
		}
		ItemModRepair component2 = itemToRepair.info.GetComponent<ItemModRepair>();
		if (!info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)
		{
			return;
		}
		if (mustKnowBlueprint)
		{
			ItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);
			if (!player.blueprints.HasUnlocked(itemDefinition) && (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))
			{
				return;
			}
		}
		if (Interface.CallHook("OnItemRepair", player, itemToRepair) != null)
		{
			return;
		}
		float num = RepairCostFraction(itemToRepair);
		bool flag = false;
		List<ItemAmount> obj = Facepunch.Pool.Get<List<ItemAmount>>();
		GetRepairCostList(component, obj);
		foreach (ItemAmount item in obj)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				if (Mathf.CeilToInt(item.amount * num) > amount)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj);
			return;
		}
		foreach (ItemAmount item2 in obj)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
				Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "repair", item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair);
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj);
		float conditionNormalized = itemToRepair.conditionNormalized;
		float maxConditionNormalized = itemToRepair.maxConditionNormalized;
		itemToRepair.DoRepair(maxConditionLostOnRepair);
		Facepunch.Rust.Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);
		if (Global.developer > 0)
		{
			Debug.Log("Item repaired! condition : " + itemToRepair.condition + "/" + itemToRepair.maxCondition);
		}
		string strName = "assets/bundled/prefabs/fx/repairbench/itemrepair.prefab";
		if (component2 != null && component2.successEffect?.Get() != null)
		{
			strName = component2.successEffect.resourcePath;
		}
		Effect.server.Run(strName, repairBenchEntity, 0u, Vector3.zero, Vector3.zero);
	}

```

## OnSignContentCopied(SignContent,ISignage,IUGCBrowserEntity)

```csharp
```csharp
/// <summary>
/// Called when the content of a sign is copied to another sign or entity.
/// </summary>
/// <param name="signContent">The original sign content being copied.</param>
/// <param name="signage">The signage entity that will receive the copied content.</param>
/// <param name="browserEntity">The UGC browser entity associated with the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignContentCopied(SignContent signContent, ISignage signage, IUGCBrowserEntity browserEntity)
{
    Puts($"Sign content copied from {signContent} to signage {signage}.");
}
```
```

### Source Code from the Library

```csharp

	public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)
	{
		FileStorage.server.ReassignEntityId(net.ID, s.NetworkID);
		s.SetTextureCRCs(textureIDs);
		b.EditingHistory.Clear();
		foreach (ulong item in editHistory)
		{
			b.EditingHistory.Add(item);
		}
		Interface.CallHook("OnSignContentCopied", this, s, b);
	}

```

## OnRackedWeaponTake(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is taken from a weapon rack by a player.
/// </summary>
/// <param name="item">The item being taken from the weapon rack.</param>
/// <param name="player">The player taking the weapon.</param>
/// <param name="rack">The weapon rack from which the weapon is taken.</param>
/// <returns>
/// Returns a non-null value to prevent the weapon from being taken, or `null` to allow the action. (object)
/// </returns>
object OnRackedWeaponTake(Item item, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player} is attempting to take weapon {item} from rack {rack}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", slot, player, this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		if (slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex))
		{
			if ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1)
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", slot, player, this);
	}

```

## OnBookmarkControlStarted(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a player starts controlling a remote entity via a bookmark.
/// </summary>
/// <param name="station">The computer station initiating the control.</param>
/// <param name="player">The player who is starting to control the entity.</param>
/// <param name="bookmarkId">The identifier of the bookmark being used.</param>
/// <param name="remoteEntity">The remote controllable entity being accessed.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkId, IRemoteControllable remoteEntity)
{
    Puts($"Player {player} started controlling entity with bookmark ID: {bookmarkId}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## OnPlayerWound(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player is wounded, allowing for custom behavior or modifications.
/// </summary>
/// <param name="player">The player who has been wounded.</param>
/// <param name="hitInfo">Information about the hit that caused the wound.</param>
/// <returns>
/// Returns a non-null value to prevent the default wounding behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnPlayerWound(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player} has been wounded with damage type: {hitInfo.damageTypes.GetMajorityDamageType()}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void BecomeWounded(HitInfo info = null)
	{
		if (IsWounded() || Interface.CallHook("OnPlayerWound", this, info) != null)
		{
			return;
		}
		bool flag = info != null && info.damageTypes.GetMajorityDamageType() == DamageType.Fall;
		if (IsCrawling())
		{
			woundedByFallDamage |= flag;
			GoToIncapacitated(info);
			return;
		}
		woundedByFallDamage = flag;
		if (flag || !ConVar.Server.crawlingenabled)
		{
			GoToIncapacitated(info);
		}
		else
		{
			GoToCrawling(info);
		}
	}

```

## CanWearItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether a player can wear a specific item in a given slot.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The item to be worn.</param>
/// <param name="targetSlot">The slot where the item is intended to be worn.</param>
/// <returns>
/// Returns `true` if the item can be worn in the specified slot; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the item can be worn. (bool)
/// </returns>
object CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
{
    Puts($"Checking if item {item} can be worn in slot {targetSlot}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanWearItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanWearItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CanWearItem(item, canAdjustClothing: true, targetSlot);
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the active item can be dropped by the player.
/// </summary>
/// <param name="player">The player attempting to drop the active item.</param>
/// <returns>
/// Returns `true` if the active item can be dropped; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the item can be dropped. (bool)
/// </returns>
object CanDropActiveItem(BasePlayer player)
{
    Puts($"Player {player} is attempting to drop their active item.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnDebrisSpawn(DecayEntity,UnityEngine.Vector3,UnityEngine.Quaternion,bool)

```csharp
```csharp
/// <summary>
/// Called when debris is spawned from a decaying entity.
/// </summary>
/// <param name="entity">The decaying entity that is spawning debris.</param>
/// <param name="position">The local position where the debris will spawn.</param>
/// <param name="rotation">The rotation of the debris when spawned.</param>
/// <param name="dropToTerrain">Indicates whether the debris should drop to the terrain.</param>
/// <returns>
/// Returns a non-null value to prevent the default debris spawning behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnDebrisSpawn(DecayEntity entity, Vector3 position, Quaternion rotation, bool dropToTerrain)
{
    Puts($"Debris spawn requested for entity {entity} at position {position} with rotation {rotation}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)
	{
		if (Interface.CallHook("OnDebrisSpawn", this, localPos, rot, dropToTerrain) != null)
		{
			return;
		}
		Vector3 vector = base.transform.TransformPoint(localPos);
		if (dropToTerrain && UnityEngine.Physics.Raycast(vector, Vector3.down, out var hitInfo, 6f, 8388608))
		{
			float num = vector.y - hitInfo.point.y;
			vector.y = hitInfo.point.y;
			localPos.y -= num;
		}
		List<DebrisEntity> list = Facepunch.Pool.Get<List<DebrisEntity>>();
		Vis.Entities(vector, 0.1f, list, 256);
		if (list.Count <= 0)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(debrisPrefab.resourcePath, base.transform.TransformPoint(localPos), base.transform.rotation * rot);
			if ((bool)baseEntity)
			{
				baseEntity.SetParent(parentEntity.Get(serverside: true), worldPositionStays: true);
				baseEntity.Spawn();
			}
		}
	}

```

## OnBookmarkAdd(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player adds a bookmark to a computer station.
/// </summary>
/// <param name="station">The computer station where the bookmark is being added.</param>
/// <param name="player">The player who is adding the bookmark.</param>
/// <param name="bookmark">The bookmark string being added.</param>
/// <returns>
/// Returns `null` to allow the bookmark to be added, or any non-null value to prevent the addition. (object)
/// </returns>
object OnBookmarkAdd(ComputerStation station, BasePlayer player, string bookmark)
{
    Puts($"Player {player} is adding a bookmark: {bookmark} to station {station}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void AddBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		if (UnityEngine.Time.realtimeSinceStartup < nextAddTime)
		{
			player.ChatMessage("Slow down...");
			return;
		}
		if (controlBookmarks.Count >= 128)
		{
			player.ChatMessage("Too many bookmarks, delete some");
			return;
		}
		nextAddTime = UnityEngine.Time.realtimeSinceStartup + 1f;
		string text = msg.read.String();
		if (Interface.CallHook("OnBookmarkAdd", this, player, text) == null)
		{
			ForceAddBookmark(text);
			SendControlBookmarks(player);
		}
	}

```

## OnVendingShopRename(VendingMachine,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop's name is updated.
/// </summary>
/// <param name="vendingMachine">The vending machine whose name is being changed.</param>
/// <param name="newName">The new name for the vending shop.</param>
/// <param name="player">The player who is renaming the shop.</param>
/// <returns>
/// Returns `null` to allow the name change, or a non-null value to prevent it. (object)
/// </returns>
object OnVendingShopRename(VendingMachine vendingMachine, string newName, BasePlayer player)
{
    Puts($"Vending shop renamed to '{newName}' by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_UpdateShopName(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string obj = msg.read.String(32);
		if (CanPlayerAdmin(player) && Interface.CallHook("OnVendingShopRename", this, obj, player) == null)
		{
			shopName = obj;
			UpdateMapMarker();
		}
	}

```

## OnSignUpdated(PhotoFrame,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated with a new image by a player.
/// </summary>
/// <param name="photoFrame">The photo frame (sign) that has been updated.</param>
/// <param name="player">The player who updated the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(PhotoFrame photoFrame, BasePlayer player)
{
    Puts($"Sign updated by player {player} on photo frame {photoFrame}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (!(msg.player == null) && CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				LogEdit(msg.player);
				SendNetworkUpdate();
				Interface.CallHook("OnSignUpdated", this, msg.player);
			}
		}
	}

```

## OnPhoneCallStart(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone call is initiated between two phone controllers.
/// </summary>
/// <param name="caller">The phone controller initiating the call.</param>
/// <param name="receiver">The phone controller receiving the call.</param>
/// <param name="player">The player involved in the call.</param>
/// <returns>
/// Returns a non-null value to prevent the call from starting; otherwise, returns null to allow the call to proceed. (object)
/// </returns>
object OnPhoneCallStart(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone call initiated from {caller} to {receiver} by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", this, activeCallTo, currentPlayer) == null)
		{
			if (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)
			{
				_ = currentPlayer != null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			Invoke(TimeOutCall, TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", this, activeCallTo, currentPlayer);
		}
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the Bradley APC can target a specified entity.
/// </summary>
/// <param name="apc">The Bradley APC attempting to target the entity.</param>
/// <param name="entity">The entity being checked for targeting.</param>
/// <returns>
/// Returns `true` if the APC can target the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default visibility logic will be used. (bool)
/// </returns>
object CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
{
    Puts($"Checking if Bradley APC can target entity: {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.transform.position, base.transform.position) < viewDistance))
		{
			return false;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			flag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position + Vector3.up * 0.1f, position);
			if (!flag && basePlayer.isMounted && basePlayer.GetMounted().VehicleParent() != null && basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)
			{
				flag = IsVisible(basePlayer.GetMounted().VehicleParent().bounds.center, position);
			}
			if (flag)
			{
				flag = !UnityEngine.Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);
			}
		}
		else
		{
			Debug.LogWarning("Standard vis test!");
			flag = IsVisible(ent.CenterPoint());
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return flag;
	}

```

## CanDesignFirework(BasePlayer,PatternFirework)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can design a firework pattern.
/// </summary>
/// <param name="player">The player attempting to design the firework.</param>
/// <param name="fireworkPattern">The firework pattern being designed.</param>
/// <returns>
/// Returns `true` if the player can design the firework pattern; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will be used to determine if the player can design the firework. (bool)
/// </returns>
object CanDesignFirework(BasePlayer player, PatternFirework fireworkPattern)
{
    Puts($"Player {player} is attempting to design a firework pattern: {fireworkPattern}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool PlayerCanModify(BasePlayer player)
	{
		if (player == null || !player.CanInteract())
		{
			return false;
		}
		object obj = Interface.CallHook("CanDesignFirework", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		if (buildingPrivilege != null && !buildingPrivilege.CanAdministrate(player))
		{
			return false;
		}
		return true;
	}

```

## OnDispenserGather(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player gathers resources from a dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser being gathered from.</param>
/// <param name="player">The player gathering the resources.</param>
/// <param name="item">The item being gathered.</param>
/// <returns>No return behavior.</returns>
void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player} gathered {item.amount} of {item.info.shortname} from dispenser {dispenser}.");
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		f = Mathf.Round(f);
		float num3 = f * destroyFraction * 2f;
		if (itemAmt.amount <= f + num3)
		{
			float num4 = (f + num3) / itemAmt.amount;
			f /= num4;
			num3 /= num4;
		}
		itemAmt.amount -= Mathf.Floor(f);
		itemAmt.amount -= Mathf.Floor(num3);
		if (f < 1f)
		{
			f = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (f >= 1f)
		{
			int num5 = CalculateGatherBonus(entity, itemAmt, f);
			int iAmount = Mathf.FloorToInt(f) + num5;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (Interface.CallHook("OnDispenserGather", this, entity, item) == null && item != null)
			{
				OverrideOwnership(item, attackWeapon);
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
				Interface.CallHook("OnDispenserGathered", this, entity, item);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnElevatorMove(Elevator,int)

```csharp
```csharp
/// <summary>
/// Called when an elevator is requested to move to a specific floor.
/// </summary>
/// <param name="elevator">The elevator that is being moved.</param>
/// <param name="targetFloor">The floor to which the elevator is requested to move.</param>
/// <returns>
/// Returns `false` if the elevator cannot move due to various conditions; otherwise, returns `true` to indicate the move is valid.
/// If the method returns a non-null value, it will prevent the elevator from moving. (bool)
/// </returns>
object OnElevatorMove(Elevator elevator, int targetFloor)
{
    Puts($"Elevator {elevator} requested to move to floor {targetFloor}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)
	{
		timeToTravel = 0f;
		if (Interface.CallHook("OnElevatorMove", this, targetFloor) != null)
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (!IsStatic && ioEntity != null && !ioEntity.IsPowered())
		{
			return false;
		}
		if (!IsValidFloor(targetFloor))
		{
			return false;
		}
		int num = LiftPositionToFloor();
		if (num == targetFloor)
		{
			OpenDoorsAtFloor(num);
			return false;
		}
		if (!liftEntity.IsValid(base.isServer))
		{
			return false;
		}
		ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
		if (!elevatorLift.CanMove())
		{
			return false;
		}
		Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);
		if (!GamePhysics.LineOfSight(elevatorLift.transform.position, worldSpaceFloorPosition, 2097152))
		{
			return false;
		}
		OnMoveBegin();
		timeToTravel = TimeToTravelDistance(Mathf.Abs(elevatorLift.transform.position.y - worldSpaceFloorPosition.y));
		LeanTween.moveY(elevatorLift.gameObject, worldSpaceFloorPosition.y, timeToTravel).delay = LiftMoveDelay;
		timeToTravel += LiftMoveDelay;
		SetFlag(Flags.Busy, b: true);
		if (targetFloor < Floor)
		{
			elevatorLift.ToggleHurtTrigger(state: true);
		}
		elevatorLift.SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, timeToTravel + 1f);
		elevatorLift.NotifyNewFloor(targetFloor, Floor);
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Busy, b: true);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
		if (ioEntity != null)
		{
			ioEntity.SetFlag(Flags.Busy, b: true);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		return true;
	}

```

## OnEngineStatsRefreshed(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called when the performance statistics of a vehicle engine are refreshed.
/// </summary>
/// <param name="engine">The engine module whose stats are being refreshed.</param>
/// <param name="engineStorage">The storage containing the engine's performance data.</param>
/// <returns>No return behavior.</returns>
void OnEngineStatsRefreshed(VehicleModuleEngine engine, EngineStorage engineStorage)
{
    Puts($"Refreshing engine stats for {engine} with storage: {engineStorage}.");
}
```
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## OnPlayerVoice(BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a player sends voice data.
/// </summary>
/// <param name="player">The player who is sending the voice data.</param>
/// <param name="data">The voice data being sent as a byte array.</param>
/// <returns>
/// Returns `null` to allow the default voice handling, or any non-null value to override the default behavior. (object)
/// </returns>
object OnPlayerVoice(BasePlayer player, byte[] data)
{
    Puts($"Player {player} sent voice data of length {data.Length}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnReceivedVoice(byte[] data)
	{
		if (Interface.CallHook("OnPlayerVoice", this, data) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.VoiceData);
			netWrite.EntityID(net.ID);
			netWrite.BytesWithSize(data);
			float num = 0f;
			if (HasPlayerFlag(PlayerFlags.VoiceRangeBoost))
			{
				num = Voice.voiceRangeBoostAmount;
			}
			netWrite.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f + num))
			{
				priority = Priority.Immediate
			});
			if (activeTelephone != null)
			{
				activeTelephone.OnReceivedVoiceFromUser(data);
			}
		}
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is rotated by a player.
/// </summary>
/// <param name="structure">The building block structure being rotated.</param>
/// <param name="player">The player who is rotating the structure.</param>
/// <returns>
/// Returns `null` to allow the rotation, or any non-null value to prevent the rotation. (object)
/// </returns>
object OnStructureRotate(BuildingBlock structure, BasePlayer player)
{
    Puts($"Player {player} is attempting to rotate structure {structure}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotateAfterPlacement && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			UpdateSkin(force: true);
			RefreshNeighbours(linkToNeighbours: false);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
			if (!globalNetworkCooldown)
			{
				globalNetworkCooldown = true;
				GlobalNetworkHandler.server.TrySendNetworkUpdate(this);
				CancelInvoke(ResetGlobalNetworkCooldown);
				Invoke(ResetGlobalNetworkCooldown, 15f);
			}
		}
	}

```

## OnCargoShipSpawnCrate(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship is about to spawn loot crates.
/// </summary>
/// <param name="cargoShip">The cargo ship that is spawning the crates.</param>
/// <returns>
/// Returns `null` to allow the default crate spawning behavior, or any non-null value to prevent it. (object)
/// </returns>
object OnCargoShipSpawnCrate(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip} is attempting to spawn loot crates.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RespawnLoot()
	{
		if (Interface.CallHook("OnCargoShipSpawnCrate", this) == null)
		{
			InvokeRepeating(PlayHorn, 0f, 8f);
			SpawnCrate(lockedCratePrefab.resourcePath);
			SpawnCrate(eliteCratePrefab.resourcePath);
			for (int i = 0; i < 4; i++)
			{
				SpawnCrate(militaryCratePrefab.resourcePath);
			}
			for (int j = 0; j < 4; j++)
			{
				SpawnCrate(junkCratePrefab.resourcePath);
			}
			lootRoundsPassed++;
			if (lootRoundsPassed >= loot_rounds)
			{
				CancelInvoke(RespawnLoot);
			}
		}
	}

```

## OnNpcEquipWeapon(NPCPlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon from its inventory.
/// </summary>
/// <param name="npc">The NPC player that is equipping the weapon.</param>
/// <param name="item">The item being equipped as a weapon.</param>
/// <returns>No return behavior.</returns>
void OnNpcEquipWeapon(NPCPlayer npc, Item item)
{
    Puts($"NPC {npc} is equipping weapon: {item}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void EquipWeapon(bool skipDeployDelay = false)
	{
		if (base.inventory == null || base.inventory.containerBelt == null)
		{
			return;
		}
		Item slot = base.inventory.containerBelt.GetSlot(0);
		if (Interface.CallHook("OnNpcEquipWeapon", this, slot) != null || slot == null)
		{
			return;
		}
		UpdateActiveItem(base.inventory.containerBelt.GetSlot(0).uid);
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		AttackEntity component = heldEntity.GetComponent<AttackEntity>();
		if (component != null)
		{
			if (skipDeployDelay)
			{
				component.ResetAttackCooldown();
			}
			component.TopUpAmmo();
		}
	}

```

## OnExcavatorGather(ExcavatorArm,Item)

```csharp
```csharp
/// <summary>
/// Called when the excavator gathers resources and produces items.
/// </summary>
/// <param name="excavator">The excavator arm that is gathering resources.</param>
/// <param name="item">The item being produced from the gathered resources.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being produced, or `null` to allow the default behavior. (object)
/// </returns>
object OnExcavatorGather(ExcavatorArm excavator, Item item)
{
    Puts($"Excavator {excavator} is gathering item: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ProduceResources()
	{
		float num = resourceProductionTickRate / timeForFullResources;
		float num2 = resourcesToMine[resourceMiningIndex].amount * num;
		pendingResources[resourceMiningIndex].amount += num2;
		ItemAmount[] array = pendingResources;
		foreach (ItemAmount itemAmount in array)
		{
			if (!(itemAmount.amount >= (float)outputPiles.Count))
			{
				continue;
			}
			int num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);
			itemAmount.amount -= num3 * 2;
			foreach (ExcavatorOutputPile outputPile in outputPiles)
			{
				Item item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);
				if (Interface.CallHook("OnExcavatorGather", this, item) != null)
				{
					return;
				}
				Facepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);
				if (!item.MoveToContainer(outputPile.inventory))
				{
					item.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());
				}
			}
		}
	}

```

## CanSpectateTarget(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can spectate a target based on the provided name.
/// </summary>
/// <param name="player">The player attempting to spectate.</param>
/// <param name="targetName">The name of the target the player wishes to spectate.</param>
/// <returns>
/// Returns `null` to allow the player to spectate the target, or any non-null value to prevent spectating. (object)
/// </returns>
object CanSpectateTarget(BasePlayer player, string targetName)
{
    Puts($"Player {player} is attempting to spectate target: {targetName}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateSpectateTarget(string strName)
	{
		if (Interface.CallHook("CanSpectateTarget", this, strName) != null)
		{
			return;
		}
		spectateFilter = strName;
		IEnumerable<BaseEntity> enumerable = null;
		if (spectateFilter.StartsWith("@"))
		{
			string filter = spectateFilter.Substring(1);
			enumerable = (from x in BaseNetworkable.serverEntities
				where x.name.Contains(filter, CompareOptions.IgnoreCase)
				where x != this
				select x).Cast<BaseEntity>();
		}
		else
		{
			IEnumerable<BasePlayer> source = activePlayerList.Where((BasePlayer x) => !x.IsSpectating() && !x.IsDead() && !x.IsSleeping());
			if (strName.Length > 0)
			{
				source = from x in source
					where x.displayName.Contains(spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)
					where x != this
					select x;
			}
			source = source.OrderBy((BasePlayer x) => x.displayName);
			enumerable = source.Cast<BaseEntity>();
		}
		BaseEntity[] array = enumerable.ToArray();
		if (array.Length == 0)
		{
			ChatMessage("No valid spectate targets!");
			return;
		}
		BaseEntity baseEntity = array[SpectateOffset % array.Length];
		if (baseEntity != null)
		{
			SpectatePlayer(baseEntity);
		}
	}

```

## OnShopCancelClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player cancels a shop interaction.
/// </summary>
/// <param name="shop">The shop front where the cancellation occurred.</param>
/// <param name="player">The player who clicked to cancel the shop interaction.</param>
/// <returns>
/// Returns `null` to allow the cancellation to proceed, or any non-null value to prevent the cancellation. (object)
/// </returns>
object OnShopCancelClick(ShopFront shop, BasePlayer player)
{
    Puts($"Player {player} has canceled the shop interaction at {shop}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", this, msg.player) == null)
		{
			_ = (bool)vendorPlayer;
			_ = (bool)customerPlayer;
			ResetTrade();
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed at the shop front.
/// </summary>
/// <param name="shop">The shop front where the trade is completed.</param>
/// <returns>
/// Returns a non-null value to prevent the trade from completing, or `null` to allow the trade to proceed. (object)
/// </returns>
object OnShopCompleteTrade(ShopFront shop)
{
    Puts($"Trade completed at shop: {shop}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			try
			{
				swappingItems = true;
				for (int num = vendorInventory.capacity - 1; num >= 0; num--)
				{
					Item slot = vendorInventory.GetSlot(num);
					Item slot2 = customerInventory.GetSlot(num);
					if ((bool)customerPlayer && slot != null)
					{
						customerPlayer.GiveItem(slot);
					}
					if ((bool)vendorPlayer && slot2 != null)
					{
						vendorPlayer.GiveItem(slot2);
					}
				}
			}
			finally
			{
				swappingItems = false;
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnLootEntityEnd(BasePlayer,ItemBasedFlowRestrictor)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="restrictor">The item-based flow restrictor associated with the looting process.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ItemBasedFlowRestrictor restrictor)
{
    Puts($"Player {player} has stopped looting the entity.");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
	}

```

## OnPlayerCorpseSpawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's corpse is about to be spawned.
/// </summary>
/// <param name="player">The player whose corpse is being spawned.</param>
/// <returns>
/// Returns `null` to prevent the corpse from spawning, or any other value to allow the default spawning behavior. (object)
/// </returns>
object OnPlayerCorpseSpawn(BasePlayer player)
{
    Puts($"Attempting to spawn corpse for player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? "assets/prefabs/player/player_corpse.prefab" : "assets/prefabs/player/player_corpse_new.prefab");
			bool flag = false;
			if (ConVar.Global.cinematicGingerbreadCorpses)
			{
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);
						flag = component.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.streamerName = RandomUsernames.Get(userID);
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				if (!CollectionEx.IsNullOrEmpty(triggersOnDeath))
				{
					foreach (TriggerBase item2 in triggersOnDeath)
					{
						if (item2 is TriggerParent triggerParent)
						{
							triggerParent.ForceParentEarly(playerCorpse);
						}
					}
				}
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			UnityEngine.Random.State state = UnityEngine.Random.state;
			UnityEngine.Random.InitState((int)(seed + steamid));
			float result = UnityEngine.Random.Range(0f, 1f);
			UnityEngine.Random.state = state;
			return result;
		}
	}

```

## OnTechTreeNodeUnlock(Workbench,TechTreeData.NodeInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player unlocks a node in the tech tree.
/// </summary>
/// <param name="workbench">The workbench associated with the tech tree.</param>
/// <param name="node">The tech tree node that has been unlocked.</param>
/// <param name="player">The player who unlocked the node.</param>
/// <returns>
/// Returns `null` to allow the default unlocking behavior, or a non-null value to prevent the unlock. (object)
/// </returns>
object OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
{
    Puts($"Player {player} has unlocked tech tree node: {node.id} at workbench: {workbench}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if (techTreeForLevel == null)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log("Node for unlock not found :" + id);
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && byID2.itemDef != null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log("Player unlocked group :" + byID.groupName);
			}
			else if (byID.itemDef != null && Interface.CallHook("OnTechTreeNodeUnlock", this, byID, player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", this, byID, player);
					Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

```

## OnBedMade(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is made by a player.
/// </summary>
/// <param name="bag">The sleeping bag that has been made.</param>
/// <param name="player">The player who made the sleeping bag.</param>
/// <returns>No return behavior.</returns>
void OnBedMade(SleepingBag bag, BasePlayer player)
{
    Puts($"Sleeping bag made by player {player} with ID {player.userID}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_MakeBed(RPCMessage msg)
	{
		if (!canBePublic || !IsPublic() || !msg.player.CanInteract())
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
			if (canAssignBedResult.HasValue)
			{
				if (canAssignBedResult.Value.Result != 0)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, cannotMakeBedPhrase, false);
				}
				else
				{
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num = deployerUserID;
		deployerUserID = msg.player.userID;
		NotifyPlayer(num);
		NotifyPlayer(deployerUserID);
		OnBagChangedOwnership(this, num);
		Interface.CallHook("OnBedMade", this, msg.player);
		SendNetworkUpdate();
	}

```

## OnEngineStart(MotorRowboat,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the engine of the motorized rowboat is requested to start.
/// </summary>
/// <param name="rowboat">The motorized rowboat attempting to start its engine.</param>
/// <param name="driver">The player attempting to start the engine.</param>
/// <returns>
/// Returns `null` to allow the engine to start, or any non-null value to prevent it from starting. (object)
/// </returns>
object OnEngineStart(MotorRowboat rowboat, BasePlayer driver)
{
    Puts($"Player {driver} is attempting to start the engine of the rowboat {rowboat}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.On, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
			if (wantsOn)
			{
				rigidBody.WakeUp();
				buoyancy.Wake();
			}
		}
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int,ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when a vending transaction occurs between a player and a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine involved in the transaction.</param>
/// <param name="buyer">The player attempting to make a purchase.</param>
/// <param name="sellOrderId">The ID of the sell order being processed.</param>
/// <param name="numberOfTransactions">The number of items the player wishes to purchase.</param>
/// <param name="targetContainer">The container where the purchased items will be placed.</param>
/// <returns>
/// Returns `true` if the transaction is successful; otherwise, returns `false`. 
/// If the method returns a non-null value, it overrides the default transaction behavior. (bool)
/// </returns>
object OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer)
{
    Puts($"Player {buyer} is attempting to make a transaction with vending machine {vendingMachine} for order ID {sellOrderId}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions, targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> obj2 = Facepunch.Pool.Get<List<Item>>();
		GetItemsToSell(sellOrder, obj2);
		if (obj2 == null || obj2.Count == 0)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = obj2.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		List<Item> source = buyer.inventory.FindItemsByItemID(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = (from x in source
			where !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)
			where x.GetItemVolume() <= maxCurrencyVolume
			select x).ToList();
		if (source.Count == 0)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;
		if (num3 < num4)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			TakeCurrencyItem(item);
			onCurrencyRemoved?.Invoke(buyer, item);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		Facepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, num4, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);
		int num7 = 0;
		foreach (Item item4 in obj2)
		{
			int num8 = num - num7;
			Item item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);
			if (item2 == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item2.amount;
				object obj3 = Interface.CallHook("CanPurchaseItem", buyer, item2, onItemPurchased, this, targetContainer);
				if (obj3 != null)
				{
					if (!(obj3 is bool))
					{
						return false;
					}
					return (bool)obj3;
				}
				RecordSaleAnalytics(item2, sellOrderId);
				if (targetContainer == null)
				{
					GiveSoldItem(item2, buyer);
				}
				else if (!item2.MoveToContainer(targetContainer))
				{
					item2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
				}
				onItemPurchased?.Invoke(buyer, item2);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj2);
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## OnClientCommand(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client sends a command to the server.
/// </summary>
/// <param name="connection">The network connection of the client sending the command.</param>
/// <param name="command">The command string sent by the client.</param>
/// <returns>
/// Returns `null` to allow the command to be processed normally, or a non-null value to prevent further processing. (object)
/// </returns>
object OnClientCommand(Network.Connection connection, string command)
{
    Puts($"Received command from client {connection}: {command}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal static void OnClientCommand(Message packet)
	{
		if (packet.read.Unread > ConVar.Server.maxpacketsize_command)
		{
			UnityEngine.Debug.LogWarning("Dropping client command due to size");
			return;
		}
		timer.Restart();
		string text = packet.read.StringRaw();
		if (packet.connection == null || !packet.connection.connected)
		{
			UnityEngine.Debug.LogWarning("Client without connection tried to run command: " + text);
		}
		else if (Interface.CallHook("OnClientCommand", packet.connection, text) == null)
		{
			string text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text);
			if (!string.IsNullOrEmpty(text2))
			{
				SendClientReply(packet.connection, text2);
			}
			if (timer.Elapsed > RuntimeProfiler.ConsoleCommandWarningThreshold)
			{
				LagSpikeProfiler.ConsoleCommand(timer.Elapsed, packet, text);
			}
		}
	}

```

## OnResearchCostDetermine(ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine the scrap cost required for researching an item.
/// </summary>
/// <param name="itemDefinition">The item definition for which the research cost is being determined.</param>
/// <returns>
/// Returns the scrap cost for researching the item. If the hook returns a non-null integer, that value will be used; otherwise, a default cost based on item rarity will be calculated. (int)
/// </returns>
object OnResearchCostDetermine(ItemDefinition itemDefinition)
{
    Puts($"Determining research cost for item: {itemDefinition}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static int ScrapForResearch(ItemDefinition info)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", info);
		if (obj is int)
		{
			return (int)obj;
		}
		if (info.isRedirectOf != null)
		{
			return ScrapForResearch(info.isRedirectOf);
		}
		int result = 0;
		if (info.rarity == Rarity.Common)
		{
			result = 20;
		}
		if (info.rarity == Rarity.Uncommon)
		{
			result = 75;
		}
		if (info.rarity == Rarity.Rare)
		{
			result = 125;
		}
		if (info.rarity == Rarity.VeryRare || info.rarity == Rarity.None)
		{
			result = 500;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(info);
		if (itemBlueprint != null && itemBlueprint.defaultBlueprint)
		{
			return ConVar.Server.defaultBlueprintResearchCost;
		}
		return result;
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player who is going to sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player} has started sleeping.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping())
		{
			Interface.CallHook("OnPlayerSleep", this);
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: false);
			}
			if (InSafeZone() && !IsInvoking(ScheduledDeath))
			{
				Invoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);
			}
			BaseMountable baseMountable = GetMounted();
			if (baseMountable != null && !AllowSleeperMounting(baseMountable))
			{
				EnsureDismounted();
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			sleepStartTime = UnityEngine.Time.time;
			sleepingPlayerList.TryAdd(this);
			bots.Remove(this);
			CancelInvoke(InventoryUpdate);
			CancelInvoke(TeamUpdate);
			CancelInvoke(UpdateClanLastSeen);
			inventory.loot.Clear();
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			EnablePlayerCollider();
			if (!IsLoadingAfterTransfer())
			{
				RemovePlayerRigidbody();
				TurnOffAllLights();
			}
			SetServerFall(wantsOn: true);
		}
	}

```

## OnXmasLootDistribute(XMasRefill)

```csharp
```csharp
/// <summary>
/// Called when distributing Christmas loot to players.
/// </summary>
/// <param name="refill">The XMasRefill object containing information about the loot distribution.</param>
/// <returns>
/// Returns `null` to proceed with the default loot distribution behavior. 
/// If a non-null value is returned, it will override the default behavior. (object)
/// </returns>
object OnXmasLootDistribute(XMasRefill refill)
{
    Puts($"Distributing Christmas loot with refill details: {refill}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerInit()
	{
		base.ServerInit();
		if (!XMas.enabled)
		{
			Invoke(RemoveMe, 0.1f);
			return;
		}
		goodKids = ((BasePlayer.activePlayerList != null) ? new List<BasePlayer>(BasePlayer.activePlayerList) : new List<BasePlayer>());
		stockings = ((Stocking.stockings != null) ? new List<Stocking>(Stocking.stockings.Values) : new List<Stocking>());
		Invoke(RemoveMe, 60f);
		if (Interface.CallHook("OnXmasLootDistribute", this) == null)
		{
			InvokeRepeating(DistributeLoot, 3f, 0.02f);
			Invoke(SendBells, 0.5f);
		}
	}

```

## OnItemStacked(Item,Item,ItemContainer,int)

```csharp
```csharp
/// <summary>
/// Called when items are stacked in a container.
/// </summary>
/// <param name="stackedItem">The item that is being stacked.</param>
/// <param name="sourceItem">The item that is being added to the stack.</param>
/// <param name="container">The container where the stacking is occurring.</param>
/// <param name="amount">The amount of the source item being stacked.</param>
/// <returns>No return behavior.</returns>
void OnItemStacked(Item stackedItem, Item sourceItem, ItemContainer container, int amount)
{
    Puts($"Stacking {amount} of {sourceItem} into {stackedItem} in container {container}.");
}
```
```

### Source Code from the Library

```csharp

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		using (TimeWarning.New("MoveToContainer"))
		{
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					foreach (Item item3 in from x in newcontainer.FindItemsByItemID(info.itemid)
						orderby x.position
						select x)
					{
						if (item3.CanStack(this) && (ignoreStackLimit || item3.amount < item3.MaxStackable()))
						{
							iTargetPos = item3.position;
						}
					}
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", slot2, this, newcontainer, num2);
						MarkDirty();
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", item2, this, newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
	}

```

## OnCargoShipHarborArrived(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when the cargo ship arrives at the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that has arrived at the harbor.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipHarborArrived(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip} has arrived at the harbor.");
}
```
```

### Source Code from the Library

```csharp

	public void OnArrivedAtHarbor()
	{
		SetFlag(Flags.Reserved1, b: true);
		List<Transform> obj = Pool.Get<List<Transform>>();
		float num = UnityEngine.Random.Range(dock_time * 0.05f, dock_time * 0.1f);
		foreach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)
		{
			if (allCrane == null || allCrane.isClient || allCrane.Distance2D(this) > 150f)
			{
				continue;
			}
			obj.Clear();
			CargoShipContainerDestination[] array = containerDestinations;
			foreach (CargoShipContainerDestination cargoShipContainerDestination in array)
			{
				if (allCrane.IsDestinationValidForCrane(cargoShipContainerDestination))
				{
					obj.Add(cargoShipContainerDestination.transform);
				}
			}
			if (obj.Count > 0)
			{
				allCrane.AssignDestination(obj, this, num);
				num += dock_time * UnityEngine.Random.Range(0.1f, 0.15f);
			}
		}
		Pool.FreeUnmanaged(ref obj);
		Invoke(PreHarborLeaveHorn, dock_time - 60f);
		if (refresh_loot_on_dock)
		{
			RespawnLoot();
		}
		if (harborIndex == 0)
		{
			SetFlag(Flags.Reserved3, b: true);
		}
		else if (harborIndex == 1)
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		Invoke(LeaveHarbor, dock_time);
		Interface.CallHook("OnCargoShipHarborArrived", this);
	}

```

## OnPhoneAnswered(PhoneController,PhoneController)

```csharp
```csharp
/// <summary>
/// Called when a phone call is answered by a player.
/// </summary>
/// <param name="caller">The phone controller that initiated the call.</param>
/// <param name="receiver">The phone controller that answered the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneAnswered(PhoneController caller, PhoneController receiver)
{
    Puts($"Phone answered: Caller {caller}, Receiver {receiver}.");
}
```
```

### Source Code from the Library

```csharp

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (IsInvoking(TimeOutDialing))
		{
			CancelInvoke(TimeOutDialing);
		}
		if (!(activeCallTo == null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", this, activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", this, activeCallTo);
			}
		}
	}

```

## IOnRconInitialize()

```csharp
```csharp
/// <summary>
/// Called to initialize the RCON (Remote Console) system.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRconInitialize()
{
    Puts("Initializing RCON system...");
}
```
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", ""));
		if (Password == "password" || Password == "")
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)
			{
				Command item = JsonConvert.DeserializeObject<Command>(msg);
				item.Ip = ip;
				item.ConnectionId = id;
				Commands.Enqueue(item);
			};
			listenerNew.Start();
			UnityEngine.Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			UnityEngine.Debug.Log("RCon Started on " + Port);
			UnityEngine.Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## CanUseHBHFSensor(BasePlayer,HBHFSensor)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use the HBHF sensor.
/// </summary>
/// <param name="player">The player attempting to use the sensor.</param>
/// <param name="sensor">The HBHF sensor being used.</param>
/// <returns>
/// Returns `true` if the player can use the sensor; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can use the sensor. (bool)
/// </returns>
object CanUseHBHFSensor(BasePlayer player, HBHFSensor sensor)
{
    Puts($"Player {player} is attempting to use the HBHF sensor: {sensor}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUse(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseHBHFSensor", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnTeamCreate(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to create a team.
/// </summary>
/// <param name="player">The player who is trying to create a team.</param>
/// <returns>
/// Returns `null` to allow the team creation, or any non-null value to prevent it. (object)
/// </returns>
object OnTeamCreate(BasePlayer player)
{
    Puts($"Player {player} is attempting to create a team.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Facepunch.Rust.Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a rocket is launched by a player.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="rocket">The entity representing the launched rocket.</param>
/// <returns>
/// Returns a non-null value to override the default launch behavior, or `null` to allow the launch to proceed as normal. (object)
/// </returns>
object OnRocketLaunched(BasePlayer player, BaseEntity rocket)
{
    Puts($"Player {player} has launched a rocket: {rocket}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (!base.UsingInfiniteAmmoCheat)
		{
			if (primaryMagazine.contents <= 0)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "magazine_empty");
				return;
			}
			ModifyAmmoCount(-1);
		}
		SignalBroadcast(Signal.Attack, string.Empty, player.net.connection);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		bool num = msg.read.Bit();
		BaseEntity mounted = player.GetParentEntity();
		if (mounted == null)
		{
			mounted = player.GetMounted();
		}
		if (num)
		{
			if (mounted != null)
			{
				vector = mounted.transform.TransformPoint(vector);
				vector2 = mounted.transform.TransformDirection(vector2);
			}
			else
			{
				vector = player.eyes.position;
				vector2 = player.eyes.BodyForward();
			}
		}
		if (!ValidateEyePos(player, vector))
		{
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		float num2 = GetAimCone() + component.projectileSpread;
		if (num2 > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);
		}
		float num3 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1237003025))
		{
			num3 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num3);
		if (baseEntity == null)
		{
			return;
		}
		baseEntity.creatorEntity = player;
		ServerProjectile component2 = baseEntity.GetComponent<ServerProjectile>();
		if ((bool)component2)
		{
			component2.InitializeVelocity(GetInheritedVelocity(player, vector2) + vector2 * component2.speed * initialSpeedMultiplier);
		}
		baseEntity.Spawn();
		ProjectileLaunched_Server(component2);
		Facepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity, this);
		Interface.CallHook("OnRocketLaunched", player, baseEntity);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			if (!base.UsingInfiniteAmmoCheat)
			{
				ownerItem.LoseCondition(UnityEngine.Random.Range(1f, 2f));
			}
			BaseMountable mounted2 = player.GetMounted();
			if (mounted2 != null)
			{
				mounted2.OnWeaponFired(this);
			}
		}
	}

```

## OnPlayerKicked(BasePlayer,string,bool)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="player">The player who has been kicked.</param>
/// <param name="reason">The reason for the kick.</param>
/// <param name="reserveSlot">Indicates whether a slot should be reserved for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason, bool reserveSlot)
{
    Puts($"Player {player} has been kicked. Reason: {reason}. Reserve slot: {reserveSlot}");
}
```
```

### Source Code from the Library

```csharp

	public void Kick(string reason, bool reserveSlot = true)
	{
		if (IsConnected)
		{
			net.connection.canReserveSlot = reserveSlot;
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason, reserveSlot);
		}
	}

```

## OnDigitalClockRing(DigitalClock)

```csharp
```csharp
/// <summary>
/// Called when the digital clock rings.
/// </summary>
/// <param name="clock">The digital clock that is ringing.</param>
/// <returns>No return behavior.</returns>
void OnDigitalClockRing(DigitalClock clock)
{
    Puts($"Digital clock {clock} is ringing.");
}
```
```

### Source Code from the Library

```csharp

	private void Ring()
	{
		if (Interface.CallHook("OnDigitalClockRing", this) == null)
		{
			isRinging = true;
			ClientRPC(RpcTarget.NetworkGroup("RPC_StartRinging"));
			Invoke(StopRinging, 5f);
			MarkDirty();
		}
	}

```

## OnHorseHitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when attempting to hitch a horse to a hitching spot.
/// </summary>
/// <param name="horse">The horse that is being hitched.</param>
/// <param name="hitch">The hitching spot to which the horse is being hitched.</param>
/// <returns>
/// Returns `true` if the horse was successfully hitched, or `false` if the hitching failed.
/// If the method returns `null`, the default hitching logic will be applied. (bool)
/// </returns>
object OnHorseHitch(RidableHorse horse, HitchSpot hitch)
{
    Puts($"Attempting to hitch horse {horse} to hitch spot {hitch}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch = null)
	{
		if (horse == null)
		{
			return false;
		}
		if (hitch == null)
		{
			hitch = GetClosest(horse.transform.position);
		}
		if (hitch != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", horse, hitch);
			if (obj is bool)
			{
				return (bool)obj;
			}
			hitch.SetOccupiedBy(horse);
			horse.SetHitch(this);
			horse.transform.SetPositionAndRotation(hitch.spot.position, hitch.spot.rotation);
			horse.DismountAllPlayers();
			return true;
		}
		return false;
	}

```

## OnCoalingTowerGather(CoalingTower,Item)

```csharp
```csharp
/// <summary>
/// Called when gathering items from a coaling tower.
/// </summary>
/// <param name="tower">The coaling tower from which items are being gathered.</param>
/// <param name="item">The item being gathered from the coaling tower.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being gathered, or `null` to allow the gathering process to continue. (object)
/// </returns>
object OnCoalingTowerGather(CoalingTower tower, Item item)
{
    Puts($"Gathering item {item} from Coaling Tower {tower}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void EmptyTenPercent()
	{
		if (!IsPowered())
		{
			EndEmptyProcess(ActionAttemptStatus.GenericError);
			return;
		}
		if (!HasUnloadableLinedUp)
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if (tcUnloadingNow == null || activeUnloadable != tcUnloadingNow)
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		StorageContainer storageContainer = tcUnloadingNow.GetStorageContainer();
		if (storageContainer.inventory == null || !TrainWagonLootData.instance.TryGetLootFromIndex(LootTypeIndex, out var lootOption))
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		bool flag = tcUnloadingNow.wagonType != TrainCarUnloadable.WagonType.Fuel;
		ItemContainer itemContainer = null;
		PercentFullStorageContainer percentFullStorageContainer = (flag ? GetOreStorage() : GetFuelStorage());
		if (percentFullStorageContainer != null)
		{
			itemContainer = percentFullStorageContainer.inventory;
		}
		if (itemContainer == null)
		{
			EndEmptyProcess(ActionAttemptStatus.GenericError);
			return;
		}
		ItemContainer inventory = storageContainer.inventory;
		ItemContainer newcontainer = itemContainer;
		int iAmount = Mathf.RoundToInt((float)lootOption.maxLootAmount / 10f);
		List<Item> obj = Facepunch.Pool.Get<List<Item>>();
		int num = inventory.Take(obj, lootOption.lootItem.itemid, iAmount);
		bool flag2 = true;
		if (num > 0)
		{
			foreach (Item item in obj)
			{
				if (tcUnloadingNow.wagonType == TrainCarUnloadable.WagonType.Lootboxes)
				{
					item.Remove();
					continue;
				}
				if (Interface.CallHook("OnCoalingTowerGather", this, item) != null)
				{
					item.Remove();
					continue;
				}
				bool flag3 = item.MoveToContainer(newcontainer);
				if (!flag2 || flag3)
				{
					continue;
				}
				item.MoveToContainer(inventory);
				flag2 = false;
				break;
			}
		}
		Facepunch.Pool.Free(ref obj, freeElements: false);
		float orePercent = tcUnloadingNow.GetOrePercent();
		if (orePercent == 0f)
		{
			EndEmptyProcess(ActionAttemptStatus.NoError);
		}
		else if (!flag2)
		{
			EndEmptyProcess(ActionAttemptStatus.OutputIsFull);
		}
		else if (flag)
		{
			tcUnloadingNow.SetVisualOreLevel(orePercent);
		}
	}

```

## OnBookmarkControl(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to control a remote entity via a bookmark.
/// </summary>
/// <param name="station">The computer station being used to control the bookmark.</param>
/// <param name="player">The player attempting to control the remote entity.</param>
/// <param name="bookmarkId">The identifier of the bookmark being controlled.</param>
/// <param name="remoteEntity">The remote controllable entity associated with the bookmark.</param>
/// <returns>
/// Returns `null` to allow the control action, or a non-null value to prevent it. (object)
/// </returns>
object OnBookmarkControl(ComputerStation station, BasePlayer player, string bookmarkId, IRemoteControllable remoteEntity)
{
    Puts($"Player {player} is attempting to control bookmark {bookmarkId} on station {station}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## OnCollectiblePickedup(CollectibleEntity,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a collectible item is picked up by a player.
/// </summary>
/// <param name="collectible">The collectible entity that was picked up.</param>
/// <param name="player">The player who picked up the collectible.</param>
/// <param name="item">The item that was collected.</param>
/// <returns>No return behavior.</returns>
void OnCollectiblePickedup(CollectibleEntity collectible, BasePlayer player, Item item)
{
    Puts($"Player {player} picked up collectible: {collectible} with item: {item}.");
}
```
```

### Source Code from the Library

```csharp

	public void DoPickup(BasePlayer reciever, bool eat = false)
	{
		if (itemList == null || Interface.CallHook("OnCollectiblePickup", this, reciever, eat) != null)
		{
			return;
		}
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			if (reciever != null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)
			{
				continue;
			}
			Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
			if (item == null)
			{
				continue;
			}
			if (eat && item.info.category == ItemCategory.Food && reciever != null)
			{
				ItemModConsume component = item.info.GetComponent<ItemModConsume>();
				if (component != null)
				{
					component.DoAction(item, reciever);
					continue;
				}
			}
			if ((bool)reciever)
			{
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);
				Interface.CallHook("OnCollectiblePickedup", this, reciever, item);
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
		}
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(reciever, base.transform.position);
		}
		Kill();
	}

```

## CanAssignBed(BasePlayer,SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can assign a sleeping bag to another player.
/// </summary>
/// <param name="player">The player attempting to assign the sleeping bag.</param>
/// <param name="sleepingBag">The sleeping bag being assigned.</param>
/// <param name="targetUserId">The user ID of the player to whom the sleeping bag is being assigned.</param>
/// <returns>
/// Returns `true` if the player can assign the sleeping bag, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the assignment is allowed. (bool)
/// </returns>
object CanAssignBed(BasePlayer player, SleepingBag sleepingBag, ulong targetUserId)
{
    Puts($"Player {player} is attempting to assign sleeping bag {sleepingBag} to user ID {targetUserId}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AssignToFriend(RPCMessage msg)
	{
		if (!msg.player.CanInteract() || deployerUserID != (ulong)msg.player.userID)
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num == 0L || Interface.CallHook("CanAssignBed", msg.player, this, num) != null)
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, num);
			if (canAssignBedResult.HasValue)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(num);
				if (canAssignBedResult.Value.Result == BagResultType.TooManyBags)
				{
					if (basePlayer == null)
					{
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedNoPlayerPhrase, false);
					}
					else
					{
						string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedPhrase, false, playerNameStreamSafe);
					}
				}
				else if (canAssignBedResult.Value.Result == BagResultType.BagBlocked)
				{
					msg.player.ShowToast(GameTip.Styles.Error, bedAssigningBlocked, false);
				}
				else if (canAssignBedResult.Value.Result == BagResultType.TargetIsPlayingTutorial)
				{
					msg.player.ShowToast(GameTip.Styles.Error, tutorialPhrase, false);
				}
				else
				{
					basePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, (GetSleepingBagCount(msg.player.userID) - 1).ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num2 = deployerUserID;
		deployerUserID = num;
		NotifyPlayer(num2);
		NotifyPlayer(deployerUserID);
		OnBagChangedOwnership(this, num2);
		Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);
		SendNetworkUpdate();
	}

```

## CanSwapToSeat(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Determines whether a player can swap to a seat on the mountable entity.
/// </summary>
/// <param name="player">The player attempting to swap to the seat.</param>
/// <param name="mountable">The mountable entity that contains the seat.</param>
/// <returns>
/// Returns `true` if the player can swap to the seat; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the player can swap. (bool)
/// </returns>
object CanSwapToSeat(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player} is attempting to swap to seat on {mountable}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnEntityDestroy(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC entity is destroyed.
/// </summary>
/// <param name="apc">The Bradley APC that is being destroyed.</param>
/// <returns>
/// Returns `null` to allow the default destruction behavior, or a non-null value to override it. (object)
/// </returns>
object OnEntityDestroy(BradleyAPC apc)
{
    Puts($"Bradley APC {apc} is being destroyed.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (base.isClient || Interface.CallHook("OnEntityDestroy", this) != null)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);
		Vector3 zero = Vector3.zero;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);
		for (int i = 0; i < 12 - maxCratesToSpawn; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);
			if (!baseEntity)
			{
				continue;
			}
			float minInclusive = 3f;
			float maxInclusive = 10f;
			Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
			baseEntity.transform.position = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * UnityEngine.Random.Range(-4f, 4f);
			Collider component = baseEntity.GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(zero + onUnitSphere * UnityEngine.Random.Range(minInclusive, maxInclusive));
			foreach (ServerGib item in list)
			{
				UnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;
			onUnitSphere2.y = 0f;
			onUnitSphere2.Normalize();
			Vector3 pos = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if ((bool)lootContainer)
			{
				lootContainer.Invoke(lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = baseEntity2.GetComponent<Collider>();
			Rigidbody rigidbody = baseEntity2.gameObject.AddComponent<Rigidbody>();
			rigidbody.useGravity = true;
			rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
			rigidbody.mass = 2f;
			rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
			rigidbody.velocity = zero + onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);
			rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
			rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if ((bool)fireBall)
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				fireBall.GetComponent<Rigidbody>().isKinematic = true;
				fireBall.GetComponent<Collider>().enabled = false;
			}
			baseEntity2.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);
			foreach (ServerGib item2 in list)
			{
				UnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);
			}
		}
		KillSpawnedScientists();
		if (info != null && info.InitiatorPlayer != null && info.InitiatorPlayer.serverClan != null)
		{
			info.InitiatorPlayer.AddClanScore(ClanScoreEventType.DestroyedBradley);
		}
		base.OnKilled(info);
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be accepted into the specified item container at a given position.
/// </summary>
/// <param name="container">The item container that is being checked.</param>
/// <param name="item">The item to be accepted.</param>
/// <param name="targetPos">The target position within the container where the item is to be placed.</param>
/// <returns>
/// Returns <c>CanAcceptResult.CanAccept</c> if the item can be accepted, 
/// <c>CanAcceptResult.CannotAccept</c> if it cannot, 
/// or <c>CanAcceptResult.CannotAcceptRightNow</c> if it cannot be accepted at this moment. (CanAcceptResult)
/// </returns>
CanAcceptResult CanAcceptItem(ItemContainer container, Item item, int targetPos)
{
    Puts($"Checking if item {item} can be accepted in container at position {targetPos}.");
    return CanAcceptResult.CanAccept; // Default return value for demonstration
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (isServer && availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			if (item.isBroken)
			{
				return CanAcceptResult.CannotAccept;
			}
			int num = 0;
			foreach (ItemSlot availableSlot in availableSlots)
			{
				num |= (int)availableSlot;
			}
			if (((uint)num & (uint)item.info.occupySlots) != (uint)item.info.occupySlots)
			{
				return CanAcceptResult.CannotAcceptRightNow;
			}
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (HasLimitedAllowedItems)
		{
			bool flag = false;
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if (onlyAllowedItems[i] == item.info)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return CanAcceptResult.CannotAccept;
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		if (blockedItems != null && blockedItems.Contains(item.info))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (item.GetItemVolume() > containerVolume)
		{
			return CanAcceptResult.CannotAccept;
		}
		return CanAcceptResult.CanAccept;
	}

```

## OnItemSplit(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is split into two parts.
/// </summary>
/// <param name="item">The item being split.</param>
/// <param name="splitAmount">The amount to split from the original item.</param>
/// <returns>
/// Returns the new item created from the split if successful; otherwise, returns `null`. 
/// If the hook returns an item, that item will be returned instead. (Item)
/// </returns>
object OnItemSplit(Item item, int splitAmount)
{
    Puts($"Item {item} is being split into {splitAmount}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		item.skin = skin;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		if (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
		}
		if (instanceData != null && instanceData.dataInt > 0 && info != null && info.Blueprint != null && info.Blueprint.workbenchLevelRequired == 3)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
			item.SetFlag(Flag.IsOn, IsOn());
		}
		MarkDirty();
		return item;
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is upgraded successfully.
/// </summary>
/// <param name="originalItem">The original item that is being upgraded.</param>
/// <param name="upgradedItem">The new item that has been created as a result of the upgrade.</param>
/// <param name="player">The player who initiated the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnItemUpgrade(Item originalItem, Item upgradedItem, BasePlayer player)
{
    Puts($"Item upgraded from {originalItem} to {upgradedItem} by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (UnityEngine.Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnHelicopterDropDoorOpen(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the drop door of the helicopter is opened or closed.
/// </summary>
/// <param name="helicopter">The helicopter whose drop door state is being changed.</param>
/// <returns>
/// Returns `null` to allow the door to open or close; any non-null value will prevent the action. (object)
/// </returns>
object OnHelicopterDropDoorOpen(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter} drop door state changed.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting a storage container.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="container">The storage container that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player} has stopped looting container {container}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnExperimentStarted(Workbench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an experiment is started at a workbench by a player.
/// </summary>
/// <param name="workbench">The workbench where the experiment is initiated.</param>
/// <param name="player">The player who started the experiment.</param>
/// <returns>No return behavior.</returns>
void OnExperimentStarted(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment started at workbench {workbench} by player {player}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## OnItemCraft(IndustrialCrafter,ItemBlueprint)

```csharp
```csharp
/// <summary>
/// Called when an item crafting process is initiated in the industrial crafter.
/// </summary>
/// <param name="crafter">The industrial crafter that is performing the crafting.</param>
/// <param name="blueprint">The blueprint of the item being crafted.</param>
/// <returns>
/// Returns a non-null value to prevent the crafting process from starting. If null is returned, the crafting proceeds as normal. (object)
/// </returns>
object OnItemCraft(IndustrialCrafter crafter, ItemBlueprint blueprint)
{
    Puts($"Crafting initiated for blueprint: {blueprint} in crafter: {crafter}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected override void RunJob()
	{
		base.RunJob();
		if (ConVar.Server.industrialCrafterFrequency <= 0f || HasFlag(Flags.Reserved1) || currentlyCrafting != null)
		{
			return;
		}
		for (int i = 0; i <= 3; i++)
		{
			Item targetBlueprint = GetTargetBlueprint(i);
			if (targetBlueprint == null || GetWorkbench() == null || GetWorkbench().Workbenchlevel < targetBlueprint.blueprintTargetDef.Blueprint.workbenchLevelRequired)
			{
				continue;
			}
			ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;
			if (Interface.CallHook("OnItemCraft", this, blueprint) != null)
			{
				break;
			}
			bool flag = true;
			foreach (ItemAmount ingredient in blueprint.ingredients)
			{
				if ((float)GetInputAmount(ingredient.itemDef) < ingredient.amount)
				{
					flag = false;
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			flag = false;
			for (int j = 8; j <= 11; j++)
			{
				Item slot = _inventory.GetSlot(j);
				if (slot == null || (slot.info == targetBlueprint.blueprintTargetDef && slot.amount + blueprint.amountToCreate <= slot.MaxStackable()))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				SetFlag(Flags.Reserved2, b: true);
				continue;
			}
			SetFlag(Flags.Reserved2, b: false);
			foreach (ItemAmount ingredient2 in blueprint.ingredients)
			{
				ConsumeInputIngredient(ingredient2);
			}
			currentlyCrafting = targetBlueprint.blueprintTargetDef;
			currentlyCraftingAmount = blueprint.amountToCreate;
			float time = blueprint.time;
			Invoke(CompleteCraft, time);
			jobFinishes = time;
			SetFlag(Flags.Reserved1, b: true);
			ClientRPC(RpcTarget.NetworkGroup("ClientUpdateCraftTimeRemaining"), (float)jobFinishes, jobFinishes.Duration);
			break;
		}
	}

```

## CanChangeCode(BasePlayer,CodeLock,string,bool)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the code on a code lock.
/// </summary>
/// <param name="player">The player attempting to change the code.</param>
/// <param name="codeLock">The code lock being modified.</param>
/// <param name="newCode">The new code to set.</param>
/// <param name="isGuestCode">Indicates if the new code is for guest access.</param>
/// <returns>
/// Returns `null` to allow the code change, or a non-null value to prevent it. (object)
/// </returns>
object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
{
    Puts($"Player {player} is attempting to change code on {codeLock} to {newCode}. Guest code: {isGuestCode}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (!IsLocked() && text.Length == 4 && text.IsNumeric() && !(!hasCode && flag) && Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!hasCode && !flag)
			{
				SetFlag(Flags.Locked, b: true);
			}
			Facepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			Interface.CallHook("OnCodeChanged", rpc.player, this, text, flag);
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when an auto turret is starting up.
/// </summary>
/// <param name="turret">The auto turret that is initiating startup.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally. 
/// If a non-null value is returned, the startup process will be prevented. (object)
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"Auto turret {turret} is starting up.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnEntityReskin(BaseEntity,ItemSkinDirectory.Skin,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is reskinned, allowing for custom behavior during the reskin process.
/// </summary>
/// <param name="entity">The entity being reskinned.</param>
/// <param name="skin">The new skin being applied to the entity.</param>
/// <param name="player">The player who initiated the reskin action.</param>
/// <returns>
/// Returns a non-null value to prevent the default reskin behavior; otherwise, returns null to allow the reskin to proceed. (object)
/// </returns>
object OnEntityReskin(BaseEntity entity, ItemSkinDirectory.Skin skin, BasePlayer player)
{
    Puts($"Entity {entity} is being reskinned with skin {skin} by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	private void ChangeItemSkin(RPCMessage msg)
	{
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))
		{
			return;
		}
		if (baseNetworkable != null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if ((object)baseEntity2 != null)
			{
				if (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))
				{
					FailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin((def.isRedirectOf != null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", baseEntity2, skin, msg.player) != null)
				{
					return;
				}
				if (skin.invItem != null && skin.invItem is ItemSkin itemSkin)
				{
					if (itemSkin.Redirect != null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if ((bool)def && def.isRedirectOf != null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if (def.isRedirectOf != null || ((bool)def && def.isRedirectOf != null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if (itemDefinition == null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2))
					{
						FailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning("Cannot find resource path of redirect entity to spawn! " + itemDefinition.gameObject.name);
						FailResponse(SprayFailReason.InvalidItem);
						return;
					}
					Vector3 localPosition = baseEntity2.transform.localPosition;
					Quaternion localRotation = baseEntity2.transform.localRotation;
					BaseEntity baseEntity3 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					HashSet<PlayerNameID> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> obj = Facepunch.Pool.Get<List<ChildPreserveInfo>>();
					if (flag)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							obj.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = child.transform.localPosition,
								LocalRotation = child.transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in obj)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity3);
					baseEntity2.transform.localPosition = localPosition;
					baseEntity2.transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity)
					{
						decayEntity.AttachToBuilding(null);
					}
					baseEntity2.Spawn();
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag)
						{
							for (int j = 0; j < baseEntity2.children.Count; j++)
							{
								RestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item2 in dictionary2)
						{
							foreach (Item item3 in item2.Value)
							{
								Debug.Log($"Deleting {item3} as it has no new container");
								item3.Remove();
							}
						}
						Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
					}
					if (flag)
					{
						foreach (ChildPreserveInfo item4 in obj)
						{
							item4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);
							item4.TargetEntity.transform.localPosition = item4.LocalPosition;
							item4.TargetEntity.transform.localRotation = item4.LocalRotation;
							item4.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Interface.CallHook("OnEntityReskinned", baseEntity2, skin, msg.player);
					Facepunch.Pool.FreeUnmanaged(ref obj);
				}
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		LoseCondition(ConditionLossPerReskin);
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		void FailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (copy.ContainsKey(key))
				{
					foreach (Item item5 in copy[key])
					{
						item5.MoveToContainer(itemContainerEntity.inventory);
					}
					copy.Remove(key);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (!dictionary.ContainsKey(key2))
				{
					dictionary.Add(key2, new List<Item>());
					foreach (Item item6 in itemContainerEntity2.inventory.itemList)
					{
						dictionary[key2].Add(item6);
					}
					{
						foreach (Item item7 in dictionary[key2])
						{
							item7.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log("Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
	}

```

## OnPlayerSpawn(BasePlayer,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a player spawns into the game.
/// </summary>
/// <param name="player">The player that is spawning.</param>
/// <param name="connection">The network connection of the player.</param>
/// <returns>
/// Returns a non-null value to prevent the player from spawning, or `null` to allow the spawn process to continue. (object)
/// </returns>
object OnPlayerSpawn(BasePlayer player, Network.Connection connection)
{
    Puts($"Player {player.displayName} is spawning with connection ID: {connection.userid}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public BasePlayer SpawnNewPlayer(Network.Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer, connection) != null)
		{
			return basePlayer;
		}
		basePlayer.health = 0f;
		basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
		basePlayer.ResetLifeStateOnSpawn = false;
		basePlayer.limitNetworking = true;
		if (connection == null)
		{
			basePlayer.EnableTransferProtection();
		}
		basePlayer.Spawn();
		basePlayer.limitNetworking = false;
		if (connection != null)
		{
			basePlayer.PlayerInit(connection);
			if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer);
			}
			else if (UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife))
			{
				basePlayer.Respawn();
			}
			DebugEx.Log($"{basePlayer.displayName} with steamid {basePlayer.userID.Get()} joined from ip {basePlayer.net.connection.ipaddress}");
			DebugEx.Log($"\tNetworkId {basePlayer.userID.Get()} is {basePlayer.net.ID} ({basePlayer.displayName})");
			if (basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
			{
				DebugEx.Log($"\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}");
			}
		}
		return basePlayer;
	}

```

## CanFastTrackCraftTask(ItemCrafter,ItemCraftTask,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a crafting task can be fast-tracked.
/// </summary>
/// <param name="crafter">The item crafter attempting to fast-track the task.</param>
/// <param name="task">The crafting task to be fast-tracked.</param>
/// <param name="taskID">The unique identifier of the crafting task.</param>
/// <returns>
/// Returns `true` if the task can be fast-tracked; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the task can be fast-tracked. (bool)
/// </returns>
object CanFastTrackCraftTask(ItemCrafter crafter, ItemCraftTask task, int taskID)
{
    Puts($"Checking if task {taskID} can be fast-tracked for crafter: {crafter}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool FastTrackTask(int taskID)
	{
		int taskID2 = taskID;
		if (queue.Count == 0)
		{
			return false;
		}
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask value = queue.First.Value;
		if (value == null)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == taskID2 && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		if (itemCraftTask == value)
		{
			return false;
		}
		object obj = Interface.CallHook("CanFastTrackCraftTask", this, itemCraftTask, taskID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		value.endTime = 0f;
		queue.Remove(itemCraftTask);
		queue.AddFirst(itemCraftTask);
		owner.Command("note.craft_fasttracked", taskID2);
		return true;
	}

```

## CanRenameBed(BasePlayer,SleepingBag,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can rename a sleeping bag.
/// </summary>
/// <param name="player">The player attempting to rename the sleeping bag.</param>
/// <param name="sleepingBag">The sleeping bag being renamed.</param>
/// <param name="newName">The new name for the sleeping bag.</param>
/// <returns>
/// Returns `true` if the player is allowed to rename the sleeping bag; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the renaming is allowed. (bool)
/// </returns>
object CanRenameBed(BasePlayer player, SleepingBag sleepingBag, string newName)
{
    Puts($"Player {player} is attempting to rename a sleeping bag to '{newName}'.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("CanRenameBed", msg.player, this, text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
			NotifyPlayer(deployerUserID);
		}
	}

```

## OnAirdrop(CargoPlane,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an airdrop is initiated, providing the drop position.
/// </summary>
/// <param name="cargoPlane">The cargo plane responsible for the airdrop.</param>
/// <param name="dropPosition">The position where the airdrop will occur.</param>
/// <returns>No return behavior.</returns>
void OnAirdrop(CargoPlane cargoPlane, Vector3 dropPosition)
{
    Puts($"Airdrop initiated from {cargoPlane} at position {dropPosition}.");
}
```
```

### Source Code from the Library

```csharp

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		startPos.Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);
		base.transform.position = startPos;
		base.transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", this, newDropPosition);
	}

```

## CanFireLiquidWeapon(BasePlayer,LiquidWeapon)

```csharp
```csharp
/// <summary>
/// Determines whether a player can fire a liquid weapon.
/// </summary>
/// <param name="player">The player attempting to fire the liquid weapon.</param>
/// <param name="liquidWeapon">The liquid weapon being fired.</param>
/// <returns>
/// Returns `true` if the player can fire the liquid weapon; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can fire the weapon. (bool)
/// </returns>
object CanFireLiquidWeapon(BasePlayer player, LiquidWeapon liquidWeapon)
{
    Puts($"Checking if player {player} can fire the liquid weapon {liquidWeapon}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanFire(BasePlayer player)
	{
		object obj = Interface.CallHook("CanFireLiquidWeapon", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequiresPumping && pressure < PressureLossPerTick)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		if (HasFlag(Flags.Open))
		{
			return false;
		}
		if (AmountHeld() <= 0)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (!player.CanAttack() || player.IsRunning())
		{
			return false;
		}
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return false;
		}
		return true;
	}

```

## OnNetworkGroupLeft(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network group is left by a networkable entity.
/// </summary>
/// <param name="networkable">The networkable entity that left the group.</param>
/// <param name="group">The network visibility group that was left.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupLeft(BaseNetworkable networkable, Network.Visibility.Group group)
{
    Puts($"Networkable {networkable} has left the group: {group}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", this, group);
	}

```

## OnBigWheelLoss(BigWheelGame,Item,BigWheelBettingTerminal)

```csharp
```csharp
/// <summary>
/// Called when a player loses a bet on the Big Wheel game.
/// </summary>
/// <param name="game">The Big Wheel game instance.</param>
/// <param name="item">The item that was lost in the bet.</param>
/// <param name="terminal">The betting terminal where the bet was placed.</param>
/// <returns>
/// Returns `null` to allow the default loss behavior, or a non-null value to override it. (object)
/// </returns>
object OnBigWheelLoss(BigWheelGame game, Item item, BigWheelBettingTerminal terminal)
{
    Puts($"Player lost item {item} at terminal {terminal} in Big Wheel game {game}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) == null)
				{
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanAssignMission(BasePlayer,BaseMission,IMissionProvider)

```csharp
```csharp
/// <summary>
/// Determines if a mission can be assigned to a player by a mission provider.
/// </summary>
/// <param name="assignee">The player to whom the mission is being assigned.</param>
/// <param name="mission">The mission that is being considered for assignment.</param>
/// <param name="provider">The provider offering the mission.</param>
/// <returns>
/// Returns `true` if the mission can be assigned, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the mission can be assigned. (bool)
/// </returns>
object CanAssignMission(BasePlayer assignee, BaseMission mission, IMissionProvider provider)
{
    Puts($"Checking if mission {mission.id} can be assigned to player {assignee} by provider {provider.ProviderID()}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", assignee, mission, provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = assignee.missions.FindIndexWith((MissionInstance i) => i.missionID, mission.id);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", mission, provider, assignee);
		return true;
	}

```

## CanLootEntity(BasePlayer,WorldItem)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity in the game world.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity that is being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can loot the entity. (bool)
/// </returns>
object CanLootEntity(BasePlayer player, WorldItem entity)
{
    Puts($"Player {player} is attempting to loot entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (item == null || item.contents == null)
		{
			return;
		}
		ItemModContainer component = item.info.GetComponent<ItemModContainer>();
		if (!(component == null) && component.canLootInWorld)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && CanOpenInSafeZone(player) && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(item.contents);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "generic_resizable");
				SendNetworkUpdate();
			}
		}
	}

```

## OnWeaponModChange(BaseProjectile,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the weapon modifications for a projectile weapon change.
/// </summary>
/// <param name="projectile">The projectile weapon whose modifications are changing.</param>
/// <param name="player">The player who owns the projectile weapon.</param>
/// <returns>
/// Returns a non-null value to prevent the default behavior of the weapon modification change. 
/// If `null` is returned, the weapon modification change proceeds as normal. (object)
/// </returns>
object OnWeaponModChange(BaseProjectile projectile, BasePlayer player)
{
    Puts($"Weapon modifications changed for {projectile} owned by {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DelayedModsChanged()
	{
		if (Interface.CallHook("OnWeaponModChange", this, GetOwnerPlayer()) != null)
		{
			return;
		}
		int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)primaryMagazine.definition.builtInSize);
		if (num == primaryMagazine.capacity)
		{
			return;
		}
		if (primaryMagazine.contents > 0 && primaryMagazine.contents > num)
		{
			_ = primaryMagazine.ammoType;
			int contents = primaryMagazine.contents;
			BasePlayer ownerPlayer = GetOwnerPlayer();
			ItemContainer itemContainer = null;
			if (ownerPlayer != null)
			{
				itemContainer = ownerPlayer.inventory.containerMain;
			}
			else if (GetCachedItem() != null)
			{
				itemContainer = GetCachedItem().parent;
			}
			SetAmmoCount(0);
			if (itemContainer != null)
			{
				Item item = ItemManager.Create(primaryMagazine.ammoType, contents, 0uL);
				if (!item.MoveToContainer(itemContainer))
				{
					Vector3 vPos = base.transform.position;
					if (itemContainer.entityOwner != null)
					{
						vPos = itemContainer.entityOwner.transform.position + Vector3.up * 0.25f;
					}
					item.Drop(vPos, Vector3.up * 5f);
				}
			}
		}
		primaryMagazine.capacity = num;
		SendNetworkUpdate();
	}

```

## OnVehicleModulesAssigned(ModularCar,Rust.Modular.ItemModVehicleModule[])

```csharp
```csharp
/// <summary>
/// Called when vehicle modules are assigned to a modular car.
/// </summary>
/// <param name="car">The modular car to which the modules are being assigned.</param>
/// <param name="modules">The array of vehicle modules being assigned.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModulesAssigned(ModularCar car, ItemModVehicleModule[] modules)
{
    Puts($"Vehicle modules assigned to car {car} with modules: {string.Join(", ", modules)}.");
}
```
```

### Source Code from the Library

```csharp

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", this, modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				Item item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);
				float num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", this, modularCarPresetConfig.socketItemDefs);
		Invoke(HandleAdminBonus, 0f);
	}

```

## OnRackedWeaponSwap(Item,WeaponRackSlot,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is swapped on a weapon rack.
/// </summary>
/// <param name="item">The item being swapped (the weapon).</param>
/// <param name="slot">The weapon rack slot where the weapon is being placed.</param>
/// <param name="player">The player performing the swap.</param>
/// <param name="rack">The weapon rack involved in the swap.</param>
/// <returns>
/// Returns `null` to allow the swap to proceed, or a non-null value to prevent the swap. (object)
/// </returns>
object OnRackedWeaponSwap(Item item, WeaponRackSlot slot, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player} is swapping weapon {item} in slot {slot} on rack {rack}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", item, weaponAtIndex, player, this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", item, weaponAtIndex, player, this);
			}
		}
	}

```

## OnTakeCurrencyItem(NPCVendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called when a currency item is taken from the NPC vending machine.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that is taking the currency item.</param>
/// <param name="currencyItem">The currency item being taken.</param>
/// <returns>No return behavior.</returns>
void OnTakeCurrencyItem(NPCVendingMachine vendingMachine, Item currencyItem)
{
    Puts($"Currency item {currencyItem} taken from vending machine {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	public override void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null)
		{
			takenCurrencyItem.MoveToContainer(base.inventory);
			takenCurrencyItem.RemoveFromContainer();
			takenCurrencyItem.Remove();
		}
	}

```

## OnItemAction(Item,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an action is performed on an item by a player.
/// </summary>
/// <param name="item">The item on which the action is performed.</param>
/// <param name="action">The action being performed on the item (e.g., "drop").</param>
/// <param name="player">The player performing the action.</param>
/// <returns>
/// Returns a non-null value to prevent the default action from occurring. If null is returned, the action proceeds as normal. (object)
/// </returns>
object OnItemAction(Item item, string action, BasePlayer player)
{
    Puts($"Player {player} performed action '{action}' on item {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server.FromOwner]
	[BaseEntity.RPC_Server]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		if ((msg.player != null && msg.player.IsWounded()) || base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		string text = msg.read.String();
		Item item = FindItemByUID(id);
		if (item == null || Interface.CallHook("OnItemAction", item, text, msg.player) != null)
		{
			return;
		}
		BaseEntity entityOwner = item.GetEntityOwner();
		if ((entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering) || item.IsLocked() || (item.parent != null && item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item))
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.Unread >= 4)
			{
				num = msg.read.Int32();
			}
			if (!msg.player.isMounted && !msg.player.HasParent() && !GamePhysics.LineOfSight(msg.player.transform.position, msg.player.eyes.position, 1218519041))
			{
				return;
			}
			base.baseEntity.stats.Add("item_drop", 1, (Stats)5);
			if (num < item.amount)
			{
				Item item2 = item.SplitItem(num);
				ItemContainer parent = item.parent;
				if (item2 != null)
				{
					DroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DropReason = DroppedItem.DropReasonEnum.Player;
						droppedItem.DroppedBy = base.baseEntity.userID;
						droppedItem.DroppedTime = DateTime.UtcNow;
						Facepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);
					}
				}
				parent?.onItemRemovedFromStack?.Invoke(item, num);
			}
			else
			{
				ItemContainer parent2 = item.parent;
				DroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;
				if (droppedItem2 != null)
				{
					droppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;
					droppedItem2.DroppedBy = base.baseEntity.userID;
					droppedItem2.DroppedTime = DateTime.UtcNow;
					Facepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);
				}
				parent2?.onItemAddedRemoved?.Invoke(item, arg2: false);
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnItemUnwrap(Item,BasePlayer,ItemModUnwrap)

```csharp
```csharp
/// <summary>
/// Called when an item is unwrapped by a player.
/// </summary>
/// <param name="item">The item being unwrapped.</param>
/// <param name="player">The player who is unwrapping the item.</param>
/// <param name="itemMod">The item modification associated with the unwrapping process.</param>
/// <returns>
/// Returns `null` to allow the unwrapping to proceed, or a non-null value to prevent it. (object)
/// </returns>
object OnItemUnwrap(Item item, BasePlayer player, ItemModUnwrap itemMod)
{
    Puts($"Player {player} is unwrapping item: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "unwrap" && item.amount > 0 && Interface.CallHook("OnItemUnwrap", item, player, this) == null)
		{
			item.UseItem();
			int num = UnityEngine.Random.Range(minTries, maxTries + 1);
			for (int i = 0; i < num; i++)
			{
				revealList.SpawnIntoContainer(player.inventory.containerMain);
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnItemDeployed(Deployer,ItemModDeployable,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is successfully deployed in the game world.
/// </summary>
/// <param name="deployer">The player who is deploying the item.</param>
/// <param name="itemMod">The deployable item mod being deployed.</param>
/// <param name="entity">The entity that has been created as a result of the deployment.</param>
/// <returns>No return behavior.</returns>
void OnItemDeployed(BasePlayer deployer, ItemModDeployable itemMod, BaseEntity entity)
{
    Puts($"Item {itemMod} deployed by player {deployer} at position {entity.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Regular(Deployable deployable, Ray ray)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
		}
		else if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.Antihack, false);
		}
		else
		{
			if (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))
			{
				return;
			}
			Vector3 point = hitInfo.point;
			Quaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);
			Item ownerItem = GetOwnerItem();
			ItemModDeployable modDeployable = GetModDeployable();
			if (ownerPlayer.Distance(point) > 3f)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);
				return;
			}
			if (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
				return;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);
			if (!baseEntity)
			{
				Debug.LogWarning("Couldn't create prefab:" + modDeployable.entityPrefab.resourcePath);
				return;
			}
			baseEntity.skinID = ownerItem.skin;
			baseEntity.SendMessage("SetDeployedBy", ownerPlayer, SendMessageOptions.DontRequireReceiver);
			baseEntity.OwnerID = ownerPlayer.userID;
			baseEntity.Spawn();
			modDeployable.OnDeployed(baseEntity, ownerPlayer);
			Interface.CallHook("OnItemDeployed", this, modDeployable, baseEntity);
			Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
			UseItemAmount(1);
		}
	}

```

## OnMissionStarted(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is started for a player.
/// </summary>
/// <param name="mission">The mission that is starting.</param>
/// <param name="instance">The instance of the mission being started.</param>
/// <param name="assignee">The player assigned to the mission.</param>
/// <returns>No return behavior.</returns>
void OnMissionStarted(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts($"Mission {mission} started for player {assignee}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", this, instance, assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", this, instance, assignee);
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a message is sent to a player.
/// </summary>
/// <param name="message">The message being sent to the player.</param>
/// <param name="player">The player receiving the message.</param>
/// <returns>
/// Returns a non-null value to prevent the message from being sent. If `null` is returned, the message is sent as normal. (object)
/// </returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Message to player {player}: {message}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 2, 0, msg);
		}
	}

```

## OnStashOcclude(StashContainer)

```csharp
```csharp
/// <summary>
/// Called to check if a stash container is occluded and should be affected accordingly.
/// </summary>
/// <param name="stash">The stash container that is being checked for occlusion.</param>
/// <returns>
/// Returns `null` to allow the default occlusion behavior. If a non-null value is returned, it overrides the default behavior. (object)
/// </returns>
object OnStashOcclude(StashContainer stash)
{
    Puts($"Checking occlusion for stash container: {stash}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoOccludedCheck()
	{
		if (UnityEngine.Physics.SphereCast(new Ray(base.transform.position + Vector3.up * 5f, Vector3.down), 0.25f, 5f, 2097152) && Interface.CallHook("OnStashOcclude", this) == null)
		{
			DropItems();
			Kill();
		}
	}

```

## OnFireBallSpread(FireBall,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a fireball attempts to spread to create a new fireball entity.
/// </summary>
/// <param name="fireball">The fireball that is spreading.</param>
/// <param name="entity">The new entity that is being created as a result of the spread.</param>
/// <returns>No return behavior.</returns>
void OnFireBallSpread(FireBall fireball, BaseEntity entity)
{
    Puts($"Fireball {fireball} is spreading to create a new entity: {entity}.");
}
```
```

### Source Code from the Library

```csharp

	public void TryToSpread()
	{
		float num = 0.9f - generation * 0.1f;
		if (UnityEngine.Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", this, baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));
				baseEntity.SendMessage("SetGeneration", generation + 1f);
			}
		}
	}

```

## OnRackedWeaponLoaded(Item,ItemDefinition,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is loaded onto a weapon rack.
/// </summary>
/// <param name="item">The item representing the weapon being loaded.</param>
/// <param name="itemDefinition">The definition of the ammo being loaded into the weapon.</param>
/// <param name="player">The player who is loading the weapon.</param>
/// <param name="weaponRack">The weapon rack where the weapon is being loaded.</param>
/// <returns>
/// Returns a non-null value to prevent the weapon from being loaded; otherwise, returns null to allow the action. (object)
/// </returns>
object OnRackedWeaponLoaded(Item item, ItemDefinition itemDefinition, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Player {player} is loading {item} with ammo {itemDefinition} onto {weaponRack}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!player)
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (heldEntity == null)
		{
			return;
		}
		BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
		if (component == null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null || Interface.CallHook("OnRackedWeaponLoad", slot, itemDefinition, player, this) != null)
		{
			return;
		}
		if (itemDefinition == SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!(itemDefinition != null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component2 = itemDefinition.GetComponent<ItemModProjectile>();
		if (!(component2 == null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", slot, itemDefinition, player, this);
		}
	}

```

## OnBoomboxStationValidate(string)

```csharp
```csharp
/// <summary>
/// Called to validate a boombox station URL.
/// </summary>
/// <param name="url">The URL of the boombox station to validate.</param>
/// <returns>
/// Returns `true` if the station is valid, or `false` if it is not. 
/// If the method returns `null`, the default validation logic will be used. (bool)
/// </returns>
object OnBoomboxStationValidate(string url)
{
    Puts($"Validating boombox station URL: {url}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool IsStationValid(string url)
	{
		ParseServerUrlList();
		object obj = Interface.CallHook("OnBoomboxStationValidate", url);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ValidStations == null || !ValidStations.ContainsValue(url))
		{
			if (ServerValidStations != null)
			{
				return ServerValidStations.ContainsValue(url);
			}
			return false;
		}
		return true;
	}

```

## OnPortalUse(BasePlayer,BasePortal)

```csharp
```csharp
/// <summary>
/// Called when a player uses a portal to teleport to another location.
/// </summary>
/// <param name="player">The player using the portal.</param>
/// <param name="portal">The portal being used.</param>
/// <returns>
/// Returns a non-null value to prevent the default portal usage behavior. If null is returned, the portal will function as intended. (object)
/// </returns>
object OnPortalUse(BasePlayer player, BasePortal portal)
{
    Puts($"Player {player} is attempting to use portal {portal}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void UsePortal(BasePlayer player)
	{
		if (Interface.CallHook("OnPortalUse", player, this) != null)
		{
			return;
		}
		LinkPortal();
		if (targetPortal != null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			Vector3 position = player.transform.position;
			Vector3 vector = targetPortal.GetLocalEntryExitPosition();
			Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 vector3 = vector2;
			if (isMirrored)
			{
				Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);
				vector = targetPortal.relativeAnchor.transform.TransformPoint(position2);
				vector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);
			}
			else
			{
				vector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, vector, Vector3.up);
			}
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(vector);
			player.ForceUpdateTriggers();
			player.ClientRPC(RpcTarget.Player("ForceViewAnglesTo", player), vector3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			player.ClientRPC(RpcTarget.Player("StartLoading_Quick", player), arg1: true);
			Interface.CallHook("OnPortalUsed", player, this);
		}
		else
		{
			Debug.Log("No portal...");
		}
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an object triggers the bear trap.
/// </summary>
/// <param name="trap">The bear trap that was triggered.</param>
/// <param name="triggeredObject">The object that entered the trap.</param>
/// <returns>No return behavior.</returns>
void OnTrapTrigger(BearTrap trap, UnityEngine.GameObject triggeredObject)
{
    Puts($"Trap triggered by object: {triggeredObject.name}.");
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## OnRidableAnimalClaim(BaseRidableAnimal,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player claims a ridable animal using a purchase token.
/// </summary>
/// <param name="animal">The ridable animal being claimed.</param>
/// <param name="player">The player claiming the animal.</param>
/// <param name="token">The item used as a purchase token for claiming the animal.</param>
/// <returns>
/// Returns `null` to allow the claim to proceed, or a non-null value to prevent the claim. (object)
/// </returns>
object OnRidableAnimalClaim(BaseRidableAnimal animal, BasePlayer player, Item token)
{
    Puts($"Player {player} is attempting to claim {animal} using token {token}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsForSale())
		{
			int tokenItemID = msg.read.Int32();
			Item item = GetPurchaseToken(player, tokenItemID);
			if (item != null && Interface.CallHook("OnRidableAnimalClaim", this, player, item) == null)
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(item);
				item.UseItem();
				Facepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);
				Facepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## OnWallpaperSet(BuildingBlock,ulong,int)

```csharp
```csharp
/// <summary>
/// Called when a wallpaper is set on a building block.
/// </summary>
/// <param name="block">The building block on which the wallpaper is being set.</param>
/// <param name="id">The ID of the wallpaper being applied.</param>
/// <param name="side">The side of the block where the wallpaper is being set (0 for one side, 1 for the other).</param>
/// <returns>
/// Returns a non-null value to prevent the wallpaper from being set; otherwise, returns null to allow the operation. (object)
/// </returns>
object OnWallpaperSet(BuildingBlock block, ulong id, int side)
{
    Puts($"Setting wallpaper ID {id} on block {block} at side {side}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetWallpaper(ulong id, int side = 0)
	{
		if (Interface.CallHook("OnWallpaperSet", this, id, side) != null)
		{
			return;
		}
		if (side == 0)
		{
			if (HasWallpaper(side) && wallpaperID == id)
			{
				return;
			}
			wallpaperID = id;
			wallpaperHealth = 100f;
		}
		else
		{
			if (HasWallpaper(side) && wallpaperID2 == id)
			{
				return;
			}
			wallpaperID2 = id;
			wallpaperHealth2 = 100f;
		}
		if (base.isServer)
		{
			SetConditionalModel(currentSkin.DetermineConditionalModelState(this));
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
		}
	}

```

## CanLock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can lock the specified object.
/// </summary>
/// <param name="player">The player attempting to lock the object.</param>
/// <param name="keyLock">The key lock associated with the object.</param>
/// <returns>
/// Returns `true` if the player can lock the object, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can lock the object. (bool)
/// </returns>
object CanLock(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player} is attempting to lock {keyLock}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void Lock(BasePlayer player)
	{
		if (!(player == null) && player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", player, this) == null && HasLockPermission(player))
		{
			LockLock(player);
			SendNetworkUpdate();
		}
	}

```

## OnNpcDuck(HumanNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC is instructed to duck.
/// </summary>
/// <param name="npc">The NPC that is ducking.</param>
/// <returns>
/// Returns `null` to allow the NPC to duck, or any non-null value to prevent the action. (object)
/// </returns>
object OnNpcDuck(HumanNPC npc)
{
    Puts($"NPC {npc} is attempting to duck.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetDucked(bool flag)
	{
		if (Interface.CallHook("OnNpcDuck", this) == null)
		{
			modelState.ducked = flag;
			SendNetworkUpdate();
		}
	}

```

## OnElevatorButtonPress(ElevatorLift,BasePlayer,Elevator.Direction,bool)

```csharp
```csharp
/// <summary>
/// Called when a player presses the button to raise or lower the elevator.
/// </summary>
/// <param name="elevator">The elevator that is being controlled.</param>
/// <param name="player">The player who pressed the button.</param>
/// <param name="direction">The direction in which the elevator is to move.</param>
/// <param name="isEmergency">Indicates if the button press is for an emergency stop.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or a non-null value to override it. (object)
/// </returns>
object OnElevatorButtonPress(ElevatorLift elevator, BasePlayer player, Elevator.Direction direction, bool isEmergency)
{
    Puts($"Player {player} pressed the elevator button: {direction}, Emergency: {isEmergency}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Server_RaiseLowerFloor(RPCMessage msg)
	{
		Elevator.Direction direction = (Elevator.Direction)msg.read.Int32();
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnElevatorButtonPress", this, msg.player, direction, flag) == null)
		{
			SetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);
			owner.Server_RaiseLowerElevator(direction, flag);
			Invoke(ClearDirection, 0.7f);
			if (liftButtonPressedEffect.isValid)
			{
				Effect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an object triggers the trap.
/// </summary>
/// <param name="landmine">The landmine that was triggered.</param>
/// <param name="triggeredObject">The game object that triggered the trap.</param>
/// <returns>
/// Returns `null` to allow the default trap behavior, or a non-null value to prevent the trap from triggering. (object)
/// </returns>
object OnTrapTrigger(Landmine landmine, UnityEngine.GameObject triggeredObject)
{
    Puts($"Trap triggered by object: {triggeredObject.name} on landmine: {landmine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## OnRidableAnimalClaimed(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a ridable animal is claimed by a player.
/// </summary>
/// <param name="animal">The ridable animal that is being claimed.</param>
/// <param name="player">The player claiming the ridable animal.</param>
/// <returns>No return behavior.</returns>
void OnRidableAnimalClaimed(BaseRidableAnimal animal, BasePlayer player)
{
    Puts($"Player {player} has claimed the ridable animal: {animal}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsForSale())
		{
			int tokenItemID = msg.read.Int32();
			Item item = GetPurchaseToken(player, tokenItemID);
			if (item != null && Interface.CallHook("OnRidableAnimalClaim", this, player, item) == null)
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(item);
				item.UseItem();
				Facepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);
				Facepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## OnTeamKick(RelationshipManager.PlayerTeam,BasePlayer,ulong)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from a team.
/// </summary>
/// <param name="team">The team from which the player is being kicked.</param>
/// <param name="player">The player being kicked from the team.</param>
/// <param name="userId">The user ID of the player to be removed.</param>
/// <returns>
/// Returns `null` to allow the kick to proceed, or any non-null value to prevent the kick. (object)
/// </returns>
object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong userId)
{
    Puts($"Player {player} with UserID {userId} is being kicked from team {team}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void kickmember(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer == null)
		{
			return;
		}
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam != null && !(playerTeam.GetLeader() != basePlayer))
		{
			ulong uLong = arg.GetULong(0, 0uL);
			if ((ulong)basePlayer.userID != uLong && Interface.CallHook("OnTeamKick", playerTeam, basePlayer, uLong) == null)
			{
				playerTeam.RemovePlayer(uLong);
			}
		}
	}

```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
```csharp
/// <summary>
/// Determines whether a player can be targeted by a flame turret.
/// </summary>
/// <param name="player">The player being checked for targeting.</param>
/// <param name="turret">The flame turret attempting to target the player.</param>
/// <returns>
/// Returns `true` if the player can be targeted by the flame turret; otherwise, returns `false`.
/// If the method returns `null`, the default targeting logic will be applied. (bool)
/// </returns>
object CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts($"Checking if player {player} can be targeted by turret {turret}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> obj = Pool.Get<List<RaycastHit>>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = item.GetComponent<BasePlayer>();
				if (component.IsSleeping() || !component.IsAlive())
				{
					continue;
				}
				object obj2 = Interface.CallHook("CanBeTargeted", component, this);
				if (obj2 is bool)
				{
					Pool.FreeUnmanaged(ref obj);
					return (bool)obj2;
				}
				if (!(component.transform.position.y <= GetEyePosition().y + 0.5f) || component.IsBuildingAuthed())
				{
					continue;
				}
				obj.Clear();
				GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
				for (int i = 0; i < obj.Count; i++)
				{
					BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
					if (entity != null && (entity == this || entity.EqualNetID(this)))
					{
						flag = true;
						break;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeUnmanaged(ref obj);
		return flag;
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player stops spectating.
/// </summary>
/// <param name="player">The player who has stopped spectating.</param>
/// <param name="filter">The filter that was used for spectating, which could be a player name or other identifier.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player} has ended spectating with filter: {filter}.");
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## CanUseVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the vending machine.
/// </summary>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <returns>
/// Returns `true` if the player can use the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine access. (bool)
/// </returns>
object CanUseVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player} is attempting to use vending machine {vendingMachine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		object obj = Interface.CallHook("CanUseVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

```

## OnServerInitialize()

```csharp
```csharp
/// <summary>
/// Called when the server is initialized, setting up necessary components and loading state.
/// </summary>
/// <returns>
/// Returns `true` if the server was loaded from a save file; otherwise, returns `false`.
/// </returns>
bool OnServerInitialize()
{
    Puts("Server is initializing...");
    return Initialize();
}
```
```

### Source Code from the Library

```csharp

	public bool Initialize(bool loadSave = true, string saveFile = "", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)
	{
		Interface.CallHook("OnServerInitialize");
		persistance = new UserPersistance(ConVar.Server.rootFolder);
		playerStateManager = new PlayerStateManager(persistance);
		TutorialIsland.GenerateIslandSpawnPoints(loadingSave: true);
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			using (TimeWarning.New("SpawnHandler.UpdateDistributions"))
			{
				SingletonComponent<SpawnHandler>.Instance.UpdateDistributions();
			}
		}
		if (loadSave)
		{
			World.LoadedFromSave = true;
			World.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));
		}
		else
		{
			SaveRestore.SaveCreatedTime = DateTime.UtcNow;
			World.LoadedFromSave = false;
		}
		if (!World.LoadedFromSave)
		{
			SaveRestore.SpawnMapEntities(SaveRestore.FindMapEntities());
		}
		SaveRestore.InitializeWipeId();
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			if (!skipInitialSpawn)
			{
				using (TimeWarning.New("SpawnHandler.InitialSpawn", 200))
				{
					SingletonComponent<SpawnHandler>.Instance.InitialSpawn();
				}
			}
			using (TimeWarning.New("SpawnHandler.StartSpawnTick", 200))
			{
				SingletonComponent<SpawnHandler>.Instance.StartSpawnTick();
			}
		}
		CreateImportantEntities();
		auth = GetComponent<ConnectionAuth>();
		Facepunch.Rust.Analytics.Azure.Initialize();
		return World.LoadedFromSave;
	}

```

## IOnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called after an entity has been saved to the stream.
/// </summary>
/// <param name="entity">The entity that has been saved.</param>
/// <param name="saveInfo">The information related to the save operation.</param>
/// <returns>No return behavior.</returns>
void IOnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity} has been saved with SaveInfo: {saveInfo}.");
}
```
```

### Source Code from the Library

```csharp

	public void ToStream(Stream stream, SaveInfo saveInfo)
	{
		using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError(this?.ToString() + ": ToStream - no BaseEntity!?");
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError(this?.ToString() + ": ToStream - no baseNetworkable!?");
			}
			Interface.CallHook("IOnEntitySaved", this, saveInfo);
			saveInfo.msg.ToProto(stream);
			PostSave(saveInfo);
		}
	}

```

## OnTeamDisbanded(RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team has been disbanded.
/// </summary>
/// <param name="team">The team that has been disbanded.</param>
/// <returns>No return behavior.</returns>
void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
{
    Puts($"Team with ID {team.teamID} has been disbanded.");
}
```
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Facepunch.Pool.Free(ref teamToDisband);
		}
	}

```

## OnHorseUnhitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is unhitched from a hitching spot.
/// </summary>
/// <param name="horse">The horse that is being unhitched.</param>
/// <param name="hitchSpot">The hitching spot from which the horse is being unhitched.</param>
/// <returns>No return behavior.</returns>
void OnHorseUnhitch(RidableHorse horse, HitchSpot hitchSpot)
{
    Puts($"Horse {horse} has been unhitched from spot {hitchSpot}.");
}
```
```

### Source Code from the Library

```csharp

	public void Unhitch(RidableHorse horse)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHorse(base.isServer) == horse)
			{
				if (Interface.CallHook("OnHorseUnhitch", horse, hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				horse.SetHitch(null);
			}
		}
	}

```

## OnMissionAssigned(BaseMission,IMissionProvider,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is assigned to a player.
/// </summary>
/// <param name="mission">The mission that is being assigned.</param>
/// <param name="provider">The provider of the mission.</param>
/// <param name="assignee">The player to whom the mission is assigned.</param>
/// <returns>
/// Returns a non-null value to prevent the mission from being assigned, or `null` to allow the assignment. (object)
/// </returns>
object OnMissionAssigned(BaseMission mission, IMissionProvider provider, BasePlayer assignee)
{
    Puts($"Mission {mission.id} assigned to player {assignee} by provider {provider.ProviderID()}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", assignee, mission, provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = assignee.missions.FindIndexWith((MissionInstance i) => i.missionID, mission.id);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", mission, provider, assignee);
		return true;
	}

```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to refresh the stock level of items available for sale in a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine whose stock is being refreshed.</param>
/// <param name="itemDef">The item definition to refresh stock for; if null, refreshes all items.</param>
/// <returns>No return behavior.</returns>
void OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDef)
{
    Puts($"Refreshing stock for Vending Machine {vendingMachine} for item: {itemDef?.shortname ?? "all items"}.");
}
```
```

### Source Code from the Library

```csharp

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		int num = 0;
		foreach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (!(itemDef == null) && itemDef.itemid != sellOrder.itemToSellID)
			{
				continue;
			}
			List<Item> obj = Facepunch.Pool.Get<List<Item>>();
			GetItemsToSell(sellOrder, obj);
			int inStock;
			if (obj.Count < 0)
			{
				inStock = 0;
			}
			else
			{
				List<Item> source = obj;
				Func<Item, int> selector = (Item x) => x.amount;
				Interface.CallHook("OnRefreshVendingStock", this, itemDef);
				inStock = source.Sum(selector) / sellOrder.itemToSellAmount;
			}
			sellOrder.inStock = inStock;
			float itemCondition = 0f;
			float itemConditionMax = 0f;
			int instanceData = 0;
			List<int> list = Facepunch.Pool.Get<List<int>>();
			int totalAttachmentSlots = 0;
			int ammoType = 0;
			int ammoCount = 0;
			if (obj.Count > 0)
			{
				if (obj[0].hasCondition)
				{
					itemCondition = obj[0].condition;
					itemConditionMax = obj[0].maxCondition;
				}
				if (obj[0].info != null && obj[0].info.amountType == ItemDefinition.AmountType.Genetics && obj[0].instanceData != null)
				{
					instanceData = obj[0].instanceData.dataInt;
					sellOrder.inStock = obj[0].amount;
				}
				if (obj[0].contents != null && obj[0].contents.capacity > 0 && obj[0].contents.HasFlag(ItemContainer.Flag.ShowSlotsOnIcon))
				{
					foreach (Item item in obj[0].contents.itemList)
					{
						list.Add(item.info.itemid);
					}
					totalAttachmentSlots = obj[0].contents.capacity;
				}
				if (obj[0].ammoCount.HasValue)
				{
					ammoCount = obj[0].ammoCount.Value;
					BaseEntity heldEntity = obj[0].GetHeldEntity();
					if ((bool)heldEntity)
					{
						BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
						if ((bool)component)
						{
							ammoType = component.primaryMagazine.ammoType.itemid;
						}
					}
				}
			}
			sellOrder.ammoType = ammoType;
			sellOrder.ammoCount = ammoCount;
			sellOrder.itemCondition = itemCondition;
			sellOrder.itemConditionMax = itemConditionMax;
			sellOrder.instanceData = instanceData;
			if (sellOrder.attachmentsList != null)
			{
				Facepunch.Pool.FreeUnmanaged(ref sellOrder.attachmentsList);
			}
			sellOrder.attachmentsList = list;
			sellOrder.totalAttachmentSlots = totalAttachmentSlots;
			sellOrder.priceMultiplier = GetDiscountForSlot(num, sellOrder);
			num++;
			Facepunch.Pool.Free(ref obj, freeElements: false);
		}
	}

```

## OnTreeMarkerHit(TreeEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a tree marker is hit by a player's action.
/// </summary>
/// <param name="tree">The tree entity that contains the marker.</param>
/// <param name="hitInfo">Information about the hit event, including position and normal.</param>
/// <returns>
/// Returns `true` if the hit is valid and the marker was successfully hit; otherwise, returns `false`.
/// If the method returns `null`, the default hit logic will be used. (bool)
/// </returns>
object OnTreeMarkerHit(TreeEntity tree, HitInfo hitInfo)
{
    Puts($"Tree marker hit detected on tree {tree} at position {hitInfo.HitPositionWorld}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool DidHitMarker(HitInfo info)
	{
		if (xMarker == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnTreeMarkerHit", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PrefabAttribute.server.Find<TreeMarkerData>(prefabID) != null)
		{
			if (new Bounds(xMarker.transform.position, Vector3.one * 0.2f).Contains(info.HitPositionWorld))
			{
				return true;
			}
		}
		else
		{
			Vector3 lhs = Vector3Ex.Direction2D(base.transform.position, xMarker.transform.position);
			Vector3 attackNormal = info.attackNormal;
			float num = Vector3.Dot(lhs, attackNormal);
			float num2 = Vector3.Distance(xMarker.transform.position, info.HitPositionWorld);
			if (num >= 0.3f && num2 <= 0.2f)
			{
				return true;
			}
		}
		return false;
	}

```

## OnShopAcceptClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player clicks the accept button in a shop interface.
/// </summary>
/// <param name="shop">The shop front where the transaction is taking place.</param>
/// <param name="player">The player who clicked the accept button.</param>
/// <returns>
/// Returns `null` to allow the default behavior of the shop acceptance; 
/// any non-null value will prevent the acceptance action from proceeding. (object)
/// </returns>
object OnShopAcceptClick(ShopFront shop, BasePlayer player)
{
    Puts($"Player {player} clicked accept on shop {shop}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !(vendorPlayer == null) && !(customerPlayer == null) && Interface.CallHook("OnShopAcceptClick", this, msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				Invoke(CompleteTrade, 2f);
			}
		}
	}

```

## OnEngineLoadoutRefresh(Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called to refresh the loadout data of the engine storage.
/// </summary>
/// <param name="engineStorage">The engine storage whose loadout is being refreshed.</param>
/// <returns>No return behavior.</returns>
void OnEngineLoadoutRefresh(Rust.Modular.EngineStorage engineStorage)
{
    Puts($"Refreshing loadout data for engine storage: {engineStorage}.");
}
```
```

### Source Code from the Library

```csharp

	public void RefreshLoadoutData()
	{
		if (Interface.CallHook("OnEngineLoadoutRefresh", this) == null)
		{
			isUsable = base.inventory.IsFull() && base.inventory.itemList.All((Item item) => !item.isBroken);
			accelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;
			topSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;
			fuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;
			SendNetworkUpdate();
			GetEngineModule()?.RefreshPerformanceStats(this);
		}
	}

```

## OnItemRecycle(Item,Recycler)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled in the recycler.
/// </summary>
/// <param name="item">The item being recycled.</param>
/// <param name="recycler">The recycler that is processing the item.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being recycled, or `null` to allow the recycling process to continue. (object)
/// </returns>
object OnItemRecycle(Item item, Recycler recycler)
{
    Puts($"Recycling item: {item} in recycler: {recycler}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", slot, this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", slot, num3, this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					float num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 *= slot.conditionNormalized;
					}
					float num5 = num / 0.5f;
					num4 *= num5;
					int num6 = Mathf.FloorToInt(num4);
					float num7 = num4 - (float)num6;
					scrapRemainder += num7;
					if (scrapRemainder >= 1f)
					{
						int num8 = Mathf.FloorToInt(scrapRemainder);
						scrapRemainder -= num8;
						num6 += num8;
					}
					if (num6 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num6, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj2 = Facepunch.Pool.Get<List<BasePlayer>>();
					Vis.Entities(base.transform.position, 3f, obj2, 131072);
					foreach (BasePlayer item3 in obj2)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Facepunch.Pool.FreeUnmanaged(ref obj2);
				}
				Facepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;
					int num10 = Mathf.FloorToInt(num9);
					float num11 = num9 - (float)num10;
					if (num11 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num11)
					{
						num10++;
					}
					if (num10 <= 0)
					{
						continue;
					}
					int num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);
					for (int i = 0; i < num12; i++)
					{
						int num13 = ((num10 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);
						Item item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
						if (!MoveItemToOutput(item2))
						{
							flag = true;
						}
						num10 -= num13;
						if (num10 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int,bool)

```csharp
```csharp
/// <summary>
/// Determines whether the item crafter can craft a specified item blueprint.
/// </summary>
/// <param name="crafter">The item crafter attempting to craft the item.</param>
/// <param name="blueprint">The item blueprint to craft.</param>
/// <param name="amount">The amount of items to craft.</param>
/// <param name="free">Indicates if crafting should be free of cost.</param>
/// <returns>
/// Returns `true` if the crafter can craft the specified item; otherwise, returns `false`. 
/// If the method returns `null`, the default crafting logic will be applied. (bool)
/// </returns>
object CanCraft(ItemCrafter crafter, ItemBlueprint blueprint, int amount, bool free)
{
    Puts($"Checking if {crafter} can craft {amount} of {blueprint}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)
	{
		if (base.baseEntity != null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if (restraintItem != null && restraintItem.BlockCrafting)
			{
				return false;
			}
		}
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount, free);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
			if (ingredient.itemDef.condition.enabled && !DoesHaveOKConditionItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="keyLock">The key lock associated with the entity.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can use the entity. (bool)
/// </returns>
object CanUseLockedEntity(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player} is attempting to use a locked entity with KeyLock: {keyLock}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## OnElevatorCall(Elevator,Elevator)

```csharp
```csharp
/// <summary>
/// Called when an elevator is requested to move to a specific floor.
/// </summary>
/// <param name="caller">The entity that is calling the elevator.</param>
/// <param name="elevator">The elevator that is being called.</param>
/// <returns>No return behavior.</returns>
void OnElevatorCall(Elevator caller, Elevator elevator)
{
    Puts($"Elevator called by {caller} to move to floor {elevator.Floor}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void CallElevator()
	{
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.IsTop && Interface.CallHook("OnElevatorCall", this, elevatorEnt) == null)
			{
				elevatorEnt.RequestMoveLiftTo(Floor, out var _, this);
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

```

## OnBookmarkControlEnd(ComputerStation,BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player stops controlling a bookmark on a computer station.
/// </summary>
/// <param name="station">The computer station being controlled.</param>
/// <param name="player">The player who is stopping control.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>
/// Returns a non-null value to prevent the default control stop behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnBookmarkControlEnd(ComputerStation station, BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player} has stopped controlling the bookmark on {station} for entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if ((bool)ply)
		{
			ply.net.SwitchSecondaryGroup(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
		CancelInvoke(CheckCCTVAchievement);
		Interface.CallHook("OnBookmarkControlEnded", this, ply, baseEntity);
	}

```

## CanHideStash(BasePlayer,StashContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hide a stash container.
/// </summary>
/// <param name="player">The player attempting to hide the stash.</param>
/// <param name="stash">The stash container that is being hidden.</param>
/// <returns>
/// Returns `true` if the player can hide the stash, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the stash can be hidden. (bool)
/// </returns>
object CanHideStash(BasePlayer player, StashContainer stash)
{
    Puts($"Player {player} is attempting to hide stash: {stash}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", rpc.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", this, rpc.player);
		}
	}

```

## OnPlayerDismountFailed(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to dismount but the position is invalid.
/// </summary>
/// <param name="player">The player attempting to dismount.</param>
/// <param name="mountable">The mountable object the player is trying to dismount from.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDismountFailed(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player} failed to dismount from {mountable} due to an invalid position.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", player, this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", player, this) == null && (!(player != null) || !player.IsRestrained))
		{
			AttemptDismount(player);
		}
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player picks up an item.
/// </summary>
/// <param name="item">The item that is being picked up.</param>
/// <param name="player">The player who is picking up the item.</param>
/// <returns>
/// Returns `null` to allow the item pickup, or any non-null value to prevent the pickup action. (object)
/// </returns>
object OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Player {player} is attempting to pick up item: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && this.item != null && allowPickup && Interface.CallHook("OnItemPickup", this.item, msg.player) == null && CanOpenInSafeZone(msg.player))
		{
			ClientRPC(RpcTarget.NetworkGroup("PickupSound"));
			Item item = this.item;
			Facepunch.Rust.Analytics.Azure.OnItemPickup(msg.player, this);
			RemoveItem();
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is deauthorized from an auto turret.
/// </summary>
/// <param name="turret">The auto turret from which the player is being deauthorized.</param>
/// <param name="player">The player being deauthorized.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Player {player} has been deauthorized from turret {turret}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			authDirty = true;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnItemDespawn(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is about to despawn from the world.
/// </summary>
/// <param name="item">The item that is being despawned.</param>
/// <returns>No return behavior.</returns>
void OnItemDespawn(Item item)
{
    Puts($"Item {item} is about to despawn.");
}
```
```

### Source Code from the Library

```csharp

	public void IdleDestroy()
	{
		Interface.CallHook("OnItemDespawn", item);
		Facepunch.Rust.Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);
		DestroyItem();
		Kill();
	}

```

## OnNpcTarget(HumanNPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC should target a specific entity.
/// </summary>
/// <param name="npc">The NPC that is evaluating potential targets.</param>
/// <param name="target">The entity being considered as a target.</param>
/// <returns>
/// Returns `null` to allow the default targeting behavior, or a non-null value to override it. (object)
/// </returns>
object OnNpcTarget(HumanNPC npc, BaseEntity target)
{
    Puts($"NPC {npc} is evaluating target: {target}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity GetBestTarget()
	{
		BaseEntity result = null;
		float num = -1f;
		foreach (BaseEntity player in Brain.Senses.Players)
		{
			if (!(player == null) && !(player.Health() <= 0f) && Interface.CallHook("OnNpcTarget", this, player) == null)
			{
				float value = Vector3.Distance(player.transform.position, base.transform.position);
				float num2 = 1f - Mathf.InverseLerp(1f, Brain.SenseRange, value);
				float value2 = Vector3.Dot((player.transform.position - base.eyes.position).normalized, base.eyes.BodyForward());
				num2 += Mathf.InverseLerp(Brain.VisionCone, 1f, value2) / 2f;
				num2 += (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);
				if (num2 > num)
				{
					result = player;
					num = num2;
				}
			}
		}
		return result;
	}

```

## OnSprayCreate(SprayCan,UnityEngine.Vector3,UnityEngine.Quaternion)

```csharp
```csharp
/// <summary>
/// Called when a spray is created using a spray can.
/// </summary>
/// <param name="sprayCan">The spray can being used to create the spray.</param>
/// <param name="position">The position where the spray is created.</param>
/// <param name="rotation">The rotation of the spray when created.</param>
/// <returns>
/// Returns `null` to allow the spray creation, or any non-null value to prevent it. (object)
/// </returns>
object OnSprayCreate(SprayCan sprayCan, Vector3 position, Quaternion rotation)
{
    Puts($"Creating spray at position {position} with rotation {rotation} using spray can {sprayCan}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void CreateSpray(RPCMessage msg)
	{
		if (IsBusy())
		{
			return;
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3();
		Vector3 point = msg.read.Vector3();
		int num = msg.read.Int32();
		if (!(Vector3.Distance(vector, base.transform.position) > 4.5f))
		{
			Quaternion quaternion = Quaternion.LookRotation((new Plane(vector2, vector).ClosestPointOnPlane(point) - vector).normalized, vector2);
			quaternion *= Quaternion.Euler(0f, 0f, 90f);
			bool flag = false;
			if (msg.player.IsDeveloper)
			{
				flag = true;
			}
			if (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))
			{
				Debug.Log($"SprayCan.ChangeItemSkin player does not have item :{num}:");
			}
			else if (Interface.CallHook("OnSprayCreate", this, vector, quaternion) == null)
			{
				ulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);
				BaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, vector, quaternion);
				baseEntity.skinID = num2;
				baseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());
				baseEntity.Spawn();
				CheckAchievementPosition(vector);
				LoseCondition(ConditionLossPerSpray);
			}
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="sign">The sign that is being updated.</param>
/// <returns>
/// Returns `true` if the player can update the sign; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can update the sign. (bool)
/// </returns>
object CanUpdateSign(BasePlayer player, Signage sign)
{
    Puts($"Player {player} is attempting to update the sign: {sign}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return true;
	}

```

## OnPlayerRespawn(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called when a player respawns at a sleeping bag.
/// </summary>
/// <param name="player">The player who is respawning.</param>
/// <param name="sleepingBag">The sleeping bag the player is respawning at.</param>
/// <returns>
/// Returns a modified sleeping bag if the hook alters the default behavior; otherwise, returns the original sleeping bag. (SleepingBag)
/// </returns>
object OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag)
{
    Puts($"Player {player} is respawning at sleeping bag {sleepingBag}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)
	{
		BasePlayer player2 = player;
		SleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);
		SleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) => x.ValidForPlayer(player2.userID, ignoreTimers: false) && x.net.ID == sleepingBag && x.unlockTime < UnityEngine.Time.realtimeSinceStartup);
		if (sleepingBag2 == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", player, sleepingBag2);
		if (obj is SleepingBag)
		{
			sleepingBag2 = (SleepingBag)obj;
		}
		if (sleepingBag2.GetRespawnState(player2.userID) != RespawnInformation.SpawnOptions.RespawnState.OK)
		{
			return false;
		}
		sleepingBag2.GetSpawnPos(out var pos, out var rot);
		player2.RespawnAt(pos, rot, sleepingBag2);
		sleepingBag2.PostPlayerSpawn(player2);
		SleepingBag[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			SetBagTimer(array2[i], pos, SleepingBagResetReason.Respawned, player2);
		}
		return true;
	}

```

## CanUnlockTechTreeNodePath(BasePlayer,TechTreeData.NodeInstance,TechTreeData)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a specific path in the tech tree.
/// </summary>
/// <param name="player">The player attempting to unlock the tech tree node path.</param>
/// <param name="node">The tech tree node instance that the player wants to unlock.</param>
/// <param name="techTree">The tech tree data containing the nodes and paths.</param>
/// <returns>
/// Returns `true` if the player can unlock the specified path; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the path can be unlocked. (bool)
/// </returns>
object CanUnlockTechTreeNodePath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
{
    Puts($"Checking if player {player} can unlock path for node {node} in tech tree.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNodePath", player, node, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		NodeInstance entryNode = GetEntryNode();
		if (entryNode == null)
		{
			return false;
		}
		return CheckChainRecursive(player, entryNode, node);
	}

```

## OnRackedWeaponSwapped(Item,WeaponRackSlot,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is swapped on a weapon rack.
/// </summary>
/// <param name="item">The item being swapped (the weapon).</param>
/// <param name="slot">The weapon rack slot where the weapon is being placed.</param>
/// <param name="player">The player performing the swap.</param>
/// <param name="rack">The weapon rack involved in the swap.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponSwapped(Item item, WeaponRackSlot slot, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player} swapped weapon {item} into slot {slot} on rack {rack}.");
}
```
```

### Source Code from the Library

```csharp

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", item, weaponAtIndex, player, this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", item, weaponAtIndex, player, this);
			}
		}
	}

```

## OnEntityReskinned(BaseEntity,ItemSkinDirectory.Skin,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is reskinned, allowing for custom behavior or modifications.
/// </summary>
/// <param name="entity">The entity that is being reskinned.</param>
/// <param name="skin">The new skin being applied to the entity.</param>
/// <param name="player">The player who initiated the reskin action.</param>
/// <returns>
/// Returns a non-null value to prevent the default reskin behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnEntityReskinned(BaseEntity entity, ItemSkinDirectory.Skin skin, BasePlayer player)
{
    Puts($"Entity {entity} is being reskinned with skin {skin.id} by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	private void ChangeItemSkin(RPCMessage msg)
	{
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))
		{
			return;
		}
		if (baseNetworkable != null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if ((object)baseEntity2 != null)
			{
				if (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))
				{
					FailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin((def.isRedirectOf != null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", baseEntity2, skin, msg.player) != null)
				{
					return;
				}
				if (skin.invItem != null && skin.invItem is ItemSkin itemSkin)
				{
					if (itemSkin.Redirect != null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if ((bool)def && def.isRedirectOf != null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if (def.isRedirectOf != null || ((bool)def && def.isRedirectOf != null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if (itemDefinition == null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2))
					{
						FailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning("Cannot find resource path of redirect entity to spawn! " + itemDefinition.gameObject.name);
						FailResponse(SprayFailReason.InvalidItem);
						return;
					}
					Vector3 localPosition = baseEntity2.transform.localPosition;
					Quaternion localRotation = baseEntity2.transform.localRotation;
					BaseEntity baseEntity3 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					HashSet<PlayerNameID> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> obj = Facepunch.Pool.Get<List<ChildPreserveInfo>>();
					if (flag)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							obj.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = child.transform.localPosition,
								LocalRotation = child.transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in obj)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity3);
					baseEntity2.transform.localPosition = localPosition;
					baseEntity2.transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity)
					{
						decayEntity.AttachToBuilding(null);
					}
					baseEntity2.Spawn();
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag)
						{
							for (int j = 0; j < baseEntity2.children.Count; j++)
							{
								RestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item2 in dictionary2)
						{
							foreach (Item item3 in item2.Value)
							{
								Debug.Log($"Deleting {item3} as it has no new container");
								item3.Remove();
							}
						}
						Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
					}
					if (flag)
					{
						foreach (ChildPreserveInfo item4 in obj)
						{
							item4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);
							item4.TargetEntity.transform.localPosition = item4.LocalPosition;
							item4.TargetEntity.transform.localRotation = item4.LocalRotation;
							item4.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Interface.CallHook("OnEntityReskinned", baseEntity2, skin, msg.player);
					Facepunch.Pool.FreeUnmanaged(ref obj);
				}
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		LoseCondition(ConditionLossPerReskin);
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		void FailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (copy.ContainsKey(key))
				{
					foreach (Item item5 in copy[key])
					{
						item5.MoveToContainer(itemContainerEntity.inventory);
					}
					copy.Remove(key);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (!dictionary.ContainsKey(key2))
				{
					dictionary.Add(key2, new List<Item>());
					foreach (Item item6 in itemContainerEntity2.inventory.itemList)
					{
						dictionary[key2].Add(item6);
					}
					{
						foreach (Item item7 in dictionary[key2])
						{
							item7.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log("Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
	}

```

## OnPlayerDig(BasePlayer,BaseDiggableEntity)

```csharp
```csharp
/// <summary>
/// Called when a player digs at a diggable entity.
/// </summary>
/// <param name="player">The player who is performing the digging action.</param>
/// <param name="diggableEntity">The diggable entity being interacted with.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDig(BasePlayer player, BaseDiggableEntity diggableEntity)
{
    Puts($"Player {player} is digging at {diggableEntity}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Dig(BasePlayer player)
	{
		if (Interface.CallHook("OnPlayerDig", player, this) != null)
		{
			return;
		}
		if (digsRemaining == RequiredDigCount)
		{
			OnFirstDig(player);
		}
		ClientRPC(RpcTarget.NetworkGroup("RPC_OnDig"), RequiredDigCount - digsRemaining, RequiredDigCount);
		digsRemaining--;
		base.health = digsRemaining;
		SendNetworkUpdate();
		OnSingleDig(player);
		if (digsRemaining <= 0)
		{
			OnFullyDug(player);
			if (DestroyOnDug)
			{
				Kill();
			}
		}
	}

```

## OnPlayerAddModifiers(BasePlayer,Item,ItemModConsumable)

```csharp
```csharp
/// <summary>
/// Called when a player consumes an item that modifies their attributes.
/// </summary>
/// <param name="player">The player who is consuming the item.</param>
/// <param name="item">The item being consumed.</param>
/// <param name="consumable">The consumable item modifier being applied.</param>
/// <returns>
/// Returns `null` to allow the default modifiers to be added; otherwise, returns a non-null value to prevent adding modifiers. (object)
/// </returns>
object OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable)
{
    Puts($"Player {player} is adding modifiers from consumable {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount < 1)
		{
			return;
		}
		GameObjectRef gameObjectRef = GetConsumeEffect();
		if (gameObjectRef.isValid)
		{
			Vector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));
			Effect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);
		}
		player.metabolism.MarkConsumption();
		ItemModConsumable consumable = GetConsumable();
		if (!string.IsNullOrEmpty(consumable.achievementWhenEaten))
		{
			player.GiveAchievement(consumable.achievementWhenEaten);
		}
		Facepunch.Rust.Analytics.Azure.OnConsumableUsed(player, item);
		float num = Mathf.Max(consumable.amountToConsume, 1);
		float num2 = Mathf.Min(item.amount, num);
		float num3 = num2 / num;
		float num4 = item.conditionNormalized;
		if (consumable.conditionFractionToLose > 0f)
		{
			num4 = consumable.conditionFractionToLose;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
		{
			if (Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)
			{
				continue;
			}
			if (effect.type == MetabolismAttribute.Type.Health)
			{
				if (effect.amount < 0f)
				{
					player.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, player.transform.position + player.transform.forward * 1f));
				}
				else
				{
					player.health += effect.amount * num3 * num4;
				}
			}
			else
			{
				player.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);
			}
		}
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);
		if (player.modifiers != null && Interface.CallHook("OnPlayerAddModifiers", player, item, consumable) == null)
		{
			player.modifiers.Add(consumable.modifiers);
		}
		if (product != null)
		{
			ItemAmountRandom[] array = product;
			foreach (ItemAmountRandom itemAmountRandom in array)
			{
				int num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);
				if (num5 > 0)
				{
					Item item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);
					player.GiveItem(item2);
				}
			}
		}
		if (string.IsNullOrEmpty(eatGesture))
		{
			player.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);
		}
		Facepunch.Rust.Analytics.Server.Consume(base.gameObject.name);
		if (consumable.conditionFractionToLose > 0f)
		{
			item.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);
		}
		else
		{
			item.UseItem((int)num2);
		}
	}

```

## OnStructureUpgraded(BuildingBlock,BasePlayer,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a new grade.
/// </summary>
/// <param name="block">The building block that is being upgraded.</param>
/// <param name="player">The player who is performing the upgrade.</param>
/// <param name="newGrade">The new grade to which the structure is being upgraded.</param>
/// <param name="skinId">The skin ID associated with the new grade.</param>
/// <returns>No return behavior.</returns>
void OnStructureUpgraded(BuildingBlock block, BasePlayer player, BuildingGrade.Enum newGrade, ulong skinId)
{
    Puts($"Structure upgraded by {player} to grade {newGrade} with skin ID {skinId}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void DoUpgradeToGrade(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		ConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());
		if (constructionGrade == null)
		{
			return;
		}
		if (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
		{
			if (!(DeployVolume.LastDeployHit != null))
			{
				return;
			}
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(DeployVolume.LastDeployHit);
			if (baseEntity != null && baseEntity is BasePlayer basePlayer)
			{
				ulong currentTeam = msg.player.currentTeam;
				if (currentTeam != 0L && currentTeam == basePlayer.currentTeam)
				{
					string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
					msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);
				}
			}
		}
		else
		{
			if (Interface.CallHook("OnStructureUpgrade", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin) != null || !CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
			{
				return;
			}
			if (base.SecondsSinceAttacked < 30f)
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
				return;
			}
			if (!constructionGrade.gradeBase.alwaysUnlock && constructionGrade.gradeBase.skin != 0L && !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);
				return;
			}
			PayForUpgrade(constructionGrade, msg.player);
			if (msg.player != null)
			{
				playerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);
			}
			ClientRPC(RpcTarget.NetworkGroup("DoUpgradeEffect"), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			BuildingGrade.Enum @enum = grade;
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);
			OnSkinChanged(skinID, constructionGrade.gradeBase.skin);
			ChangeGrade(constructionGrade.gradeBase.type, playEffect: true);
			if (msg.player != null && @enum != constructionGrade.gradeBase.type)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload
				{
					NetworkIdentifier = net.ID,
					IntIdentifier = (int)constructionGrade.gradeBase.type
				}, 1f);
			}
			Interface.CallHook("OnStructureUpgraded", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
		}
	}

```

## CanSeeStash(BasePlayer,StashContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can see a stash container.
/// </summary>
/// <param name="player">The player attempting to see the stash.</param>
/// <param name="stash">The stash container being checked for visibility.</param>
/// <returns>
/// Returns `true` if the player can see the stash, or `false` if they cannot.
/// If the method returns a non-null value, it overrides the default visibility logic. (bool)
/// </returns>
object CanSeeStash(BasePlayer player, StashContainer stash)
{
    Puts($"Checking visibility for stash {stash} by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void CheckStashRevealInvoke()
	{
		for (int i = 0; i < nearbyStashes.Count; i++)
		{
			NearbyStash nearbyStash = nearbyStashes[i];
			if (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)
			{
				nearbyStashes.RemoveAt(i);
			}
			else if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))
			{
				nearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;
				if (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)
				{
					if (Interface.CallHook("CanSeeStash", this, nearbyStash.Entity) != null)
					{
						break;
					}
					nearbyStash.Entity.SetHidden(isHidden: false);
					Facepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);
					Interface.CallHook("OnStashExposed", nearbyStash.Entity, this);
				}
			}
			else
			{
				nearbyStash.LookingAtTime = 0f;
			}
		}
	}

```

## OnDeleteVendingOffer(VendingMachine,int)

```csharp
```csharp
/// <summary>
/// Called when a vending offer is deleted from the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the offer is being deleted.</param>
/// <param name="offerIndex">The index of the vending offer being deleted.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, int offerIndex)
{
    Puts($"Vending offer at index {offerIndex} deleted from vending machine {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", this, num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[num];
				Facepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, added: false);
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## OnIORefCleared(IOEntity.IORef,IOEntity)

```csharp
```csharp
/// <summary>
/// Called when an IO reference is cleared from an IO entity.
/// </summary>
/// <param name="ioRef">The IO reference that was cleared.</param>
/// <param name="entity">The entity from which the IO reference was cleared.</param>
/// <returns>No return behavior.</returns>
void OnIORefCleared(IOEntity.IORef ioRef, IOEntity entity)
{
    Puts($"IO reference cleared from entity: {entity}.");
}
```
```

### Source Code from the Library

```csharp

		public void Clear()
		{
			IOEntity obj = ioEnt;
			ioEnt = null;
			entityRef.Set(null);
			Interface.CallHook("OnIORefCleared", this, obj);
		}

```

## OnPlayerRespawn(BasePlayer,BasePlayer.SpawnPoint)

```csharp
```csharp
/// <summary>
/// Called when a player is about to respawn.
/// </summary>
/// <param name="player">The player that is respawning.</param>
/// <param name="spawnPoint">The spawn point where the player will respawn.</param>
/// <returns>
/// Returns a modified spawn point if the hook alters the default behavior; otherwise, returns the original spawn point. (SpawnPoint)
/// </returns>
object OnPlayerRespawn(BasePlayer player, SpawnPoint spawnPoint)
{
    Puts($"Player {player} is respawning at {spawnPoint.pos}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this);
		if (ConVar.Server.respawnAtDeathPosition && ServerCurrentDeathNote != null)
		{
			spawnPoint.pos = ServerCurrentDeathNote.worldPosition;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", this, spawnPoint);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnWeaponReload(BaseProjectile,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a weapon is reloaded by a player.
/// </summary>
/// <param name="weapon">The weapon being reloaded.</param>
/// <param name="player">The player who is reloading the weapon.</param>
/// <returns>
/// Returns `null` to allow the default reload behavior, or a non-null value to prevent the reload action. (object)
/// </returns>
object OnWeaponReload(BaseProjectile weapon, BasePlayer player)
{
    Puts($"Player {player} is reloading weapon {weapon}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnWeaponReload", this, player) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			fractionalInsertCounter = 0;
			if (CanRefundAmmo)
			{
				SwitchAmmoTypesIfNeeded(player.inventory);
			}
			OnReloadStarted();
			StartReloadCooldown(GetReloadDuration());
		}
	}

```

## OnCrateHackEnd(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when the hacking of a locked crate has completed.
/// </summary>
/// <param name="crate">The hackable locked crate that was hacked.</param>
/// <returns>No return behavior.</returns>
void OnCrateHackEnd(HackableLockedCrate crate)
{
    Puts($"Hacking completed for crate: {crate}.");
}
```
```

### Source Code from the Library

```csharp

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", this);
			Facepunch.Rust.Analytics.Azure.OnLockedCrateFinished(originalHackerPlayerId, this);
			if (originalHackerPlayer != null && originalHackerPlayer.serverClan != null)
			{
				originalHackerPlayer.AddClanScore(ClanScoreEventType.HackedCrate);
			}
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			CancelInvoke(HackProgress);
		}
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), (int)hackSeconds, (int)requiredHackSeconds);
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a melee item is thrown by a player.
/// </summary>
/// <param name="player">The player who threw the melee item.</param>
/// <param name="item">The item that was thrown.</param>
/// <returns>No return behavior.</returns>
void OnMeleeThrown(BasePlayer player, Item item)
{
    Puts($"Player {player} has thrown the melee item: {item.info.shortname}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (player == null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsProjectile)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "item_missing");
				return;
			}
			ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
			if (component == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "mod_missing");
				return;
			}
			ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
			if (projectileShoot.projectiles.Count != 1)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "count_mismatch");
				return;
			}
			player.CleanupExpiredProjectiles();
			Guid projectileGroupId = Guid.NewGuid();
			foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.LogInvalid(player, this, "duplicate_id");
					continue;
				}
				Vector3 positionOffset = Vector3.zero;
				if (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))
				{
					if (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))
					{
						continue;
					}
					Vector3 position = player.eyes.position;
					positionOffset = position - projectile.startPos;
					projectile.startPos = position;
				}
				else if (!ValidateEyePos(player, projectile.startPos))
				{
					continue;
				}
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, projectileGroupId, positionOffset, item);
				Effect effect = new Effect();
				effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
				effect.scale = 1f;
				effect.pooledString = component.projectileObject.resourcePath;
				effect.number = projectile.seed;
				EffectNetwork.Send(effect);
			}
			projectileShoot?.Dispose();
			item.SetParent(null);
			Interface.CallHook("OnMeleeThrown", player, item);
			if (!canAiHearIt)
			{
				return;
			}
			float num = 0f;
			if (component.projectileObject == null)
			{
				return;
			}
			GameObject gameObject = component.projectileObject.Get();
			if (!(gameObject != null))
			{
				return;
			}
			Projectile component2 = gameObject.GetComponent<Projectile>();
			if (!(component2 != null))
			{
				return;
			}
			foreach (DamageTypeEntry damageType in component2.damageTypes)
			{
				num += damageType.amount;
			}
		}
	}

```

## OnEntityDistanceCheck(BaseEntity,BasePlayer,uint,string,float,bool)

```csharp
```csharp
/// <summary>
/// Called to check if a player is within a specified distance of an entity.
/// </summary>
/// <param name="entity">The entity being checked for distance.</param>
/// <param name="player">The player whose distance from the entity is being evaluated.</param>
/// <param name="id">An identifier for the distance check operation.</param>
/// <param name="debugName">A name for debugging purposes.</param>
/// <param name="maximumDistance">The maximum distance allowed for the check.</param>
/// <param name="checkParent">Indicates whether to check the parent entity's distance if the initial check fails.</param>
/// <returns>
/// Returns `true` if the player is within the maximum distance of the entity, or `false` otherwise.
/// If the method returns `null`, the default distance check logic will be used. (bool)
/// </returns>
object OnEntityDistanceCheck(BaseEntity entity, BasePlayer player, uint id, string debugName, float maximumDistance, bool checkParent)
{
    Puts($"Checking distance for Player {player} to Entity {entity} with ID {id} and DebugName {debugName}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance, bool checkParent = false)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityDistanceCheck", ent, player, id, debugName, maximumDistance, checkParent);
				if (obj is bool)
				{
					return (bool)obj;
				}
				bool flag = ent.Distance(player.eyes.position) <= maximumDistance;
				if (checkParent && !flag)
				{
					BaseEntity parentEntity = ent.GetParentEntity();
					flag = parentEntity != null && parentEntity.Distance(player.eyes.position) <= maximumDistance;
				}
				return flag;
			}

```

## OnMapMarkerAdded(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player adds a new marker to the map.
/// </summary>
/// <param name="player">The player who added the map marker.</param>
/// <param name="mapNote">The details of the map marker that was added.</param>
/// <returns>
/// Returns `null` to allow the addition of the marker, or a non-null value to prevent it. (object)
/// </returns>
object OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player} added a map marker: {mapNote}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 13L;
			if (State.pointsOfInterest == null)
			{
				State.pointsOfInterest = Facepunch.Pool.Get<List<MapNote>>();
			}
			if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
			{
				msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());
				return;
			}
			MapNote mapNote = MapNote.Deserialize(msg.read);
			ValidateMapNote(mapNote);
			mapNote.colourIndex = FindUnusedPointOfInterestColour();
			State.pointsOfInterest.Add(mapNote);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, mapNote);
		}
	}

```

## OnDemoRecordingStop(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is stopped for a player.
/// </summary>
/// <param name="filename">The filename of the recorded demo.</param>
/// <param name="player">The player for whom the demo recording is being stopped.</param>
/// <returns>
/// Returns `null` to allow the recording to stop normally, or any non-null value to prevent it from stopping. (object)
/// </returns>
object OnDemoRecordingStop(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped for player {player} with filename: {filename}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnDefaultItemsReceive(PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when default items are being given to a player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory receiving the default items.</param>
/// <returns>
/// Returns a non-null value to prevent the default items from being given. 
/// If `null` is returned, the default items will be added to the inventory. (object)
/// </returns>
object OnDefaultItemsReceive(PlayerInventory inventory)
{
    Puts($"Default items are being received for inventory: {inventory}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);
			}
		}
	}

```

## OnCupboardDeauthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is deauthorized from a cupboard's access.
/// </summary>
/// <param name="cupboard">The cupboard from which the player is being deauthorized.</param>
/// <param name="player">The player being removed from the cupboard's authorization list.</param>
/// <returns>No return behavior.</returns>
void OnCupboardDeauthorize(BuildingPrivlidge cupboard, BasePlayer player)
{
    Puts($"Player {player} has been deauthorized from cupboard {cupboard}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && CanAdministrate(rpc2.player) && Interface.CallHook("OnCupboardDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player can be wounded based on various conditions.
/// </summary>
/// <param name="player">The player being checked for wounding eligibility.</param>
/// <param name="hitInfo">Information about the hit that may cause wounding.</param>
/// <returns>
/// Returns `true` if the player can be wounded; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can be wounded. (bool)
/// </returns>
object CanBeWounded(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Checking if player {player} can be wounded with hit info: {hitInfo}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsWounded())
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (!IsWounded() && UnityEngine.Time.realtimeSinceStartup - lastWoundedStartTime < ConVar.Server.rewounddelay)
		{
			return false;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((bool)activeGameMode && !activeGameMode.allowWounding)
		{
			return false;
		}
		if (triggers != null)
		{
			for (int i = 0; i < triggers.Count; i++)
			{
				if (triggers[i] is IHurtTrigger)
				{
					return false;
				}
			}
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnItemRecycleAmount(Item,int,Recycler)

```csharp
```csharp
/// <summary>
/// Called to determine the amount of an item that can be recycled.
/// </summary>
/// <param name="item">The item being recycled.</param>
/// <param name="amount">The amount of the item to recycle.</param>
/// <param name="recycler">The recycler that is processing the item.</param>
/// <returns>
/// Returns the amount that can be recycled. If the method returns a non-null value, it overrides the default recycling amount. (int)
/// </returns>
object OnItemRecycleAmount(Item item, int amount, Recycler recycler)
{
    Puts($"Recycling {amount} of item {item.info.shortname} at recycler {recycler}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", slot, this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", slot, num3, this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					float num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 *= slot.conditionNormalized;
					}
					float num5 = num / 0.5f;
					num4 *= num5;
					int num6 = Mathf.FloorToInt(num4);
					float num7 = num4 - (float)num6;
					scrapRemainder += num7;
					if (scrapRemainder >= 1f)
					{
						int num8 = Mathf.FloorToInt(scrapRemainder);
						scrapRemainder -= num8;
						num6 += num8;
					}
					if (num6 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num6, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj2 = Facepunch.Pool.Get<List<BasePlayer>>();
					Vis.Entities(base.transform.position, 3f, obj2, 131072);
					foreach (BasePlayer item3 in obj2)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Facepunch.Pool.FreeUnmanaged(ref obj2);
				}
				Facepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;
					int num10 = Mathf.FloorToInt(num9);
					float num11 = num9 - (float)num10;
					if (num11 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num11)
					{
						num10++;
					}
					if (num10 <= 0)
					{
						continue;
					}
					int num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);
					for (int i = 0; i < num12; i++)
					{
						int num13 = ((num10 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);
						Item item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
						if (!MoveItemToOutput(item2))
						{
							flag = true;
						}
						num10 -= num13;
						if (num10 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

```

## OnQueueMessage(Network.Connection,int)

```csharp
```csharp
/// <summary>
/// Called when sending a queue message to a network connection.
/// </summary>
/// <param name="connection">The network connection to which the message is being sent.</param>
/// <param name="position">The position of the player in the queue.</param>
/// <returns>
/// Returns `null` to allow the default message to be sent, or any non-null value to prevent the message from being sent. (object)
/// </returns>
object OnQueueMessage(Network.Connection connection, int position)
{
    Puts($"Sending queue message to connection {connection} with position {position}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendMessage(Connection c, int position)
	{
		if (Interface.CallHook("OnQueueMessage", c, position) == null)
		{
			string empty = string.Empty;
			empty = ((position <= 0) ? string.Format("YOU'RE NEXT - {1:N0} PLAYERS BEHIND YOU", position, queue.Count - position - 1) : $"{position:N0} PLAYERS AHEAD OF YOU, {queue.Count - position - 1:N0} PLAYERS BEHIND");
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.Message);
			netWrite.String("QUEUE");
			netWrite.String(empty);
			netWrite.Send(new SendInfo(c));
		}
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing from the ground, triggering its destruction.
/// </summary>
/// <param name="entity">The entity that is missing from the ground.</param>
/// <returns>
/// Returns `null` to allow the default destruction behavior, or a non-null value to prevent it. (object)
/// </returns>
object OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity} is missing from the ground and will be processed.");
    return null;
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (baseEntity != null && Interface.CallHook("OnEntityGroundMissing", baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}

```

## OnWindmillUpdated(ElectricWindmill)

```csharp
```csharp
/// <summary>
/// Called when the state of the electric windmill is updated.
/// </summary>
/// <param name="windmill">The electric windmill that is being updated.</param>
/// <returns>No return behavior.</returns>
void OnWindmillUpdated(ElectricWindmill windmill)
{
    Puts($"Windmill {windmill} has been updated. Current energy: {windmill.currentEnergy}");
}
```
```

### Source Code from the Library

```csharp

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", this);
		}
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an entity is built in the game world.
/// </summary>
/// <param name="planner">The planner responsible for the building action.</param>
/// <param name="gameObject">The game object that has been built.</param>
/// <returns>No return behavior.</returns>
void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
{
    Puts($"Entity built by {planner} at position {gameObject.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		if (RayEx.IsNaNOrInfinity(target.ray))
		{
			return null;
		}
		if (target.position.IsNaNOrInfinity())
		{
			return null;
		}
		if (target.normal.IsNaNOrInfinity())
		{
			return null;
		}
		Construction.lastPlacementError = "";
		Construction.lastPlacementErrorDebug = "";
		Construction.lastBuildingBlockError = null;
		Construction.lastPlacementErrorIsDetailed = false;
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketNotFemale, false);
				Construction.lastPlacementErrorDebug = target.socket.socketName;
				return null;
			}
			if (target.entity != null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketOccupied, false);
				Construction.lastPlacementErrorDebug = target.socket.socketName;
				return null;
			}
			if (target.onTerrain)
			{
				Construction.lastPlacementErrorDebug = "Target on terrain is not allowed when attaching to socket (" + target.socket.socketName + ")";
				return null;
			}
		}
		Vector3 deployPos = ((target.entity != null && target.socket != null) ? target.GetWorldPosition() : target.position);
		if (AntiHack.TestIsBuildingInsideSomething(target, deployPos))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.InsideObjects, false);
			return null;
		}
		if (ConVar.AntiHack.eye_protection >= 2 && !HasLineOfSight(ownerPlayer, deployPos, target, component))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.LineOfSightBlocked, false);
			return null;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanBuildResult? result = SleepingBag.CanBuildBed(ownerPlayer, component);
			if (HandleCanBuild(result, ownerPlayer))
			{
				return null;
			}
		}
		if (ConVar.Server.max_shelters > 0)
		{
			CanBuildResult? result2 = LegacyShelter.CanBuildShelter(ownerPlayer, component);
			if (HandleCanBuild(result2, ownerPlayer))
			{
				return null;
			}
		}
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			if (!string.IsNullOrEmpty(Construction.lastPlacementError.translated))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, Construction.lastPlacementError, false);
			}
			ConstructionErrors.Log(ownerPlayer, Construction.lastPlacementErrorDebug);
		}
		if (gameObject != null)
		{
			Interface.CallHook("OnEntityBuilt", this, gameObject);
			Deployable deployable = GetDeployable();
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
			if (baseEntity != null && deployable != null)
			{
				if (ShouldParent(target.entity, deployable))
				{
					if (target.socket is Socket_Specific_Female socket_Specific_Female)
					{
						if (socket_Specific_Female.parentToBone)
						{
							baseEntity.SetParent(target.entity, socket_Specific_Female.boneName, worldPositionStays: true);
						}
						else
						{
							baseEntity.SetParent(target.entity, worldPositionStays: true);
						}
					}
					else
					{
						baseEntity.SetParent(target.entity, worldPositionStays: true);
					}
				}
				if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
				{
					(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
				}
				if (deployable.copyInventoryFromItem)
				{
					StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
					if ((bool)component2)
					{
						component2.ReceiveInventoryFromItem(GetOwnerItem());
					}
				}
				ItemModDeployable modDeployable = GetModDeployable();
				if (modDeployable != null)
				{
					modDeployable.OnDeployed(baseEntity, ownerPlayer);
				}
				baseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer, GetOwnerItem());
				if (deployable.placeEffect.isValid)
				{
					if ((bool)target.entity && target.socket != null)
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up);
					}
					else
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, target.position, target.normal);
					}
				}
			}
			if (baseEntity != null)
			{
				Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
				if (GetOwnerItemDefinition() != null)
				{
					ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
					{
						WorldPosition = baseEntity.transform.position,
						UintIdentifier = baseEntity.prefabID,
						IntIdentifier = GetOwnerItemDefinition().itemid
					}, 1f);
				}
			}
			PayForPlacement(ownerPlayer, component);
			return baseEntity;
		}
		return null;
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is assigned to a player from a resource dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser providing the bonus.</param>
/// <param name="player">The player receiving the bonus item.</param>
/// <param name="item">The item being given as a bonus.</param>
/// <returns>
/// Returns a modified item if the hook alters the default behavior; otherwise, returns the original item. (Item)
/// </returns>
object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player} received a bonus item: {item} from dispenser {dispenser}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", this, player, item);
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnBookmarksSendControl(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when sending control bookmarks to a player from a computer station.
/// </summary>
/// <param name="station">The computer station sending the bookmarks.</param>
/// <param name="player">The player receiving the bookmarks.</param>
/// <param name="bookmarks">The generated bookmarks string to be sent.</param>
/// <returns>No return behavior.</returns>
void OnBookmarksSendControl(ComputerStation station, BasePlayer player, string bookmarks)
{
    Puts($"Sending control bookmarks to player {player} from station {station}.");
}
```
```

### Source Code from the Library

```csharp

	public void SendControlBookmarks(BasePlayer player)
	{
		if (!(player == null))
		{
			string text = GenerateControlBookmarkString();
			if (Interface.CallHook("OnBookmarksSendControl", this, player, text) == null)
			{
				ClientRPC(RpcTarget.Player("ReceiveBookmarks", player), text);
			}
		}
	}

```

## OnEntityFlagsNetworkUpdate(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when the network update for entity flags is sent.
/// </summary>
/// <param name="entity">The entity whose flags are being updated.</param>
/// <returns>No return behavior.</returns>
void OnEntityFlagsNetworkUpdate(BaseEntity entity)
{
    Puts($"Network flags updated for entity ID: {entity.net.ID}");
}
```
```

### Source Code from the Library

```csharp

	public void SendNetworkUpdate_Flags()
	{
		if (Rust.Application.isLoading || Rust.Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		using (TimeWarning.New("SendNetworkUpdate_Flags"))
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate_Flags");
			if (Interface.CallHook("OnEntityFlagsNetworkUpdate", this) == null)
			{
				List<Connection> subscribers = GetSubscribers();
				if (subscribers != null && subscribers.Count > 0)
				{
					NetWrite netWrite = Network.Net.sv.StartWrite();
					netWrite.PacketID(Message.Type.EntityFlags);
					netWrite.EntityID(net.ID);
					netWrite.Int32((int)flags);
					SendInfo info = new SendInfo(subscribers);
					netWrite.Send(info);
				}
				base.gameObject.SendOnSendNetworkUpdate(this);
			}
		}
	}

```

## OnWireClear(BasePlayer,IOEntity,int,IOEntity,bool)

```csharp
```csharp
/// <summary>
/// Called when attempting to clear a wire connection from an IOEntity.
/// </summary>
/// <param name="player">The player attempting to clear the wire connection.</param>
/// <param name="entity">The IOEntity from which the wire connection is being cleared.</param>
/// <param name="index">The index of the input or output being cleared.</param>
/// <param name="connectedEntity">The entity that is currently connected to the specified slot.</param>
/// <param name="isInput">Indicates whether the slot being cleared is an input (true) or an output (false).</param>
/// <returns>
/// Returns `true` if the wire connection was successfully cleared; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine the outcome. (bool)
/// </returns>
object OnWireClear(BasePlayer player, IOEntity entity, int index, IOEntity connectedEntity, bool isInput)
{
    Puts($"Player {player} is attempting to clear wire from {entity} at index {index}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)
	{
		IOEntity iOEntity = ((clearEnt != null) ? clearEnt.GetComponent<IOEntity>() : null);
		IOEntity iOEntity2 = (IOEntity)(object)(isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);
		if (((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get() == null)
		{
			return false;
		}
		iOEntity2 = ((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get();
		object obj = Interface.CallHook("OnWireClear", ply, iOEntity, clearIndex, iOEntity2, isInput);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (iOEntity == null)
		{
			return false;
		}
		if (ply != null && !CanModifyEntity(ply, iOEntity))
		{
			return false;
		}
		return iOEntity.Disconnect(clearIndex, isInput);
	}

```

## OnEntityControl(PoweredRemoteControlEntity,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can control the powered remote control entity.
/// </summary>
/// <param name="entity">The powered remote control entity being controlled.</param>
/// <param name="playerId">The ID of the player attempting to control the entity.</param>
/// <returns>
/// Returns `true` if the player can control the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine control eligibility. (bool)
/// </returns>
object OnEntityControl(PoweredRemoteControlEntity entity, ulong playerId)
{
    Puts($"Player {playerId} is attempting to control entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", this, playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsPowered())
		{
			return IsStatic();
		}
		return true;
	}

```

## OnLockRemove(ModularCar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a lock is removed from a modular car by a player.
/// </summary>
/// <param name="car">The modular car from which the lock is being removed.</param>
/// <param name="player">The player attempting to remove the lock.</param>
/// <returns>
/// Returns `null` to allow the lock removal, or any non-null value to prevent it. (object)
/// </returns>
object OnLockRemove(ModularCar car, BasePlayer player)
{
    Puts($"Player {player} is attempting to remove the lock from car {car}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_RequestRemoveLock(RPCMessage msg)
	{
		if (HasOccupant && carOccupant.CarLock.HasALock && Interface.CallHook("OnLockRemove", carOccupant, msg.player) == null)
		{
			carOccupant.CarLock.RemoveLock();
			Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

```

## OnBroadcastCommand(string,object[])

```csharp
```csharp
/// <summary>
/// Called when a broadcast command is issued to all clients.
/// </summary>
/// <param name="command">The command string to be broadcasted.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>
/// Returns `null` to allow the command to be broadcasted, or any non-null value to prevent the broadcast. (object)
/// </returns>
object OnBroadcastCommand(string command, object[] args)
{
    Puts($"Broadcasting command: {command} with arguments: {string.Join(", ", args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void BroadcastToAllClients(string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnBroadcastCommand", strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			netWrite.String(ConsoleSystem.BuildCommand(strCommand, args));
			netWrite.Send(new SendInfo(Network.Net.sv.connections));
		}
	}

```

## CanUnlock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a code lock.
/// </summary>
/// <param name="player">The player attempting to unlock the code lock.</param>
/// <param name="codeLock">The code lock being unlocked.</param>
/// <returns>
/// Returns `true` if the player can unlock the code lock, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can unlock it. (bool)
/// </returns>
object CanUnlock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player} is attempting to unlock the code lock.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && !IsCodeEntryBlocked() && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnComposterUpdate(Composter)

```csharp
```csharp
/// <summary>
/// Called to update the composting process in the composter.
/// </summary>
/// <param name="composter">The composter that is being updated.</param>
/// <returns>No return behavior.</returns>
void OnComposterUpdate(Composter composter)
{
    Puts($"Updating composting process for composter: {composter}.");
}
```
```

### Source Code from the Library

```csharp

	public void UpdateComposting()
	{
		if (Interface.CallHook("OnComposterUpdate", this) != null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				CompostItem(slot);
			}
		}
	}

```

## OnTakeCurrencyItem(VendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called when a currency item is taken from the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the currency item is taken.</param>
/// <param name="currencyItem">The currency item that is being taken.</param>
/// <returns>No return behavior.</returns>
void OnTakeCurrencyItem(VendingMachine vendingMachine, Item currencyItem)
{
    Puts($"Currency item {currencyItem} taken from vending machine {vendingMachine}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null && !takenCurrencyItem.MoveToContainer(base.inventory))
		{
			takenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);
		}
	}

```

## OnXmasGiftsDistribute(XMasRefill,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to distribute Christmas gifts to a specified player.
/// </summary>
/// <param name="xmasRefill">The reference object for the Christmas gift distribution.</param>
/// <param name="player">The player receiving the gifts.</param>
/// <returns>
/// Returns `false` if the distribution is canceled by the hook; otherwise, returns `true` if gifts were successfully distributed.
/// </returns>
bool OnXmasGiftsDistribute(XMasRefill xmasRefill, BasePlayer player)
{
    Puts($"Distributing Christmas gifts to player {player}.");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool DistributeGiftsForPlayer(BasePlayer player)
	{
		if (Interface.CallHook("OnXmasGiftsDistribute", this, player) != null)
		{
			return false;
		}
		int num = GiftsPerPlayer();
		int num2 = GiftSpawnAttempts();
		for (int i = 0; i < num2; i++)
		{
			if (num <= 0)
			{
				break;
			}
			Vector2 vector = UnityEngine.Random.insideUnitCircle * GiftRadius();
			Vector3 pos = player.transform.position + new Vector3(vector.x, 10f, vector.y);
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			if (DropToGround(ref pos))
			{
				string resourcePath = giftPrefabs[UnityEngine.Random.Range(0, giftPrefabs.Length)].resourcePath;
				BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);
				if ((bool)baseEntity)
				{
					baseEntity.Spawn();
					num--;
				}
			}
		}
		return true;
	}

```

## OnFuelItemCheck(EntityFuelSystem,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to check which fuel item is available in the fuel container.
/// </summary>
/// <param name="fuelSystem">The entity fuel system that is checking for fuel.</param>
/// <param name="container">The storage container being checked for fuel items.</param>
/// <returns>
/// Returns the fuel item if found; otherwise, returns `null`. If the hook returns a non-null item, that item will be used as the fuel. (Item)
/// </returns>
object OnFuelItemCheck(EntityFuelSystem fuelSystem, StorageContainer container)
{
    Puts($"Checking fuel item for {fuelSystem} in container {container}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public Item GetFuelItem()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("OnFuelItemCheck", this, fuelContainer);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (fuelContainer == null)
		{
			return null;
		}
		return fuelContainer.inventory.GetSlot(0);
	}

```

## OnItemRefill(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is being refilled by a player.
/// </summary>
/// <param name="item">The item that is being refilled.</param>
/// <param name="player">The player who is refilling the item.</param>
/// <returns>
/// Returns `null` to allow the refill to proceed, or any non-null value to prevent the refill action. (object)
/// </returns>
object OnItemRefill(Item item, BasePlayer player)
{
    Puts($"Player {player} is attempting to refill item: {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", item, player) == null)
		{
			float conditionNormalized = item.conditionNormalized;
			float maxConditionNormalized = item.maxConditionNormalized;
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
			Facepunch.Rust.Analytics.Azure.OnItemRepaired(player, player.GetCachedCraftLevelWorkbench(), item, conditionNormalized, maxConditionNormalized);
		}
	}

```

## OnRackedWeaponUnloaded(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is unloaded from a weapon rack.
/// </summary>
/// <param name="item">The item representing the weapon being unloaded.</param>
/// <param name="player">The player who is unloading the weapon.</param>
/// <param name="weaponRack">The weapon rack from which the weapon is being unloaded.</param>
/// <returns>
/// Returns a non-null value to prevent the weapon from being unloaded; otherwise, returns null to allow the action. (object)
/// </returns>
object OnRackedWeaponUnloaded(Item item, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Weapon {item} is being unloaded by player {player} from rack {weaponRack}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", slot, player, this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity == null))
		{
			BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
			if (!(component == null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", slot, player, this);
			}
		}
	}

```

## OnMlrsTarget(MLRS,UnityEngine.Vector3,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when setting the target position for the MLRS (Multiple Launch Rocket System).
/// </summary>
/// <param name="mlrs">The MLRS instance that is being targeted.</param>
/// <param name="targetPosition">The world position that is being set as the target.</param>
/// <param name="player">The player who is setting the target.</param>
/// <returns>
/// Returns `null` to allow the target position to be set, or any non-null value to prevent it. (object)
/// </returns>
object OnMlrsTarget(MLRS mlrs, Vector3 targetPosition, BasePlayer player)
{
    Puts($"MLRS targeting position set by {player} at {targetPosition}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 vector = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", this, worldPos, _mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Vector3 center = allSafeZone.triggerCollider.bounds.center;
				center.y = 0f;
				float num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 vector2 = trueTargetHitPos - center;
					trueTargetHitPos = center + vector2.normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", this, trueTargetHitPos, _mounted);
	}

```

## OnHelicopterOutOfCrates(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if the helicopter has run out of crates to drop.
/// </summary>
/// <param name="helicopter">The helicopter AI controller checking for crates.</param>
/// <returns>
/// Returns `true` if the helicopter is out of crates; otherwise, returns `false`.
/// If the method returns `null`, the default logic will be used to determine the crate status. (bool)
/// </returns>
object OnHelicopterOutOfCrates(CH47HelicopterAIController helicopter)
{
    Puts($"Checking crate status for helicopter {helicopter}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

```

## OnNpcAlert(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC is alerted to a situation or event.
/// </summary>
/// <param name="npc">The NPC that is being alerted.</param>
/// <returns>
/// Returns `null` to allow the default alert behavior, or any non-null value to prevent the alert from occurring.
/// </returns>
object OnNpcAlert(ScientistNPC npc)
{
    Puts($"NPC {npc} has been alerted.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Alert()
	{
		if (Interface.CallHook("OnNpcAlert", this) == null)
		{
			lastAlertedTime = Time.time;
			SetChatterType(RadioChatterType.Alert);
		}
	}

```

## OnCupboardClearList(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the list of authorized players in a cupboard is cleared.
/// </summary>
/// <param name="cupboard">The building privilege cupboard being cleared.</param>
/// <param name="player">The player who initiated the clear action.</param>
/// <returns>No return behavior.</returns>
void OnCupboardClearList(BuildingPrivlidge cupboard, BasePlayer player)
{
    Puts($"Clearing authorized player list for cupboard owned by {player}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player) && Interface.CallHook("OnCupboardClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnInterferenceUpdate(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to update the interference status of the auto turret.
/// </summary>
/// <param name="turret">The auto turret that is checking for interference.</param>
/// <returns>No return behavior.</returns>
void OnInterferenceUpdate(AutoTurret turret)
{
    Puts($"Updating interference for turret ID: {turret.net.ID}");
}
```
```

### Source Code from the Library

```csharp

	public void UpdateInterference()
	{
		if (!IsOn() || Interface.CallHook("OnInterferenceUpdate", this) != null)
		{
			return;
		}
		float num = 0f;
		foreach (AutoTurret nearbyTurret in nearbyTurrets)
		{
			if (!nearbyTurret.isClient && nearbyTurret.IsValid() && nearbyTurret.gameObject.activeSelf && !nearbyTurret.EqualNetID(net.ID) && nearbyTurret.IsOn() && !nearbyTurret.HasInterference())
			{
				num += 1f;
			}
		}
		SetFlag(Flags.OnFire, num >= (float)Sentry.maxinterference);
	}

```

## OnIngredientsCollect(ItemCrafter,ItemBlueprint,ItemCraftTask,int,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when ingredients are collected for crafting an item.
/// </summary>
/// <param name="crafter">The item crafter collecting the ingredients.</param>
/// <param name="blueprint">The blueprint for the item being crafted.</param>
/// <param name="task">The crafting task associated with the collection.</param>
/// <param name="amount">The amount of items to craft.</param>
/// <param name="player">The player who is crafting the item, if applicable.</param>
/// <returns>No return behavior.</returns>
void OnIngredientsCollect(ItemCrafter crafter, ItemBlueprint blueprint, ItemCraftTask task, int amount, BasePlayer player)
{
    Puts($"Ingredients collected for crafting {blueprint} by {player}.");
}
```
```

### Source Code from the Library

```csharp

	public void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null)
	{
		if (Interface.CallHook("OnIngredientsCollect", this, bp, task, amount, player) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			CollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list);
		}
		foreach (Item item in list)
		{
			item.CollectedForCrafting(player);
		}
		task.takenItems = list;
	}

```

## OnEngineStatsRefresh(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called to refresh the performance statistics of a vehicle engine.
/// </summary>
/// <param name="engine">The vehicle engine module whose stats are being refreshed.</param>
/// <param name="engineStorage">The storage containing the engine's performance data.</param>
/// <returns>No return behavior.</returns>
void OnEngineStatsRefresh(VehicleModuleEngine engine, Rust.Modular.EngineStorage engineStorage)
{
    Puts($"Refreshing engine stats for {engine} with storage: {engineStorage}.");
}
```
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## CanSwapToSeat(BasePlayer,ModularCarSeat)

```csharp
```csharp
/// <summary>
/// Determines whether a player can swap to a specific seat in a modular car.
/// </summary>
/// <param name="player">The player attempting to swap seats.</param>
/// <param name="seat">The seat the player wants to swap to.</param>
/// <returns>
/// Returns `true` if the player can swap to the seat; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the player can swap seats. (bool)
/// </returns>
object CanSwapToSeat(BasePlayer player, ModularCarSeat seat)
{
    Puts($"Player {player} is attempting to swap to seat {seat}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (associatedSeatingModule.DoorsAreLockable)
		{
			ModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;
			if (modularCar != null)
			{
				return modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
			}
		}
		return true;
	}

```

## OnHuntEventStart(EggHuntEvent)

```csharp
```csharp
/// <summary>
/// Called when the egg hunt event starts.
/// </summary>
/// <param name="event">The egg hunt event that is starting.</param>
/// <returns>
/// Returns `null` to allow the event to start normally. Any non-null value will prevent the event from starting. (object)
/// </returns>
object OnHuntEventStart(EggHuntEvent event)
{
    Puts($"Egg hunt event starting: {event}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void StartEvent()
	{
		if (Interface.CallHook("OnHuntEventStart", this) == null)
		{
			if (initialSpawnIndex <= BasePlayer.activePlayerList.Count)
			{
				eggSpawningFrameBudget = float.PositiveInfinity;
			}
			EnableEggs();
		}
	}

```

## OnVehicleModuleSelected(Item,ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player selects a module from a vehicle's garage.
/// </summary>
/// <param name="item">The item representing the selected vehicle module.</param>
/// <param name="garage">The modular car garage from which the module is selected.</param>
/// <param name="player">The player who selected the module.</param>
/// <returns>
/// Returns a non-null value to prevent the default selection behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnVehicleModuleSelected(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player} selected module {item} from garage {garage}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!ObjectEx.IsUnityNull(container))
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!ObjectEx.IsUnityNull(container2))
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## OnPlayerReported(BasePlayer,string,string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player reports another player.
/// </summary>
/// <param name="reporter">The player who is making the report.</param>
/// <param name="reportMessage">The message detailing the report.</param>
/// <param name="reportType">The type of report being made.</param>
/// <param name="targetId">The ID of the player being reported.</param>
/// <param name="targetName">The name of the player being reported.</param>
/// <param name="additionalInfo">Any additional information related to the report.</param>
/// <returns>No return behavior.</returns>
void OnPlayerReported(BasePlayer reporter, string reportMessage, string reportType, string targetId, string targetName, string additionalInfo)
{
    Puts($"Player {reporter} reported {targetName} (ID: {targetId}) with message: \"{reportMessage}\".");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnPlayerReported(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		string text3 = msg.read.String();
		string text4 = msg.read.String();
		string text5 = msg.read.String();
		DebugEx.Log($"[PlayerReport] {this} reported {text5}[{text4}] - \"{text}\"");
		RCon.Broadcast(RCon.LogType.Report, new
		{
			PlayerId = UserIDString,
			PlayerName = displayName,
			TargetId = text4,
			TargetName = text5,
			Subject = text,
			Message = text2,
			Type = text3
		});
		Interface.CallHook("OnPlayerReported", this, text5, text4, text, text2, text3);
	}

```

## OnPhotoCapture(PhotoEntity,Item,BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a photo is captured by a player.
/// </summary>
/// <param name="photoEntity">The photo entity that is being created.</param>
/// <param name="item">The item used to capture the photo.</param>
/// <param name="player">The player who captured the photo.</param>
/// <param name="imageData">The byte array containing the image data of the photo.</param>
/// <returns>
/// Returns a non-null value to override the default photo capture behavior. If `null` is returned, the photo capture proceeds as normal. (object)
/// </returns>
object OnPhotoCapture(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] imageData)
{
    Puts($"Player {player} captured a photo with item {item}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.FromOwner]
	private void TakePhoto(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Item item = GetItem();
		if (player == null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError("Failed to create photo item");
			return;
		}
		if (!item2.instanceData.subEntity.IsValid)
		{
			item2.Remove();
			Debug.LogError("Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if (baseNetworkable == null)
		{
			item2.Remove();
			Debug.LogError("Sub-entity was not found");
			return;
		}
		if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError("Sub-entity is not a photo");
			return;
		}
		photoEntity.SetImageData(player.userID, array);
		if (Interface.CallHook("OnPhotoCapture", photoEntity, item, player, array) != null)
		{
			return;
		}
		if (!player.inventory.GiveItem(item2))
		{
			item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
		}
		EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));
		if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
		{
			Vector3 position = GetOwnerPlayer().eyes.position;
			Vector3 vector = GetOwnerPlayer().eyes.HeadForward();
			List<BasePlayer> obj = Facepunch.Pool.Get<List<BasePlayer>>();
			Vis.Entities(position + vector * 5f, 5f, obj, 131072);
			foreach (BasePlayer item3 in obj)
			{
				if (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
				{
					hasSentAchievement = true;
					GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
					break;
				}
			}
			Facepunch.Pool.FreeUnmanaged(ref obj);
		}
		item.LoseCondition(1f);
		Interface.CallHook("OnPhotoCaptured", photoEntity, item, player, array);
	}

```

## CanExplosiveStick(TimedExplosive,BaseEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the explosive can stick to the specified entity.
/// </summary>
/// <param name="explosive">The timed explosive attempting to stick.</param>
/// <param name="entity">The entity to which the explosive is trying to stick.</param>
/// <returns>
/// Returns `true` if the explosive can stick to the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the explosive can stick. (bool)
/// </returns>
object CanExplosiveStick(TimedExplosive explosive, BaseEntity entity)
{
    Puts($"Checking if explosive can stick to entity: {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanStickTo(BaseEntity entity)
	{
		object obj = Interface.CallHook("CanExplosiveStick", this, entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (entity.TryGetComponent<DecorDeployable>(out var _))
		{
			return false;
		}
		if (entity is Drone)
		{
			return false;
		}
		if (entity is TravellingVendor)
		{
			return false;
		}
		return true;
	}

```

## OnVehicleLockableCheck(ModularCarCodeLock)

```csharp
```csharp
/// <summary>
/// Called to check if a vehicle can have a lock applied to it.
/// </summary>
/// <param name="vehicle">The vehicle being checked for lockability.</param>
/// <returns>
/// Returns `true` if the vehicle can have a lock, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the vehicle can be locked. (bool)
/// </returns>
object OnVehicleLockableCheck(ModularCarCodeLock vehicle)
{
    Puts($"Checking if vehicle {vehicle} can have a lock.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanHaveALock()
	{
		object obj = Interface.CallHook("OnVehicleLockableCheck", this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		if (!owner.IsDead())
		{
			return owner.HasDriverMountPoints();
		}
		return false;
	}

```

## CanAdministerVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Determines whether a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine in question.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine the player's ability to administer. (bool)
/// </returns>
object CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Checking if player {player} can administer vending machine {vendingMachine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

```

## OnItemResearched(ResearchTable,int)

```csharp
```csharp
/// <summary>
/// Called when an item has been successfully researched at a research table.
/// </summary>
/// <param name="researchTable">The research table where the item was researched.</param>
/// <param name="scrapUsed">The amount of scrap used for the research.</param>
/// <returns>
/// Returns the amount of scrap used for the research, which can be modified by the hook. (int)
/// </returns>
object OnItemResearched(ResearchTable researchTable, int scrapUsed)
{
    Puts($"Item researched at {researchTable}: {scrapUsed} scrap used.");
    return scrapUsed;
}
```
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", this, num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount == num)
				{
					base.inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				base.inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
				item.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);
				if (!item.MoveToContainer(base.inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## OnPhotoCaptured(PhotoEntity,Item,BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a photo is captured by a player.
/// </summary>
/// <param name="photoEntity">The photo entity that holds the captured image data.</param>
/// <param name="item">The item used to capture the photo.</param>
/// <param name="player">The player who captured the photo.</param>
/// <param name="imageData">The byte array containing the image data of the captured photo.</param>
/// <returns>
/// Returns a non-null value to override the default behavior after a photo is captured. 
/// If `null` is returned, the default behavior will proceed. (object)
/// </returns>
object OnPhotoCaptured(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] imageData)
{
    Puts($"Photo captured by {player} with item {item}. Image data size: {imageData.Length} bytes.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.FromOwner]
	private void TakePhoto(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Item item = GetItem();
		if (player == null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError("Failed to create photo item");
			return;
		}
		if (!item2.instanceData.subEntity.IsValid)
		{
			item2.Remove();
			Debug.LogError("Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if (baseNetworkable == null)
		{
			item2.Remove();
			Debug.LogError("Sub-entity was not found");
			return;
		}
		if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError("Sub-entity is not a photo");
			return;
		}
		photoEntity.SetImageData(player.userID, array);
		if (Interface.CallHook("OnPhotoCapture", photoEntity, item, player, array) != null)
		{
			return;
		}
		if (!player.inventory.GiveItem(item2))
		{
			item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
		}
		EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));
		if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
		{
			Vector3 position = GetOwnerPlayer().eyes.position;
			Vector3 vector = GetOwnerPlayer().eyes.HeadForward();
			List<BasePlayer> obj = Facepunch.Pool.Get<List<BasePlayer>>();
			Vis.Entities(position + vector * 5f, 5f, obj, 131072);
			foreach (BasePlayer item3 in obj)
			{
				if (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
				{
					hasSentAchievement = true;
					GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
					break;
				}
			}
			Facepunch.Pool.FreeUnmanaged(ref obj);
		}
		item.LoseCondition(1f);
		Interface.CallHook("OnPhotoCaptured", photoEntity, item, player, array);
	}

```

## OnRemoveDying(GrowableEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a dying growable entity is removed.
/// </summary>
/// <param name="entity">The growable entity that is being removed.</param>
/// <param name="receiver">The player receiving the item from the removed entity.</param>
/// <returns>No return behavior.</returns>
void OnRemoveDying(GrowableEntity entity, BasePlayer receiver)
{
    Puts($"Removing dying entity: {entity} for player: {receiver}.");
}
```
```

### Source Code from the Library

```csharp

	public void RemoveDying(BasePlayer receiver)
	{
		if (State == PlantProperties.State.Dying && !(Properties.removeDyingItem == null) && Interface.CallHook("OnRemoveDying", this, receiver) == null)
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, Vector3.up);
			}
			Item item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);
			if (receiver != null)
			{
				receiver.GiveItem(item, GiveItemReason.PickedUp);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
			}
			TellPlanter();
			Die();
		}
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player performs an attack.
/// </summary>
/// <param name="player">The player who is attacking.</param>
/// <param name="hitInfo">Information about the attack, including the target and damage details.</param>
/// <returns>
/// Returns a non-null value to prevent the default attack behavior; otherwise, returns null to allow the attack to proceed. (object)
/// </returns>
object OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player} is attacking with HitInfo: {hitInfo}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", GetOwnerPlayer(), info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (info.DoHitEffects)
		{
			if (base.isServer)
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.server.ImpactEffect(info);
				}
			}
			else
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.client.ImpactEffect(info);
				}
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay);
		}
	}

```

## OnMlrsFired(MLRS,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the Multiple Launch Rocket System (MLRS) has fired rockets.
/// </summary>
/// <param name="mlrs">The MLRS that has been fired.</param>
/// <param name="owner">The player who owns the MLRS.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFired(MLRS mlrs, BasePlayer owner)
{
    Puts($"MLRS fired by player {owner} with ID {owner.userID}.");
}
```
```

### Source Code from the Library

```csharp

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !(_mounted == null) && Interface.CallHook("OnMlrsFire", this, owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			InvokeRepeating(FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", this, owner);
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="codeLock">The code lock associated with the entity.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can use the entity. (bool)
/// </returns>
object CanUseLockedEntity(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player} is attempting to use locked entity with CodeLock: {codeLock}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player finishes looting an entity or container.
/// </summary>
/// <param name="loot">The loot object associated with the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot loot)
{
    Puts($"Player has finished looting: {loot}.");
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		base.baseEntity.HasClosedLoot();
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		ClearContainers();
		entitySource = null;
		itemSource = null;
	}

```

## CanBeHomingTargeted(AttackHeliPilotFlare)

```csharp
```csharp
/// <summary>
/// Determines whether the specified attack helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="heli">The attack helicopter to check.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the helicopter can be targeted. (bool)
/// </returns>
object CanBeHomingTargeted(AttackHeliPilotFlare heli)
{
    Puts($"Checking homing target for Attack Helicopter ID: {heli.net.ID}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnRemoteIdentifierUpdate(PoweredRemoteControlEntity,string)

```csharp
```csharp
/// <summary>
/// Called when the identifier of a powered remote control entity is updated.
/// </summary>
/// <param name="remoteControl">The powered remote control entity whose identifier is being updated.</param>
/// <param name="newIdentifier">The new identifier being set.</param>
/// <returns>
/// Returns a non-null value to prevent the identifier from being updated; otherwise, returns null to allow the update. (object)
/// </returns>
object OnRemoteIdentifierUpdate(PoweredRemoteControlEntity remoteControl, string newIdentifier)
{
    Puts($"Updating remote control identifier for {remoteControl} to {newIdentifier}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		if (Interface.CallHook("OnRemoteIdentifierUpdate", this, newID) != null)
		{
			return;
		}
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!RemoteControlEntity.IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			if (!Rust.Application.isLoadingSave)
			{
				SendNetworkUpdate();
			}
		}
	}

```

## OnEntitySnapshot(BaseNetworkable,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when sending a snapshot of an entity to a network connection.
/// </summary>
/// <param name="entity">The entity being sent in the snapshot.</param>
/// <param name="connection">The network connection to which the snapshot is being sent.</param>
/// <returns>
/// Returns a non-null value to prevent the default snapshot behavior; otherwise, returns null to proceed with sending the snapshot. (object)
/// </returns>
object OnEntitySnapshot(BaseNetworkable entity, Network.Connection connection)
{
    Puts($"Sending snapshot for entity {entity} to connection {connection}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendEntitySnapshot(BaseNetworkable ent)
	{
		if (Interface.CallHook("OnEntitySnapshot", ent, net.connection) != null)
		{
			return;
		}
		using (TimeWarning.New("SendEntitySnapshot"))
		{
			if (!(ent == null) && ent.net != null && ent.ShouldNetworkTo(this))
			{
				NetWrite netWrite = Network.Net.sv.StartWrite();
				net.connection.validate.entityUpdates++;
				SaveInfo saveInfo = default(SaveInfo);
				saveInfo.forConnection = net.connection;
				saveInfo.forDisk = false;
				SaveInfo saveInfo2 = saveInfo;
				netWrite.PacketID(Message.Type.Entities);
				netWrite.UInt32(net.connection.validate.entityUpdates);
				ent.ToStreamForNetwork(netWrite, saveInfo2);
				netWrite.Send(new SendInfo(net.connection));
			}
		}
	}

```

## OnTurretIdentifierSet(AutoTurret,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when the identifier for a turret is set by a player.
/// </summary>
/// <param name="turret">The turret whose identifier is being set.</param>
/// <param name="player">The player setting the turret's identifier.</param>
/// <param name="newIdentifier">The new identifier being set for the turret.</param>
/// <returns>
/// Returns `null` to allow the identifier change, or any non-null value to prevent it. (object)
/// </returns>
object OnTurretIdentifierSet(AutoTurret turret, BasePlayer player, string newIdentifier)
{
    Puts($"Player {player} is setting turret identifier to: {newIdentifier}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Server_SetID(RPCMessage msg)
	{
		if (msg.player == null || !CanChangeID(msg.player))
		{
			return;
		}
		string text = msg.read.String();
		if (string.IsNullOrEmpty(text) || ComputerStation.IsValidIdentifier(text))
		{
			string text2 = msg.read.String();
			if (ComputerStation.IsValidIdentifier(text2) && text == GetIdentifier() && Interface.CallHook("OnTurretIdentifierSet", this, msg.player, text2) == null)
			{
				Debug.Log("SetID success!");
				UpdateIdentifier(text2);
			}
		}
	}

```

## OnPlayerKeepAlive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a keep-alive message while wounded.
/// </summary>
/// <param name="woundedPlayer">The player who is currently wounded.</param>
/// <param name="interactingPlayer">The player sending the keep-alive message.</param>
/// <returns>
/// Returns `null` to allow the default behavior of prolonging the wounding; 
/// any non-null value will prevent the prolonging action. (object)
/// </returns>
object OnPlayerKeepAlive(BasePlayer woundedPlayer, BasePlayer interactingPlayer)
{
    Puts($"Player {interactingPlayer} sent a keep-alive for wounded player {woundedPlayer}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_KeepAlive(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerKeepAlive", this, msg.player) == null)
		{
			ProlongWounding(10f);
		}
	}

```

## OnCargoPlaneSignaled(BaseEntity,SupplySignal)

```csharp
```csharp
/// <summary>
/// Called when a cargo plane is signaled to drop supplies.
/// </summary>
/// <param name="entity">The entity that triggered the cargo plane signal.</param>
/// <param name="supplySignal">The supply signal that was used to signal the cargo plane.</param>
/// <returns>No return behavior.</returns>
void OnCargoPlaneSignaled(BaseEntity entity, SupplySignal supplySignal)
{
    Puts($"Cargo plane signaled by {entity} with signal: {supplySignal}.");
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		BaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);
		if ((bool)baseEntity)
		{
			Vector3 vector = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));
			baseEntity.SendMessage("InitDropPosition", base.transform.position + vector, SendMessageOptions.DontRequireReceiver);
			baseEntity.Spawn();
			Interface.CallHook("OnCargoPlaneSignaled", baseEntity, this);
		}
		Invoke(FinishUp, 210f);
		SetFlag(Flags.On, b: true);
		SendNetworkUpdateImmediate();
	}

```

## OnBigWheelWin(BigWheelGame,Item,BigWheelBettingTerminal,int)

```csharp
```csharp
/// <summary>
/// Called when a player wins on the Big Wheel game.
/// </summary>
/// <param name="game">The Big Wheel game instance.</param>
/// <param name="item">The item associated with the win.</param>
/// <param name="terminal">The betting terminal where the win occurred.</param>
/// <param name="multiplier">The multiplier applied to the win.</param>
/// <returns>
/// Returns `null` to allow the default payout behavior, or a non-null value to override it. (object)
/// </returns>
object OnBigWheelWin(BigWheelGame game, Item item, BigWheelBettingTerminal terminal, int multiplier)
{
    Puts($"Player won on Big Wheel! Item: {item}, Multiplier: {multiplier} at terminal: {terminal}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) == null)
				{
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanEntityBeHostile(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the entity can be considered hostile.
/// </summary>
/// <param name="player">The player to check against the entity's hostility.</param>
/// <returns>
/// Returns `true` if the entity is hostile; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine the entity's hostility. (bool)
/// </returns>
object CanEntityBeHostile(BasePlayer player)
{
    Puts($"Checking hostility for entity {this} against player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return State.unHostileTimestamp > TimeEx.currentTimestamp;
	}

```

## OnSamSiteModeToggle(SamSite,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when the mode of a SAM site is toggled by a player.
/// </summary>
/// <param name="samSite">The SAM site whose mode is being toggled.</param>
/// <param name="player">The player who is toggling the mode.</param>
/// <param name="isDefenderMode">Indicates whether the SAM site is being set to defender mode.</param>
/// <returns>
/// Returns `null` to allow the mode toggle, or a non-null value to prevent it. (object)
/// </returns>
object OnSamSiteModeToggle(SamSite samSite, BasePlayer player, bool isDefenderMode)
{
    Puts($"SAM Site mode toggled by {player} to {(isDefenderMode ? "Defender" : "Offensive")} mode.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	private void ToggleDefenderMode(RPCMessage msg)
	{
		if (staticRespawn)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!(player == null) && player.CanBuild())
		{
			bool flag = msg.read.Bit();
			if (flag != IsInDefenderMode() && Interface.CallHook("OnSamSiteModeToggle", this, player, flag) == null)
			{
				SetFlag(Flag_ManuallySetMode, flag);
				SetFlag(Flag_TargetMode, flag);
			}
		}
	}

```

## OnHelicopterAttack(CH47HelicopterAIController,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when the helicopter is attacked.
/// </summary>
/// <param name="helicopter">The helicopter that is being attacked.</param>
/// <param name="hitInfo">Information about the hit, including damage and source.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterAttack(CH47HelicopterAIController helicopter, HitInfo hitInfo)
{
    Puts($"Helicopter {helicopter} is under attack with damage: {hitInfo.damage} from {hitInfo.Initiator}.");
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttack", this, info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved9, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

```

## OnSleepingBagDestroyed(SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The sleeping bag that is being destroyed.</param>
/// <param name="userId">The user ID of the player who owns the sleeping bag.</param>
/// <returns>No return behavior.</returns>
void OnSleepingBagDestroyed(SleepingBag sleepingBag, ulong userId)
{
    Puts($"Sleeping bag {sleepingBag} owned by user {userId} has been destroyed.");
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) => x.net.ID == sleepingBag);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, userID) != null)
		{
			return false;
		}
		RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
		sleepingBag2.deployerUserID = 0uL;
		sleepingBag2.SendNetworkUpdate();
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if (basePlayer != null)
		{
			basePlayer.SendRespawnOptions();
			Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, userID);
			Facepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
		}
		return true;
	}

```

## CanAdministerVending(BasePlayer,NPCVendingMachine)

```csharp
```csharp
/// <summary>
/// Determines whether a player can administer the specified vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine in question.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine the administration rights. (bool)
/// </returns>
object CanAdministerVending(BasePlayer player, NPCVendingMachine vendingMachine)
{
    Puts($"Checking administration rights for player {player} on vending machine {vendingMachine}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret is set to target a new entity.
/// </summary>
/// <param name="helicopter">The helicopter turret that is acquiring a new target.</param>
/// <param name="target">The new target entity that the helicopter turret will focus on.</param>
/// <returns>
/// Returns a non-null value to prevent the helicopter from targeting the specified entity; otherwise, returns `null` to allow the targeting. (object)
/// </returns>
object OnHelicopterTarget(HelicopterTurret helicopter, BaseCombatEntity target)
{
    Puts($"Helicopter {helicopter} is attempting to target {target}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## OnFishCaught(ItemDefinition,BaseFishingRod,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a fish is caught by a player using a fishing rod.
/// </summary>
/// <param name="fish">The item definition of the caught fish.</param>
/// <param name="fishingRod">The fishing rod used to catch the fish.</param>
/// <param name="player">The player who caught the fish.</param>
/// <returns>
/// Returns a modified item if the hook alters the default behavior; otherwise, returns the original fish item. (Item)
/// </returns>
object OnFishCaught(ItemDefinition fish, BaseFishingRod fishingRod, BasePlayer player)
{
    Puts($"Player {player} caught a fish: {fish.shortname} using {fishingRod}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine if a world projectile can be created based on the hit information and item definition.
/// </summary>
/// <param name="info">The hit information related to the projectile creation.</param>
/// <param name="itemDef">The item definition of the projectile being created.</param>
/// <returns>
/// Returns `true` if the projectile can be created; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will be used to determine if the projectile can be created. (bool)
/// </returns>
object CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
{
    Puts($"Checking if world projectile can be created with item {itemDef} at hit position {info.HitPositionWorld}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if (droppedItem != null)
			{
				droppedItem.StickIn();
			}
			else
			{
				baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			Rigidbody component = baseEntity.GetComponent<Rigidbody>();
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## OnInventoryItemsCount(PlayerInventory,int)

```csharp
```csharp
/// <summary>
/// Called to get the count of a specific item in the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory being checked.</param>
/// <param name="itemId">The ID of the item to count.</param>
/// <returns>
/// Returns the number of items in the inventory with the specified ID. 
/// If the hook returns a non-null value, that value will be used instead. (int)
/// </returns>
object OnInventoryItemsCount(PlayerInventory inventory, int itemId)
{
    Puts($"Counting items in inventory for item ID: {itemId}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int GetAmount(int itemid)
	{
		if (itemid == 0)
		{
			return 0;
		}
		object obj = Interface.CallHook("OnInventoryItemsCount", this, itemid);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerWear != null)
		{
			num += containerWear.GetAmount(itemid, onlyUsableAmounts: true);
		}
		return num;
	}

```

## OnMlrsRocketFired(MLRS,ServerProjectile)

```csharp
```csharp
/// <summary>
/// Called when a rocket is fired from the MLRS (Multiple Launch Rocket System).
/// </summary>
/// <param name="mlrs">The MLRS instance that fired the rocket.</param>
/// <param name="projectile">The projectile that was fired.</param>
/// <returns>No return behavior.</returns>
void OnMlrsRocketFired(MLRS mlrs, ServerProjectile projectile)
{
    Puts($"Rocket fired from MLRS {mlrs} with projectile ID: {projectile.net.ID}.");
}
```
```

### Source Code from the Library

```csharp

	public void FireNextRocket()
	{
		RocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount(AmmoTypes.MLRS_ROCKET);
		if (nextRocketIndex < 0 || nextRocketIndex >= RocketAmmoCount || IsBroken())
		{
			EndFiring();
			return;
		}
		StorageContainer rocketContainer = GetRocketContainer();
		Vector3 firingPos = firingPoint.position + firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;
		float num = 1f;
		if (radiusModIndex < radiusMods.Length)
		{
			num = radiusMods[radiusModIndex];
		}
		radiusModIndex++;
		Vector2 vector = UnityEngine.Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;
		Vector3 target = TrueHitPos + new Vector3(vector.x, 0f, vector.y);
		float requiredGravity;
		Vector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, target, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out requiredGravity);
		if (TryFireProjectile(rocketContainer, AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))
		{
			projectile.gravityModifier = requiredGravity / (0f - UnityEngine.Physics.gravity.y);
			Interface.CallHook("OnMlrsRocketFired", this, projectile);
			nextRocketIndex--;
		}
		else
		{
			EndFiring();
		}
	}

```

## OnBackpackDrop(Item,PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when a backpack is dropped by a player.
/// </summary>
/// <param name="backpack">The backpack item that is being dropped.</param>
/// <param name="inventory">The inventory of the player dropping the backpack.</param>
/// <returns>
/// Returns a non-null value to prevent the backpack from being dropped; otherwise, returns null to allow the drop. (object)
/// </returns>
object OnBackpackDrop(Item backpack, PlayerInventory inventory)
{
    Puts($"Backpack {backpack} is being dropped from inventory of {inventory}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TryDropBackpack()
	{
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack != null && base.baseEntity.isServer && Interface.CallHook("OnBackpackDrop", anyBackpack, this) == null)
		{
			anyBackpack.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
		}
	}

```

## CanDemolish(BasePlayer,StabilityEntity)

```csharp
```csharp
/// <summary>
/// Determines whether a player can demolish a specified stability entity.
/// </summary>
/// <param name="player">The player attempting to demolish the entity.</param>
/// <param name="entity">The stability entity that is being checked for demolishment.</param>
/// <returns>
/// Returns `true` if the player can demolish the entity; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the player can demolish the entity. (bool)
/// </returns>
object CanDemolish(BasePlayer player, StabilityEntity entity)
{
    Puts($"Player {player} is attempting to demolish entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CanBeDemolished && IsDemolishable())
		{
			return HasDemolishPrivilege(player);
		}
		return false;
	}

```

## OnEntityVisibilityCheck(BaseEntity,BasePlayer,uint,string,float)

```csharp
```csharp
/// <summary>
/// Called to check if a specific entity is visible to a player within a certain distance.
/// </summary>
/// <param name="entityId">The unique identifier of the entity being checked.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <param name="entity">The entity to check visibility for.</param>
/// <param name="player">The player attempting to see the entity.</param>
/// <param name="maximumDistance">The maximum distance within which visibility is checked.</param>
/// <returns>
/// Returns `true` if the entity is visible to the player; otherwise, returns `false`. 
/// If the method returns `null`, the default visibility logic will be applied. (bool)
/// </returns>
object OnEntityVisibilityCheck(uint entityId, string debugName, BaseEntity entity, BasePlayer player, float maximumDistance)
{
    Puts($"Checking visibility for entity {entityId} ({debugName}) to player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityVisibilityCheck", ent, player, id, debugName, maximumDistance);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 1218519041))
				{
					if (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))
					{
						return ent.IsVisible(player.eyes.position, maximumDistance);
					}
					return true;
				}
				return false;
			}

```

## OnScientistRecalled(BradleyAPC,ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when a scientist NPC is recalled from a vehicle or position.
/// </summary>
/// <param name="apc">The APC vehicle from which the scientist is being recalled.</param>
/// <param name="scientist">The scientist NPC that is being recalled.</param>
/// <returns>No return behavior.</returns>
void OnScientistRecalled(BradleyAPC apc, ScientistNPC scientist)
{
    Puts($"Scientist {scientist} has been recalled from APC {apc}.");
}
```
```

### Source Code from the Library

```csharp

	public void OnScientistMounted(ScientistNPC scientist)
	{
		if (!(scientist == null))
		{
			if (scientistPrefabLookUp.TryGetValue(scientist.prefabID, out var value))
			{
				mountedScientistPrefabs.Add(value);
			}
			activeScientists.Remove(scientist);
			numberOfScientistsToSpawn++;
			Interface.CallHook("OnScientistRecalled", this, scientist);
		}
	}

```

## CanUpdateSign(BasePlayer,CarvablePumpkin)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update the sign associated with the CarvablePumpkin.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="pumpkin">The CarvablePumpkin instance associated with the sign.</param>
/// <returns>
/// Returns `true` if the player can update the sign; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can update the sign. (bool)
/// </returns>
object CanUpdateSign(BasePlayer player, CarvablePumpkin pumpkin)
{
    Puts($"Player {player} is attempting to update the sign on pumpkin {pumpkin}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

```

## OnExperimentStart(Workbench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an experiment starts at a workbench.
/// </summary>
/// <param name="workbench">The workbench where the experiment is being conducted.</param>
/// <param name="player">The player initiating the experiment.</param>
/// <returns>
/// Returns a non-null value to prevent the experiment from starting, or `null` to allow it to proceed. (object)
/// </returns>
object OnExperimentStart(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment started at workbench by player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## CanSetRelationship(BasePlayer,BasePlayer,RelationshipManager.RelationshipType,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a relationship can be set between two players.
/// </summary>
/// <param name="player">The player initiating the relationship change.</param>
/// <param name="otherPlayer">The player with whom the relationship is being set.</param>
/// <param name="type">The type of relationship to set.</param>
/// <param name="weight">The weight of the relationship, default is 1.</param>
/// <returns>
/// Returns `null` to allow the relationship to be set, or any non-null value to prevent the change. (object)
/// </returns>
object CanSetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipManager.RelationshipType type, int weight = 1)
{
    Puts($"Checking if {player} can set relationship with {otherPlayer} of type {type} with weight {weight}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight = 1, bool sendImmediate = false)
	{
		if (!contacts)
		{
			return;
		}
		ulong num = player.userID.Get();
		ulong num2 = otherPlayer.userID.Get();
		if (player == null || player == otherPlayer || player.IsNpc || (otherPlayer != null && otherPlayer.IsNpc) || Interface.CallHook("CanSetRelationship", player, otherPlayer, type, weight) != null)
		{
			return;
		}
		PlayerRelationships playerRelationships = GetRelationships(num);
		if (!CleanupOldContacts(playerRelationships, num))
		{
			CleanupOldContacts(playerRelationships, num, RelationshipType.Enemy);
		}
		PlayerRelationshipInfo relations = playerRelationships.GetRelations(num2);
		bool flag = false;
		if (relations.type != type)
		{
			flag = true;
			relations.weight = 0;
		}
		relations.type = type;
		relations.weight += weight;
		float num3 = UnityEngine.Time.realtimeSinceStartup - relations.lastMugshotTime;
		if (flag || relations.mugshotCrc == 0 || num3 >= mugshotUpdateInterval)
		{
			bool flag2 = otherPlayer.IsAlive();
			bool num4 = player.SecondsSinceAttacked > 10f && !player.IsAiming;
			float num5 = 100f;
			if (num4)
			{
				Vector3 normalized = (otherPlayer.eyes.position - player.eyes.position).normalized;
				bool flag3 = Vector3.Dot(player.eyes.HeadForward(), normalized) >= 0.6f;
				float num6 = Vector3Ex.Distance2D(player.transform.position, otherPlayer.transform.position);
				if (flag2 && num6 < num5 && flag3)
				{
					ClientRPC(RpcTarget.Player("CLIENT_DoMugshot", player), num2);
					relations.lastMugshotTime = UnityEngine.Time.realtimeSinceStartup;
				}
			}
		}
		if (sendImmediate)
		{
			SendRelationshipsFor(player);
		}
		else
		{
			MarkRelationshipsDirtyFor(player);
		}
	}

```

## OnPlayerSleepEnd(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player finishes sleeping.
/// </summary>
/// <param name="player">The player who has ended their sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnd(BasePlayer player)
{
    Puts($"Player {player} has ended their sleep.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", this) == null)
		{
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: true);
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if ((ulong)userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			CancelInvoke(ScheduledDeath);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
			}
			InvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				RemoveFromTriggers();
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", this);
			EACServer.LogPlayerSpawn(this);
			if (TotalPingCount > 0)
			{
				SendPingsToClient();
			}
			if (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))
			{
				ClientRPC(RpcTarget.Player("PromptToStartTutorial", this));
			}
		}
	}

```

## OnMissionStart(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission starts, allowing for custom behavior before the mission begins.
/// </summary>
/// <param name="mission">The mission that is starting.</param>
/// <param name="instance">The instance of the mission being started.</param>
/// <param name="assignee">The player assigned to the mission.</param>
/// <returns>
/// Returns a non-null value to prevent the default mission start behavior; otherwise, returns null to allow it. (object)
/// </returns>
object OnMissionStart(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts($"Mission {mission} is starting for player {assignee}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", this, instance, assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", this, instance, assignee);
	}

```

## CanBuild(Planner,Construction,Construction.Target)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can build a specific construction at a target location.
/// </summary>
/// <param name="planner">The planner used for the building process.</param>
/// <param name="construction">The construction type that is being placed.</param>
/// <param name="target">The target location and context for the construction.</param>
/// <returns>
/// Returns `null` to allow the building process to continue, or any non-null value to prevent building. (object)
/// </returns>
object CanBuild(Planner planner, Construction construction, Construction.Target target)
{
    Puts($"Player {target.player} is attempting to build {construction} at {target.position}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.Antihack, false);
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindConstruction, false);
			ConstructionErrors.Log(ownerPlayer, msg.blockID.ToString());
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			using (ItemAmountList itemAmountList = Facepunch.Pool.Get<ItemAmountList>())
			{
				itemAmountList.amount = Facepunch.Pool.Get<List<float>>();
				itemAmountList.itemID = Facepunch.Pool.Get<List<int>>();
				GetConstructionCost(itemAmountList, construction);
				ownerPlayer.ClientRPC(RpcTarget.Player("Client_OnRepairFailedResources", ownerPlayer), itemAmountList);
				return;
			}
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		Deployable deployable = GetDeployable(msg.entity);
		if (construction.deployable != deployable)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.DeployableMismatch, false);
			return;
		}
		Construction.Target target = default(Construction.Target);
		if (msg.entity.IsValid)
		{
			target.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if (target.entity == null)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindEntity, false);
				ConstructionErrors.Log(ownerPlayer, msg.entity.ToString());
				return;
			}
			msg.ray = new Ray(target.entity.transform.TransformPoint(msg.ray.origin), target.entity.transform.TransformDirection(msg.ray.direction));
			msg.position = target.entity.transform.TransformPoint(msg.position);
			msg.normal = target.entity.transform.TransformDirection(msg.normal);
			msg.rotation = target.entity.transform.rotation * msg.rotation;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != "")
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				if (target.socket == null)
				{
					ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindSocket, false);
					ConstructionErrors.Log(ownerPlayer, msg.socket.ToString());
					return;
				}
			}
			else if (target.entity is Door)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantDeployOnDoor, false);
				return;
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.isHoldingShift = msg.isHoldingShift;
		target.valid = true;
		if (Interface.CallHook("CanBuild", this, construction, target) != null)
		{
			return;
		}
		if (ShouldParent(target.entity, deployable))
		{
			Vector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);
			float num = target.entity.Distance(position);
			if (num > 1f)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.ParentTooFar, false);
				ConstructionErrors.Log(ownerPlayer, num.ToString());
				return;
			}
		}
		BaseEntity baseEntity = DoBuild(target, construction);
		if (baseEntity != null && ownerPlayer.IsInCreativeMode && Creative.freeBuild && baseEntity is BuildingBlock buildingBlock)
		{
			ConstructionGrade constructionGrade = construction.grades[msg.setToGrade];
			if (buildingBlock.currentGrade != constructionGrade)
			{
				buildingBlock.ChangeGradeAndSkin(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			}
		}
	}

```

## OnInventoryNetworkUpdate(PlayerInventory,ItemContainer,ProtoBuf.UpdateItemContainer,PlayerInventory.Type,PlayerInventory.NetworkInventoryMode)

```csharp
```csharp
/// <summary>
/// Called when the inventory of a player is updated over the network.
/// </summary>
/// <param name="playerInventory">The player's inventory that is being updated.</param>
/// <param name="container">The item container that is being updated.</param>
/// <param name="updateData">The data related to the item container update.</param>
/// <param name="type">The type of inventory being updated.</param>
/// <param name="mode">The network mode for the inventory update.</param>
/// <returns>Returns a non-null value to override the default inventory update behavior; otherwise, returns null.</returns>
object OnInventoryNetworkUpdate(PlayerInventory playerInventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateData, PlayerInventory.Type type, PlayerInventory.NetworkInventoryMode mode)
{
    Puts($"Updating inventory for player {playerInventory} with container {container}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode)
	{
		using UpdateItemContainer updateItemContainer = Facepunch.Pool.Get<UpdateItemContainer>();
		updateItemContainer.type = (int)type;
		if (container != null)
		{
			container.dirty = false;
			updateItemContainer.container = Facepunch.Pool.Get<List<ProtoBuf.ItemContainer>>();
			bool bIncludeContainer = type != Type.Wear || mode == NetworkInventoryMode.LocalPlayer;
			updateItemContainer.container.Add(container.Save(bIncludeContainer));
		}
		if (Interface.CallHook("OnInventoryNetworkUpdate", this, container, updateItemContainer, type, mode) != null)
		{
			return;
		}
		switch (mode)
		{
		case NetworkInventoryMode.Everyone:
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("UpdatedItemContainer"), updateItemContainer);
			break;
		case NetworkInventoryMode.LocalPlayer:
			base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", base.baseEntity), updateItemContainer);
			break;
		case NetworkInventoryMode.EveryoneButLocal:
			if (base.baseEntity.net?.group?.subscribers == null)
			{
				break;
			}
			{
				foreach (Connection subscriber in base.baseEntity.net.group.subscribers)
				{
					if (subscriber.player is BasePlayer basePlayer && basePlayer != base.baseEntity)
					{
						base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", basePlayer), updateItemContainer);
					}
				}
				break;
			}
		}
	}

```

## OnTeamDisband(RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team is disbanded.
/// </summary>
/// <param name="team">The team that is being disbanded.</param>
/// <returns>
/// Returns `null` to allow the team to be disbanded, or any non-null value to prevent the disbanding. (object)
/// </returns>
object OnTeamDisband(RelationshipManager.PlayerTeam team)
{
    Puts($"Disbanding team with ID: {team.teamID}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Facepunch.Pool.Free(ref teamToDisband);
		}
	}

```

## CanCheckFuel(EntityFuelSystem,StorageContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can check the fuel of a storage container.
/// </summary>
/// <param name="fuelSystem">The fuel system associated with the entity.</param>
/// <param name="container">The storage container holding the fuel.</param>
/// <param name="player">The player attempting to check the fuel.</param>
/// <returns>
/// Returns `true` if the player can check the fuel, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can check the fuel. (bool)
/// </returns>
object CanCheckFuel(EntityFuelSystem fuelSystem, StorageContainer container, BasePlayer player)
{
    Puts($"Player {player} is attempting to check fuel in container {container}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool IsInFuelInteractionRange(BasePlayer player)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanCheckFuel", this, fuelContainer, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (fuelContainer != null)
		{
			float num = 0f;
			if (isServer)
			{
				num = 3f;
			}
			return fuelContainer.Distance(player.eyes.position) <= num;
		}
		return false;
	}

```

## CanBeHomingTargeted(CH47Helicopter)

```csharp
```csharp
/// <summary>
/// Determines whether the specified CH47 helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The CH47 helicopter to check.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default behavior is to deny targeting. (bool)
/// </returns>
object CanBeHomingTargeted(CH47Helicopter helicopter)
{
    Puts($"Checking if CH47 Helicopter ID: {helicopter.net.ID} can be targeted by homing missiles.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnEntityDismounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player dismounts from an entity.
/// </summary>
/// <param name="mountable">The mountable entity from which the player is dismounting.</param>
/// <param name="player">The player who is dismounting.</param>
/// <returns>No return behavior.</returns>
void OnEntityDismounted(BaseMountable mountable, BasePlayer player)
{
    Puts($"Player {player} has dismounted from {mountable}.");
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.transform.rotation = Quaternion.identity;
			_mounted.ClientRPC(RpcTarget.Player("ForcePositionTo", _mounted), res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID.Get() + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
		}
		else
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.SendModelState(force: true);
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), res);
			}
			Facepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnActiveItemChanged(BasePlayer,Item,Item)

```csharp
```csharp
/// <summary>
/// Called when the active item of a player changes.
/// </summary>
/// <param name="player">The player whose active item has changed.</param>
/// <param name="previousItem">The item that was previously active.</param>
/// <param name="newItem">The item that is now active.</param>
/// <returns>No return behavior.</returns>
void OnActiveItemChanged(BasePlayer player, Item previousItem, Item newItem)
{
    Puts($"Player {player} changed active item from {previousItem} to {newItem}.");
}
```
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(ItemId itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnSendCommand(System.Collections.Generic.List<Network.Connection>,string,object[])

```csharp
```csharp
/// <summary>
/// Called when a command is sent to a list of network connections.
/// </summary>
/// <param name="connections">The list of connections to which the command is being sent.</param>
/// <param name="command">The command string to be executed on the client.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>
/// Returns `null` to allow the command to be sent; any non-null value will prevent the command from being sent. (object)
/// </returns>
object OnSendCommand(List<Network.Connection> connections, string command, object[] args)
{
    Puts($"Sending command '{command}' to {connections.Count} connections.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(List<Connection> cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnSendCommand", cn, strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			netWrite.String(ConsoleSystem.BuildCommand(strCommand, args));
			netWrite.Send(new SendInfo(cn));
		}
	}

```

## IOnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnServerShutdown()
{
    Puts("Server is shutting down. Performing cleanup tasks.");
}
```
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("IOnServerShutdown");
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## OnDecayHeal(DecayEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is healed during the decay process.
/// </summary>
/// <param name="decayEntity">The entity that is undergoing decay and may be healed.</param>
/// <returns>
/// Returns `null` to allow the default healing behavior, or a non-null value to prevent healing. (object)
/// </returns>
object OnDecayHeal(DecayEntity decayEntity)
{
    Puts($"Healing during decay for entity: {decayEntity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnDecay(Decay decay, float decayDeltaTime)
	{
		lastDecayTick = UnityEngine.Time.time;
		if (HasParent() || !decay.ShouldDecay(this))
		{
			return;
		}
		float num = decayDeltaTime * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if (buildingPrivilege != null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", this) == null)
				{
					float num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();
					Heal(MaxHealth() * num2);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num;
		if (decayTimer < GetEntityDecayDelay())
		{
			return;
		}
		using (TimeWarning.New("DecayTick"))
		{
			float num3 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num3 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num3 -= decayPoint.protection;
					}
				}
			}
			if (Interface.CallHook("OnDecayDamage", this) == null && num3 > 0f)
			{
				float num4 = num / GetEntityDecayDuration() * MaxHealth();
				Hurt(num4 * num3 * decayVariance, DamageType.Decay);
			}
		}
	}

```

## OnItemCraftCancelled(ItemCraftTask,ItemCrafter)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is cancelled.
/// </summary>
/// <param name="task">The item crafting task that was cancelled.</param>
/// <param name="craftingStation">The entity or station that was crafting the item.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task, ItemCrafter craftingStation)
{
    Puts($"Crafting task {task.taskUID} has been cancelled for crafting station: {craftingStation}.");
}
```
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask, this);
		owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(owner.inventory.containerMain))
					{
						takenItem.Drop(owner.inventory.containerMain.dropPosition + UnityEngine.Random.value * Vector3.down + UnityEngine.Random.insideUnitSphere, owner.inventory.containerMain.dropVelocity);
						owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
			itemCraftTask.takenItems.Clear();
		}
		return true;
	}

```

## OnPhoneDialTimedOut(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing attempt times out.
/// </summary>
/// <param name="caller">The phone controller that initiated the call.</param>
/// <param name="receiver">The phone controller that was being called.</param>
/// <param name="player">The player associated with the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialTimedOut(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone call from {caller} to {receiver} timed out for player {player}.");
}
```
```

### Source Code from the Library

```csharp

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", activeCallTo, this, activeCallTo.currentPlayer) == null)
		{
			if (activeCallTo != null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", activeCallTo, this, activeCallTo.currentPlayer);
		}
	}

```

## OnBookmarkControlEnded(ComputerStation,BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player's control over a bookmark ends.
/// </summary>
/// <param name="station">The computer station that was being controlled.</param>
/// <param name="player">The player who was controlling the station.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, BaseEntity entity)
{
    Puts($"Control ended for player {player} on station {station} controlling entity {entity}.");
}
```
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if ((bool)ply)
		{
			ply.net.SwitchSecondaryGroup(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
		CancelInvoke(CheckCCTVAchievement);
		Interface.CallHook("OnBookmarkControlEnded", this, ply, baseEntity);
	}

```

## IOnCupboardAuthorize(ulong,BasePlayer,BuildingPrivlidge)

```csharp
```csharp
/// <summary>
/// Called when a player is authorized to a cupboard.
/// </summary>
/// <param name="playerId">The unique identifier of the player being authorized.</param>
/// <param name="player">The player who is authorizing.</param>
/// <param name="cupboard">The cupboard to which the player is being authorized.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent it. (object)
/// </returns>
object IOnCupboardAuthorize(ulong playerId, BasePlayer player, BuildingPrivlidge cupboard)
{
    Puts($"Player {player} (ID: {playerId}) is attempting to authorize to cupboard {cupboard}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void AddAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player))
		{
			ulong num = rpc.read.UInt64();
			if (Interface.CallHook("IOnCupboardAuthorize", num, rpc.player, this) == null)
			{
				AddPlayer(rpc.player, num);
				SendNetworkUpdate();
			}
		}
	}

```

## OnFishingRodCast(BaseFishingRod,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a fishing rod is cast by a player.
/// </summary>
/// <param name="rod">The fishing rod being used to cast.</param>
/// <param name="player">The player who is casting the fishing rod.</param>
/// <param name="lure">The lure item being used for the cast.</param>
/// <returns>No return behavior.</returns>
void OnFishingRodCast(BaseFishingRod rod, BasePlayer player, Item lure)
{
    Puts($"Player {player} has cast the fishing rod {rod} using lure {lure}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_RequestCast(RPCMessage msg)
	{
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		ItemModCompostable component = (ItemModCompostable)Interface.CallHook("CanCastFishingRod", ownerPlayer, this, currentLure, pos);
		if (!(component is bool) || (bool)(object)component)
		{
			FishingBobber component2 = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();
			component2.transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component2.Spawn();
			component2.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);
			int usedLureAmount = 0;
			if (FishLookup.Instance != null)
			{
				currentFishTarget = FishLookup.Instance.GetFish(component2.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);
			}
			lureUsed = currentLure.info;
			currentLure.UseItem(usedLureAmount);
			lastFish = fishableModifier;
			currentBobber.Set(component2);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReceiveCastPoint"), component2.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));
			catchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;
			float val = (lureUsed.TryGetComponent<ItemModCompostable>(out component) ? component.BaitValue : 0f);
			val = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);
			catchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);
			playerStartPosition = ownerPlayer.transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			InvokeRepeating(CatchProcess, 0f, 0f);
			inQueue = false;
			Interface.CallHook("OnFishingRodCast", this, ownerPlayer, currentLure);
		}
	}

```

## IOnRunCommandLine()

```csharp
```csharp
/// <summary>
/// Called when processing command line arguments for the application.
/// </summary>
/// <returns>
/// Returns a non-null value to override the default command line processing behavior. 
/// If `null` is returned, the default processing will continue. (object)
/// </returns>
object IOnRunCommandLine()
{
    Puts("Running command line processing.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The arguments associated with the console command.</param>
/// <returns>
/// Returns `true` if the command was successfully processed, or `false` if it was invalid or failed to execute.
/// If the method returns a non-null value, it overrides the default command handling behavior. (bool)
/// </returns>
object IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Processing server command: {arg.cmd.FullName} with arguments: {string.Join(", ", arg.Args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null && string.IsNullOrWhiteSpace(arg.Reply))
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## OnClientDisconnected(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The connection of the client that has disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnected(Network.Connection connection, string reason)
{
    Puts($"Client disconnected: {connection} - Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	protected void OnDisconnected(string strReason, Connection cn)
	{
		if (cn != null)
		{
			RecordDisconnection(cn);
			cn.connected = false;
			cn.active = false;
			if (callbackHandler != null)
			{
				callbackHandler.OnDisconnected(strReason, cn);
			}
			Interface.CallHook("OnClientDisconnected", cn, strReason);
			RemoveConnection(cn);
		}
	}

```

## OnNetworkSubscriptionsUpdate(Network.Networkable,System.Collections.Generic.List<Network.Visibility.Group>,unknown)

```csharp
```csharp
/// <summary>
/// Called to update the network subscriptions for a networkable entity.
/// </summary>
/// <param name="networkable">The networkable entity whose subscriptions are being updated.</param>
/// <param name="visibleGroups">The list of visibility groups that are currently visible to the entity.</param>
/// <param name="unknown">An unknown parameter that may be used for additional context.</param>
/// <returns>
/// Returns `null` to allow the default subscription behavior, or a non-null value to override it. (object)
/// </returns>
object OnNetworkSubscriptionsUpdate(Network.Networkable networkable, List<Network.Visibility.Group> visibleGroups, object unknown)
{
    Puts($"Updating network subscriptions for {networkable} with {visibleGroups.Count} visible groups.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool UpdateHighPrioritySubscriptions()
	{
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateHighPrioritySubscriptions"))
		{
			List<Group> obj = Pool.Get<List<Group>>();
			List<Group> obj2 = Pool.Get<List<Group>>();
			sv.visibility.GetVisibleFromNear(this.group, obj2);
			AddVisibleFromNear(secondaryGroup, obj2);
			subscriber.subscribed.Compare(obj2, obj, null, null);
			if (Interface.CallHook("OnNetworkSubscriptionsUpdate", this, obj, null) == null)
			{
				for (int i = 0; i < obj.Count; i++)
				{
					Group group = obj[i];
					subscriber.Subscribe(group);
					if (handler != null)
					{
						handler.OnNetworkGroupEnter(group);
					}
				}
			}
			Pool.FreeUnmanaged(ref obj);
			Pool.FreeUnmanaged(ref obj2);
		}
		return true;
	}

```

## OnNetworkSubscriptionsUpdate(Network.Networkable,System.Collections.Generic.List<Network.Visibility.Group>,System.Collections.Generic.List<Network.Visibility.Group>)

```csharp
```csharp
/// <summary>
/// Called to update the network subscriptions for a networkable entity.
/// </summary>
/// <param name="networkable">The networkable entity whose subscriptions are being updated.</param>
/// <param name="removedGroups">The list of groups that were removed from subscriptions.</param>
/// <param name="addedGroups">The list of groups that were added to subscriptions.</param>
/// <returns>
/// Returns a non-null value to override the default subscription update behavior. 
/// If `null` is returned, the default logic will proceed with the update. (object)
/// </returns>
object OnNetworkSubscriptionsUpdate(Network.Networkable networkable, List<Network.Visibility.Group> removedGroups, List<Network.Visibility.Group> addedGroups)
{
    Puts($"Updating network subscriptions for {networkable}. Removed: {removedGroups.Count}, Added: {addedGroups.Count}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool UpdateSubscriptions(int removeLimit, int addLimit)
	{
		if (!updateSubscriptions)
		{
			return false;
		}
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateSubscriptions"))
		{
			updateSubscriptions = false;
			List<Group> obj = Pool.Get<List<Group>>();
			List<Group> obj2 = Pool.Get<List<Group>>();
			List<Group> obj3 = Pool.Get<List<Group>>();
			sv.visibility.GetVisibleFromFar(this.group, obj3);
			AddVisibleFromNear(secondaryGroup, obj3);
			subscriber.subscribed.Compare(obj3, obj, obj2, null);
			if (Interface.CallHook("OnNetworkSubscriptionsUpdate", this, obj, obj2) == null)
			{
				for (int i = 0; i < obj2.Count; i++)
				{
					Group group = obj2[i];
					if (removeLimit > 0)
					{
						subscriber.Unsubscribe(group);
						if (handler != null)
						{
							handler.OnNetworkGroupLeave(group);
						}
						removeLimit -= group.networkables.Count;
					}
					else
					{
						updateSubscriptions = true;
					}
				}
				for (int j = 0; j < obj.Count; j++)
				{
					Group group2 = obj[j];
					if (addLimit > 0)
					{
						subscriber.Subscribe(group2);
						if (handler != null)
						{
							handler.OnNetworkGroupEnter(group2);
						}
						addLimit -= group2.networkables.Count;
					}
					else
					{
						updateSubscriptions = true;
					}
				}
			}
			Pool.FreeUnmanaged(ref obj);
			Pool.FreeUnmanaged(ref obj2);
			Pool.FreeUnmanaged(ref obj3);
		}
		return true;
	}

```

## OnGroupCreated(string,string,int)

```csharp
```csharp
/// <summary>
/// Called when a new group is created.
/// </summary>
/// <param name="groupName">The name of the group that was created.</param>
/// <param name="groupTitle">The title of the group that was created.</param>
/// <param name="groupRank">The rank assigned to the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupCreated(string groupName, string groupTitle, int groupRank)
{
    Puts($"Group created: Name = {groupName}, Title = {groupTitle}, Rank = {groupRank}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string groupName, string groupTitle, int groupRank)
	{
		if (GroupExists(groupName) || string.IsNullOrEmpty(groupName))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = groupTitle,
			Rank = groupRank
		};
		groupsData.Add(groupName, value);
		Interface.CallHook("OnGroupCreated", groupName, groupTitle, groupRank);
		return true;
	}

```

## OnUserNameUpdated(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's nickname is updated.
/// </summary>
/// <param name="id">The ID of the player whose nickname is being updated.</param>
/// <param name="oldName">The player's previous nickname.</param>
/// <param name="newName">The player's new nickname.</param>
/// <returns>No return behavior.</returns>
void OnUserNameUpdated(string id, string oldName, string newName)
{
    Puts($"Player {id} changed their nickname from {oldName} to {newName}.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string playerId, string playerName)
	{
		if (UserExists(playerId))
		{
			UserData userData = GetUserData(playerId);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = playerName.Sanitize();
			userData.LastSeenNickname = playerName.Sanitize();
			Interface.CallHook("OnUserNameUpdated", playerId, lastSeenNickname, obj);
		}
	}

```

## OnGroupRankSet(string,int)

```csharp
```csharp
/// <summary>
/// Called when the rank of a group is set.
/// </summary>
/// <param name="groupName">The name of the group whose rank is being set.</param>
/// <param name="groupRank">The new rank to assign to the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupRankSet(string groupName, int groupRank)
{
    Puts($"Group rank for '{groupName}' has been set to {groupRank}.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string groupName, int groupRank)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Rank == groupRank)
		{
			return true;
		}
		value.Rank = groupRank;
		Interface.CallHook("OnGroupRankSet", groupName, groupRank);
		return true;
	}

```

## OnGroupTitleSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when the title of a group is set or updated.
/// </summary>
/// <param name="groupName">The name of the group whose title is being set.</param>
/// <param name="groupTitle">The new title for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupTitleSet(string groupName, string groupTitle)
{
    Puts($"Group title for '{groupName}' has been set to '{groupTitle}'.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string groupName, string groupTitle)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Title == groupTitle)
		{
			return true;
		}
		value.Title = groupTitle;
		Interface.CallHook("OnGroupTitleSet", groupName, groupTitle);
		return true;
	}

```

## OnPermissionRegistered(string,Oxide.Core.Plugins.Plugin)

```csharp
```csharp
/// <summary>
/// Called when a new permission is registered by a plugin.
/// </summary>
/// <param name="permission">The name of the permission being registered.</param>
/// <param name="owner">The plugin that is registering the permission.</param>
/// <returns>No return behavior.</returns>
void OnPermissionRegistered(string permission, Oxide.Core.Plugins.Plugin owner)
{
    Puts($"Permission '{permission}' registered by plugin '{owner.Title}'.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string permission, Plugin owner)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return;
		}
		if (PermissionExists(permission))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", permission, owner.Title);
			return;
		}
		if (!registeredPermissions.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			registeredPermissions.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(permission);
		Interface.CallHook("OnPermissionRegistered", permission, owner);
		if (!permission.StartsWith(owner.Name + ".", StringComparison.OrdinalIgnoreCase) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", owner.Name.ToLower(), permission, owner.Title);
		}
	}

```

## OnGroupParentSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's parent is set or changed.
/// </summary>
/// <param name="groupName">The name of the group whose parent is being set.</param>
/// <param name="parentGroupName">The name of the new parent group.</param>
/// <returns>No return behavior.</returns>
void OnGroupParentSet(string groupName, string parentGroupName)
{
    Puts($"Group '{groupName}' parent set to '{parentGroupName}'.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string groupName, string parentGroupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parentGroupName))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))
		{
			return false;
		}
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parentGroupName))
		{
			return true;
		}
		if (HasCircularParent(groupName, parentGroupName))
		{
			return false;
		}
		value.ParentGroup = parentGroupName;
		Interface.CallHook("OnGroupParentSet", groupName, parentGroupName);
		return true;
	}

```

## OnGroupDeleted(string)

```csharp
```csharp
/// <summary>
/// Called when a group is deleted from the system.
/// </summary>
/// <param name="groupName">The name of the group that has been deleted.</param>
/// <returns>No return behavior.</returns>
void OnGroupDeleted(string groupName)
{
    Puts($"Group '{groupName}' has been deleted.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		bool flag = groupsData.Remove(groupName);
		if (flag)
		{
			foreach (GroupData item in groupsData.Values.Where((GroupData g) => g.ParentGroup == groupName))
			{
				item.ParentGroup = string.Empty;
			}
		}
		if (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(groupName)))
		{
			SaveUsers();
		}
		if (flag)
		{
			Interface.CallHook("OnGroupDeleted", groupName);
		}
		return true;
	}

```

## OnDestroyUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a UI element is destroyed for a player.
/// </summary>
/// <param name="player">The player for whom the UI element is being destroyed.</param>
/// <param name="element">The identifier of the UI element to be destroyed.</param>
/// <returns>
/// Returns `true` if the UI element was successfully destroyed; otherwise, returns `false` if the player is invalid or the operation failed.
/// </returns>
bool OnDestroyUI(BasePlayer player, string element)
{
    Puts($"Destroying UI element '{element}' for player {player}.");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		if (player?.net != null)
		{
			Interface.CallHook("OnDestroyUI", player, elem);
			CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("DestroyUI", player.net.connection), elem);
			return true;
		}
		return false;
	}

```

## OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a user executes a command.
/// </summary>
/// <param name="player">The player who executed the command.</param>
/// <param name="command">The command that was executed.</param>
/// <param name="args">The arguments passed with the command.</param>
/// <returns>
/// Returns a non-null value to indicate that the command was handled, or `null` to allow further processing. (object)
/// </returns>
object OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer player, string command, string[] args)
{
    Puts($"User {player.Name} executed command: {command} with arguments: {string.Join(", ", args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnApplicationCommand(BasePlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player executes a command in the application.
/// </summary>
/// <param name="player">The player who executed the command.</param>
/// <param name="command">The command that was executed.</param>
/// <param name="args">The arguments passed with the command.</param>
/// <returns>
/// Returns a non-null value to override the default command handling behavior. 
/// If `null` is returned, the command will be processed normally. (object)
/// </returns>
object OnApplicationCommand(BasePlayer player, string command, string[] args)
{
    Puts($"Player {player} executed command: {command} with arguments: {string.Join(", ", args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player changes their language setting.
/// </summary>
/// <param name="player">The player whose language has changed.</param>
/// <param name="newLanguage">The new language setting for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer player, string newLanguage)
{
    Puts($"Player {player} has changed their language to {newLanguage}.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnPlayerLanguageChanged(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player changes their language setting.
/// </summary>
/// <param name="player">The player whose language has changed.</param>
/// <param name="newLanguage">The new language setting for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(BasePlayer player, string newLanguage)
{
    Puts($"Player {player} has changed their language to {newLanguage}.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>
/// Returns a non-null value to override the default respawn behavior. If `null` is returned, the player respawns normally. (object)
/// </returns>
object OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"User {player.Name} has respawned.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.CallHook("OnUserRespawn", iPlayer);
	}

```

## OnApplicationCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player issues a command in the application.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The command that was issued.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>
/// Returns a non-null value to override the default command handling behavior. 
/// If `null` is returned, the command will be processed normally. (object)
/// </returns>
object OnApplicationCommand(Oxide.Core.Libraries.Covalence.IPlayer player, string command, string[] args)
{
    Puts($"Player {player.Name} issued command: {command} with arguments: {string.Join(", ", args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnRconCommand(System.Net.IPAddress,string,string[])

```csharp
```csharp
/// <summary>
/// Called when an RCON command is received from a remote client.
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the command.</param>
/// <param name="command">The command string sent by the client.</param>
/// <param name="args">An array of arguments associated with the command.</param>
/// <returns>
/// Returns `true` if the command was handled and should not be processed further; otherwise, returns `null` to allow default processing. (object)
/// </returns>
object OnRconCommand(System.Net.IPAddress ipAddress, string command, string[] args)
{
    Puts($"Received RCON command from {ipAddress}: {command} with arguments: {string.Join(", ", args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", ipAddress, message) != null)
			{
				return true;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnEntityTakeDamage(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit, including damage amount and source.</param>
/// <returns>
/// Returns a non-null value to override the default damage behavior. If `null` is returned, the default damage logic will proceed. (object)
/// </returns>
object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} took damage: {hitInfo.damage} from {hitInfo.Initiator}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.CallHook("OnEntityTakeDamage", entity, hitInfo);
		}
		return null;
	}

```

## OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>No return behavior.</returns>
void OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"User {player.Name} has respawned.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", iPlayer);
		}
	}

```

## OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user disconnects from the server.
/// </summary>
/// <param name="player">The player who has disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer player, string reason)
{
    Puts($"User {player} has disconnected. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer basePlayer, string reason)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(basePlayer);
	}

```

## OnServerInitialized(bool)

```csharp
```csharp
/// <summary>
/// Called when the server has completed its initialization process.
/// </summary>
/// <param name="isInitialized">Indicates whether the server has been initialized.</param>
/// <returns>No return behavior.</returns>
void OnServerInitialized(bool isInitialized)
{
    Puts($"Server initialization status: {isInitialized}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			Analytics.Collect();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", serverInitialized);
		}
	}

```

## OnCupboardAssign(BuildingPrivlidge,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is assigned to a cupboard's privileges.
/// </summary>
/// <param name="privilege">The building privilege associated with the cupboard.</param>
/// <param name="userId">The user ID of the player being assigned.</param>
/// <param name="player">The player being assigned to the cupboard.</param>
/// <returns>
/// Returns a non-null value to prevent the assignment, or `null` to allow it. (object)
/// </returns>
object OnCupboardAssign(BuildingPrivlidge privilege, ulong userId, BasePlayer player)
{
    Puts($"Assigning user {userId} to cupboard privileges for player {player}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnCupboardAuthorize")]
	private object IOnCupboardAuthorize(ulong userID, BasePlayer player, BuildingPrivlidge privlidge)
	{
		if (userID == (ulong)player.userID)
		{
			if (Interface.CallHook("OnCupboardAuthorize", privlidge, player) != null)
			{
				return true;
			}
		}
		else if (Interface.CallHook("OnCupboardAssign", privlidge, userID, player) != null)
		{
			return true;
		}
		return null;
	}

```

## CanUserLogin(string,string,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a user can log in to the server.
/// </summary>
/// <param name="username">The username of the user attempting to log in.</param>
/// <param name="steamId">The Steam ID of the user attempting to log in.</param>
/// <param name="ipAddress">The IP address of the user attempting to log in.</param>
/// <returns>
/// Returns a non-null value to override the default login behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is allowed to log in. (string | bool)
/// </returns>
object CanUserLogin(string username, string steamId, string ipAddress)
{
    Puts($"Checking login for user {username} with SteamID {steamId} from IP {ipAddress}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnPlayerChat(BasePlayer,string,ConVar.Chat.ChatChannel)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="player">The player who sent the message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <param name="channel">The chat channel in which the message was sent.</param>
/// <returns>
/// Returns a non-null value to prevent the message from being processed further. 
/// If `null` is returned, the message will be processed normally. (object)
/// </returns>
object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
{
    Puts($"Player {player} sent a message in channel {channel}: {message}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, string steamId, string ipAddress)
{
    Puts($"User {username} (SteamID: {steamId}, IP: {ipAddress}) has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## CanClientLogin(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a client can log in to the server.
/// </summary>
/// <param name="connection">The network connection of the client attempting to log in.</param>
/// <returns>
/// Returns a non-null value to prevent the client from logging in. If a string is returned, the client will be kicked with the provided message. 
/// If `null` is returned, the client is allowed to log in. (string | bool)
/// </returns>
object CanClientLogin(Network.Connection connection)
{
    Puts($"Client with ID {connection.userid} is attempting to log in.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnRconMessage(System.Net.IPAddress,Oxide.Core.RemoteConsole.RemoteMessage)

```csharp
```csharp
/// <summary>
/// Called when a message is received via RCON (Remote Console).
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the RCON message.</param>
/// <param name="message">The remote message containing the command and its parameters.</param>
/// <returns>
/// Returns `true` if the message was handled by the hook, or `null` if it was not handled. 
/// If a non-null value is returned, it indicates that the message should not be processed further. (object)
/// </returns>
object OnRconMessage(System.Net.IPAddress ipAddress, Oxide.Core.RemoteConsole.RemoteMessage message)
{
    Puts($"Received RCON message from {ipAddress}: {message?.Message}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", ipAddress, message) != null)
			{
				return true;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnPlayerBanned(string,ulong,string,string,long)

```csharp
```csharp
/// <summary>
/// Called when a player is banned from the server.
/// </summary>
/// <param name="playerName">The name of the player being banned.</param>
/// <param name="steamId">The Steam ID of the player being banned.</param>
/// <param name="ipAddress">The IP address of the player being banned.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The expiry time of the ban in Unix timestamp format.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string playerName, ulong steamId, string ipAddress, string reason, long expiry)
{
    Puts($"Player {playerName} (SteamID: {steamId}, IP: {ipAddress}) has been banned. Reason: {reason}, Expiry: {expiry}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnPlayerOfflineChat(ulong,string,string,ConVar.Chat.ChatChannel)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message while offline.
/// </summary>
/// <param name="playerId">The unique identifier of the player sending the message.</param>
/// <param name="playerName">The name of the player sending the message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <param name="channel">The chat channel in which the message was sent.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. If `null` is returned, the message is processed normally. (object)
/// </returns>
object OnPlayerOfflineChat(ulong playerId, string playerName, string message, ConVar.Chat.ChatChannel channel)
{
    Puts($"Offline chat from {playerName} (ID: {playerId}): {message}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a specific entity.
/// </summary>
/// <param name="npc">The NPC that is targeting an entity.</param>
/// <param name="target">The entity being targeted by the NPC.</param>
/// <returns>
/// Returns a non-null value to override the default targeting behavior. If `null` is returned, the NPC will proceed with its default targeting logic. (object)
/// </returns>
object OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc} is targeting {target}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcTarget", npc, target) != null)
		{
			npc.SetFact(BaseNpc.Facts.HasEnemy, 0);
			npc.SetFact(BaseNpc.Facts.EnemyRange, 3);
			npc.SetFact(BaseNpc.Facts.AfraidRange, 1);
			npc.playerTargetDecisionStartTime = 0f;
			return 0f;
		}
		return null;
	}

```

## OnPlayerBanned(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned from the server.
/// </summary>
/// <param name="connection">The network connection of the banned player.</param>
/// <param name="reason">The reason for the ban, typically a message or status code.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(Network.Connection connection, string reason)
{
    Puts($"Player with connection ID {connection.userid} has been banned. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerBanned")]
	private void IOnPlayerBanned(Connection connection, AuthResponse status)
	{
		Interface.CallHook("OnPlayerBanned", connection, status.ToString());
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The player who was kicked.</param>
/// <param name="reason">The reason for the kick.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer player, string reason)
{
    Puts($"User {player.Name} has been kicked. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer basePlayer, string reason)
	{
		if (basePlayer.IPlayer != null)
		{
			Interface.CallHook("OnUserKicked", basePlayer.IPlayer, reason);
		}
	}

```

## OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user connects to the server.
/// </summary>
/// <param name="player">The player that has connected.</param>
/// <returns>No return behavior.</returns>
void OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"User {player.Name} with ID {player.Id} has connected to the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnServerCommand(string,string[])

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="command">The name of the command being executed.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns `true` to indicate that the command was handled, or `null` to allow default processing. 
/// If a non-null value is returned, it overrides the default behavior. (object)
/// </returns>
object OnServerCommand(string command, string[] args)
{
    Puts($"Server command executed: {command} with arguments: {string.Join(", ", args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnLoseCondition(object[])

```csharp
```csharp
/// <summary>
/// Called when an item loses condition due to damage or wear.
/// </summary>
/// <param name="parameters">An array containing the item and the amount of condition lost.</param>
/// <returns>
/// Returns `true` if the condition loss is processed successfully; otherwise, returns `false`. 
/// If the hook modifies the amount, it will be reflected in the parameters array. (bool)
/// </returns>
object OnLoseCondition(object[] parameters)
{
    Puts($"Item {parameters[0]} is losing condition: {parameters[1]}.");
    return true;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

```

## OnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The arguments associated with the server command.</param>
/// <returns>
/// Returns `true` to prevent the command from executing further, or `null` to allow the command to proceed. 
/// If a non-null value is returned from the hook, it will override the default behavior. (object)
/// </returns>
object OnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Server command received: {arg.cmd.FullName} with arguments: {string.Join(", ", arg.Args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerShutdown()
{
    Puts("Server is shutting down. Performing cleanup tasks.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerShutdown")]
	private void IOnServerShutdown()
	{
		Interface.Oxide.CallHook("OnServerShutdown");
		Interface.Oxide.OnShutdown();
		Covalence.PlayerManager.SavePlayerData();
	}

```

## OnUserBanned(string,string,string,string,long)

```csharp
```csharp
/// <summary>
/// Called when a user is banned from the server.
/// </summary>
/// <param name="playerName">The name of the player being banned.</param>
/// <param name="steamId">The Steam ID of the player being banned.</param>
/// <param name="ipAddress">The IP address of the player being banned.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The expiry time of the ban in Unix timestamp format.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string playerName, string steamId, string ipAddress, string reason, long expiry)
{
    Puts($"User {playerName} (SteamID: {steamId}, IP: {ipAddress}) has been banned. Reason: {reason}, Expiry: {expiry}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnEntityTakeDamage(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="player">The player entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns `true` to indicate that the damage event was handled, or `null` to allow the default damage handling to proceed. (object)
/// </returns>
object OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Entity {player} is taking damage from {hitInfo.damageTypes}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)
	{
		if (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", basePlayer, hitInfo) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			basePlayer.OnAttacked(hitInfo);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

```

## OnUserApproved(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="username">The username of the approved user.</param>
/// <param name="steamId">The Steam ID of the approved user.</param>
/// <param name="ipAddress">The IP address of the approved user.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal. (string | bool)
/// </returns>
object OnUserApproved(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been approved to join the server.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <returns>
/// Returns a non-null value to prevent the message from being processed further. 
/// If `null` is returned, the message will be processed normally. (object)
/// </returns>
object OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer player, string message)
{
    Puts($"Player {player.Name} sent a chat message: {message}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player successfully connects to the server.
/// </summary>
/// <param name="player">The player who has connected.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player} has connected to the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved to the server.
/// </summary>
/// <param name="entity">The entity that is being saved.</param>
/// <param name="saveInfo">The information related to the save operation.</param>
/// <returns>No return behavior.</returns>
void OnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity} has been saved with save info: {saveInfo}.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnEntitySaved")]
	private void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)
	{
		if (serverInitialized && saveInfo.forConnection != null)
		{
			Interface.CallHook("OnEntitySaved", baseNetworkable, saveInfo);
		}
	}

```

## OnPlayerCommand(BasePlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player issues a command.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The command that was issued.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>
/// Returns a non-null value to override the default command handling. If `null` is returned, the command will be processed normally. (object)
/// </returns>
object OnPlayerCommand(BasePlayer player, string command, string[] args)
{
    Puts($"Player {player} issued command: {command} with arguments: {string.Join(", ", args)}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## CanUseUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a specific UI element.
/// </summary>
/// <param name="player">The player attempting to use the UI.</param>
/// <param name="uiJson">The JSON representation of the UI to be used.</param>
/// <returns>
/// Returns `true` if the player can use the UI, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can use the UI. (bool)
/// </returns>
object CanUseUI(BasePlayer player, string uiJson)
{
    Puts($"Checking UI usage for player {player} with UI JSON: {uiJson}");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AddUi(BasePlayer player, string json)
	{
		if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
		{
			CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", player.net.connection), json);
			return true;
		}
		return false;
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The name of the player who has been unbanned.</param>
/// <param name="steamId">The Steam ID of the player who has been unbanned.</param>
/// <param name="ipAddress">The IP address of the player who has been unbanned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} (SteamID: {steamId}) has been unbanned. IP: {ipAddress}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## OnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a user is being approved to connect to the server.
/// </summary>
/// <param name="connection">The network connection of the user being approved.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal. (object)
/// </returns>
object OnUserApprove(Network.Connection connection)
{
    Puts($"Approving user with ID: {connection.userid}, Username: {connection.username}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## CanPickupEntity(BasePlayer,DoorCloser)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pick up a specific entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity that is being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the entity can be picked up. (bool)
/// </returns>
object CanPickupEntity(BasePlayer player, DoorCloser entity)
{
    Puts($"Player {player} is attempting to pick up entity {entity}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)
	{
		object obj = Interface.CallHook("CanPickupEntity", basePlayer, entity);
		if (!(obj is bool) || (bool)obj)
		{
			return null;
		}
		return true;
	}

```

## OnClanMemberAdded(long,ulong)

```csharp
```csharp
/// <summary>
/// Called when a new member is added to a clan.
/// </summary>
/// <param name="clanId">The ID of the clan to which the member is being added.</param>
/// <param name="steamId">The Steam ID of the player being added to the clan.</param>
/// <returns>No return behavior.</returns>
void OnClanMemberAdded(long clanId, ulong steamId)
{
    Puts($"Player with SteamID {steamId} has been added to clan with ID {clanId}.");
}
```
```

### Source Code from the Library

```csharp

	public bool AcceptInvite(long clanId, ulong steamId)
	{
		BeginTransaction();
		try
		{
			if (DeleteInvite(clanId, steamId) && CreateMember(clanId, steamId))
			{
				Commit();
				Interface.CallHook("OnClanMemberAdded", clanId, steamId);
				return true;
			}
			Rollback();
			return false;
		}
		catch
		{
			Rollback();
			throw;
		}
	}

```

