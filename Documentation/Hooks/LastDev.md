# Hook Definitions

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating another player or entity.
/// </summary>
/// <param name="player">The player who is starting to spectate.</param>
/// <param name="filter">The filter used to determine what the player is spectating (e.g., player name or ID).</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.displayName} is attempting to spectate with filter: {filter}.");
    
    // Example condition to block spectating
    if (filter == "blockedPlayer")
    {
        Puts($"Player {player.displayName} is not allowed to spectate {filter}.");
        return "You cannot spectate this player.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnFuelConsumed(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by the oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The fuel item being consumed.</param>
/// <param name="burnable">The burnable item mod associated with the fuel.</param>
/// <returns>No return behavior.</returns>
void OnFuelConsumed(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel consumed in oven: {oven.net.ID}, Fuel: {fuel.info.displayName.english}, Burnable: {burnable.shortname}");
    
    if (fuel.amount <= 0)
    {
        Puts("No fuel left to consume.");
    }
    else
    {
        Puts($"Remaining fuel amount: {fuel.amount}");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Facepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## OnNpcConversationStart(NPCTalking,BasePlayer,ConversationData)

```csharp
```csharp
/// <summary>
/// Called when a player starts a conversation with an NPC.
/// </summary>
/// <param name="npc">The NPC that the player is talking to.</param>
/// <param name="player">The player initiating the conversation.</param>
/// <param name="conversationData">The data related to the conversation.</param>
/// <returns>Returns `null` to allow the conversation to proceed, or any non-null value to prevent it.</returns>
object OnNpcConversationStart(NPCTalking npc, BasePlayer player, ConversationData conversationData)
{
    Puts($"Player {player.displayName} has started a conversation with NPC: {npc.name}.");
    
    if (player.HasAchievement("NoTalk"))
    {
        Puts($"Player {player.displayName} is not allowed to talk to NPCs.");
        return "You cannot talk to NPCs.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Server_BeginTalking(BasePlayer ply)
	{
		if (!CanTalkTo(ply))
		{
			return;
		}
		CleanupConversingPlayers();
		OnConversationStarted(ply);
		ConversationData conversationFor = GetConversationFor(ply);
		if (conversationFor != null)
		{
			if (conversingPlayers.Contains(ply))
			{
				OnConversationEnded(ply);
			}
			if (Interface.CallHook("OnNpcConversationStart", this, ply, conversationFor) == null)
			{
				conversingPlayers.Add(ply);
				UpdateFlags();
				ClientRPC(RpcTarget.Player("Client_StartConversation", ply), GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech(ply));
			}
		}
	}

```

## OnCrateHack(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate starts being hacked.
/// </summary>
/// <param name="crate">The hackable locked crate that is being hacked.</param>
/// <returns>No return behavior.</returns>
void OnCrateHack(HackableLockedCrate crate)
{
    Puts($"Hacking started on crate ID: {crate.net.ID} by player {crate.OwnerID}.");
}
```
```

### Source Code from the Library

```csharp

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", this);
		BroadcastEntityMessage("HackingStarted", 20f, 256);
		SetFlag(Flags.Reserved1, b: true);
		InvokeRepeating(HackProgress, 1f, 1f);
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

```

## CanAffordToPlace(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Determines if a player can afford to place a construction using a planner.
/// </summary>
/// <param name="player">The player attempting to place the construction.</param>
/// <param name="planner">The planner being used for the construction.</param>
/// <param name="construction">The construction being placed.</param>
/// <returns>
/// Returns `true` if the player can afford to place the construction, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can afford the placement.
/// </returns>
bool? CanAffordToPlace(BasePlayer player, Planner planner, Construction construction)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to place a {construction.fullName} using a planner.");

    if (construction.fullName == "foundation.stone")
    {
        Puts($"Player {player.displayName} is not allowed to place a stone foundation.");
        return false;
    }

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can place constructions without resource checks.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordToPlace(Construction component)
	{
		if (isTypeDeployable)
		{
			return true;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return false;
		}
		object obj = Interface.CallHook("CanAffordToPlace", ownerPlayer, this, component);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			if ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnDoorKnocked(DoorKnocker,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player knocks on a door.
/// </summary>
/// <param name="doorKnocker">The door that was knocked on.</param>
/// <param name="player">The player who knocked on the door.</param>
/// <returns>No return behavior.</returns>
void OnDoorKnocked(DoorKnocker doorKnocker, BasePlayer player)
{
    Puts($"Player {player.displayName} knocked on the door at position: {doorKnocker.transform.position}.");
    
    // Additional logic can be added here, such as triggering sounds or animations.
}
```
```

### Source Code from the Library

```csharp

	public void Knock(BasePlayer player)
	{
		ClientRPC(RpcTarget.NetworkGroup("ClientKnock"), player.transform.position);
		Interface.CallHook("OnDoorKnocked", this, player);
	}

```

## CanLock(BasePlayer,ModularCar,ModularCarCodeLock)

```csharp
```csharp
/// <summary>
/// Determines whether a player can lock a modular car with a code lock.
/// </summary>
/// <param name="player">The player attempting to lock the car.</param>
/// <param name="car">The modular car being locked.</param>
/// <param name="codeLock">The code lock being used.</param>
/// <returns>
/// Returns `true` if the player can lock the car, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can lock the car.
/// </returns>
bool? CanLock(BasePlayer player, ModularCar car, ModularCarCodeLock codeLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to lock the car {car.net.ID}.");

    if (car.HasALock)
    {
        Puts($"Car {car.net.ID} already has a lock.");
        return false;
    }

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} is dead and cannot lock the car.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool HasLockPermission(BasePlayer player)
	{
		if (!HasALock)
		{
			return true;
		}
		if (!player.IsValid() || player.IsDead())
		{
			return false;
		}
		object obj = Interface.CallHook("CanLock", player, owner, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return whitelistPlayers.Contains(player.userID);
	}

```

## OnGrowableGather(GrowableEntity,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to gather resources from a growable entity.
/// </summary>
/// <param name="growable">The growable entity being harvested.</param>
/// <param name="player">The player attempting to gather resources.</param>
/// <param name="eat">Indicates whether the player intends to eat the gathered fruit.</param>
/// <returns>No return behavior.</returns>
void OnGrowableGather(GrowableEntity growable, BasePlayer player, bool eat)
{
    Puts($"Player {player.displayName} is attempting to gather from {growable.prefabID} (Eat: {eat}).");
    
    if (growable.harvests >= growable.Properties.maxHarvests)
    {
        Puts($"The growable entity {growable.prefabID} has reached its maximum harvest limit.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PickFruit(BasePlayer player, bool eat = false)
	{
		if (!CanPick() || Interface.CallHook("OnGrowableGather", this, player, eat) != null)
		{
			return;
		}
		harvests++;
		GiveFruit(player, CurrentPickAmount, eat);
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(player, base.transform.position);
		}
		ResetSeason();
		if (Properties.pickEffect.isValid)
		{
			Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
		}
		if (harvests >= Properties.maxHarvests)
		{
			if (Properties.disappearAfterHarvest)
			{
				TellPlanter();
				Die();
			}
			else
			{
				ChangeState(PlantProperties.State.Dying, resetAge: true);
			}
		}
		else
		{
			ChangeState(PlantProperties.State.Mature, resetAge: true);
		}
	}

```

## CanBeHomingTargeted(PlayerHelicopter)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player-controlled helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The player-controlled helicopter to check.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the helicopter can be targeted.
/// </returns>
bool? CanBeHomingTargeted(PlayerHelicopter helicopter)
{
    Puts($"Checking if Helicopter ID: {helicopter.net.ID} can be targeted by homing missiles.");
    // Additional logic can be added here if needed
    return null; // Default behavior will be used
}
```
```

### Source Code from the Library

```csharp

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsOn();
	}

```

## OnItemUnlock(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is unlocked.
/// </summary>
/// <param name="item">The item that has been unlocked.</param>
/// <returns>No return behavior.</returns>
void OnItemUnlock(Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) has been unlocked.");
    
    // Additional logic can be added here, such as notifying players or updating inventory.
}
```
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## CanUseHelicopter(BasePlayer,CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a helicopter.
/// </summary>
/// <param name="player">The player attempting to use the helicopter.</param>
/// <param name="helicopter">The helicopter that the player is trying to use.</param>
/// <returns>
/// Returns `null` to allow the player to use the helicopter, or any non-null value to prevent usage.
/// </returns>
object CanUseHelicopter(BasePlayer player, CH47HelicopterAIController helicopter)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use the helicopter.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot use the helicopter while dead.");
        return "You cannot use the helicopter while dead.";
    }

    if (player.inventory.armorAmount < 50)
    {
        Puts($"Player {player.displayName} does not have enough armor to use the helicopter.");
        return "You need more armor to use the helicopter.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", player, this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject,UnityEngine.Collider)

```csharp
```csharp
/// <summary>
/// Called when an object is detected by a trap trigger.
/// </summary>
/// <param name="trap">The trap that has been triggered.</param>
/// <param name="triggeredObject">The game object that triggered the trap.</param>
/// <param name="collider">The collider of the triggered object.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trap, UnityEngine.GameObject triggeredObject, UnityEngine.Collider collider)
{
    Puts($"Trap {trap.gameObject.name} has been triggered by {triggeredObject.name}.");
    
    // Additional logic can be added here, such as applying effects to the triggered object.
}
```
```

### Source Code from the Library

```csharp

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		Interface.CallHook("OnTrapSnapped", this, obj, col);
		base.OnObjectAdded(obj, col);
		_trap.ObjectEntered(obj);
	}

```

## OnBoomboxToggle(BoomBox,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a boombox is toggled on or off by a player.
/// </summary>
/// <param name="boombox">The boombox that is being toggled.</param>
/// <param name="player">The player who is toggling the boombox.</param>
/// <param name="isPlaying">Indicates whether the boombox is being turned on (true) or off (false).</param>
/// <returns>No return behavior.</returns>
void OnBoomboxToggle(BoomBox boombox, BasePlayer player, bool isPlaying)
{
    Puts($"Boombox {boombox.net.ID} toggled by {player.displayName}. Now playing: {isPlaying}");
    
    if (isPlaying)
    {
        Puts($"Boombox {boombox.net.ID} is now playing music.");
    }
    else
    {
        Puts($"Boombox {boombox.net.ID} has been stopped.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ServerTogglePlay(BaseEntity.RPCMessage msg)
	{
		if (IsPowered())
		{
			bool flag = msg.read.ReadByte() == 1;
			if (Interface.CallHook("OnBoomboxToggle", this, msg.player, flag) == null)
			{
				ServerTogglePlay(flag);
			}
		}
	}

```

## OnDemoRecordingStopped(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is stopped.
/// </summary>
/// <param name="filename">The name of the recording file that was stopped.</param>
/// <param name="player">The player who stopped the recording.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStopped(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped for player {player.displayName} (ID: {player.UserIDString}). Filename: {filename}");
}
```
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a code is entered into the code lock.
/// </summary>
/// <param name="codeLock">The code lock that received the code entry.</param>
/// <param name="player">The player who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>
/// Returns a non-null value to prevent the default behavior of the code entry. 
/// If `null` is returned, the code entry will proceed as normal.
/// </returns>
object OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
{
    Puts($"Player {player.displayName} entered code: {code} on CodeLock ID: {codeLock.net.ID}");

    if (code == "1234")
    {
        Puts("Access granted with the default code.");
        return null; // Allow default behavior
    }

    Puts("Access denied: Invalid code entered.");
    return true; // Prevent default behavior
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked() || IsCodeEntryBlocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, blockwarning, false);
			}
			if ((float)wrongCodes >= maxFailedAttempts)
			{
				SetFlag(Flags.Reserved11, b: true);
				Invoke(ClearCodeEntryBlocked, lockoutCooldown);
			}
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
				wrongCodes = 0;
			}
			Facepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: false);
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
			Facepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: true);
		}
	}

```

## OnCodeChanged(BasePlayer,CodeLock,string,bool)

```csharp
```csharp
/// <summary>
/// Called when the code for a code lock is changed.
/// </summary>
/// <param name="player">The player who is changing the code.</param>
/// <param name="codeLock">The code lock being modified.</param>
/// <param name="newCode">The new code being set.</param>
/// <param name="isGuestCode">Indicates if the new code is a guest code.</param>
/// <returns>No return behavior.</returns>
void OnCodeChanged(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
{
    Puts($"Player {player.displayName} changed the code for {codeLock.name} to {newCode}. Guest code: {isGuestCode}");

    if (isGuestCode)
    {
        Puts($"Guest code set by {player.displayName} for {codeLock.name}.");
    }
    else
    {
        Puts($"Main code set by {player.displayName} for {codeLock.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (!IsLocked() && text.Length == 4 && text.IsNumeric() && !(!hasCode && flag) && Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!hasCode && !flag)
			{
				SetFlag(Flags.Locked, b: true);
			}
			Facepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			Interface.CallHook("OnCodeChanged", rpc.player, this, text, flag);
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item,ItemCrafter)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is completed.
/// </summary>
/// <param name="task">The crafting task that has been finished.</param>
/// <param name="item">The item that was crafted.</param>
/// <param name="craftingStation">The entity or station that performed the crafting.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftFinished(ItemCraftTask task, Item item, ItemCrafter craftingStation)
{
    Puts($"Crafting finished: {item.info.displayName.english} (ID: {item.info.itemid}) crafted by {craftingStation?.gameObject.name ?? "unknown"}.");

    if (item.info.shortname == "explosive.timed")
    {
        Puts("Warning: A timed explosive has been crafted!");
    }

    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item2 = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item2.amount = task.blueprint.amountToCreate;
		int amount = item2.amount;
		_ = owner.currentCraftLevel;
		bool inSafezone = owner.InSafeZone();
		if (item2.hasCondition && task.conditionScale != 1f)
		{
			item2.maxCondition *= task.conditionScale;
			item2.condition = item2.maxCondition;
		}
		item2.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					Facepunch.Rust.Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item2.info.shortname);
					takenItem.UseItem(num);
					num -= num2;
				}
				if (num <= 0)
				{
					break;
				}
			}
		}
		task.takenItems?.RemoveAll((Item item) => item.amount == 0);
		Facepunch.Rust.Analytics.Server.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		Facepunch.Rust.Analytics.Azure.OnCraftItem(item2.info.shortname, item2.amount, base.baseEntity, task.workbenchEntity, inSafezone);
		owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item2, this);
		if (task.instanceData != null)
		{
			item2.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		owner.ProcessMissionEvent(BaseMission.MissionEventType.CRAFT_ITEM, item2.info.itemid, amount);
		if (owner.inventory.GiveItem(item2))
		{
			owner.Command("note.inv", item2.info.itemid, amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		owner.Command("note.inv", item2.info.itemid, amount);
		owner.Command("note.inv", item2.info.itemid, -item2.amount);
		item2.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnItemFilter(Item,StorageContainer,int)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be accepted into a storage container based on its category.
/// </summary>
/// <param name="item">The item being filtered.</param>
/// <param name="storage">The storage container that is receiving the item.</param>
/// <param name="targetSlot">The slot in the storage container where the item is being placed.</param>
/// <returns>
/// Returns `true` if the item can be accepted, or `false` if it cannot. 
/// If the method returns `null`, the default filtering logic will be applied.
/// </returns>
bool? OnItemFilter(Item item, StorageContainer storage, int targetSlot)
{
    Puts($"Filtering item: {item.info.displayName.english} for storage in slot {targetSlot}.");

    if (item.info.shortname == "wood")
    {
        Puts("Wood is always accepted.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ItemFilter(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("OnItemFilter", item, this, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (onlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		return item.info.category == onlyAcceptCategory;
	}

```

## CanUnlock(BasePlayer,ModularCarCodeLock,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a modular car's code lock with the provided code.
/// </summary>
/// <param name="player">The player attempting to unlock the code lock.</param>
/// <param name="codeLock">The modular car's code lock being unlocked.</param>
/// <param name="codeEntered">The code entered by the player.</param>
/// <returns>
/// Returns `true` if the player can unlock the code lock, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can unlock the code lock.
/// </returns>
bool? CanUnlock(BasePlayer player, ModularCarCodeLock codeLock, string codeEntered)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to unlock the code lock with code: {codeEntered}.");

    if (codeEntered.Length < 4)
    {
        Puts($"Player {player.displayName} entered an invalid code length.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool TryOpenWithCode(BasePlayer player, string codeEntered)
	{
		object obj = Interface.CallHook("CanUnlock", player, this, codeEntered);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CodeEntryBlocked(player))
		{
			return false;
		}
		if (!(codeEntered == Code))
		{
			if (Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				player.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning, false);
			}
			if ((float)wrongCodes >= CodeLock.maxFailedAttempts)
			{
				owner.SetFlag(BaseEntity.Flags.Reserved10, b: true);
				owner.Invoke(ClearCodeEntryBlocked, CodeLock.lockoutCooldown);
			}
			lastWrongTime = Time.realtimeSinceStartup;
			return false;
		}
		if (TryAddPlayer(player.userID))
		{
			wrongCodes = 0;
		}
		owner.SendNetworkUpdate();
		return true;
	}

```

## OnSignalBroadcast(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a signal is broadcasted from a server entity.
/// </summary>
/// <param name="entity">The entity that is broadcasting the signal.</param>
/// <returns>Returns `null` to allow the broadcast, or any non-null value to prevent it.</returns>
object OnSignalBroadcast(BaseEntity entity)
{
    Puts($"Signal broadcasted from entity: {entity.net.ID} ({entity.ShortPrefabName})");

    // Example condition to prevent broadcasting
    if (entity.ShortPrefabName == "restricted.signal.entity")
    {
        Puts("Broadcasting is restricted for this entity.");
        return true; // Prevent the broadcast
    }

    return null; // Allow the broadcast
}
```
```

### Source Code from the Library

```csharp

	public void SignalBroadcast(Signal signal, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", this) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("SignalFromServer", this, SendMethod.Unreliable, Priority.Immediate), (int)signal, sourceConnection?.userid ?? 0);
		}
	}

```

## OnAdventGiftAward(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an advent gift is awarded to a player.
/// </summary>
/// <param name="calendar">The advent calendar instance managing the gifts.</param>
/// <param name="player">The player receiving the gift.</param>
/// <returns>No return behavior.</returns>
void OnAdventGiftAward(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Awarding advent gift to player {player.displayName} (ID: {player.userID}).");
    
    if (player.IsBanned)
    {
        Puts($"Player {player.displayName} is banned and cannot receive gifts.");
        return;
    }
    
    Puts($"Player {player.displayName} is eligible for the advent gift.");
}
```
```

### Source Code from the Library

```csharp

	public void AwardGift(BasePlayer player)
	{
		if (Interface.CallHook("OnAdventGiftAward", this, player) != null)
		{
			return;
		}
		DateTime now = DateTime.Now;
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) == startMonth && num >= 0 && num < days.Length)
		{
			if (!playerRewardHistory.ContainsKey(player.userID))
			{
				playerRewardHistory.Add(player.userID, new List<int>());
			}
			playerRewardHistory[player.userID].Add(num);
			Effect.server.Run(giftEffect.resourcePath, player.transform.position);
			if (num >= 0 && num < crosses.Length)
			{
				Effect.server.Run(boxCloseEffect.resourcePath, base.transform.position + Vector3.up * 1.5f);
			}
			DayReward dayReward = days[num];
			for (int i = 0; i < dayReward.rewards.Length; i++)
			{
				ItemAmount itemAmount = dayReward.rewards[i];
				player.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);
			}
			Interface.CallHook("OnAdventGiftAwarded", this, player);
		}
	}

```

## CanUnlock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a key lock.
/// </summary>
/// <param name="player">The player attempting to unlock the key lock.</param>
/// <param name="keyLock">The key lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the unlocking, or any non-null value to prevent the unlocking action.
/// </returns>
object CanUnlock(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to unlock a key lock.");

    if (player.inventory.GetAmount("key") < 1)
    {
        Puts($"Player {player.displayName} does not have a key to unlock the lock.");
        return "You need a key to unlock this.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnNearbyTurretsScan(AutoTurret,System.Collections.Generic.List<AutoTurret>,bool)

```csharp
```csharp
/// <summary>
/// Called to scan for nearby turrets and update their references.
/// </summary>
/// <param name="turret">The turret performing the scan.</param>
/// <param name="nearbyTurrets">A list of nearby turrets found during the scan.</param>
/// <param name="created">Indicates whether the turrets were newly created or not.</param>
/// <returns>No return behavior.</returns>
void OnNearbyTurretsScan(AutoTurret turret, List<AutoTurret> nearbyTurrets, bool created)
{
    Puts($"Scanning for nearby turrets around turret ID: {turret.net.ID}, Created: {created}");
    
    if (created)
    {
        Puts($"New turrets detected around turret ID: {turret.net.ID}");
    }
    else
    {
        Puts($"Updating existing turrets around turret ID: {turret.net.ID}");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateNearbyTurrets(bool created)
	{
		List<AutoTurret> obj = Facepunch.Pool.Get<List<AutoTurret>>();
		if (Interface.CallHook("OnNearbyTurretsScan", this, obj, created) == null)
		{
			Vis.Entities(base.transform.position, Sentry.interferenceradius, obj, 256, QueryTriggerInteraction.Ignore);
		}
		foreach (AutoTurret item in obj)
		{
			if (!(item == this))
			{
				if (created)
				{
					nearbyTurrets.Add(item);
					item.nearbyTurrets.Add(this);
				}
				else
				{
					item.nearbyTurrets.Remove(this);
				}
			}
		}
		if (!created)
		{
			nearbyTurrets.Clear();
		}
		Facepunch.Pool.FreeUnmanaged(ref obj);
	}

```

## OnEntityDestroy(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the CH47 helicopter AI controller is destroyed.
/// </summary>
/// <param name="helicopter">The helicopter that is being destroyed.</param>
/// <returns>
/// Returns `null` to allow the default destruction behavior, or any non-null value to prevent it.
/// </returns>
object OnEntityDestroy(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.net.ID} is being destroyed.");
    
    // Example condition to prevent destruction
    if (helicopter.HasActiveMission())
    {
        Puts($"Helicopter {helicopter.net.ID} cannot be destroyed while on a mission.");
        return true; // Prevent destruction
    }
    
    return null; // Allow destruction
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

```

## OnExperimentEnded(Workbench)

```csharp
```csharp
/// <summary>
/// Called when an experiment at the workbench has completed.
/// </summary>
/// <param name="workbench">The workbench where the experiment was conducted.</param>
/// <returns>No return behavior.</returns>
void OnExperimentEnded(Workbench workbench)
{
    Puts($"Experiment ended at Workbench ID: {workbench.net.ID}. Pending blueprint: {workbench.pendingBlueprint?.itemid ?? "None"}");

    if (workbench.pendingBlueprint == null)
    {
        Puts("No pending blueprint to process after experiment.");
    }
    else
    {
        Puts($"Blueprint {workbench.pendingBlueprint.itemid} is ready for crafting.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnFishCatch(Item,BaseFishingRod,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a fish is successfully caught by a player.
/// </summary>
/// <param name="item">The item representing the caught fish.</param>
/// <param name="fishingRod">The fishing rod used to catch the fish.</param>
/// <param name="player">The player who caught the fish.</param>
/// <returns>
/// Returns an item to replace the caught fish if needed, or `null` to proceed with the caught fish.
/// </returns>
object OnFishCatch(Item item, BaseFishingRod fishingRod, BasePlayer player)
{
    Puts($"Player {player.displayName} has caught a fish: {item.info.displayName.english} (Item ID: {item.info.itemid}).");

    if (item.info.shortname == "fish.tuna")
    {
        Puts("A rare tuna has been caught!");
        // Potentially replace the item with a special version
        return ItemManager.Create("fish.tuna.special", 1, 0uL);
    }

    return null; // Proceed with the caught fish as is
}
```
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## OnWildlifeTrap(WildlifeTrap,TrappableWildlife)

```csharp
```csharp
/// <summary>
/// Called when a wildlife trap successfully traps a wild animal.
/// </summary>
/// <param name="trap">The wildlife trap that captured the animal.</param>
/// <param name="wildlife">The wild animal that was trapped.</param>
/// <returns>No return behavior.</returns>
void OnWildlifeTrap(WildlifeTrap trap, TrappableWildlife wildlife)
{
    Puts($"Wildlife trap {trap.name} has captured a {wildlife.displayName}.");
    
    if (wildlife.isRare)
    {
        Puts($"A rare wildlife has been trapped: {wildlife.displayName}!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void TrapWildlife(TrappableWildlife trapped)
	{
		if (Interface.CallHook("OnWildlifeTrap", this, trapped) == null)
		{
			Item item = ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Remove();
				OnTrappedWildlife(setFlag: false);
			}
			else
			{
				OnTrappedWildlife(setFlag: true);
			}
		}
	}

```

## OnNpcEquipWeapon(ScientistNPC,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon.
/// </summary>
/// <param name="npc">The NPC that is equipping the weapon.</param>
/// <param name="item">The item being equipped as a weapon.</param>
/// <returns>
/// Returns a non-null value to prevent the NPC from equipping the weapon. 
/// If `null` is returned, the NPC will proceed to equip the weapon as normal.
/// </returns>
object OnNpcEquipWeapon(ScientistNPC npc, Item item)
{
    Puts($"NPC {npc.displayName} is attempting to equip weapon: {item.info.displayName.english}.");

    if (item.info.shortname == "weapon.semiauto")
    {
        Puts($"NPC {npc.displayName} is not allowed to equip a semi-automatic weapon.");
        return true; // Prevent equipping
    }

    return null; // Allow equipping
}
```
```

### Source Code from the Library

```csharp

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
		HeldEntity heldEntity = GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		Item item = heldEntity.GetItem();
		if (item == null || item.contents == null || Interface.CallHook("OnNpcEquipWeapon", this, item) != null)
		{
			return;
		}
		if (UnityEngine.Random.Range(0, 3) == 0)
		{
			Item item2 = ItemManager.CreateByName("weapon.mod.flashlight", 1, 0uL);
			if (!item2.MoveToContainer(item.contents))
			{
				item2.Remove();
				return;
			}
			lightsOn = false;
			InvokeRandomized(base.LightCheck, 0f, 30f, 5f);
			LightCheck();
		}
		else
		{
			Item item3 = ItemManager.CreateByName("weapon.mod.lasersight", 1, 0uL);
			if (!item3.MoveToContainer(item.contents))
			{
				item3.Remove();
			}
			LightToggle();
			lightsOn = true;
		}
	}

```

## CanBeRecycled(Item,Recycler)

```csharp
```csharp
/// <summary>
/// Determines whether the specified item can be recycled at the recycler.
/// </summary>
/// <param name="item">The item to check for recyclability.</param>
/// <param name="recycler">The recycler that is attempting to recycle the item.</param>
/// <returns>
/// Returns `true` if the item can be recycled; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the item can be recycled.
/// </returns>
bool? CanBeRecycled(Item item, Recycler recycler)
{
    Puts($"Checking recyclability for item: {item.info.displayName.english} (ID: {item.info.itemid}) at recycler: {recycler.gameObject.name}.");

    if (item.info.shortname == "wood")
    {
        Puts("Wood can always be recycled.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanBeRecycled(Item item)
	{
		object obj = Interface.CallHook("CanBeRecycled", item, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item != null)
		{
			return item.info.Blueprint != null;
		}
		return false;
	}

```

## OnQuarryConsumeFuel(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when the mining quarry consumes fuel.
/// </summary>
/// <param name="quarry">The mining quarry that is consuming fuel.</param>
/// <param name="fuelItem">The item being used as fuel.</param>
/// <returns>
/// Returns the item that was consumed as fuel, or `null` if no fuel was consumed.
/// </returns>
Item OnQuarryConsumeFuel(MiningQuarry quarry, Item fuelItem)
{
    Puts($"Mining Quarry {quarry.net.ID} is attempting to consume fuel: {fuelItem?.info.displayName.english ?? "None"}.");

    if (fuelItem != null && fuelItem.info.shortname == "diesel_barrel")
    {
        Puts($"Fuel consumed: {fuelItem.info.displayName.english}.");
        return fuelItem; // Return the consumed fuel item
    }

    Puts("No valid fuel item was consumed.");
    return null; // No fuel consumed
}
```
```

### Source Code from the Library

```csharp

	public bool FuelCheck()
	{
		if (pendingWork > 0f)
		{
			return true;
		}
		Item item = fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemByItemName("diesel_barrel");
		object obj = Interface.CallHook("OnQuarryConsumeFuel", this, item);
		if (obj is Item)
		{
			item = (Item)obj;
		}
		if (item != null && item.amount >= 1)
		{
			pendingWork += workPerFuel;
			Facepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);
			item.UseItem();
			return true;
		}
		return false;
	}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an admin opens the vending machine interface.
/// </summary>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <param name="adminPlayer">The player who is an admin and opening the vending machine.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer adminPlayer)
{
    Puts($"Admin {adminPlayer.displayName} has opened the vending machine: {vendingMachine.net.ID}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			OpenShop(player);
			ClientRPC(RpcTarget.Player("CLIENT_OpenAdminMenu", player));
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## CanReceiveCall(PhoneController)

```csharp
```csharp
/// <summary>
/// Determines whether the phone controller can receive calls.
/// </summary>
/// <param name="phoneController">The phone controller instance checking for call reception.</param>
/// <returns>
/// Returns `true` if the phone can receive calls; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine call reception capability.
/// </returns>
bool? CanReceiveCall(PhoneController phoneController)
{
    Puts($"Checking if PhoneController (ID: {phoneController.net.ID}) can receive calls.");

    if (!phoneController.IsPowered())
    {
        Puts("PhoneController is not powered and cannot receive calls.");
        return false;
    }

    if (phoneController.RequireParent && !phoneController.baseEntity.HasParent())
    {
        Puts("PhoneController requires a parent entity to receive calls.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanReceiveCall()
	{
		object obj = Interface.CallHook("CanReceiveCall", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequirePower && !IsPowered())
		{
			return false;
		}
		if (RequireParent && !base.baseEntity.HasParent())
		{
			return false;
		}
		return true;
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when an auto turret acquires or loses a target.
/// </summary>
/// <param name="turret">The auto turret that is targeting.</param>
/// <param name="target">The target entity being acquired or lost.</param>
/// <returns>No return behavior.</returns>
void OnTurretTarget(AutoTurret turret, BaseCombatEntity target)
{
    Puts($"Turret {turret.net.ID} has changed target to {target?.net.ID ?? "none"}.");
    
    if (target != null)
    {
        Puts($"Turret {turret.net.ID} is now targeting entity {target.net.ID}.");
    }
    else
    {
        Puts($"Turret {turret.net.ID} has lost its target.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);
				MarkDirtyForceUpdateOutputs();
				nextShotTime += 0.1f;
				authDirty = true;
			}
			target = targ;
		}
	}

```

## OnEntityActiveCheck(BaseEntity,BasePlayer,uint,string)

```csharp
```csharp
/// <summary>
/// Called to check if a player can interact with a specific entity based on activity conditions.
/// </summary>
/// <param name="entity">The entity being checked for activity.</param>
/// <param name="player">The player attempting to interact with the entity.</param>
/// <param name="id">A unique identifier for the check.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <returns>
/// Returns `true` if the player can interact with the entity, `false` otherwise.
/// If the method returns `null`, the default game logic will determine the interaction validity.
/// </returns>
bool? OnEntityActiveCheck(BaseEntity entity, BasePlayer player, uint id, string debugName)
{
    Puts($"Checking activity for Player {player.displayName} on Entity {entity?.name} (ID: {entity?.net.ID}) with debug name: {debugName}");

    if (entity == null || player == null)
    {
        Puts("Entity or player is null, cannot proceed with the check.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityActiveCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				Item activeItem = player.GetActiveItem();
				if (activeItem == null)
				{
					return false;
				}
				if (activeItem.GetHeldEntity() != ent)
				{
					return false;
				}
				return true;
			}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Determines whether the helicopter can use napalm based on cooldown and external hooks.
/// </summary>
/// <param name="helicopter">The helicopter instance attempting to use napalm.</param>
/// <returns>
/// Returns `true` if the helicopter can use napalm, or `false` if it cannot.
/// If the method returns `null`, the default cooldown logic will be applied.
/// </returns>
bool? CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter {helicopter.net.ID} can use napalm.");
    
    // Example condition to block napalm usage
    if (helicopter.IsUnderAttack)
    {
        Puts($"Helicopter {helicopter.net.ID} is under attack and cannot use napalm.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= UnityEngine.Random.Range(25f, 35f);
	}

```

## OnPhoneCallStarted(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone call is successfully started.
/// </summary>
/// <param name="caller">The phone controller initiating the call.</param>
/// <param name="receiver">The phone controller receiving the call.</param>
/// <param name="player">The player involved in the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneCallStarted(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone call started from {caller} to {receiver} by player {player.displayName} (ID: {player.UserIDString}).");
    
    if (receiver != null && receiver.RequirePower)
    {
        Puts($"Call cannot proceed: {receiver} requires power.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", this, activeCallTo, currentPlayer) == null)
		{
			if (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)
			{
				_ = currentPlayer != null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			Invoke(TimeOutCall, TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", this, activeCallTo, currentPlayer);
		}
	}

```

## OnSignUpdated(CarvablePumpkin,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated by a player.
/// </summary>
/// <param name="pumpkin">The CarvablePumpkin that contains the sign being updated.</param>
/// <param name="player">The player who is updating the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(CarvablePumpkin pumpkin, BasePlayer player)
{
    Puts($"Sign updated by player {player.displayName} on CarvablePumpkin ID: {pumpkin.net.ID}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has updated the sign successfully.");
    }
    else
    {
        Puts($"Player {player.displayName} updated the sign but is not an admin.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			UnityEngine.Debug.LogWarning($"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", this, msg.player);
	}

```

## OnVendingShopOpen(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to open a vending shop.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player attempting to open the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpen(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to open the vending shop at {vendingMachine.transform.position}.");
    
    if (player.IsBannedFromVending())
    {
        Puts($"Player {player.displayName} is banned from using vending machines.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", this, msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", this, msg.player);
		}
	}

```

## OnExcavatorMiningToggled(ExcavatorArm)

```csharp
```csharp
/// <summary>
/// Called when the mining state of the excavator is toggled.
/// </summary>
/// <param name="excavator">The excavator arm that is being toggled for mining.</param>
/// <returns>No return behavior.</returns>
void OnExcavatorMiningToggled(ExcavatorArm excavator)
{
    Puts($"Excavator {excavator.net.ID} mining state toggled. Current state: {(excavator.IsMining() ? "Mining" : "Not Mining")}");
}
```
```

### Source Code from the Library

```csharp

	public void BeginMining()
	{
		if (!IsPowered())
		{
			return;
		}
		SetFlag(Flags.On, b: true);
		InvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);
		if (UnityEngine.Time.time > nextNotificationTime)
		{
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				if (!activePlayer.IsNpc && activePlayer.IsConnected && !activePlayer.IsInTutorial)
				{
					activePlayer.ShowToast(GameTip.Styles.Server_Event, excavatorPhrase, false);
				}
			}
			nextNotificationTime = UnityEngine.Time.time + 60f;
		}
		ExcavatorServerEffects.SetMining(isMining: true);
		Facepunch.Rust.Analytics.Server.ExcavatorStarted();
		excavatorStartTime = GetNetworkTime();
		Interface.CallHook("OnExcavatorMiningToggled", this);
	}

```

## OnClientProjectileEffectCreate(Network.Connection,BaseProjectile,string)

```csharp
```csharp
/// <summary>
/// Called when a projectile effect is created on the client side.
/// </summary>
/// <param name="connection">The network connection of the player for whom the effect is being created.</param>
/// <param name="projectile">The projectile associated with the effect.</param>
/// <param name="prefabName">The name of the prefab for the projectile effect.</param>
/// <returns>
/// Returns `null` to allow the default effect creation behavior, or any non-null value to prevent it.
/// </returns>
object OnClientProjectileEffectCreate(Network.Connection connection, BaseProjectile projectile, string prefabName)
{
    Puts($"Creating client projectile effect for {prefabName} from connection {connection.address}.");
    
    if (prefabName == "explosive.projectile")
    {
        Puts("Preventing explosive projectile effect from being created on the client.");
        return true; // Prevent the effect
    }
    
    return null; // Allow the effect to be created
}
```
```

### Source Code from the Library

```csharp

	public void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false, List<Connection> targets = null)
	{
		if (Interface.CallHook("OnClientProjectileEffectCreate", sourceConnection, this, prefabName) == null)
		{
			Effect effect = reusableInstance;
			effect.Clear();
			effect.Init(Effect.Type.Projectile, pos, velocity, sourceConnection);
			effect.scale = (silenced ? 0f : 1f);
			if (forceClientsideEffects)
			{
				effect.scale = 2f;
			}
			effect.pooledString = prefabName;
			effect.number = seed;
			effect.targets = targets;
			EffectNetwork.Send(effect);
		}
	}

```

## OnHorseLead(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to lead a horse.
/// </summary>
/// <param name="horse">The horse being led.</param>
/// <param name="player">The player attempting to lead the horse.</param>
/// <returns>
/// Returns `null` to allow the leading action, or any non-null value to prevent the action.
/// </returns>
object OnHorseLead(BaseRidableAnimal horse, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to lead horse ID: {horse.net.ID}.");

    if (player.IsInCombat)
    {
        Puts($"Player {player.displayName} cannot lead the horse while in combat.");
        return "You cannot lead a horse while in combat.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Lead(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && !AnyMounted() && !IsForSale())
		{
			bool num = IsLeading();
			bool flag = msg.read.Bit();
			if (num != flag && Interface.CallHook("OnHorseLead", this, player) == null)
			{
				SetLeading(flag ? player : null);
				LeadingChanged();
			}
		}
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base combat entity is hurt.
/// </summary>
/// <param name="entity">The base combat entity that is being hurt.</param>
/// <param name="hitInfo">Information about the hit, including damage and the attacker.</param>
/// <returns>
/// Returns a non-null value to prevent further processing of the hurt event. 
/// If `null` is returned, the default damage handling will proceed.
/// </returns>
object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.net.ID} is being hurt by {hitInfo.Initiator?.net.ID} with damage: {hitInfo.damageTypes.Total()}");

    if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Explosive)
    {
        Puts($"Entity {entity.net.ID} cannot be hurt by explosives.");
        return true; // Prevents further processing
    }

    return null; // Allow default processing
}
```
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead() || IsTransferProtected())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (!(this is BasePlayer))
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			float num2 = info.damageTypes.Total();
			health = num - num2;
			SendNetworkUpdate();
			LogEntry(RustLog.EntryType.Combat, 2, "hurt {0}/{1} - {2} health left", info.damageTypes.GetMajorityDamageType(), num2, health.ToString("0"));
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
					baseCombatEntity.lastDealtDamageTo = this;
				}
				if (this.IsValid() && lastAttacker is BasePlayer basePlayer)
				{
					basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.HURT_ENTITY, net.ID, num2);
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (markAttackerHostile && baseCombatEntity2 != null && baseCombatEntity2 != this)
			{
				baseCombatEntity2.MarkHostileFor();
			}
			if (lastDamage.IsConsideredAnAttack())
			{
				SetJustAttacked();
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;
				}
			}
			bool flag = Health() <= 0f;
			Facepunch.Rust.Analytics.Azure.OnEntityTakeDamage(info, flag);
			if (flag)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.LogAttack(info, "killed", num);
				}
				else
				{
					initiatorPlayer.stats.combat.LogAttack(info, "", num);
				}
			}
		}
	}

```

## OnAddVendingOffer(VendingMachine,ProtoBuf.VendingMachine.SellOrder)

```csharp
```csharp
/// <summary>
/// Called when a new vending offer is added to the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine where the offer is being added.</param>
/// <param name="sellOrder">The details of the sell order being added.</param>
/// <returns>No return behavior.</returns>
void OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"New vending offer added: Sell {sellOrder.itemToSellAmount} of item ID {sellOrder.itemToSellID} " +
         $"for {sellOrder.currencyAmountPerItem} of currency ID {sellOrder.currencyID}.");

    if (sellOrder.currencyIsBP)
    {
        Puts("This offer uses blueprint currency.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = itemToSellID;
			sellOrder.itemToSellAmount = itemToSellAmount;
			sellOrder.currencyID = currencyToUseID;
			sellOrder.currencyAmountPerItem = currencyAmount;
			sellOrder.currencyIsBP = bpState == 3 || bpState == 2;
			sellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", this, sellOrder);
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## OnHelicopterRetire(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called when a patrol helicopter is set to retire.
/// </summary>
/// <param name="helicopter">The patrol helicopter that is retiring.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterRetire(PatrolHelicopterAI helicopter)
{
    Puts($"Patrol Helicopter ID: {helicopter.net.ID} is retiring.");
    if (helicopter.isRetiring)
    {
        Puts($"Helicopter ID: {helicopter.net.ID} is already in the process of retiring.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Retire()
	{
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", this) == null)
		{
			Invoke(DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 newPos = Vector3Ex.Range(-1f, 1f);
			newPos.y = 0f;
			newPos.Normalize();
			newPos *= x * 20f;
			newPos.y = y;
			ExitCurrentState();
			isRetiring = true;
			State_Move_Enter(newPos);
		}
	}

```

## CanElevatorLiftMove(ElevatorLift)

```csharp
```csharp
/// <summary>
/// Determines whether the elevator lift can move based on its current state and contents.
/// </summary>
/// <param name="elevator">The elevator lift being checked for movement capability.</param>
/// <returns>
/// Returns `true` if the elevator lift can move; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the elevator can move.
/// </returns>
bool? CanElevatorLiftMove(ElevatorLift elevator)
{
    Puts($"Checking if ElevatorLift ID: {elevator.net.ID} can move.");

    if (elevator.VehicleTrigger.HasContents)
    {
        Puts("Elevator has contents, checking for valid entities.");
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanMove()
	{
		object obj = Interface.CallHook("CanElevatorLiftMove", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (VehicleTrigger.HasContents && VehicleTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in VehicleTrigger.entityContents)
			{
				if (!vehiclePrefabWhitelist.Contains(entityContent.prefabID))
				{
					return false;
				}
			}
		}
		return true;
	}

```

## OnOvenStart(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when the oven starts cooking.
/// </summary>
/// <param name="oven">The oven that is starting to cook.</param>
/// <returns>No return behavior.</returns>
void OnOvenStart(BaseOven oven)
{
    Puts($"Oven {oven.net.ID} is starting to cook.");
    if (oven.inventory.temperature > 100)
    {
        Puts($"Oven {oven.net.ID} is already at a high temperature.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			InvokeRepeating(Cook, 0.5f, 0.5f);
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", this);
		}
	}

```

## OnMapImageUpdated()

```csharp
```csharp
/// <summary>
/// Called when a map image is updated by a player.
/// </summary>
/// <returns>No return behavior.</returns>
void OnMapImageUpdated()
{
    Puts("A map image has been updated.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(1uL)]
	public void ImageUpdate(RPCMessage msg)
	{
		if (msg.player == null)
		{
			return;
		}
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}

```

## IOnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine how much a NPC wants to attack a given target.
/// </summary>
/// <param name="npc">The NPC that is considering the attack.</param>
/// <param name="target">The target entity that the NPC may attack.</param>
/// <returns>
/// Returns a float value representing the NPC's desire to attack the target. 
/// If the method returns `null`, the default logic will be used to determine the attack desire.
/// </returns>
float? IOnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is evaluating attack on target: {target?.ShortPrefabName ?? "Unknown"}.");

    if (target is PlayerEntity)
    {
        Puts($"NPC {npc.displayName} has a strong desire to attack a player.");
        return 10.0f; // High desire to attack players
    }

    return null; // Use default logic if no specific condition is met
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

```

## OnSignLocked(PhotoFrame,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that is being locked.</param>
/// <param name="player">The player who is locking the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(PhotoFrame sign, BasePlayer player)
{
    Puts($"Sign locked by player {player.displayName} (ID: {player.UserIDString}). Sign ID: {sign.net.ID}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the looter can loot the target player; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if looting is allowed.
/// </returns>
bool? CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.displayName} is attempting to loot {target.displayName}.");

    if (target.IsSleeping())
    {
        Puts($"{target.displayName} is sleeping and cannot be looted.");
        return false;
    }

    if (target.IsWounded())
    {
        Puts($"{target.displayName} is wounded and can be looted.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		if ((IsWounded() || IsSleeping() || CurrentGestureIsSurrendering || IsRestrainedOrSurrendering) && !IsLoadingAfterTransfer())
		{
			return !IsTransferring();
		}
		return false;
	}

```

## CanLootEntity(BasePlayer,BaseRidableAnimal)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="animal">The entity being looted, which is a BaseRidableAnimal.</param>
/// <returns>
/// Returns `true` if the player can loot the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, BaseRidableAnimal animal)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot {animal.displayName}.");

    if (animal.IsSleeping())
    {
        Puts($"Player {player.displayName} cannot loot a sleeping animal.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (storageInventory == null)
		{
			return;
		}
		BasePlayer player = rpc.player;
		string text = rpc.read.String();
		if ((bool)player && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			ItemContainer container = equipmentInventory;
			string arg = lootPanelName;
			if (text == "storage")
			{
				arg = storagePanelName;
				container = storageInventory;
			}
			player.inventory.loot.AddContainer(container);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), arg);
			SendNetworkUpdate();
		}
	}

```

## OnWorldPrefabSpawned(UnityEngine.GameObject,string)

```csharp
```csharp
/// <summary>
/// Called when a prefab is spawned in the world.
/// </summary>
/// <param name="spawnedObject">The GameObject that was spawned.</param>
/// <param name="category">The category of the prefab that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnWorldPrefabSpawned(UnityEngine.GameObject spawnedObject, string category)
{
    Puts($"Prefab of category '{category}' has been spawned: {spawnedObject.name} at position {spawnedObject.transform.position}.");
    
    if (category == "enemy")
    {
        Puts("An enemy prefab has been spawned! Prepare for battle!");
    }
}
```
```

### Source Code from the Library

```csharp

	private static void SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		if (prefab != null && (bool)prefab.Object)
		{
			spawnTimer.Restart();
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject gameObject = prefab.Spawn(position, rotation, scale);
			if ((bool)gameObject)
			{
				Interface.CallHook("OnWorldPrefabSpawned", gameObject, category);
				GameObjectEx.SetHierarchyGroup(gameObject, category);
			}
			spawnTimer.Stop();
			spawnTimings.Add(new SpawnTiming
			{
				category = category,
				prefab = prefab,
				position = position,
				rotation = rotation,
				scale = scale,
				time = spawnTimer.Elapsed
			});
		}
	}

```

## OnItemStacked(Item,Item,ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when two items are stacked together in a container.
/// </summary>
/// <param name="stackedItem">The item that is being stacked on top.</param>
/// <param name="sourceItem">The item that is being added to the stack.</param>
/// <param name="container">The container where the stacking occurs.</param>
/// <returns>No return behavior.</returns>
void OnItemStacked(Item stackedItem, Item sourceItem, ItemContainer container)
{
    Puts($"Items stacked: {sourceItem.info.displayName.english} onto {stackedItem.info.displayName.english} in container {container.name}.");
    
    if (stackedItem.amount > stackedItem.MaxStackable())
    {
        Puts($"Warning: Stacked item {stackedItem.info.displayName.english} exceeds max stack limit.");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		using (TimeWarning.New("MoveToContainer"))
		{
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					foreach (Item item3 in from x in newcontainer.FindItemsByItemID(info.itemid)
						orderby x.position
						select x)
					{
						if (item3.CanStack(this) && (ignoreStackLimit || item3.amount < item3.MaxStackable()))
						{
							iTargetPos = item3.position;
						}
					}
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", slot2, this, newcontainer, num2);
						MarkDirty();
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", item2, this, newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
	}

```

## OnInputUpdate(IOEntity,int,int)

```csharp
```csharp
/// <summary>
/// Called when the input state of an IOEntity is updated.
/// </summary>
/// <param name="inputAmount">The amount of input received.</param>
/// <param name="inputSlot">The slot number of the input being updated.</param>
/// <returns>No return behavior.</returns>
void OnInputUpdate(IOEntity entity, int inputAmount, int inputSlot)
{
    Puts($"Input updated for entity {entity.net.ID} with amount: {inputAmount} on slot: {inputSlot}");
    
    if (inputAmount < 0)
    {
        Puts("Received negative input amount, ignoring update.");
        return;
    }
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public virtual void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (Interface.CallHook("OnInputUpdate", this, inputAmount, inputSlot) != null)
		{
			return;
		}
		if (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)
		{
			IOStateChanged(inputAmount, inputSlot);
			return;
		}
		UpdateHasPower(inputAmount, inputSlot);
		lastEnergy = currentEnergy;
		currentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);
		int passthroughAmount = GetPassthroughAmount();
		bool flag = lastPassthroughEnergy != passthroughAmount;
		lastPassthroughEnergy = passthroughAmount;
		if (currentEnergy != lastEnergy || flag)
		{
			IOStateChanged(inputAmount, inputSlot);
			ensureOutputsUpdated = true;
		}
		_processQueues[GetQueueType()].Enqueue(this);
	}

```

## OnWireConnect(BasePlayer,IOEntity,int,IOEntity,int,System.Collections.Generic.List<UnityEngine.Vector3>,System.Collections.Generic.List<float>)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to connect two IO entities with a wire.
/// </summary>
/// <param name="player">The player making the connection.</param>
/// <param name="inputEntity">The input IO entity being connected.</param>
/// <param name="inputIndex">The index of the input on the input entity.</param>
/// <param name="outputEntity">The output IO entity being connected.</param>
/// <param name="outputIndex">The index of the output on the output entity.</param>
/// <param name="linePoints">The points that define the wire's path.</param>
/// <param name="slackLevels">The slack levels for the wire connection.</param>
/// <returns>No return behavior.</returns>
void OnWireConnect(BasePlayer player, IOEntity inputEntity, int inputIndex, IOEntity outputEntity, int outputIndex, List<Vector3> linePoints, List<float> slackLevels)
{
    Puts($"Player {player.displayName} is attempting to connect {inputEntity.name} (Input Index: {inputIndex}) to {outputEntity.name} (Output Index: {outputIndex}).");

    if (inputEntity == null || outputEntity == null)
    {
        Puts("Connection failed: One of the entities is null.");
        return;
    }

    Puts($"Connection established between {inputEntity.name} and {outputEntity.name}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RPC_MakeConnection(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		WireConnectionMessage wireConnectionMessage = WireConnectionMessage.Deserialize(rpc.read);
		List<Vector3> linePoints = wireConnectionMessage.linePoints;
		int inputIndex = wireConnectionMessage.inputIndex;
		int outputIndex = wireConnectionMessage.outputIndex;
		IOEntity iOEntity = new EntityRef<IOEntity>(wireConnectionMessage.inputID).Get(serverside: true);
		IOEntity iOEntity2 = new EntityRef<IOEntity>(wireConnectionMessage.outputID).Get(serverside: true);
		if (iOEntity == null || iOEntity2 == null || !ValidateLine(linePoints, iOEntity, iOEntity2, player, outputIndex) || inputIndex >= iOEntity.inputs.Length || outputIndex >= iOEntity2.outputs.Length || iOEntity.inputs[inputIndex].connectedTo.Get() != null || iOEntity2.outputs[outputIndex].connectedTo.Get() != null || (iOEntity.inputs[inputIndex].rootConnectionsOnly && !iOEntity2.IsRootEntity()) || !CanModifyEntity(player, iOEntity) || !CanModifyEntity(player, iOEntity2))
		{
			return;
		}
		List<float> slackLevels = wireConnectionMessage.slackLevels;
		IOEntity.LineAnchor[] array = new IOEntity.LineAnchor[wireConnectionMessage.lineAnchors.Count];
		for (int i = 0; i < wireConnectionMessage.lineAnchors.Count; i++)
		{
			WireLineAnchorInfo wireLineAnchorInfo = wireConnectionMessage.lineAnchors[i];
			array[i].entityRef = new EntityRef<Door>(wireLineAnchorInfo.parentID);
			array[i].boneName = wireLineAnchorInfo.boneName;
			array[i].index = (int)wireLineAnchorInfo.index;
			array[i].position = wireLineAnchorInfo.position;
		}
		WireColour wireColour = IntToColour(wireConnectionMessage.wireColor);
		if (Interface.CallHook("OnWireConnect", player, iOEntity, inputIndex, iOEntity2, outputIndex, wireConnectionMessage.linePoints, slackLevels) == null)
		{
			if (wireColour == WireColour.Invisible && !player.IsInCreativeMode)
			{
				wireColour = DefaultColor;
			}
			iOEntity2.ConnectTo(iOEntity, outputIndex, inputIndex, linePoints, slackLevels, array, wireColour);
			if (wireType == IOEntity.IOType.Industrial)
			{
				iOEntity.NotifyIndustrialNetworkChanged();
				iOEntity2.NotifyIndustrialNetworkChanged();
			}
		}
	}

```

## OnScientistInitialized(BradleyAPC,ScientistNPC,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when a scientist NPC is initialized and spawned in the game world.
/// </summary>
/// <param name="apc">The Bradley APC associated with the scientist.</param>
/// <param name="scientist">The scientist NPC that has been initialized.</param>
/// <param name="spawnPosition">The position where the scientist is spawned.</param>
/// <returns>No return behavior.</returns>
void OnScientistInitialized(BradleyAPC apc, ScientistNPC scientist, Vector3 spawnPosition)
{
    Puts($"Scientist {scientist.displayName} initialized at position {spawnPosition} for APC {apc.net.ID}.");
    
    if (scientist.IsHostile)
    {
        Puts($"Warning: Scientist {scientist.displayName} is hostile and may attack players.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)
	{
		if (scientist == null)
		{
			return;
		}
		scientist.transform.position = spawnPos;
		if (!scientist.Brain.Navigator.PlaceOnNavMesh(0.2f))
		{
			activeScientists.Remove(scientist);
			scientist.Kill();
			return;
		}
		if (triggerPlayer != null)
		{
			scientist.Brain.Events.Memory.Entity.Set(triggerPlayer, 0);
			scientist.Brain.Senses.Memory.SetKnown(triggerPlayer, scientist, null);
			scientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 7);
			scientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 4);
			scientist.Brain.Events.Memory.Entity.Set(this, 7);
			AttackEntity attackEntity = scientist.GetAttackEntity();
			if (SetScientistChaseBasedOnWeapon && attackEntity != null && !attackEntity.CanUseAtLongRange)
			{
				startChasing = true;
			}
			scientist.Brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint = startChasing;
			scientist.Brain.Navigator.CanUseRandomMovePointIfNonFound = !startChasing;
			if (startChasing)
			{
				scientist.Brain.SwitchToState(AIState.Chase, 6);
			}
			else
			{
				scientist.Brain.SwitchToState(AIState.TakeCover, 4);
			}
			scientist.Brain.Think(0f);
		}
		Interface.CallHook("OnScientistInitialized", this, scientist, spawnPos);
	}

```

## OnPayForUpgrade(BasePlayer,BuildingBlock,ConstructionGrade)

```csharp
```csharp
/// <summary>
/// Called when a player pays for an upgrade on a building block.
/// </summary>
/// <param name="player">The player who is paying for the upgrade.</param>
/// <param name="block">The building block being upgraded.</param>
/// <param name="grade">The construction grade to which the block is being upgraded.</param>
/// <returns>No return behavior.</returns>
void OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade grade)
{
    Puts($"Player {player.displayName} is attempting to pay for an upgrade to {block.name} at grade {grade.name}.");

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and does not need to pay for upgrades.");
        return;
    }

    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
	{
		if (Interface.CallHook("OnPayForUpgrade", player, this, g) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in g.CostToBuild(grade))
		{
			player.inventory.Take(list, item.itemid, (int)item.amount);
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemid);
			Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "upgrade_block", itemDefinition.shortname, (int)item.amount, this, null, safezone: false, null, player.userID);
			player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## OnServerRestart(string,int)

```csharp
```csharp
/// <summary>
/// Called when the server is about to restart.
/// </summary>
/// <param name="notice">The notice message to display to players about the restart.</param>
/// <param name="seconds">The number of seconds until the server restarts.</param>
/// <returns>
/// Returns a non-null value to interrupt the server restart process. 
/// If `null` is returned, the server will proceed with the restart.
/// </returns>
object OnServerRestart(string notice, int seconds)
{
    Puts($"Server restart initiated with notice: '{notice}' in {seconds} seconds.");
    
    if (seconds < 10)
    {
        Puts("Restart is too soon! Cancelling the restart.");
        return "Restart too soon!";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (SingletonComponent<ServerMgr>.Instance == null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
			SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", strNotice, iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

```

## OnPhoneAnswer(PhoneController,PhoneController)

```csharp
```csharp
/// <summary>
/// Called when a phone call is answered by a player.
/// </summary>
/// <param name="caller">The phone controller of the caller who initiated the call.</param>
/// <param name="receiver">The phone controller of the receiver who answered the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneAnswer(PhoneController caller, PhoneController receiver)
{
    Puts($"Phone call answered from {caller.GetPlayer().displayName} to {receiver.GetPlayer().displayName}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (IsInvoking(TimeOutDialing))
		{
			CancelInvoke(TimeOutDialing);
		}
		if (!(activeCallTo == null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", this, activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", this, activeCallTo);
			}
		}
	}

```

## OnOvenTemperature(BaseOven,int)

```csharp
```csharp
/// <summary>
/// Called to retrieve the current temperature of the oven for a specific slot.
/// </summary>
/// <param name="oven">The oven instance for which the temperature is being queried.</param>
/// <param name="slot">The slot number for which the temperature is requested.</param>
/// <returns>
/// Returns the current temperature of the specified slot in the oven. 
/// If the method returns `null`, the default temperature logic will be used.
/// </returns>
float? OnOvenTemperature(BaseOven oven, int slot)
{
    Puts($"Checking temperature for Oven ID: {oven.net.ID}, Slot: {slot}");
    
    // Example condition to modify temperature
    if (slot == 0)
    {
        Puts("Slot 0 is currently set to a special temperature.");
        return 200f; // Custom temperature for slot 0
    }

    return null; // Allow default temperature logic to apply
}
```
```

### Source Code from the Library

```csharp

	public float GetTemperature(int slot)
	{
		object obj = Interface.CallHook("OnOvenTemperature", this, slot);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!HasFlag(Flags.On))
		{
			return 15f;
		}
		return cookingTemperature;
	}

```

## OnCoalingTowerStart(CoalingTower,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts using a coaling tower.
/// </summary>
/// <param name="tower">The coaling tower being used.</param>
/// <param name="player">The player who is attempting to use the coaling tower.</param>
/// <returns>
/// Returns `null` to allow the action to proceed, or any non-null value to prevent the action.
/// </returns>
object OnCoalingTowerStart(CoalingTower tower, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to start using the coaling tower at {tower.transform.position}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot use the coaling tower while in a safe zone.");
        return "You cannot use the coaling tower in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Unload(RPCMessage msg)
	{
		if (Interface.CallHook("OnCoalingTowerStart", this, msg.player) == null && !TryUnloadActiveWagon(out var attemptStatus) && msg.player != null)
		{
			ClientRPC(RpcTarget.Player("ActionFailed", msg.player), (byte)attemptStatus, arg2: true);
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the patrol helicopter can target a specific player.
/// </summary>
/// <param name="helicopter">The patrol helicopter attempting to target the player.</param>
/// <param name="player">The player being targeted.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine targeting eligibility.
/// </returns>
bool? CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Helicopter {helicopter.net.ID} is checking if it can target player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} is dead and cannot be targeted.");
        return false;
    }

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (ply.eyes.position.y < WaterSystem.OceanLevel && Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) > oceanDepthTargetCutoff)
		{
			return false;
		}
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## CanDestroyLock(BasePlayer,ModularCar,BaseVehicleModule)

```csharp
```csharp
/// <summary>
/// Determines whether a player can destroy a lock on a modular car using a specific vehicle module.
/// </summary>
/// <param name="player">The player attempting to destroy the lock.</param>
/// <param name="car">The modular car that has the lock.</param>
/// <param name="viaModule">The vehicle module being used to attempt the destruction.</param>
/// <returns>
/// Returns `true` if the player can destroy the lock; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can destroy the lock.
/// </returns>
bool? CanDestroyLock(BasePlayer player, ModularCar car, BaseVehicleModule viaModule)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to destroy a lock on {car.name} using {viaModule.name}.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can destroy locks.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
	{
		object obj = Interface.CallHook("CanDestroyLock", player, this, viaModule);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CarLock.PlayerCanDestroyLock(viaModule);
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldHealth">The player's health before the change.</param>
/// <param name="newHealth">The player's health after the change.</param>
/// <returns>No return behavior.</returns>
void OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Player {player.displayName} health changed from {oldHealth} to {newHealth}.");

    if (newHealth < oldHealth)
    {
        Puts($"Player {player.displayName} took damage: {oldHealth - newHealth}.");
    }
    else if (newHealth > oldHealth)
    {
        Puts($"Player {player.displayName} healed: {newHealth - oldHealth}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) != null)
		{
			return;
		}
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer)
		{
			if (oldvalue > newvalue)
			{
				LifeStoryHurt(oldvalue - newvalue);
			}
			else
			{
				LifeStoryHeal(newvalue - oldvalue);
			}
			metabolism.isDirty = true;
		}
	}

```

## OnDemoRecordingStart(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is about to start for a player.
/// </summary>
/// <param name="filePath">The file path where the demo will be saved.</param>
/// <param name="player">The player who is starting the demo recording.</param>
/// <returns>
/// Returns `null` to allow the recording to start, or any non-null value to prevent the recording from starting.
/// </returns>
object OnDemoRecordingStart(string filePath, BasePlayer player)
{
    Puts($"Demo recording for player {player.displayName} is starting. File path: {filePath}");
    
    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and cannot start demo recordings.");
        return "Recording is disabled in creative mode.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnItemSubmit(Item,Mailbox,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is submitted to a mailbox.
/// </summary>
/// <param name="item">The item being submitted.</param>
/// <param name="mailbox">The mailbox receiving the item.</param>
/// <param name="fromPlayer">The player submitting the item.</param>
/// <returns>No return behavior.</returns>
void OnItemSubmit(Item item, Mailbox mailbox, BasePlayer fromPlayer)
{
    Puts($"Item {item.info.displayName.english} submitted to mailbox by {fromPlayer.displayName}.");
    
    if (item.info.shortname == "special.item")
    {
        Puts($"Player {fromPlayer.displayName} submitted a special item!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SubmitInputItems(BasePlayer fromPlayer)
	{
		Item slot = base.inventory.GetSlot(mailInputSlot);
		if (IsFull() || slot == null || Interface.CallHook("OnItemSubmit", slot, this, fromPlayer) != null)
		{
			return;
		}
		if (MoveItemToStorage(slot))
		{
			if (slot.position != mailInputSlot)
			{
				Effect.server.Run(mailDropSound.resourcePath, GetDropPosition());
				if (fromPlayer != null && !PlayerIsOwner(fromPlayer))
				{
					SetFlag(Flags.On, b: true);
				}
			}
		}
		else
		{
			slot.Drop(GetDropPosition(), GetDropVelocity());
		}
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is being repaired by a player.
/// </summary>
/// <param name="structure">The structure that is being repaired.</param>
/// <param name="player">The player attempting to repair the structure.</param>
/// <returns>
/// Returns `null` to allow the repair to proceed, or any non-null value to prevent the repair action.
/// </returns>
object OnStructureRepair(BaseCombatEntity structure, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to repair structure: {structure.ShortPrefabName}.");

    if (structure.Health() >= structure.MaxHealth())
    {
        Puts($"Repair attempt by {player.displayName} failed: Structure is already at full health.");
        return "Structure is already fully repaired.";
    }

    if (player.inventory.GetAmount("repair.tool") < 1)
    {
        Puts($"Repair attempt by {player.displayName} failed: Not enough resources.");
        return "You need a repair tool to perform this action.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		float num = 30f;
		if (player2.IsInCreativeMode && Creative.freeRepair)
		{
			num = 0f;
		}
		if (SecondsSinceAttacked <= num)
		{
			OnRepairFailed(player2, RecentlyDamagedError, (num - SecondsSinceAttacked).ToString("N0"));
			return;
		}
		float num2 = MaxHealth() - Health();
		float num3 = num2 / MaxHealth();
		if (num2 <= 0f || num3 <= 0f)
		{
			OnRepairFailed(player2, NotDamagedError);
			return;
		}
		List<ItemAmount> list = RepairCost(num3);
		if (list == null)
		{
			return;
		}
		float num4 = list.Sum((ItemAmount x) => x.amount);
		float healthBefore = health;
		if (player2.IsInCreativeMode && Creative.freeRepair)
		{
			num4 = 0f;
		}
		if (num4 > 0f)
		{
			float num5 = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			if (float.IsNaN(num5))
			{
				num5 = 0f;
			}
			num5 = Mathf.Min(num5, 50f / num2);
			if (num5 <= 0f)
			{
				OnRepairFailedResources(player2, list);
				return;
			}
			int num6 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(num5 * item.amount);
				int num7 = player2.inventory.Take(null, item.itemid, amount);
				Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "repair_entity", item.itemDef.shortname, num7, this, null, safezone: false, null, player2.userID);
				if (num7 > 0)
				{
					num6 += num7;
					player2.Command("note.inv", item.itemid, num7 * -1);
				}
			}
			float num8 = (float)num6 / num4;
			health += num2 * num8;
			SendNetworkUpdate();
		}
		else
		{
			health += num2;
			SendNetworkUpdate();
		}
		Facepunch.Rust.Analytics.Azure.OnEntityRepaired(player2, this, healthBefore, health);
		if (Health() >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines if the specified player can be targeted for strafe attacks by the helicopter.
/// </summary>
/// <param name="helicopter">The patrol helicopter attempting to strafe.</param>
/// <param name="player">The player being evaluated as a target.</param>
/// <returns>
/// Returns `true` if the player can be targeted for strafe attacks; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the player can be targeted.
/// </returns>
bool? CanHelicopterStrafeTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Evaluating strafe target for player {player.displayName} (ID: {player.UserIDString}) by helicopter.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidRocketTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ply == null)
		{
			return false;
		}
		return !ply.IsNearEnemyBase();
	}

```

## OnStashExposed(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a stash container is exposed to a player.
/// </summary>
/// <param name="stash">The stash container that has been exposed.</param>
/// <param name="player">The player who exposed the stash.</param>
/// <returns>No return behavior.</returns>
void OnStashExposed(StashContainer stash, BasePlayer player)
{
    Puts($"Stash {stash.net.ID} has been exposed to player {player.displayName} (ID: {player.UserIDString}).");

    if (stash.IsLocked())
    {
        Puts($"Stash {stash.net.ID} is locked and cannot be accessed by {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void CheckStashRevealInvoke()
	{
		for (int i = 0; i < nearbyStashes.Count; i++)
		{
			NearbyStash nearbyStash = nearbyStashes[i];
			if (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)
			{
				nearbyStashes.RemoveAt(i);
			}
			else if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))
			{
				nearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;
				if (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)
				{
					if (Interface.CallHook("CanSeeStash", this, nearbyStash.Entity) != null)
					{
						break;
					}
					nearbyStash.Entity.SetHidden(isHidden: false);
					Facepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);
					Interface.CallHook("OnStashExposed", nearbyStash.Entity, this);
				}
			}
			else
			{
				nearbyStash.LookingAtTime = 0f;
			}
		}
	}

```

## CanLootEntity(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a storage container.
/// </summary>
/// <param name="player">The player attempting to loot the container.</param>
/// <param name="container">The storage container being looted.</param>
/// <returns>
/// Returns `true` if the player is allowed to loot the container; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can loot the container.
/// </returns>
bool? CanLootEntity(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot container: {container.name}.");

    if (container.IsLocked())
    {
        Puts($"Container {container.name} is locked. Player {player.displayName} cannot loot.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (IsLocked() || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, LockedMessage, false);
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, InUseMessage, false);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = panelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			AddContainers(player.inventory.loot);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnPhoneDialTimeout(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing attempt times out.
/// </summary>
/// <param name="caller">The phone controller that initiated the call.</param>
/// <param name="receiver">The phone controller that was being called.</param>
/// <param name="player">The player associated with the call.</param>
/// <returns>
/// Returns a non-null value to prevent the default timeout behavior. 
/// If `null` is returned, the default timeout actions will be executed.
/// </returns>
object OnPhoneDialTimeout(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone call from {player.displayName} to {receiver.phoneNumber} has timed out.");
    return null; // Allow default behavior to proceed
}
```
```

### Source Code from the Library

```csharp

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", activeCallTo, this, activeCallTo.currentPlayer) == null)
		{
			if (activeCallTo != null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", activeCallTo, this, activeCallTo.currentPlayer);
		}
	}

```

## OnVendingShopOpen(NPCVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to open a vending shop.
/// </summary>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <param name="player">The player attempting to open the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpen(NPCVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to open the vending shop: {vendingMachine.name}.");
    
    if (vendingMachine.IsOutOfStock())
    {
        Puts($"Vending shop {vendingMachine.name} is out of stock for player {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if (vendingMachine == null)
		{
			vendingMachine = GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", vendingMachine, msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", vendingMachine, msg.player);
		}
	}

```

## CanRecycle(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled at a recycler.
/// </summary>
/// <param name="recycler">The recycler attempting to recycle the item.</param>
/// <param name="item">The item being checked for recyclability.</param>
/// <returns>
/// Returns `true` if the item can be recycled, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the item can be recycled.
/// </returns>
bool? CanRecycle(Recycler recycler, Item item)
{
    Puts($"Checking recyclability for item: {item.info.displayName.english} (ID: {item.info.itemid}) at recycler: {recycler.name}.");

    if (item.info.shortname == "wood")
    {
        Puts("Wood can always be recycled.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## OnCCTVDirectionChange(CCTV_RC,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the direction of a CCTV camera is changed by a player.
/// </summary>
/// <param name="cctv">The CCTV camera whose direction is being changed.</param>
/// <param name="player">The player changing the direction of the CCTV camera.</param>
/// <returns>
/// Returns `null` to allow the direction change, or any non-null value to prevent it.
/// </returns>
object OnCCTVDirectionChange(CCTV_RC cctv, BasePlayer player)
{
    Puts($"Player {player.displayName} is changing the direction of CCTV at {cctv.transform.position}.");
    
    if (player.IsInRestrictedArea())
    {
        Puts($"Player {player.displayName} is in a restricted area and cannot change CCTV direction.");
        return "You cannot change the CCTV direction from this location.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void Server_SetDir(RPCMessage msg)
	{
		if (!IsStatic())
		{
			BasePlayer player = msg.player;
			if (player.CanBuild() && player.IsBuildingAuthed() && Interface.CallHook("OnCCTVDirectionChange", this, player) == null)
			{
				Vector3 direction = Vector3Ex.Direction(player.eyes.position, yaw.transform.position);
				direction = base.transform.InverseTransformDirection(direction);
				Vector3 vector = BaseMountable.ConvertVector(Quaternion.LookRotation(direction).eulerAngles);
				pitchAmount = Mathf.Clamp(vector.x, pitchClamp.x, pitchClamp.y);
				yawAmount = Mathf.Clamp(vector.y, yawClamp.x, yawClamp.y);
				SendNetworkUpdate();
			}
		}
	}

```

## OnWaterCollect(WaterCatcher)

```csharp
```csharp
/// <summary>
/// Called when water is collected from a water catcher.
/// </summary>
/// <param name="catcher">The water catcher that is collecting water.</param>
/// <returns>
/// Returns `null` to allow the water collection to proceed, or any non-null value to prevent it.
/// </returns>
object OnWaterCollect(WaterCatcher catcher)
{
    Puts($"Water collection initiated for catcher at position: {catcher.transform.position}.");
    
    // Example condition to prevent water collection
    if (catcher.IsFull())
    {
        Puts("Water catcher is already full. Collection cannot proceed.");
        return "Water catcher is full.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CollectWater()
	{
		if (!IsFull() && Interface.CallHook("OnWaterCollect", this) == null)
		{
			float baseRate = collectionRates.baseRate;
			baseRate += Climate.GetFog(base.transform.position) * collectionRates.fogRate;
			if (TestIsOutside())
			{
				baseRate += Climate.GetRain(base.transform.position) * collectionRates.rainRate;
				baseRate += Climate.GetSnow(base.transform.position) * collectionRates.snowRate;
			}
			AddResource(Mathf.CeilToInt(maxItemToCreate * baseRate));
		}
	}

```

## OnTeamPromote(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is promoted to team leader within their team.
/// </summary>
/// <param name="team">The team to which the player belongs.</param>
/// <param name="newLeader">The player being promoted to team leader.</param>
/// <returns>
/// Returns `null` to allow the promotion, or any non-null value to prevent the promotion.
/// </returns>
object OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer newLeader)
{
    Puts($"Player {newLeader.displayName} has been promoted to team leader of team ID: {team.teamID}.");
    
    if (newLeader.IsBannedFromLeadership())
    {
        Puts($"Player {newLeader.displayName} is banned from being a team leader.");
        return "You are banned from being a team leader.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void promote(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);
		if (!(lookingAtPlayer == null) && !lookingAtPlayer.IsDead() && !(lookingAtPlayer == basePlayer) && lookingAtPlayer.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == (ulong)basePlayer.userID && Interface.CallHook("OnTeamPromote", playerTeam, lookingAtPlayer) == null)
			{
				playerTeam.SetTeamLeader(lookingAtPlayer.userID);
			}
		}
	}

```

## OnMapMarkersClear(BasePlayer,System.Collections.Generic.List<ProtoBuf.MapNote>)

```csharp
```csharp
/// <summary>
/// Called when a player clears their map markers.
/// </summary>
/// <param name="player">The player who is clearing the map markers.</param>
/// <param name="mapNotes">The list of map notes that are being cleared.</param>
/// <returns>
/// Returns a non-null value to prevent the clearing of map markers. If `null` is returned, the markers will be cleared as normal.
/// </returns>
object OnMapMarkersClear(BasePlayer player, List<ProtoBuf.MapNote> mapNotes)
{
    Puts($"Player {player.displayName} is attempting to clear map markers. Total markers: {mapNotes.Count}");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot clear map markers.");
        return "You cannot clear map markers while in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, State.pointsOfInterest) != null)
		{
			return;
		}
		ServerCurrentDeathNote?.Dispose();
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				item?.Dispose();
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", this);
	}

```

## OnFuelCheck(EntityFuelSystem)

```csharp
```csharp
/// <summary>
/// Called to check if the entity has sufficient fuel for operation.
/// </summary>
/// <param name="fuelSystem">The fuel system of the entity being checked.</param>
/// <returns>
/// Returns `true` if the entity has fuel, `false` if it does not, 
/// or `null` to allow the default fuel check logic to proceed.
/// </returns>
bool? OnFuelCheck(EntityFuelSystem fuelSystem)
{
    Puts($"Checking fuel status for entity: {fuelSystem.gameObject.name} (ID: {fuelSystem.GetInstanceID()})");
    
    // Example condition to block fuel usage
    if (fuelSystem.GetFuelAmount() < 10f)
    {
        Puts($"Entity {fuelSystem.gameObject.name} does not have enough fuel.");
        return false;
    }

    return null; // Allow default logic to determine fuel status
}
```
```

### Source Code from the Library

```csharp

	public bool HasFuel(bool forceCheck = false)
	{
		if (Time.time > nextFuelCheckTime || forceCheck)
		{
			object obj = Interface.CallHook("OnFuelCheck", this);
			if (obj is bool)
			{
				return (bool)obj;
			}
			cachedHasFuel = (float)GetFuelAmount() > 0f;
			nextFuelCheckTime = Time.time + UnityEngine.Random.Range(1f, 2f);
		}
		return cachedHasFuel;
	}

```

## OnSamSiteTargetScan(SamSite,System.Collections.Generic.List<SamSite.ISamSiteTarget>)

```csharp
```csharp
/// <summary>
/// Called to scan for potential targets for the SAM site.
/// </summary>
/// <param name="samSite">The SAM site performing the target scan.</param>
/// <param name="targets">A list to populate with potential targets detected during the scan.</param>
/// <returns>No return behavior.</returns>
void OnSamSiteTargetScan(SamSite samSite, List<SamSite.ISamSiteTarget> targets)
{
    Puts($"Scanning for targets by SAM site at position: {samSite.transform.position}");

    // Example logic to add a target
    if (targets.Count == 0)
    {
        Puts("No targets found during the scan.");
    }
    else
    {
        foreach (var target in targets)
        {
            Puts($"Target detected: {target.GetType().Name} at {target.CenterPoint()}");
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (UnityEngine.Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> obj = Facepunch.Pool.Get<List<ISamSiteTarget>>();
		if (Interface.CallHook("OnSamSiteTargetScan", this, obj) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(obj, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(obj, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in obj)
		{
			if (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!ObjectEx.IsUnityNull(samSiteTarget) && currentTarget != samSiteTarget)
		{
			lockOnTime = UnityEngine.Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!ObjectEx.IsUnityNull(currentTarget))
		{
			lastTargetVisibleTime = UnityEngine.Time.time;
		}
		Facepunch.Pool.FreeUnmanaged(ref obj);
		if (ObjectEx.IsUnityNull(currentTarget))
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

```

## OnBookmarkInput(ComputerStation,BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player provides input while interacting with a computer station's bookmark feature.
/// </summary>
/// <param name="station">The computer station receiving the input.</param>
/// <param name="player">The player providing the input.</param>
/// <param name="inputState">The state of the input provided by the player.</param>
/// <returns>
/// Returns `null` to allow the default input handling, or any non-null value to override the default behavior.
/// </returns>
object OnBookmarkInput(ComputerStation station, BasePlayer player, InputState inputState)
{
    Puts($"Player {player.displayName} provided input on bookmark at station {station.net.ID}.");
    
    if (inputState.IsPressed(InputButton.Cancel))
    {
        Puts($"Player {player.displayName} canceled the bookmark action.");
        return "Bookmark action canceled.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (HasFlag(Flags.Reserved2) && currentlyControllingEnt.IsValid(serverside: true) && Interface.CallHook("OnBookmarkInput", this, player, inputState) == null)
		{
			currentlyControllingEnt.Get(serverside: true).GetComponent<IRemoteControllable>().UserInput(inputState, new CameraViewerId(player.userID, 0L));
		}
	}

```

## OnItemSkinChange(int,Item,RepairBench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player changes the skin of an item at a repair bench.
/// </summary>
/// <param name="skinId">The ID of the skin being applied.</param>
/// <param name="item">The item whose skin is being changed.</param>
/// <param name="repairBench">The repair bench where the skin change is taking place.</param>
/// <param name="player">The player changing the skin.</param>
/// <returns>
/// Returns a non-null value to prevent the skin change from occurring. 
/// If `null` is returned, the skin change proceeds as normal.
/// </returns>
object OnItemSkinChange(int skinId, Item item, RepairBench repairBench, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to change skin of {item.info.displayName.english} to skin ID {skinId}.");

    if (skinId == 12345) // Example of a restricted skin ID
    {
        Puts($"Player {player.displayName} is not allowed to use skin ID {skinId}.");
        return "You cannot use this skin.";
    }

    return null; // Allow the skin change to proceed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ChangeSkin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		ItemId itemId = new ItemId(msg.read.UInt64());
		bool isValid = itemId.IsValid;
		bool flag = !isValid || UnityEngine.Time.realtimeSinceStartup > nextSkinChangeAudioTime;
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || Interface.CallHook("OnItemSkinChange", num, slot, this, player) != null || (isValid && slot.uid != itemId))
		{
			return;
		}
		bool flag2 = false;
		if (msg.player.UnlockAllSkins)
		{
			flag2 = true;
		}
		if (num != 0 && !flag2 && !player.blueprints.CheckSkinOwnership(num, player.userID))
		{
			debugprint("RepairBench.ChangeSkin player does not have item :" + num + ":");
			return;
		}
		ulong Skin = ItemDefinition.FindSkin(slot.info.itemid, num);
		if (Skin == slot.skin && slot.info.isRedirectOf == null)
		{
			debugprint("RepairBench.ChangeSkin cannot apply same skin twice : " + Skin + ": " + slot.skin);
			return;
		}
		if (flag)
		{
			nextSkinChangeAudioTime = UnityEngine.Time.realtimeSinceStartup + 0.75f;
		}
		ItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		if (slot.info.isRedirectOf != null)
		{
			Skin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, num);
			skin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		}
		ItemSkin itemSkin = ((skin.id == 0) ? null : (skin.invItem as ItemSkin));
		if (((bool)itemSkin && (itemSkin.Redirect != null || slot.info.isRedirectOf != null)) || (!itemSkin && slot.info.isRedirectOf != null))
		{
			ItemDefinition template = ((itemSkin != null) ? itemSkin.Redirect : slot.info.isRedirectOf);
			bool flag3 = false;
			if (itemSkin != null && itemSkin.Redirect == null && slot.info.isRedirectOf != null)
			{
				template = slot.info.isRedirectOf;
				flag3 = num != 0;
			}
			float condition = slot.condition;
			float maxCondition = slot.maxCondition;
			int amount = slot.amount;
			int ammoCount = 0;
			ItemDefinition ammoType = null;
			if (slot.GetHeldEntity() != null && slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
			{
				ammoCount = baseProjectile.primaryMagazine.contents;
				ammoType = baseProjectile.primaryMagazine.ammoType;
			}
			List<Item> obj = Facepunch.Pool.Get<List<Item>>();
			if (slot.contents != null && slot.contents.itemList != null && slot.contents.itemList.Count > 0)
			{
				if (slot.contents.itemList.Count > obj.Capacity)
				{
					obj.Capacity = slot.contents.itemList.Count;
				}
				foreach (Item item2 in slot.contents.itemList)
				{
					obj.Add(item2);
				}
				foreach (Item item3 in obj)
				{
					item3.RemoveFromContainer();
				}
			}
			slot.Remove();
			ItemManager.DoRemoves();
			Item item = ItemManager.Create(template, 1, 0uL);
			item.MoveToContainer(base.inventory, 0, allowStack: false);
			item.maxCondition = maxCondition;
			item.condition = condition;
			item.amount = amount;
			if (item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile baseProjectile2)
			{
				if (baseProjectile2.primaryMagazine != null)
				{
					baseProjectile2.SetAmmoCount(ammoCount);
					baseProjectile2.primaryMagazine.ammoType = ammoType;
				}
				baseProjectile2.ForceModsChanged();
			}
			if (obj.Count > 0 && item.contents != null)
			{
				foreach (Item item4 in obj)
				{
					item4.MoveToContainer(item.contents);
				}
			}
			Facepunch.Pool.Free(ref obj, freeElements: false);
			if (flag3)
			{
				ApplySkinToItem(item, Skin);
			}
			Facepunch.Rust.Analytics.Server.SkinUsed(item.info.shortname, num);
			Facepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, item, Skin);
		}
		else
		{
			ApplySkinToItem(slot, Skin);
			Facepunch.Rust.Analytics.Server.SkinUsed(slot.info.shortname, num);
			Facepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, slot, Skin);
		}
		if (flag && skinchangeEffect.isValid)
		{
			Effect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);
		}
	}

```

## OnSupplyDropDropped(BaseEntity,CargoPlane)

```csharp
```csharp
/// <summary>
/// Called when a supply drop has been successfully dropped from the cargo plane.
/// </summary>
/// <param name="supplyDrop">The entity representing the dropped supply drop.</param>
/// <param name="cargoPlane">The cargo plane that released the supply drop.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropDropped(BaseEntity supplyDrop, CargoPlane cargoPlane)
{
    Puts($"Supply drop {supplyDrop.net.ID} has been dropped from cargo plane {cargoPlane.net.ID} at position {supplyDrop.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	private void Update()
	{
		if (!base.isServer)
		{
			return;
		}
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);
			if ((bool)baseEntity)
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
				Interface.CallHook("OnSupplyDropDropped", baseEntity, this);
			}
		}
		base.transform.position = Vector3.Lerp(startPos, endPos, num);
		base.transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
	}

```

## CanUseFuel(EntityFuelSystem,StorageContainer,float,float)

```csharp
```csharp
/// <summary>
/// Called to determine if fuel can be used from a storage container for a specified duration.
/// </summary>
/// <param name="fuelSystem">The fuel system attempting to use the fuel.</param>
/// <param name="fuelContainer">The storage container holding the fuel.</param>
/// <param name="seconds">The duration for which fuel is requested.</param>
/// <param name="fuelUsedPerSecond">The amount of fuel used per second.</param>
/// <returns>
/// Returns the amount of fuel successfully used. If the method returns `0`, no fuel was used.
/// If a non-zero integer is returned, that amount of fuel was consumed from the container.
/// </returns>
int CanUseFuel(EntityFuelSystem fuelSystem, StorageContainer fuelContainer, float seconds, float fuelUsedPerSecond)
{
    Puts($"Attempting to use fuel for {seconds} seconds at a rate of {fuelUsedPerSecond} units per second.");
    
    if (fuelContainer == null || fuelContainer.inventory.GetSlot(0) == null)
    {
        Puts("No fuel container or fuel item found.");
        return 0;
    }

    return 1; // Simulating successful fuel usage for demonstration
}
```
```

### Source Code from the Library

```csharp

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanUseFuel", this, fuelContainer, seconds, fuelUsedPerSecond);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelContainer == null)
		{
			return 0;
		}
		Item slot = fuelContainer.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		pendingFuel += seconds * fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Facepunch.Rust.Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, "fuel_system");
			pendingFuel -= num;
			return num;
		}
		return 0;
	}

```

## OnLootSpawn(LootContainer)

```csharp
```csharp
/// <summary>
/// Called when loot is spawned in a loot container.
/// </summary>
/// <param name="container">The loot container where the loot is being spawned.</param>
/// <returns>No return behavior.</returns>
void OnLootSpawn(LootContainer container)
{
    Puts($"Loot is being spawned in container: {container.gameObject.name} (ID: {container.net.ID})");
    
    // Example condition to prevent spawning loot in certain containers
    if (container.gameObject.name.Contains("Restricted"))
    {
        Puts("Loot spawning is restricted for this container.");
        return;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				Invoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

```

## OnPlayerAssist(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player assists another player who is wounded.
/// </summary>
/// <param name="assistedPlayer">The player who is being assisted.</param>
/// <param name="assistingPlayer">The player who is providing assistance.</param>
/// <returns>
/// Returns `null` to allow the assistance action, or any non-null value to prevent it.
/// </returns>
object OnPlayerAssist(BasePlayer assistedPlayer, BasePlayer assistingPlayer)
{
    Puts($"Player {assistingPlayer.displayName} is assisting wounded player {assistedPlayer.displayName}.");
    
    if (assistedPlayer.IsInSafeZone())
    {
        Puts($"Assistance denied: {assistedPlayer.displayName} is in a safe zone.");
        return "Cannot assist players in safe zones.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Assist(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerAssist", this, msg.player) == null)
		{
			StopWounded(msg.player);
			msg.player.stats.Add("wounded_assisted", 1, (Stats)5);
			stats.Add("wounded_healed", 1);
		}
	}

```

## IOnServerInitialized()

```csharp
```csharp
/// <summary>
/// Called when the server has been initialized and is ready to accept connections.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnServerInitialized()
{
    Puts("Server has been initialized and is ready for connections.");
    // Additional initialization logic can be added here.
}
```
```

### Source Code from the Library

```csharp

	public void OpenConnection(bool useSteamServer = true)
	{
		if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
		{
			ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
		}
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		if (useSteamServer)
		{
			StartSteamServer();
		}
		else
		{
			PlatformService.Instance.Initialize(RustPlatformHooks.Instance);
		}
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			CloseConnection();
			return;
		}
		Network.Net.sv.callbackHandler = this;
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		EACServer.DoStartup();
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
		if (ConVar.Server.autoUploadMap)
		{
			MapUploader.UploadMap();
		}
		Interface.CallHook("IOnServerInitialized");
	}

```

## OnDecayDamage(DecayEntity)

```csharp
```csharp
/// <summary>
/// Called when a decay event occurs, allowing for custom damage handling during decay.
/// </summary>
/// <param name="decayEntity">The entity that is undergoing decay.</param>
/// <returns>
/// Returns a non-null value to override the default decay damage behavior. 
/// If `null` is returned, the default decay damage will be applied.
/// </returns>
object OnDecayDamage(DecayEntity decayEntity)
{
    Puts($"Decay event triggered for entity: {decayEntity.gameObject.name} (ID: {decayEntity.net.ID})");

    if (decayEntity.healthFraction < 0.5f)
    {
        Puts($"Entity {decayEntity.gameObject.name} is critically decayed and will take additional damage.");
        return true; // Indicate that custom damage handling should occur
    }

    return null; // Allow default decay damage to proceed
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnDecay(Decay decay, float decayDeltaTime)
	{
		lastDecayTick = UnityEngine.Time.time;
		if (HasParent() || !decay.ShouldDecay(this))
		{
			return;
		}
		float num = decayDeltaTime * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if (buildingPrivilege != null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", this) == null)
				{
					float num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();
					Heal(MaxHealth() * num2);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num;
		if (decayTimer < GetEntityDecayDelay())
		{
			return;
		}
		using (TimeWarning.New("DecayTick"))
		{
			float num3 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num3 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num3 -= decayPoint.protection;
					}
				}
			}
			if (Interface.CallHook("OnDecayDamage", this) == null && num3 > 0f)
			{
				float num4 = num / GetEntityDecayDuration() * MaxHealth();
				Hurt(num4 * num3 * decayVariance, DamageType.Decay);
			}
		}
	}

```

## OnActiveItemChange(BasePlayer,Item,ItemId)

```csharp
```csharp
/// <summary>
/// Called when a player's active item changes.
/// </summary>
/// <param name="player">The player whose active item is changing.</param>
/// <param name="previousItem">The item that was previously active.</param>
/// <param name="newItemId">The ID of the new active item.</param>
/// <returns>
/// Returns `null` to allow the item change, or any non-null value to prevent the change.
/// </returns>
object OnActiveItemChange(BasePlayer player, Item previousItem, ItemId newItemId)
{
    Puts($"Player {player.displayName} is changing active item from {previousItem?.info.displayName.english ?? "none"} to item ID: {newItemId}.");

    if (newItemId == ItemId.Invalid)
    {
        Puts($"Player {player.displayName} attempted to equip an invalid item.");
        return "Invalid item cannot be equipped.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(ItemId itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnOvenStarted(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when the oven starts cooking.
/// </summary>
/// <param name="oven">The oven that has started cooking.</param>
/// <returns>No return behavior.</returns>
void OnOvenStarted(BaseOven oven)
{
    Puts($"Oven {oven.net.ID} has started cooking at temperature: {oven.inventory.temperature}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			InvokeRepeating(Cook, 0.5f, 0.5f);
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", this);
		}
	}

```

## OnSupplyDropLanded(SupplyDrop)

```csharp
```csharp
/// <summary>
/// Called when a supply drop has landed in the game world.
/// </summary>
/// <param name="supplyDrop">The supply drop that has landed.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropLanded(SupplyDrop supplyDrop)
{
    Puts($"Supply drop landed at position: {supplyDrop.transform.position}.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	private void OnCollisionEnter(Collision collision)
	{
		bool flag = ((1 << collision.collider.gameObject.layer) & 0x40A10111) > 0;
		if (((1 << collision.collider.gameObject.layer) & 0x8000000) > 0 && CollisionEx.GetEntity(collision) is Tugboat)
		{
			flag = true;
		}
		if (flag)
		{
			RemoveParachute();
			MakeLootable();
		}
		Interface.CallHook("OnSupplyDropLanded", this);
	}

```

## OnSignalBroadcast(BaseEntity,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a signal is broadcasted from a networked entity.
/// </summary>
/// <param name="entity">The entity that is broadcasting the signal.</param>
/// <param name="connection">The network connection from which the signal is sent.</param>
/// <returns>Returns `null` to allow the signal broadcast, or any non-null value to prevent it.</returns>
object OnSignalBroadcast(BaseEntity entity, Network.Connection connection)
{
    Puts($"Signal broadcast from entity {entity.net.ID} with connection ID: {connection?.userid ?? 0}.");
    
    // Example condition to block the signal
    if (entity.net.ID == 12345) // Replace with actual condition
    {
        Puts("Broadcast blocked for this entity.");
        return true; // Prevent the broadcast
    }
    
    return null; // Allow the broadcast
}
```
```

### Source Code from the Library

```csharp

	public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", this, sourceConnection) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("SignalFromServerEx", this, SendMethod.Unreliable, Priority.Immediate), (int)signal, arg, sourceConnection?.userid ?? 0);
		}
	}

```

## OnOvenCooked(BaseOven,Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item has finished cooking in the oven.
/// </summary>
/// <param name="oven">The oven that cooked the item.</param>
/// <param name="item">The item that was cooked.</param>
/// <param name="cookingEntity">The entity that is associated with the cooking process.</param>
/// <returns>No return behavior.</returns>
void OnOvenCooked(BaseOven oven, Item item, BaseEntity cookingEntity)
{
    Puts($"Oven {oven.net.ID} has finished cooking item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "food.cooked.chicken")
    {
        Puts("Cooked chicken is ready! Enjoy your meal!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		if (HasFlag(Flags.Reserved8))
		{
			return;
		}
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		if (item != null)
		{
			ItemModBurnable itemModBurnable = item.info.ItemModBurnable;
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, itemModBurnable);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnConstructionPlace(BaseEntity,Construction,Construction.Target,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a construction is placed in the game world.
/// </summary>
/// <param name="entity">The entity being placed.</param>
/// <param name="construction">The construction component being used.</param>
/// <param name="placement">The target placement location for the construction.</param>
/// <param name="player">The player who is placing the construction.</param>
/// <returns>
/// Returns the GameObject of the placed construction if successful; otherwise, returns `null`.
/// If the method returns a non-null value, the placement is considered valid.
/// </returns>
GameObject OnConstructionPlace(BaseEntity entity, Construction construction, Construction.Target placement, BasePlayer player)
{
    Puts($"Player {player.displayName} is placing a construction at {placement.position}.");

    if (placement.position.y < 0)
    {
        Puts("Invalid placement position: below ground.");
        return null;
    }

    return entity.gameObject; // Simulate successful placement
}
```
```

### Source Code from the Library

```csharp

	public GameObject DoPlacement(Construction.Target placement, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		BaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);
		if (!baseEntity)
		{
			return null;
		}
		float num = 1f;
		float num2 = 0f;
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			baseEntity.skinID = ownerItem.skin;
			if (ownerItem.hasCondition)
			{
				num = ownerItem.conditionNormalized;
			}
		}
		PoolableEx.AwakeFromInstantiate(baseEntity.gameObject);
		BuildingBlock buildingBlock = baseEntity as BuildingBlock;
		if ((bool)buildingBlock)
		{
			buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
			if (!buildingBlock.blockDefinition)
			{
				Debug.LogError("Placing a building block that has no block definition!");
				return null;
			}
			buildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);
			num2 = buildingBlock.currentGrade.maxHealth;
		}
		BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
		if ((bool)baseCombatEntity)
		{
			num2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);
			baseCombatEntity.ResetLifeStateOnSpawn = false;
			baseCombatEntity.InitializeHealth(num2 * num, num2);
		}
		if (Interface.CallHook("OnConstructionPlace", baseEntity, component, placement, ownerPlayer) != null)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.KillMessage();
			}
			else
			{
				GameManager.Destroy(baseEntity);
			}
			return null;
		}
		baseEntity.OnPlaced(ownerPlayer);
		baseEntity.OwnerID = ownerPlayer.userID;
		baseEntity.Spawn();
		if ((bool)buildingBlock)
		{
			Effect.server.Run("assets/bundled/prefabs/fx/build/frame_place.prefab", baseEntity, 0u, Vector3.zero, Vector3.zero);
		}
		StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
		if ((bool)stabilityEntity)
		{
			stabilityEntity.UpdateSurroundingEntities();
		}
		return baseEntity.gameObject;
	}

```

## OnGrowableStateChange(GrowableEntity,PlantProperties.State)

```csharp
```csharp
/// <summary>
/// Called when the state of a growable entity changes.
/// </summary>
/// <param name="growable">The growable entity whose state is changing.</param>
/// <param name="newState">The new state of the growable entity.</param>
/// <returns>
/// Returns a non-null value to prevent the state change, or `null` to allow it.
/// </returns>
object OnGrowableStateChange(GrowableEntity growable, PlantProperties.State newState)
{
    Puts($"Growable entity {growable.GetInstanceID()} is attempting to change state to {newState}.");
    
    if (newState == PlantProperties.State.Dead)
    {
        Puts($"Growable entity {growable.GetInstanceID()} cannot change to Dead state.");
        return true; // Prevent state change
    }
    
    return null; // Allow state change
}
```
```

### Source Code from the Library

```csharp

	public void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)
	{
		if (Interface.CallHook("OnGrowableStateChange", this, state) != null || (base.isServer && State == state))
		{
			return;
		}
		State = state;
		if (!base.isServer)
		{
			return;
		}
		if (!loading)
		{
			if (currentStage.resources > 0f)
			{
				yieldPool = currentStage.yield;
			}
			if (state == PlantProperties.State.Crossbreed)
			{
				if (Properties.CrossBreedEffect.isValid)
				{
					Effect.server.Run(Properties.CrossBreedEffect.resourcePath, base.transform.position, Vector3.up);
				}
				GrowableGenetics.CrossBreed(this);
			}
			SendNetworkUpdate();
		}
		if (resetAge)
		{
			stageAge = 0f;
		}
	}

```

## OnLootEntityEnd(BasePlayer,ContainerIOEntity)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="container">The container entity that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ContainerIOEntity container)
{
    Puts($"Player {player.displayName} has stopped looting the container: {container.name}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Determines whether a potential target can be targeted by the helicopter turret.
/// </summary>
/// <param name="target">The potential target entity.</param>
/// <param name="turret">The helicopter turret attempting to target the entity.</param>
/// <returns>
/// Returns `true` if the target can be engaged; otherwise, returns `false`.
/// If the method returns `null`, the default targeting logic will be applied.
/// </returns>
bool? CanBeTargeted(BaseCombatEntity target, HelicopterTurret turret)
{
    Puts($"Checking if target {target.displayName} can be engaged by turret {turret.net.ID}.");

    if (target.IsDead())
    {
        Puts($"Target {target.displayName} is dead and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## OnRackedWeaponLoad(Item,ItemDefinition,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is loaded with ammo on a weapon rack.
/// </summary>
/// <param name="slot">The item representing the weapon being loaded.</param>
/// <param name="ammoDefinition">The definition of the ammo being loaded into the weapon.</param>
/// <param name="player">The player loading the weapon.</param>
/// <param name="weaponRack">The weapon rack where the loading occurs.</param>
/// <returns>
/// Returns a non-null value to prevent the weapon from being loaded. 
/// If `null` is returned, the weapon will be loaded as normal.
/// </returns>
object OnRackedWeaponLoad(Item slot, ItemDefinition ammoDefinition, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Player {player.displayName} is attempting to load {ammoDefinition.displayName.english} into {slot.info.displayName.english} on the weapon rack.");

    if (ammoDefinition == null)
    {
        Puts("Attempted to load null ammo definition.");
        return "Invalid ammo type.";
    }

    if (ammoDefinition.itemid == 12345) // Example item ID for a restricted ammo type
    {
        Puts($"Player {player.displayName} is not allowed to load restricted ammo.");
        return "You cannot load this type of ammo.";
    }

    return null; // Allow the loading to proceed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!player)
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (heldEntity == null)
		{
			return;
		}
		BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
		if (component == null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null || Interface.CallHook("OnRackedWeaponLoad", slot, itemDefinition, player, this) != null)
		{
			return;
		}
		if (itemDefinition == SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!(itemDefinition != null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component2 = itemDefinition.GetComponent<ItemModProjectile>();
		if (!(component2 == null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", slot, itemDefinition, player, this);
		}
	}

```

## OnTeamUpdated(ulong,ProtoBuf.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's team information is updated.
/// </summary>
/// <param name="teamId">The unique identifier of the team being updated.</param>
/// <param name="teamData">The updated team data containing members and their statuses.</param>
/// <param name="updatingPlayer">The player who initiated the team update.</param>
/// <returns>Returns `null` to allow the default update behavior, or a non-null value to override it.</returns>
object OnTeamUpdated(ulong teamId, ProtoBuf.PlayerTeam teamData, BasePlayer updatingPlayer)
{
    Puts($"Team update received for Team ID: {teamId} by Player: {updatingPlayer.displayName}");

    if (teamData.members.Count < 1)
    {
        Puts($"Team ID: {teamId} has no members.");
        return "No members in the team.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TeamUpdate(bool fullTeamUpdate)
	{
		if (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)
		{
			return;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(currentTeam);
		if (playerTeam == null)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		using PlayerTeam playerTeam2 = Facepunch.Pool.Get<PlayerTeam>();
		playerTeam2.teamLeader = playerTeam.teamLeader;
		playerTeam2.teamID = playerTeam.teamID;
		playerTeam2.teamName = playerTeam.teamName;
		playerTeam2.members = Facepunch.Pool.Get<List<PlayerTeam.TeamMember>>();
		playerTeam2.teamLifetime = playerTeam.teamLifetime;
		playerTeam2.teamPings = Facepunch.Pool.Get<List<MapNote>>();
		foreach (ulong member in playerTeam.members)
		{
			BasePlayer basePlayer = RelationshipManager.FindByID(member);
			if ((bool)basePlayer && basePlayer.IsInTutorial)
			{
				continue;
			}
			PlayerTeam.TeamMember teamMember = Facepunch.Pool.Get<PlayerTeam.TeamMember>();
			teamMember.displayName = ((basePlayer != null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
			teamMember.healthFraction = ((basePlayer != null && basePlayer.IsAlive()) ? basePlayer.healthFraction : 0f);
			teamMember.position = ((basePlayer != null) ? basePlayer.transform.position : Vector3.zero);
			teamMember.online = basePlayer != null && !basePlayer.IsSleeping();
			teamMember.wounded = basePlayer != null && basePlayer.IsWounded();
			if ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) && basePlayer != null)
			{
				if ((bool)basePlayer.GetHeldEntity() && basePlayer.GetHeldEntity().IsInstrument())
				{
					num++;
				}
				if (basePlayer.isMounted)
				{
					if (basePlayer.GetMounted().IsInstrument())
					{
						num++;
					}
					if (basePlayer.GetMounted().IsSummerDlcVehicle)
					{
						num2++;
					}
				}
				if (num >= 4 && !sentInstrumentTeamAchievement)
				{
					GiveAchievement("TEAM_INSTRUMENTS");
					sentInstrumentTeamAchievement = true;
				}
				if (num2 >= 4)
				{
					GiveAchievement("SUMMER_INFLATABLE");
					sentSummerTeamAchievement = true;
				}
			}
			teamMember.userID = member;
			playerTeam2.members.Add(teamMember);
			if (basePlayer != null)
			{
				if (basePlayer.State.pings != null && basePlayer.State.pings.Count > 0 && basePlayer != this)
				{
					playerTeam2.teamPings.AddRange(basePlayer.State.pings);
				}
				if (fullTeamUpdate && basePlayer != this)
				{
					basePlayer.TeamUpdate(fullTeamUpdate: false);
				}
			}
		}
		playerTeam2.leaderMapNotes = Facepunch.Pool.Get<List<MapNote>>();
		PlayerState playerState = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(playerTeam.teamLeader);
		if (playerState?.pointsOfInterest != null)
		{
			foreach (MapNote item in playerState.pointsOfInterest)
			{
				playerTeam2.leaderMapNotes.Add(item);
			}
		}
		if (Interface.CallHook("OnTeamUpdated", currentTeam, playerTeam2, this) == null)
		{
			ClientRPC(RpcTarget.PlayerAndSpectators("CLIENT_ReceiveTeamInfo", this), playerTeam2);
			if (playerTeam2.leaderMapNotes != null)
			{
				playerTeam2.leaderMapNotes.Clear();
			}
			if (playerTeam2.teamPings != null)
			{
				playerTeam2.teamPings.Clear();
			}
			BasePlayer basePlayer2 = FindByID(playerTeam.teamLeader);
			if (fullTeamUpdate && basePlayer2 != null && basePlayer2 != this)
			{
				basePlayer2.TeamUpdate(fullTeamUpdate: false);
			}
		}
	}

```

## OnRconConnection(System.Net.IPAddress)

```csharp
```csharp
/// <summary>
/// Called when a new RCON connection is established.
/// </summary>
/// <param name="ipAddress">The IP address of the connecting client.</param>
/// <returns>
/// Returns a non-null value to reject the connection, or `null` to allow the connection to proceed.
/// </returns>
object OnRconConnection(System.Net.IPAddress ipAddress)
{
    Puts($"New RCON connection attempt from IP: {ipAddress}");

    if (ipAddress.ToString() == "192.168.0.100")
    {
        Puts($"Connection from {ipAddress} is not allowed.");
        return "Access denied for this IP address.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", iPEndPoint.Address) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					UnityEngine.Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnEntityTakeDamage(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit, including damage type and amount.</param>
/// <returns>
/// Returns a non-null value to prevent the damage from being applied. 
/// If `null` is returned, the damage will be processed as normal.
/// </returns>
object OnEntityTakeDamage(ResourceEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.net.ID} is taking damage: {hitInfo.damageTypes.Total()} from {hitInfo.Initiator?.ToString() ?? "unknown source"}.");

    if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Explosion)
    {
        Puts($"Entity {entity.net.ID} is immune to explosion damage.");
        return true; // Prevent damage from explosions
    }

    return null; // Allow normal damage processing
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", this, info) != null)
		{
			return;
		}
		if (resourceDispenser != null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if ((bool)baseProtection)
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnKilled(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

```

## OnOutputUpdate(IOEntity)

```csharp
```csharp
/// <summary>
/// Called when the outputs of an IOEntity are updated.
/// </summary>
/// <param name="entity">The IOEntity whose outputs are being updated.</param>
/// <returns>No return behavior.</returns>
void OnOutputUpdate(IOEntity entity)
{
    Puts($"Output update triggered for IOEntity: {entity.name} (ID: {entity.net.ID})");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public virtual void UpdateOutputs()
	{
		if (Interface.CallHook("OnOutputUpdate", this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		ensureOutputsUpdated = false;
		using (TimeWarning.New("ProcessIOOutputs"))
		{
			for (int i = 0; i < outputs.Length; i++)
			{
				IOSlot iOSlot = outputs[i];
				bool flag = true;
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if (!(iOEntity != null))
				{
					continue;
				}
				if (ioType == IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)
				{
					using (TimeWarning.New("FluidOutputProcessing"))
					{
						if (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))
						{
							flag = false;
						}
					}
				}
				int passthroughAmount = GetPassthroughAmount(i);
				iOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);
			}
		}
	}

```

## OnExcavatorResourceSet(ExcavatorArm,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the resource target for an excavator is set by a player.
/// </summary>
/// <param name="excavator">The excavator arm that is being set.</param>
/// <param name="resourceType">The type of resource being targeted (e.g., HQM, Sulfur, Stone, Metal).</param>
/// <param name="player">The player who set the resource target.</param>
/// <returns>No return behavior.</returns>
void OnExcavatorResourceSet(ExcavatorArm excavator, string resourceType, BasePlayer player)
{
    Puts($"Player {player.displayName} set the excavator resource target to: {resourceType}.");
    
    if (resourceType == "HQM")
    {
        Puts("High Quality Metal is now the target resource.");
    }
    else if (resourceType == "Sulfur")
    {
        Puts("Sulfur is now the target resource.");
    }
    else if (resourceType == "Stone")
    {
        Puts("Stone is now the target resource.");
    }
    else if (resourceType == "Metal")
    {
        Puts("Metal is now the target resource.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SetResourceTarget(RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnExcavatorResourceSet", this, text, msg.player) == null)
		{
			switch (text)
			{
			case "HQM":
				resourceMiningIndex = 0;
				break;
			case "Sulfur":
				resourceMiningIndex = 1;
				break;
			case "Stone":
				resourceMiningIndex = 2;
				break;
			case "Metal":
				resourceMiningIndex = 3;
				break;
			}
			if (!IsOn())
			{
				BeginMining();
			}
		}
	}

```

## OnPlayerPveDamage(BaseEntity,HitInfo,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to deal damage in a PvE environment.
/// </summary>
/// <param name="initiator">The entity initiating the damage (usually a player).</param>
/// <param name="hitInfo">Information about the hit, including damage types and amounts.</param>
/// <param name="buildingBlock">The building block that is being damaged.</param>
/// <returns>No return behavior.</returns>
void OnPlayerPveDamage(BaseEntity initiator, HitInfo hitInfo, BuildingBlock buildingBlock)
{
    Puts($"Player {initiator?.ToString() ?? "Unknown"} attempted to deal PvE damage to {buildingBlock?.ToString() ?? "a building block"}.");
    
    if (initiator is BasePlayer player)
    {
        Puts($"Player {player.displayName} is dealing PvE damage.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer)
		{
			if (Interface.CallHook("OnPlayerPveDamage", info.Initiator, info, this) == null)
			{
				(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			}
		}
		else
		{
			if ((bool)info.Initiator && info.Initiator is BasePlayer { IsInTutorial: not false })
			{
				return;
			}
			if (HasWallpaper())
			{
				DamageType majorityDamageType = info.damageTypes.GetMajorityDamageType();
				bool flag = info.damageTypes.Contains(DamageType.Explosion);
				DamageTypeList damageTypeList = info.damageTypes.Clone();
				if (wallpaperProtection != null)
				{
					wallpaperProtection.Scale(damageTypeList);
				}
				float totalDamage = damageTypeList.Total();
				if (majorityDamageType == DamageType.Decay || flag || majorityDamageType == DamageType.Heat)
				{
					DamageWallpaper(totalDamage);
					DamageWallpaper(totalDamage, 1);
				}
				else
				{
					bool flag2 = false;
					for (int i = 0; i < propDirection.Length; i++)
					{
						if (propDirection[i].IsWeakspot(base.transform, info))
						{
							flag2 = true;
							break;
						}
					}
					DamageWallpaper(totalDamage, (!flag2) ? 1 : 0);
				}
			}
			base.Hurt(info);
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The item container from which items are being dropped.</param>
/// <returns>
/// Returns a non-null value to prevent items from being dropped, or `null` to allow the drop operation to proceed.
/// </returns>
object OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping items from container owned by: {container.entityOwner?.name ?? "Unknown"}");

    if (container.itemList.Count == 0)
    {
        Puts("No items to drop from the container.");
        return "Container is empty.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			float num2 = UnityEngine.Random.Range(0f, 2f);
			item.RemoveFromContainer();
			BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
			if (baseEntity == null)
			{
				item.Remove();
				continue;
			}
			if (baseEntity is DroppedItem droppedItem && container.entityOwner is LootContainer)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;
			}
			if (num2 > 0f)
			{
				baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
				baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
			}
		}
	}

```

## OnGrowableGathered(GrowableEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a growable entity is gathered by a player.
/// </summary>
/// <param name="growable">The growable entity that was gathered.</param>
/// <param name="item">The item that was harvested from the growable entity.</param>
/// <param name="player">The player who gathered the item.</param>
/// <returns>No return behavior.</returns>
void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} gathered {item.amount} of {item.info.displayName.english} from {growable.gameObject.name}.");
    
    if (item.info.shortname == "berry")
    {
        Puts($"Player {player.displayName} has gathered berries, a nutritious snack!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)
	{
		Item item = ItemManager.Create(Properties.pickupItem, amount, 0uL);
		if (applyCondition)
		{
			item.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);
		}
		if (eat && player != null && IsFood())
		{
			ItemModConsume component = item.info.GetComponent<ItemModConsume>();
			if (component != null)
			{
				component.DoAction(item, player);
				return;
			}
		}
		if (player != null)
		{
			Interface.CallHook("OnGrowableGathered", this, item, player);
			Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
		}
		else
		{
			item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
		}
	}

```

## OnItemDeployed(Deployer,BaseEntity,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is successfully deployed in the game world.
/// </summary>
/// <param name="deployer">The player who deployed the item.</param>
/// <param name="baseEntity">The base entity to which the item is being deployed.</param>
/// <param name="deployedEntity">The entity that has been deployed.</param>
/// <returns>No return behavior.</returns>
void OnItemDeployed(Deployer deployer, BaseEntity baseEntity, BaseEntity deployedEntity)
{
    Puts($"Item deployed by {deployer.OwnerID} at position {deployedEntity.transform.position} on {baseEntity.name}.");
    
    if (deployedEntity is Deployable deployable)
    {
        Puts($"Deployable item {deployable.name} has been placed successfully.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		if (ownerPlayer.Distance(baseEntity) > 3f)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);
			return;
		}
		if (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		if (ownerPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = ownerPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null && !currentTutorialIsland.CheckPlacement(ownerPlayer, deployable, baseEntity.transform.position, baseEntity.transform.rotation))
			{
				return;
			}
		}
		Item ownerItem = GetOwnerItem();
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			baseEntity2.skinID = ownerItem.skin;
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity, ownerPlayer, ownerItem);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
			if (ownerPlayer.IsInTutorial)
			{
				TutorialIsland currentTutorialIsland2 = ownerPlayer.GetCurrentTutorialIsland();
				if (currentTutorialIsland2 != null)
				{
					currentTutorialIsland2.OnPlayerBuiltConstruction(ownerPlayer);
				}
			}
			if (GetOwnerItemDefinition() != null)
			{
				ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
				{
					WorldPosition = baseEntity2.transform.position,
					UintIdentifier = baseEntity2.prefabID,
					IntIdentifier = GetOwnerItemDefinition().itemid
				}, 1f);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity, baseEntity2);
		Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);
		if (!ownerPlayer.IsInCreativeMode || !Creative.freeBuild)
		{
			UseItemAmount(1);
		}
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a new building grade.
/// </summary>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="newGrade">The new grade to which the structure is being upgraded.</param>
/// <param name="skinId">The skin ID associated with the new grade.</param>
/// <returns>No return behavior.</returns>
void OnStructureUpgrade(BuildingBlock buildingBlock, BasePlayer player, BuildingGrade.Enum newGrade, ulong skinId)
{
    Puts($"Player {player.displayName} upgraded structure {buildingBlock.net.ID} to grade {newGrade} with skin ID {skinId}.");
    
    if (newGrade == BuildingGrade.Enum.Stone)
    {
        Puts($"Structure {buildingBlock.net.ID} upgraded to Stone grade by {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void DoUpgradeToGrade(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		ConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());
		if (constructionGrade == null)
		{
			return;
		}
		if (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
		{
			if (!(DeployVolume.LastDeployHit != null))
			{
				return;
			}
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(DeployVolume.LastDeployHit);
			if (baseEntity != null && baseEntity is BasePlayer basePlayer)
			{
				ulong currentTeam = msg.player.currentTeam;
				if (currentTeam != 0L && currentTeam == basePlayer.currentTeam)
				{
					string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
					msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);
				}
			}
		}
		else
		{
			if (Interface.CallHook("OnStructureUpgrade", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin) != null || !CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
			{
				return;
			}
			if (base.SecondsSinceAttacked < 30f)
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
				return;
			}
			if (!constructionGrade.gradeBase.alwaysUnlock && constructionGrade.gradeBase.skin != 0L && !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);
				return;
			}
			PayForUpgrade(constructionGrade, msg.player);
			if (msg.player != null)
			{
				playerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);
			}
			ClientRPC(RpcTarget.NetworkGroup("DoUpgradeEffect"), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			BuildingGrade.Enum @enum = grade;
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);
			OnSkinChanged(skinID, constructionGrade.gradeBase.skin);
			ChangeGrade(constructionGrade.gradeBase.type, playEffect: true);
			if (msg.player != null && @enum != constructionGrade.gradeBase.type)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload
				{
					NetworkIdentifier = net.ID,
					IntIdentifier = (int)constructionGrade.gradeBase.type
				}, 1f);
			}
			Interface.CallHook("OnStructureUpgraded", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
		}
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player can use the mailbox; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can use the mailbox.
/// </returns>
bool? CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use the mailbox.");

    if (player.IsBannedFromMailboxes)
    {
        Puts($"Player {player.displayName} is banned from using mailboxes.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine is rotated by a player.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="player">The player who is rotating the vending machine.</param>
/// <returns>No return behavior.</returns>
void OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending machine at {vendingMachine.transform.position} rotated by player {player.displayName} (ID: {player.UserIDString}).");
    
    if (!player.CanBuild())
    {
        Puts($"Player {player.displayName} does not have permission to build.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RotateVM(RPCMessage msg)
	{
		if (Interface.CallHook("OnRotateVendingMachine", this, msg.player) == null && CanRotate())
		{
			UpdateEmptyFlag();
			if (msg.player.CanBuild() && IsInventoryEmpty())
			{
				base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
				SendNetworkUpdate();
			}
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting a lootable entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="corpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse corpse)
{
    Puts($"Player {player.displayName} has stopped looting the corpse.");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a landmine trap is disarmed by a player.
/// </summary>
/// <param name="landmine">The landmine trap that is being disarmed.</param>
/// <param name="disarmer">The player who is attempting to disarm the trap.</param>
/// <returns>
/// Returns `null` to allow the disarm action, or any non-null value to prevent it.
/// </returns>
object OnTrapDisarm(Landmine landmine, BasePlayer disarmer)
{
    Puts($"Player {disarmer.displayName} is attempting to disarm a landmine.");
    
    if (disarmer.IsAdmin)
    {
        Puts($"Admin {disarmer.displayName} has disarmed the landmine successfully.");
        return null; // Allow disarm
    }

    Puts($"Player {disarmer.displayName} is not authorized to disarm this landmine.");
    return "You are not allowed to disarm this trap."; // Prevent disarm
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if ((ulong)rpc.player.userID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			if (UnityEngine.Random.Range(0, 100) < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## OnTurretRotate(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an auto turret rotates.
/// </summary>
/// <param name="turret">The auto turret that is rotating.</param>
/// <param name="player">The player who triggered the rotation.</param>
/// <returns>
/// Returns `null` to allow the turret to rotate, or any non-null value to prevent the rotation.
/// </returns>
object OnTurretRotate(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.net.ID} is rotating due to player {player.displayName} (ID: {player.UserIDString}).");
    
    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone; turret rotation is blocked.");
        return "Turret rotation is not allowed in safe zones.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void FlipAim(RPCMessage rpc)
	{
		if (!IsOnline() && IsAuthed(rpc.player) && !booting && Interface.CallHook("OnTurretRotate", this, rpc.player) == null)
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnBookmarkControlEnded(ComputerStation,BasePlayer,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a player ends control of a remote controllable entity via a bookmark.
/// </summary>
/// <param name="station">The computer station that facilitated the control.</param>
/// <param name="player">The player who ended the control.</param>
/// <param name="remoteControllable">The remote controllable entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, IRemoteControllable remoteControllable)
{
    Puts($"Player {player.displayName} has ended control of {remoteControllable.GetEnt()?.name ?? "an unknown entity"}.");
    
    if (remoteControllable != null)
    {
        Puts($"Remote controllable entity {remoteControllable.GetEnt().name} has been released by {player.displayName}.");
    }
    else
    {
        Puts($"No remote controllable entity was found for player {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## CanUseGesture(BasePlayer,GestureConfig)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use a specific gesture based on various conditions.
/// </summary>
/// <param name="player">The player attempting to use the gesture.</param>
/// <param name="gestureConfig">The configuration of the gesture being used.</param>
/// <returns>
/// Returns `true` if the player can use the gesture; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the gesture can be used.
/// </returns>
bool? CanUseGesture(BasePlayer player, GestureConfig gestureConfig)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use gesture: {gestureConfig.gestureName}.");

    if (gestureConfig.gestureType == GestureType.Cinematic && !player.IsAdmin)
    {
        Puts($"Player {player.displayName} is not an admin and cannot use cinematic gestures.");
        return false;
    }

    if (gestureConfig.dlcItem != null && !gestureConfig.dlcItem.CanUse(player))
    {
        Puts($"Player {player.displayName} does not own the required DLC to use this gesture.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool IsOwnedBy(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseGesture", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (gestureType == GestureType.NPC)
		{
			return player.IsNpc;
		}
		if (gestureType == GestureType.Cinematic)
		{
			return player.IsAdmin;
		}
		if (dlcItem != null && dlcItem.CanUse(player))
		{
			return true;
		}
		if (inventoryItem != null && player.blueprints.steamInventory.HasItem(inventoryItem.id))
		{
			return true;
		}
		return false;
	}

```

## OnClientDisconnect(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The network connection of the client that disconnected.</param>
/// <param name="reason">The reason for the client's disconnection.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnect(Network.Connection connection, string reason)
{
    Puts($"Client {connection.address} has disconnected. Reason: {reason}");
    if (reason.Contains("timeout"))
    {
        Puts($"Client {connection.address} disconnected due to timeout.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ReadDisconnectReason(Message packet)
	{
		string text = packet.read.String(4096);
		string text2 = packet.connection.ToString();
		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
		{
			Interface.CallHook("OnClientDisconnect", packet.connection, text);
			DebugEx.Log(text2 + " disconnecting: " + text);
		}
	}

```

## OnEntityMarkHostile(BaseCombatEntity,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile for a specified duration.
/// </summary>
/// <param name="entity">The entity that is being marked as hostile.</param>
/// <param name="duration">The duration for which the entity is marked hostile, in seconds.</param>
/// <returns>No return behavior.</returns>
void OnEntityMarkHostile(BaseCombatEntity entity, float duration)
{
    Puts($"Entity {entity.net.ID} marked as hostile for {duration} seconds.");
    if (duration > 120f)
    {
        Puts($"Warning: Entity {entity.net.ID} marked hostile for an unusually long duration.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			float b = UnityEngine.Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, b);
		}
	}

```

## OnSprayRemove(SprayCanSpray,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a spray can is removed from a player.
/// </summary>
/// <param name="spray">The spray can spray that is being removed.</param>
/// <param name="player">The player who is removing the spray can.</param>
/// <returns>
/// Returns `null` to allow the spray can to be removed, or any non-null value to prevent the removal.
/// </returns>
object OnSprayRemove(SprayCanSpray spray, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to remove spray: {spray.name}.");
    
    if (player.inventory.GetAmount(spray.itemID) < 1)
    {
        Puts($"Player {player.displayName} does not have the spray can to remove.");
        return "You do not have the spray can.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void Server_RequestWaterClear(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && Menu_WaterClear_ShowIf(player) && Interface.CallHook("OnSprayRemove", this, player) == null)
		{
			Kill();
		}
	}

```

## OnServerRestartInterrupt()

```csharp
```csharp
/// <summary>
/// Called when a server restart is interrupted.
/// </summary>
/// <returns>
/// Returns a non-null value to prevent the default behavior of the server restart interruption.
/// If `null` is returned, the default interruption behavior will proceed.
/// </returns>
object OnServerRestartInterrupt()
{
    Puts("Server restart has been interrupted by a hook.");
    return null; // Returning null allows the default behavior to continue.
}
```
```

### Source Code from the Library

```csharp

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (SingletonComponent<ServerMgr>.Instance == null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
			SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", strNotice, iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

```

## OnPlayerRevive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is revived by another player or an item.
/// </summary>
/// <param name="reviver">The player who is reviving another player.</param>
/// <param name="revived">The player being revived.</param>
/// <returns>
/// Returns `null` to allow the revival process to continue, or any non-null value to prevent the revival.
/// </returns>
object OnPlayerRevive(BasePlayer reviver, BasePlayer revived)
{
    Puts($"Player {reviver.displayName} is attempting to revive {revived.displayName}.");

    if (revived.IsWounded())
    {
        Puts($"{revived.displayName} is currently wounded and can be revived.");
        return null; // Allow the revival
    }
    
    Puts($"{revived.displayName} is not in a state to be revived.");
    return "Player is not wounded."; // Prevent the revival
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Facepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if (player != ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
					player.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}

```

## OnNpcRadioChatter(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC plays radio chatter.
/// </summary>
/// <param name="npc">The NPC that is playing the radio chatter.</param>
/// <returns>
/// Returns `null` to allow the radio chatter to play, or any non-null value to prevent it from playing.
/// </returns>
object OnNpcRadioChatter(ScientistNPC npc)
{
    Puts($"NPC {npc.displayName} is attempting to play radio chatter.");
    
    // Example condition to prevent radio chatter
    if (npc.IsSilent)
    {
        Puts($"NPC {npc.displayName} is currently silent and cannot play radio chatter.");
        return true; // Prevents chatter
    }
    
    return null; // Allows chatter
}
```
```

### Source Code from the Library

```csharp

	public void PlayRadioChatter()
	{
		if (RadioChatterEffects.Length != 0)
		{
			if (base.IsDestroyed || base.transform == null)
			{
				CancelInvoke(PlayRadioChatter);
			}
			else if (Interface.CallHook("OnNpcRadioChatter", this) == null)
			{
				Effect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				QueueRadioChatter();
			}
		}
	}

```

## OnTechTreeNodeUnlocked(Workbench,TechTreeData.NodeInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a technology tree node is unlocked by a player.
/// </summary>
/// <param name="workbench">The workbench associated with the unlocking action.</param>
/// <param name="node">The technology tree node that has been unlocked.</param>
/// <param name="player">The player who unlocked the technology tree node.</param>
/// <returns>No return behavior.</returns>
void OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
{
    Puts($"Player {player.displayName} has unlocked the tech tree node: {node.itemDef?.shortname ?? "Unknown"} at workbench: {workbench.name}.");
    
    if (node.itemDef != null)
    {
        Puts($"Node unlocked: {node.itemDef.displayName.english} (ID: {node.itemDef.itemid})");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if (techTreeForLevel == null)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log("Node for unlock not found :" + id);
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && byID2.itemDef != null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log("Player unlocked group :" + byID.groupName);
			}
			else if (byID.itemDef != null && Interface.CallHook("OnTechTreeNodeUnlock", this, byID, player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", this, byID, player);
					Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

```

## OnAmmoUnload(BaseProjectile,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player unloads ammo from a projectile weapon.
/// </summary>
/// <param name="projectile">The projectile weapon from which ammo is being unloaded.</param>
/// <param name="item">The item representing the ammo being unloaded.</param>
/// <param name="player">The player performing the unload action.</param>
/// <returns>
/// Returns a non-null value to prevent the ammo unload action from proceeding. 
/// If `null` is returned, the ammo unload will continue as normal.
/// </returns>
object OnAmmoUnload(BaseProjectile projectile, Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to unload ammo from {projectile.info.displayName.english}.");

    if (projectile.primaryMagazine.contents > 10)
    {
        Puts($"Ammo unload blocked: {player.displayName} has too much ammo in the magazine.");
        return "Cannot unload ammo while magazine is over 10 rounds.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UnloadAmmo(Item item, BasePlayer player)
	{
		BaseProjectile component = item.GetHeldEntity().GetComponent<BaseProjectile>();
		if (!component.canUnloadAmmo || Interface.CallHook("OnAmmoUnload", component, item, player) != null || !component)
		{
			return;
		}
		int num = component.primaryMagazine.contents;
		if (num <= 0)
		{
			return;
		}
		component.SetAmmoCount(0);
		item.MarkDirty();
		SendNetworkUpdateImmediate();
		int stackable = component.primaryMagazine.ammoType.stackable;
		if (num > stackable)
		{
			int num2 = Mathf.FloorToInt(num / component.primaryMagazine.ammoType.stackable);
			num %= stackable;
			for (int i = 0; i < num2; i++)
			{
				Item item2 = ItemManager.Create(component.primaryMagazine.ammoType, stackable, 0uL);
				player.GiveItem(item2);
			}
		}
		if (num > 0)
		{
			Item item3 = ItemManager.Create(component.primaryMagazine.ammoType, num, 0uL);
			player.GiveItem(item3);
		}
	}

```

## OnPlayerRecovered(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player has recovered from a wounded state.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecovered(BasePlayer player)
{
    Puts($"Player {player.displayName} has recovered from being wounded.");
    
    // Additional logic can be added here, such as notifying other players or updating stats.
}
```
```

### Source Code from the Library

```csharp

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			if (IsCrawling())
			{
				base.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if ((bool)BaseGameMode.GetActiveGameMode(base.isServer))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", this);
		}
	}

```

## OnLiquidWeaponFired(LiquidWeapon,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a liquid weapon is fired by a player.
/// </summary>
/// <param name="liquidWeapon">The liquid weapon that is being fired.</param>
/// <param name="player">The player who fired the weapon.</param>
/// <returns>No return behavior.</returns>
void OnLiquidWeaponFired(LiquidWeapon liquidWeapon, BasePlayer player)
{
    Puts($"Player {player.displayName} fired the liquid weapon: {liquidWeapon.info.displayName.english}.");
    
    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot fire the weapon.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartFiring(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (OnCooldown())
		{
			return;
		}
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		if (CanFire(player))
		{
			CancelInvoke(FireTick);
			InvokeRepeating(FireTick, 0f, FireRate);
			SetFlag(Flags.On, b: true);
			StartCooldown(FireRate);
			if (base.isServer)
			{
				SendNetworkUpdateImmediate();
			}
			Interface.CallHook("OnLiquidWeaponFired", this, player);
		}
	}

```

## OnNetworkGroupEntered(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network group is entered by a networkable entity.
/// </summary>
/// <param name="group">The network visibility group that has been entered.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupEntered(BaseNetworkable entity, Network.Visibility.Group group)
{
    Puts($"Entity {entity.net.ID} has entered the network group: {group.name}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", this, group);
	}

```

## CanStackItem(Item,Item)

```csharp
```csharp
/// <summary>
/// Determines whether two items can be stacked together in the inventory.
/// </summary>
/// <param name="item">The item to check for stacking compatibility.</param>
/// <returns>
/// Returns `true` if the items can be stacked, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the items can be stacked.
/// </returns>
bool? CanStackItem(Item item)
{
    Puts($"Checking if items can stack: {this.info.displayName.english} and {item.info.displayName.english}");

    if (item.info.itemid == this.info.itemid)
    {
        Puts("Items can stack because they are of the same type.");
        return true;
    }

    Puts("Items cannot stack due to different item types.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (MaxStackable() <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != item.info.condition.max)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.info.condition.max)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		if (item.skin != skin)
		{
			return false;
		}
		if (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			int num2 = ((instanceData != null) ? instanceData.dataInt : (-1));
			if (num != num2)
			{
				return false;
			}
		}
		if (item.instanceData != null && instanceData != null && (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt && item.info.Blueprint != null && item.info.Blueprint.workbenchLevelRequired == 3)))
		{
			return false;
		}
		if (instanceData != null && instanceData.subEntity.IsValid && (bool)info.GetComponent<ItemModSign>())
		{
			return false;
		}
		if (item.instanceData != null && item.instanceData.subEntity.IsValid && (bool)item.info.GetComponent<ItemModSign>())
		{
			return false;
		}
		return true;
	}

```

## OnDieselEngineToggled(DieselEngine)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off.
/// </summary>
/// <param name="engine">The diesel engine that has been toggled.</param>
/// <returns>No return behavior.</returns>
void OnDieselEngineToggled(DieselEngine engine)
{
    Puts($"Diesel engine {engine.net.ID} has been toggled. Current state: {(engine.HasFlag(Flags.On) ? "On" : "Off")}");
}
```
```

### Source Code from the Library

```csharp

	public void EngineOff()
	{
		SetFlag(Flags.On, b: false);
		BroadcastEntityMessage("DieselEngineOff");
		Interface.CallHook("OnDieselEngineToggled", this);
	}

```

## OnPhoneDial(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to dial a phone number.
/// </summary>
/// <param name="caller">The phone controller of the caller.</param>
/// <param name="receiver">The phone controller of the receiver.</param>
/// <param name="player">The player who is making the call.</param>
/// <returns>
/// Returns `null` to allow the call to proceed, or any non-null value to prevent the call from being connected.
/// </returns>
object OnPhoneDial(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to call {receiver.PhoneNumber} from {caller.PhoneNumber}.");

    if (receiver.serverState == Telephone.CallState.Busy)
    {
        Puts($"Call from {player.displayName} to {receiver.PhoneNumber} failed: receiver is busy.");
        return "The line is currently busy.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CallPhone(int number)
	{
		if (number == PhoneNumber)
		{
			OnDialFailed(Telephone.DialFailReason.CallSelf);
			return;
		}
		if (TelephoneManager.GetCurrentActiveCalls() + 1 > TelephoneManager.MaxConcurrentCalls)
		{
			OnDialFailed(Telephone.DialFailReason.NetworkBusy);
			return;
		}
		PhoneController telephone = TelephoneManager.GetTelephone(number);
		if (telephone != null)
		{
			if (Interface.CallHook("OnPhoneDial", this, telephone, currentPlayer) == null)
			{
				if (telephone.serverState == Telephone.CallState.Idle && telephone.CanReceiveCall())
				{
					SetPhoneState(Telephone.CallState.Dialing);
					lastDialedNumber = number;
					activeCallTo = telephone;
					activeCallTo.ReceiveCallFrom(this);
				}
				else
				{
					OnDialFailed(Telephone.DialFailReason.Engaged);
					telephone.OnIncomingCallWhileBusy();
				}
			}
		}
		else
		{
			OnDialFailed(Telephone.DialFailReason.WrongNumber);
		}
	}

```

## OnLootEntityEnd(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="container">The dropped item container that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, DroppedItemContainer container)
{
    Puts($"Player {player.displayName} has stopped looting the container with ID: {container.net.ID}.");
    
    if (container.inventory != null && container.inventory.itemList.Count > 0)
    {
        Puts($"Container still has items. Player {player.displayName} may return to loot.");
    }
    else
    {
        Puts($"Container is empty. It will be removed.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		if (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)
		{
			Kill();
		}
		else
		{
			ResetRemovalTime();
			SetFlag(Flags.Open, b: false);
			SendNetworkUpdate();
		}
		EvaluateBagConditions();
	}

```

## OnInventoryItemsTake(PlayerInventory,System.Collections.Generic.List<Item>,int,int)

```csharp
```csharp
/// <summary>
/// Called when items are taken from the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory from which items are being taken.</param>
/// <param name="collect">The list of items being collected.</param>
/// <param name="itemId">The ID of the item being taken.</param>
/// <param name="amount">The amount of the item to take.</param>
/// <returns>
/// Returns the actual amount of items taken. If a non-null integer is returned, it overrides the default behavior.
/// </returns>
int OnInventoryItemsTake(PlayerInventory inventory, List<Item> collect, int itemId, int amount)
{
    Puts($"Attempting to take {amount} of item ID {itemId} from inventory.");

    if (itemId == 12345) // Example item ID for a restricted item
    {
        Puts("Taking this item is not allowed.");
        return 0; // Prevent taking the item
    }

    return amount; // Allow taking the specified amount
}
```
```

### Source Code from the Library

```csharp

	public int Take(List<Item> collect, int itemid, int amount)
	{
		object obj = Interface.CallHook("OnInventoryItemsTake", this, collect, itemid, amount);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			int num2 = containerMain.Take(collect, itemid, amount);
			num += num2;
			amount -= num2;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerBelt != null)
		{
			int num3 = containerBelt.Take(collect, itemid, amount);
			num += num3;
			amount -= num3;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerWear != null)
		{
			int num4 = containerWear.Take(collect, itemid, amount);
			num += num4;
			amount -= num4;
		}
		return num;
	}

```

## OnCargoShipHarborApproach(CargoShip,CargoNotifier)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship approaches the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that is approaching the harbor.</param>
/// <param name="notifier">The notifier that provides information about the cargo ship's approach.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipHarborApproach(CargoShip cargoShip, CargoNotifier notifier)
{
    Puts($"Cargo ship {cargoShip.net.ID} is approaching the harbor with notifier ID: {notifier?.ID}");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void StartHarborApproach(CargoNotifier cn)
	{
		if (Interface.CallHook("OnCargoShipHarborApproach", this, cn) != null)
		{
			return;
		}
		PlayHorn();
		isDoingHarborApproach = true;
		dockCount++;
		shouldLookAhead = false;
		if (proxManager != null)
		{
			proxManager.StartMovement();
		}
		ClearAllHarborEntitiesOnShip();
		foreach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)
		{
			if (!(allCrane == null) && !allCrane.isClient && !(allCrane.Distance2D(harborApproachPath.nodes[harborApproachPath.nodes.Count / 2].Position) > 150f))
			{
				allCrane.ReplenishContainers();
			}
		}
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
```csharp
/// <summary>
/// Called to determine if two dropped items can be combined into one.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>
/// Returns `true` if the items can be combined, or `false` if they cannot. 
/// If the method returns `null`, the default game logic will determine if the items can be combined.
/// </returns>
bool? CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts($"Checking if items {item1.item.info.displayName.english} and {item2.item.info.displayName.english} can be combined.");

    if (item1.item.info.itemid == item2.item.info.itemid)
    {
        Puts("Items can be combined.");
        return true;
    }

    Puts("Items cannot be combined due to different item IDs.");
    return false;
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.DestroyItem();
			di.Kill();
			Interface.CallHook("OnDroppedItemCombined", this);
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(base.transform.position, Vector3.zero, base.transform.rotation);
			}
		}
	}

```

## OnDefaultItemsReceived(PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when default items are given to a player.
/// </summary>
/// <param name="inventory">The player's inventory receiving the default items.</param>
/// <returns>No return behavior.</returns>
void OnDefaultItemsReceived(PlayerInventory inventory)
{
    Puts($"Default items have been given to player with inventory ID: {inventory.ID}.");
    
    if (inventory.IsFull())
    {
        Puts("Player's inventory is full; cannot give default items.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);
			}
		}
	}

```

## OnEntityLeave(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the comfort trigger area.
/// </summary>
/// <param name="entity">The entity that has left the trigger area.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity?.name} has left the comfort trigger area.");
    
    if (entity is BasePlayer player)
    {
        Puts($"Player {player.displayName} has exited the comfort zone.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityLeave(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			_players.Remove(basePlayer);
		}
	}

```

## CanBeHomingTargeted(PatrolHelicopter)

```csharp
```csharp
/// <summary>
/// Determines whether the specified patrol helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The patrol helicopter to check.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the helicopter can be targeted.
/// </returns>
bool? CanBeHomingTargeted(PatrolHelicopter helicopter)
{
    Puts($"Checking if Patrol Helicopter ID: {helicopter.net.ID} can be targeted by homing missiles.");
    // Additional logic can be added here if needed
    return null; // Default behavior will be used
}
```
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is patrolling its designated path.
/// </summary>
/// <param name="apc">The Bradley APC that is currently patrolling.</param>
/// <returns>
/// Returns `null` to allow the APC to continue its patrol, or any non-null value to interrupt the patrol behavior.
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC (ID: {apc.net.ID}) is patrolling. Current position: {apc.transform.position}.");

    // Example condition to interrupt patrol
    if (apc.IsUnderAttack())
    {
        Puts("Bradley APC is under attack! Interrupting patrol.");
        return true; // Interrupt patrol
    }

    return null; // Continue patrol
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		IAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		IAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);
		bool flag = false;
		List<IAIPathNode> nodes = Facepunch.Pool.Get<List<IAIPathNode>>();
		IAIPathNode iAIPathNode;
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			iAIPathNode = nodes[nodes.Count - 1];
		}
		else
		{
			iAIPathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.Position) > 2f))
		{
			return;
		}
		if (closestToPoint == iAIPathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.Position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
		else
		{
			if (!AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].Position);
				}
			}
			foreach (IAIPathNode item in path)
			{
				currentPath.Add(item.Position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
	}

```

## OnAdventGiftAwarded(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is awarded a gift from the Advent Calendar.
/// </summary>
/// <param name="calendar">The Advent Calendar instance awarding the gift.</param>
/// <param name="player">The player receiving the gift.</param>
/// <returns>No return behavior.</returns>
void OnAdventGiftAwarded(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Player {player.displayName} has been awarded a gift from the Advent Calendar.");
    
    if (player.IsBanned)
    {
        Puts($"Player {player.displayName} is banned and cannot receive gifts.");
        return;
    }
    
    // Additional logic for awarding gifts can be added here.
}
```
```

### Source Code from the Library

```csharp

	public void AwardGift(BasePlayer player)
	{
		if (Interface.CallHook("OnAdventGiftAward", this, player) != null)
		{
			return;
		}
		DateTime now = DateTime.Now;
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) == startMonth && num >= 0 && num < days.Length)
		{
			if (!playerRewardHistory.ContainsKey(player.userID))
			{
				playerRewardHistory.Add(player.userID, new List<int>());
			}
			playerRewardHistory[player.userID].Add(num);
			Effect.server.Run(giftEffect.resourcePath, player.transform.position);
			if (num >= 0 && num < crosses.Length)
			{
				Effect.server.Run(boxCloseEffect.resourcePath, base.transform.position + Vector3.up * 1.5f);
			}
			DayReward dayReward = days[num];
			for (int i = 0; i < dayReward.rewards.Length; i++)
			{
				ItemAmount itemAmount = dayReward.rewards[i];
				player.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);
			}
			Interface.CallHook("OnAdventGiftAwarded", this, player);
		}
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player finishes sleeping.
/// </summary>
/// <param name="player">The player who has ended their sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player.displayName} has woken up from sleep.");
    
    if (player.IsRestrained)
    {
        Puts($"Player {player.displayName} is restrained and cannot move immediately.");
    }
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", this) == null)
		{
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: true);
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if ((ulong)userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			CancelInvoke(ScheduledDeath);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
			}
			InvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				RemoveFromTriggers();
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", this);
			EACServer.LogPlayerSpawn(this);
			if (TotalPingCount > 0)
			{
				SendPingsToClient();
			}
			if (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))
			{
				ClientRPC(RpcTarget.Player("PromptToStartTutorial", this));
			}
		}
	}

```

## OnAmmoSwitch(BaseProjectile,BasePlayer,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when a player switches the ammo type of a projectile weapon.
/// </summary>
/// <param name="projectile">The projectile weapon whose ammo is being switched.</param>
/// <param name="player">The player performing the ammo switch.</param>
/// <param name="newAmmo">The new ammo type being switched to.</param>
/// <returns>
/// Returns `null` to allow the ammo switch, or any non-null value to prevent the switch.
/// </returns>
object OnAmmoSwitch(BaseProjectile projectile, BasePlayer player, ItemDefinition newAmmo)
{
    Puts($"Player {player.displayName} is switching ammo to {newAmmo.displayName.english} for {projectile.info.displayName.english}.");
    
    if (newAmmo.shortname == "explosive.splash")
    {
        Puts($"Player {player.displayName} is not allowed to switch to explosive ammo.");
        return "You cannot switch to explosive ammo.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnAmmoSwitch", this, ownerPlayer, itemDefinition) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				SetAmmoCount(0);
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnInterferenceOthersUpdate(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to update interference status for nearby turrets.
/// </summary>
/// <param name="turret">The auto turret that is updating its interference status.</param>
/// <returns>No return behavior.</returns>
void OnInterferenceOthersUpdate(AutoTurret turret)
{
    Puts($"Updating interference status for turret ID: {turret.net.ID} at position: {turret.transform.position}");
}
```
```

### Source Code from the Library

```csharp

	public void UpdateInterferenceOnOthers()
	{
		if (Interface.CallHook("OnInterferenceOthersUpdate", this) != null)
		{
			return;
		}
		foreach (AutoTurret nearbyTurret in nearbyTurrets)
		{
			if (nearbyTurret != null)
			{
				nearbyTurret.TryRegisterForInterferenceUpdate();
			}
		}
	}

```

## OnEntityDeath(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a resource entity is killed.
/// </summary>
/// <param name="entity">The resource entity that has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(ResourceEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.name} has been killed. Damage dealt: {hitInfo.damageTypes.Total()} by {hitInfo.Initiator?.name ?? "unknown source"}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnKilled(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", this, info);
		Kill();
	}

```

## OnFireworkExhausted(BaseFirework)

```csharp
```csharp
/// <summary>
/// Called when a firework has exhausted its fuel and is no longer active.
/// </summary>
/// <param name="firework">The firework that has been exhausted.</param>
/// <returns>No return behavior.</returns>
void OnFireworkExhausted(BaseFirework firework)
{
    Puts($"Firework {firework.net.ID} has exhausted its fuel and is now inactive.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnExhausted()
	{
		SetFlag(Flags.Reserved8, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.OnFire, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		EnableGlobalBroadcast(wants: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkExhausted", this);
		Invoke(Cleanup, corpseDuration);
		_activeFireworks.Remove(this);
	}

```

## OnVehicleLockRequest(ModularCarGarage,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player requests to add a lock to a vehicle.
/// </summary>
/// <param name="garage">The modular car garage where the lock is being requested.</param>
/// <param name="player">The player requesting to add the lock.</param>
/// <param name="lockCode">The code for the lock being added.</param>
/// <returns>No return behavior.</returns>
void OnVehicleLockRequest(ModularCarGarage garage, BasePlayer player, string lockCode)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) requested to add a lock with code: {lockCode} to the vehicle in garage {garage.net.ID}.");
    
    if (string.IsNullOrEmpty(lockCode))
    {
        Puts("Lock code cannot be empty.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestAddLock(RPCMessage msg)
	{
		if (!HasOccupant || carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (player == null)
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("OnVehicleLockRequest", this, player, text) == null)
		{
			ItemAmount itemAmount = lockResourceCost;
			if ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && carOccupant.CarLock.TryAddALock(text, player.userID))
			{
				player.inventory.Take(null, itemAmount.itemDef.itemid, Mathf.CeilToInt(itemAmount.amount));
				Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnServerInformationUpdated()

```csharp
```csharp
/// <summary>
/// Called when the server information is updated, including server name, player count, and other metadata.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerInformationUpdated()
{
    Puts("Server information has been updated successfully.");
    // Additional logging or actions can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		using (TimeWarning.New("UpdateServerInformation"))
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.GetServerBrowserMapName();
			string value = "stok";
			if (Restarting)
			{
				value = "strst";
			}
			string text = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text2 = $"gm{GamemodeName()}";
			string text3 = (ConVar.Server.pve ? ",pve" : string.Empty);
			string text4 = ConVar.Server.tags?.Trim(',') ?? "";
			string text5 = ((!string.IsNullOrWhiteSpace(text4)) ? ("," + text4) : "");
			string text6 = BuildInfo.Current?.Scm?.ChangeId ?? "0";
			string text7 = PingEstimater.GetCachedClosestRegion().Code;
			if (!string.IsNullOrEmpty(ConVar.Server.ping_region_code_override))
			{
				text7 = ConVar.Server.ping_region_code_override;
			}
			SteamServer.GameTags = ServerTagCompressor.CompressTags($"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},$r{text7},v{2564}{text3}{text5},{text},{text2},cs{text6}");
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = ConVar.Server.description.SplitToChunks(100).ToArray();
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			SteamServer.SetKey("status", value);
			string value2 = World.Seed.ToString();
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			if (activeGameMode != null && !activeGameMode.ingameMap)
			{
				value2 = "0";
			}
			SteamServer.SetKey("world.seed", value2);
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("logoimage", ConVar.Server.logoimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			if (!string.IsNullOrWhiteSpace(ConVar.Server.favoritesEndpoint))
			{
				SteamServer.SetKey("favendpoint", ConVar.Server.favoritesEndpoint);
			}
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("uptime", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("ram_sys", (Performance.report.memoryUsageSystem / 1000000).ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
		Interface.CallHook("OnServerInformationUpdated");
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when the quarry gathers resources.
/// </summary>
/// <param name="quarry">The mining quarry that is gathering resources.</param>
/// <param name="item">The item that has been gathered by the quarry.</param>
/// <returns>No return behavior.</returns>
void OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts($"Quarry {quarry.net.ID} has gathered {item.amount} of {item.info.displayName.english}.");

    if (item.info.shortname == "stone")
    {
        Puts("Stone has been gathered, check inventory for capacity.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
		float num = Mathf.Min(workToAdd, pendingWork);
		pendingWork -= num;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			float workNeeded = resource.workNeeded;
			int num2 = Mathf.FloorToInt(resource.workDone / workNeeded);
			resource.workDone += num;
			int num3 = Mathf.FloorToInt(resource.workDone / workNeeded);
			if (resource.workDone > workNeeded)
			{
				resource.workDone %= workNeeded;
			}
			if (num2 != num3)
			{
				int iAmount = num3 - num2;
				Item item = ItemManager.Create(resource.type, iAmount, 0uL);
				Facepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);
				if (Interface.CallHook("OnQuarryGather", this, item) != null)
				{
					item.Remove();
				}
				else if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
	}

```

## OnVehicleModuleSelect(Item,ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player selects a module for a vehicle.
/// </summary>
/// <param name="item">The item representing the vehicle module being selected.</param>
/// <param name="garage">The garage or entity that contains the vehicle.</param>
/// <param name="player">The player who is selecting the vehicle module.</param>
/// <returns>
/// Returns a non-null value to prevent the selection of the vehicle module. 
/// If `null` is returned, the selection proceeds as normal.
/// </returns>
object OnVehicleModuleSelect(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.displayName} selected module: {item.info.displayName.english} for vehicle in garage.");

    if (item.info.shortname == "vehicle.module.restricted")
    {
        Puts($"Player {player.displayName} attempted to select a restricted module.");
        return "You cannot select this module.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!ObjectEx.IsUnityNull(container))
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!ObjectEx.IsUnityNull(container2))
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## OnRackedWeaponTaken(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is taken from a weapon rack.
/// </summary>
/// <param name="item">The item that represents the weapon being taken.</param>
/// <param name="player">The player who is taking the weapon.</param>
/// <param name="weaponRack">The weapon rack from which the weapon is being taken.</param>
/// <returns>
/// Returns a non-null value to prevent the weapon from being taken, or `null` to allow the action.
/// </returns>
object OnRackedWeaponTaken(Item item, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Player {player.displayName} is attempting to take weapon: {item.info.displayName.english} from the weapon rack.");
    
    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot take weapons from the rack while in a safe zone.");
        return "You cannot take weapons from here.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", slot, player, this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		if (slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex))
		{
			if ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1)
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", slot, player, this);
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Determines if a player can afford to upgrade a building block to a specified grade.
/// </summary>
/// <param name="player">The player attempting to perform the upgrade.</param>
/// <param name="block">The building block being upgraded.</param>
/// <param name="grade">The target grade for the upgrade.</param>
/// <param name="skin">The skin ID for the building block.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can afford the upgrade.
/// </returns>
bool? CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade, ulong skin)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to upgrade a building block to grade {grade}.");

    if (grade == BuildingGrade.Enum.Twigs)
    {
        Puts($"Player {player.displayName} is not allowed to upgrade to Twigs grade.");
        return false;
    }

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can upgrade without resource checks.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade, iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player != null && player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		foreach (ItemAmount item in blockDefinition.GetGrade(iGrade, iSkin).CostToBuild(grade))
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## CanLootEntity(BasePlayer,ContainerIOEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity that is being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity; otherwise, returns `false`.
/// If the method returns a non-null value, it indicates that looting is not allowed.
/// </returns>
bool? CanLootEntity(BasePlayer player, ContainerIOEntity entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot entity: {entity.name}.");

    if (entity.IsLocked())
    {
        Puts($"Entity {entity.name} is locked and cannot be looted.");
        return false;
    }

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot loot.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (needsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if ((onlyOneUser && IsOpen()) || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, StorageContainer.LockedMessage, false);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = lootPanelName;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(_inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnEntityFromOwnerCheck(BaseEntity,BasePlayer,uint,string)

```csharp
```csharp
/// <summary>
/// Called to check if a player is the owner of a specific entity.
/// </summary>
/// <param name="entityId">The unique identifier of the entity.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <param name="entity">The entity being checked.</param>
/// <param name="player">The player attempting to access the entity.</param>
/// <returns>
/// Returns `true` if the player is the owner of the entity, `false` if not, 
/// or `null` if the default ownership check should be applied.
/// </returns>
bool? OnEntityFromOwnerCheck(uint entityId, string debugName, BaseEntity entity, BasePlayer player)
{
    Puts($"Checking ownership for Entity ID: {entityId}, Debug Name: {debugName}, Player: {player.displayName}");

    if (entity == null || player == null)
    {
        Puts("Entity or player is null, returning false.");
        return false;
    }

    if (entity.net.ID == player.net.ID)
    {
        Puts($"Player {player.displayName} is the owner of the entity.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityFromOwnerCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				return true;
			}

```

## OnCupboardAuthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is authorized to a cupboard (Building Privilege).
/// </summary>
/// <param name="cupboard">The cupboard being authorized.</param>
/// <param name="player">The player being authorized to the cupboard.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent the player from being authorized.
/// </returns>
object OnCupboardAuthorize(BuildingPrivlidge cupboard, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to authorize to cupboard ID: {cupboard.net.ID}.");

    if (player.IsBannedFromCupboard())
    {
        Puts($"Player {player.displayName} is banned from authorizing to cupboards.");
        return "You are banned from using this cupboard.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	internal void OnDeployed(BaseEntity ent, BasePlayer player)
	{
		if (player.IsValid() && !string.IsNullOrEmpty(UnlockAchievement))
		{
			player.GiveAchievement(UnlockAchievement);
		}
		if (ent is BuildingPrivlidge buildingPrivlidge && Interface.CallHook("OnCupboardAuthorize", buildingPrivlidge, player) == null)
		{
			buildingPrivlidge.AddPlayer(player, player.userID);
		}
	}

```

## OnEntityMarkHostile(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player entity is marked as hostile for a specified duration.
/// </summary>
/// <param name="player">The player entity being marked as hostile.</param>
/// <param name="duration">The duration in seconds for which the player is marked hostile.</param>
/// <returns>No return behavior.</returns>
void OnEntityMarkHostile(BasePlayer player, float duration)
{
    Puts($"Player {player.displayName} has been marked hostile for {duration} seconds.");
    
    if (duration > 120f)
    {
        Puts($"Warning: Player {player.displayName} is marked hostile for an unusually long duration.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			double currentTimestamp = TimeEx.currentTimestamp;
			double val = currentTimestamp + (double)duration;
			State.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);
			DirtyPlayerState();
			double num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);
			ClientRPC(RpcTarget.Player("SetHostileLength", this), (float)num);
		}
	}

```

## OnMagazineReload(BaseProjectile,IAmmoContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a magazine is reloaded for a projectile weapon.
/// </summary>
/// <param name="projectile">The projectile weapon being reloaded.</param>
/// <param name="ammoSource">The source of the ammunition for the reload.</param>
/// <param name="player">The player who owns the projectile weapon.</param>
/// <returns>
/// Returns `true` if the magazine was successfully reloaded; otherwise, returns `false`. 
/// If the method returns `null`, the default reload logic will be applied.
/// </returns>
bool? OnMagazineReload(BaseProjectile projectile, IAmmoContainer ammoSource, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to reload the magazine of {projectile.info.displayName.english}.");

    if (ammoSource.GetAmount() < 1)
    {
        Puts($"Player {player.displayName} cannot reload because there is no ammunition available.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount = -1)
	{
		object obj = Interface.CallHook("OnMagazineReload", this, ammoSource, GetOwnerPlayer());
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!TryReload(ammoSource, desiredAmount))
		{
			return false;
		}
		SendNetworkUpdateImmediate();
		ItemManager.DoRemoves();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer != null)
		{
			ownerPlayer.inventory.ServerUpdate(0f);
		}
		return true;
	}

```

## OnSendModelState(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the model state of a player needs to be sent to clients.
/// </summary>
/// <param name="player">The player whose model state is being sent.</param>
/// <returns>No return behavior.</returns>
void OnSendModelState(BasePlayer player)
{
    Puts($"Sending model state for player: {player.displayName} (ID: {player.UserIDString}).");
    
    if (player.IsDead())
    {
        Puts($"Player {player.displayName} is dead; model state will not be sent.");
        return;
    }

    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void SendModelState(bool force = false)
	{
		if (!force && (!wantsSendModelState || nextModelStateUpdate > UnityEngine.Time.time))
		{
			return;
		}
		wantsSendModelState = false;
		nextModelStateUpdate = UnityEngine.Time.time + 0.1f;
		if (!IsDead() && !IsSpectating())
		{
			modelState.sleeping = IsSleeping();
			modelState.mounted = isMounted;
			modelState.relaxed = IsRelaxed();
			modelState.onPhone = HasActiveTelephone && !activeTelephone.IsMobile;
			modelState.crawling = IsCrawling();
			if (!base.limitNetworking && Interface.CallHook("OnSendModelState", this) == null)
			{
				modelState.loading = IsLoadingAfterTransfer();
				ClientRPC(RpcTarget.NetworkGroup("OnModelState"), modelState);
			}
		}
	}

```

## OnFireworkDesignChange(PatternFirework,ProtoBuf.PatternFirework.Design,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player changes the design of a firework.
/// </summary>
/// <param name="firework">The firework whose design is being changed.</param>
/// <param name="design">The new design for the firework.</param>
/// <param name="player">The player making the design change.</param>
/// <returns>No return behavior.</returns>
void OnFireworkDesignChange(PatternFirework firework, ProtoBuf.PatternFirework.Design design, BasePlayer player)
{
    Puts($"Player {player.displayName} changed the firework design to {design?.ToString() ?? "default"} for firework ID: {firework.net.ID}.");
    
    if (design?.stars.Count > 0)
    {
        Puts($"New design includes {design.stars.Count} stars.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		ProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);
		if (Interface.CallHook("OnFireworkDesignChange", this, design, rpc.player) != null)
		{
			return;
		}
		if (design?.stars != null)
		{
			while (design.stars.Count > MaxStars)
			{
				int index = design.stars.Count - 1;
				design.stars[index].Dispose();
				design.stars.RemoveAt(index);
			}
			foreach (ProtoBuf.PatternFirework.Star star in design.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			design.editedBy = rpc.player.userID;
		}
		Design?.Dispose();
		Design = design;
		Interface.CallHook("OnFireworkDesignChanged", this, design, rpc.player);
		SendNetworkUpdateImmediate();
	}

```

## CanVendingAcceptItem(VendingMachine,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether a vending machine can accept a specific item for a given slot.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being offered to the vending machine.</param>
/// <param name="targetSlot">The slot in the vending machine where the item is to be placed.</param>
/// <returns>
/// Returns `true` if the item can be accepted by the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the item can be accepted.
/// </returns>
bool? CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)
{
    Puts($"Checking if vending machine can accept item: {item.info.displayName.english} (ID: {item.info.itemid}) for slot {targetSlot}.");

    if (item.info.shortname == "restricted.item")
    {
        Puts("This item is restricted and cannot be accepted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (transactionActive || industrialItemIncoming)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (base.inventory.itemList.Contains(item))
		{
			return true;
		}
		if (basePlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(basePlayer);
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container to which the item is being added.</param>
/// <param name="item">The item that is being added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) has been added to container {container.name}.");
    
    if (item.info.itemid == 12345) // Example item ID for a special item
    {
        Puts($"Special item {item.info.displayName.english} added to container!");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## OnFeedbackReported(BasePlayer,string,string,Facepunch.Models.ReportType)

```csharp
```csharp
/// <summary>
/// Called when a player reports feedback regarding an issue or suggestion.
/// </summary>
/// <param name="player">The player who reported the feedback.</param>
/// <param name="subject">The subject of the feedback report.</param>
/// <param name="message">The detailed message of the feedback report.</param>
/// <param name="reportType">The type of report being submitted.</param>
/// <returns>No return behavior.</returns>
void OnFeedbackReported(BasePlayer player, string subject, string message, Facepunch.Models.ReportType reportType)
{
    Puts($"Feedback reported by {player.displayName} (ID: {player.UserIDString}): Subject - \"{subject}\", Message - \"{message}\", Type - {reportType}.");

    if (reportType == Facepunch.Models.ReportType.Bug)
    {
        Puts("A bug report has been submitted. Investigate promptly!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnFeedbackReport(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		ReportType reportType = (ReportType)Mathf.Clamp(msg.read.Int32(), 0, 5);
		if (ConVar.Server.printReportsToConsole)
		{
			DebugEx.Log($"[FeedbackReport] {this} reported {reportType} - \"{text}\" \"{text2}\"");
			RCon.Broadcast(RCon.LogType.Report, new
			{
				PlayerId = UserIDString,
				PlayerName = displayName,
				Subject = text,
				Message = text2,
				Type = reportType
			});
		}
		if (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))
		{
			string image = msg.read.StringMultiLine(60000);
			Facepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);
			feedback.Type = reportType;
			feedback.Message = text2;
			feedback.Subject = text;
			Facepunch.Models.Feedback feedback2 = feedback;
			feedback2.AppInfo.Image = image;
			Facepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2);
			Interface.CallHook("OnFeedbackReported", this, text, text2, reportType);
		}
	}

```

## OnQueueCycle(int)

```csharp
```csharp
/// <summary>
/// Called to cycle through the queue of players waiting to join the game.
/// </summary>
/// <param name="availableSlots">The number of available slots for players to join.</param>
/// <returns>No return behavior.</returns>
void OnQueueCycle(int availableSlots)
{
    Puts($"Queue cycle initiated with {availableSlots} available slots.");
    if (availableSlots <= 0)
    {
        Puts("No available slots for players to join.");
        return;
    }
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void Cycle(int availableSlots)
	{
		if (Interface.CallHook("OnQueueCycle", availableSlots) != null)
		{
			return;
		}
		if (UnityEngine.Time.realtimeSinceStartup > nextCleanupReservedSlots)
		{
			nextCleanupReservedSlots = UnityEngine.Time.realtimeSinceStartup + 1f;
			CleanupExpiredReservedSlots();
		}
		if (queue.Count != 0)
		{
			if (availableSlots - Joining > 0)
			{
				JoinGame(queue[0]);
			}
			SendMessages();
		}
	}

```

## CanMoveItem(Item,PlayerInventory,ItemContainerId,int,int,ItemMoveModifier)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be moved from one container to another by a player.
/// </summary>
/// <param name="item">The item being moved.</param>
/// <param name="playerInventory">The inventory of the player attempting to move the item.</param>
/// <param name="containerId">The ID of the container the item is being moved to.</param>
/// <param name="slot">The slot in the target container where the item will be placed.</param>
/// <param name="amount">The amount of the item to move.</param>
/// <param name="modifier">Any modifiers affecting the item move operation.</param>
/// <returns>
/// Returns `true` if the item can be moved, `false` if it cannot, or `null` to allow default game logic to determine the outcome.
/// </returns>
bool? CanMoveItem(Item item, PlayerInventory playerInventory, ItemContainerId containerId, int slot, int amount, ItemMoveModifier modifier)
{
    Puts($"Attempting to move item {item.info.displayName.english} (ID: {item.info.itemid}) to container {containerId} at slot {slot}.");

    if (item.amount <= 0)
    {
        Puts("Cannot move item: amount is zero or less.");
        return false;
    }

    if (playerInventory.IsFull())
    {
        Puts("Cannot move item: player's inventory is full.");
        return false;
    }

    return null; // Allow default logic to handle the move
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	public void MoveItem(BaseEntity.RPCMessage msg)
	{
		if (base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		ItemContainerId itemContainerId = msg.read.ItemContainerID();
		int num = msg.read.Int8();
		int num2 = (int)msg.read.UInt32();
		ItemMoveModifier itemMoveModifier = (ItemMoveModifier)msg.read.Int32();
		Item item = FindItemByUID(id);
		if (item == null)
		{
			msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidItem, false);
			ConstructionErrors.Log(msg.player, id.ToString());
		}
		else
		{
			if (Interface.CallHook("CanMoveItem", item, this, itemContainerId, num, num2, itemMoveModifier) != null)
			{
				return;
			}
			BaseEntity entityOwner = item.GetEntityOwner();
			if (entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering)
			{
				return;
			}
			if (!CanMoveItemsFrom(entityOwner, item))
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.CannotMoveItem, true);
				return;
			}
			if (num2 <= 0)
			{
				num2 = item.amount;
			}
			num2 = Mathf.Clamp(num2, 1, item.MaxStackable());
			if (msg.player.GetActiveItem() == item)
			{
				msg.player.UpdateActiveItem(default(ItemId));
			}
			if (!itemContainerId.IsValid)
			{
				BaseEntity baseEntity = entityOwner;
				if (loot.containers.Count > 0)
				{
					if (entityOwner == base.baseEntity)
					{
						if (!itemMoveModifier.HasFlag(ItemMoveModifier.Alt))
						{
							baseEntity = loot.entitySource;
						}
					}
					else
					{
						baseEntity = base.baseEntity;
					}
				}
				if (baseEntity is IIdealSlotEntity idealSlotEntity)
				{
					itemContainerId = idealSlotEntity.GetIdealContainer(base.baseEntity, item, itemMoveModifier);
					if (itemContainerId == ItemContainerId.Invalid)
					{
						return;
					}
				}
				ItemContainer parent = item.parent;
				if (parent != null && parent.IsLocked())
				{
					msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
					return;
				}
				if (!itemContainerId.IsValid)
				{
					if (baseEntity == loot.entitySource)
					{
						foreach (ItemContainer container in loot.containers)
						{
							if (!container.PlayerItemInputBlocked() && !container.IsLocked() && item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))
							{
								break;
							}
						}
						return;
					}
					if (!GiveItem(item, itemMoveModifier))
					{
						msg.player.ShowToast(GameTip.Styles.Error, "GiveItem failed!", true);
					}
					return;
				}
			}
			ItemContainer itemContainer = FindContainer(itemContainerId);
			if (itemContainer == null)
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidContainer, false);
				ConstructionErrors.Log(msg.player, itemContainerId.ToString());
				return;
			}
			if (itemContainer.IsLocked())
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.ContainerLocked, false);
				return;
			}
			if (itemContainer.PlayerItemInputBlocked())
			{
				msg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.DoesntAcceptPlayerItems, false);
				return;
			}
			if (itemContainer.maxStackSize > 0)
			{
				num2 = Mathf.Clamp(num2, 1, itemContainer.maxStackSize);
			}
			using (TimeWarning.New("Split"))
			{
				if (item.amount > num2)
				{
					int split_Amount = num2;
					Item item2 = item.SplitItem(split_Amount);
					Item slot = itemContainer.GetSlot(num);
					if (slot != null && !item.CanStack(slot) && item.parent != null && !item2.MoveToContainer(item.parent, -1, allowStack: false, ignoreStackLimit: false, base.baseEntity, allowSwap: false))
					{
						item.amount += item2.amount;
						item2.Remove();
						ItemManager.DoRemoves();
						ServerUpdate(0f);
						return;
					}
					if (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))
					{
						item.amount += item2.amount;
						item2.Remove();
					}
					else
					{
						item.parent.onItemRemovedFromStack?.Invoke(item, num2);
					}
					ItemManager.DoRemoves();
					ServerUpdate(0f);
					return;
				}
			}
			if (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))
			{
				ItemManager.DoRemoves();
				ServerUpdate(0f);
			}
		}
	}

```

## OnBuildingMerge(ServerBuildingManager,BuildingManager.Building,BuildingManager.Building)

```csharp
```csharp
/// <summary>
/// Called when two buildings are merged into one.
/// </summary>
/// <param name="manager">The server building manager handling the merge.</param>
/// <param name="building1">The first building that is being merged.</param>
/// <param name="building2">The second building that is being merged.</param>
/// <returns>No return behavior.</returns>
void OnBuildingMerge(ServerBuildingManager manager, BuildingManager.Building building1, BuildingManager.Building building2)
{
    Puts($"Merging buildings: {building1.ID} and {building2.ID}.");
    
    if (building1.IsProtected() || building2.IsProtected())
    {
        Puts("One of the buildings is protected and cannot be merged.");
        return;
    }
}
```
```

### Source Code from the Library

```csharp

	private void Merge(Building building1, Building building2)
	{
		Interface.CallHook("OnBuildingMerge", this, building1, building2);
		while (building2.HasDecayEntities())
		{
			building2.decayEntities[0].AttachToBuilding(building1.ID);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building1.isNavMeshCarvingDirty = true;
			building2.isNavMeshCarvingDirty = true;
			int ticks = 3;
			UpdateNavMeshCarver(building1, ref ticks, 0);
			UpdateNavMeshCarver(building1, ref ticks, 0);
		}
	}

```

## CanLock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can lock a code lock.
/// </summary>
/// <param name="player">The player attempting to lock the code lock.</param>
/// <param name="codeLock">The code lock being interacted with.</param>
/// <returns>
/// Returns `null` to allow the locking action, or any non-null value to prevent it.
/// </returns>
object CanLock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to lock the code lock.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can lock the code lock.");
        return null;
    }

    if (codeLock.IsLocked())
    {
        Puts($"Code lock is already locked. Player {player.displayName} cannot lock it again.");
        return "Code lock is already locked.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", rpc.player, this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnCrateDropped(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate is dropped in the game world.
/// </summary>
/// <param name="crate">The hackable locked crate that has been dropped.</param>
/// <returns>No return behavior.</returns>
void OnCrateDropped(HackableLockedCrate crate)
{
    Puts($"A hackable locked crate has been dropped at position: {crate.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", this);
	}

```

## OnConnectionDequeue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a connection is dequeued from the server's connection queue.
/// </summary>
/// <param name="connection">The connection that is being dequeued.</param>
/// <returns>
/// Returns a non-null value to prevent the connection from being removed from the queue. 
/// If `null` is returned, the connection will be removed as normal.
/// </returns>
object OnConnectionDequeue(Network.Connection connection)
{
    Puts($"Connection from {connection.address} is being dequeued.");
    
    // Example condition to block a specific IP address
    if (connection.address == "192.168.1.100")
    {
        Puts($"Connection from {connection.address} is blocked from dequeuing.");
        return "Blocked: Unauthorized IP address.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RemoveConnection(Connection connection)
	{
		if (Interface.CallHook("OnConnectionDequeue", connection) == null)
		{
			if (queue.Remove(connection))
			{
				nextMessageTime = 0f;
			}
			joining.Remove(connection);
		}
	}

```

## OnSendCommand(Network.Connection,string,object[])

```csharp
```csharp
/// <summary>
/// Called when a command is sent to a client.
/// </summary>
/// <param name="connection">The network connection of the client receiving the command.</param>
/// <param name="command">The command being sent to the client.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>
/// Returns `null` to allow the command to be sent, or any non-null value to prevent the command from being sent.
/// </returns>
object OnSendCommand(Network.Connection connection, string command, object[] args)
{
    Puts($"Sending command '{command}' to client with connection ID: {connection.userid}.");

    if (command == "kick")
    {
        Puts($"Command '{command}' is not allowed to be sent to the client.");
        return "You cannot send kick command.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(Connection cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnSendCommand", cn, strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			string val = ConsoleSystem.BuildCommand(strCommand, args);
			netWrite.String(val);
			netWrite.Send(new SendInfo(cn));
		}
	}

```

## OnLootNetworkUpdate(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called to update the loot network for a player.
/// </summary>
/// <param name="loot">The loot instance being updated.</param>
/// <returns>
/// Returns `null` to allow the default loot update behavior, or any non-null value to prevent the update.
/// </returns>
object OnLootNetworkUpdate(PlayerLoot loot)
{
    Puts($"Updating loot network for player: {loot.baseEntity.displayName} (ID: {loot.baseEntity.net.ID})");

    // Example condition to prevent loot update
    if (loot.containers.Count == 0)
    {
        Puts("No containers available for loot update.");
        return "No loot to update.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SendUpdate()
	{
		isInvokingSendUpdate = false;
		if (!base.baseEntity.IsValid() || Interface.CallHook("OnLootNetworkUpdate", this) != null)
		{
			return;
		}
		using PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		if ((bool)entitySource && entitySource.net != null)
		{
			playerUpdateLoot.entityID = entitySource.net.ID;
		}
		if (itemSource != null)
		{
			playerUpdateLoot.itemID = itemSource.uid;
		}
		if (containers.Count > 0)
		{
			playerUpdateLoot.containers = Pool.Get<List<ProtoBuf.ItemContainer>>();
			foreach (ItemContainer container in containers)
			{
				playerUpdateLoot.containers.Add(container.Save());
			}
		}
		base.baseEntity.ClientRPC(RpcTarget.Player("UpdateLoot", base.baseEntity), playerUpdateLoot);
	}

```

## CanUnlockTechTreeNode(BasePlayer,TechTreeData.NodeInstance,TechTreeData)

```csharp
```csharp
/// <summary>
/// Determines if a player can unlock a specific node in the tech tree.
/// </summary>
/// <param name="player">The player attempting to unlock the tech tree node.</param>
/// <param name="node">The tech tree node instance that the player wants to unlock.</param>
/// <param name="techTree">The tech tree data containing all nodes and paths.</param>
/// <returns>
/// Returns `true` if the player can unlock the node, `false` if they cannot, 
/// or `null` if the decision is deferred to the hook implementation.
/// </returns>
bool? CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to unlock node: {node.nodeName}.");

    if (node.nodeName == "advancedCrafting")
    {
        Puts($"Player {player.displayName} does not have permission to unlock advanced crafting.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerCanUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNode", player, node, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerHasPathForUnlock(player, node))
		{
			return !HasPlayerUnlocked(player, node);
		}
		return false;
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
```csharp
/// <summary>
/// Determines whether the specified combat entity can be targeted by the auto turret.
/// </summary>
/// <param name="target">The combat entity that is being checked for targeting.</param>
/// <param name="turret">The auto turret attempting to target the entity.</param>
/// <returns>
/// Returns `true` if the entity can be targeted; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the entity can be targeted.
/// </returns>
bool? CanBeTargeted(BaseCombatEntity target, AutoTurret turret)
{
    Puts($"Checking if {target.displayName} can be targeted by turret {turret.net.ID}.");

    if (target.IsDead())
    {
        Puts($"Target {target.displayName} is dead and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.Get<List<RaycastHit>>();
		Vector3 position = eyePos.transform.position;
		if (GamePhysics.CheckSphere(position, 0.1f, 2097152))
		{
			return false;
		}
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);
		for (int i = 0; (float)i < (CheckPeekers() ? 3f : 1f); i++)
		{
			Vector3 normalized = (vector + vector2 * visibilityOffsets[i] - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);
			for (int j = 0; j < obj3.Count; j++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);
				if ((!(entity != null) || !entity.isClient) && (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) && (!(entity != null) || !entity.EqualNetID(this)))
				{
					if (entity != null && (entity == obj || entity.EqualNetID(obj)))
					{
						Facepunch.Pool.FreeUnmanaged(ref obj3);
						peekIndex = i;
						return true;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj3);
		return false;
	}

```

## OnCollectiblePickup(CollectibleEntity,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a collectible entity is picked up by a player.
/// </summary>
/// <param name="collectible">The collectible entity being picked up.</param>
/// <param name="player">The player who is picking up the collectible.</param>
/// <param name="eat">Indicates whether the item should be consumed immediately (for food items).</param>
/// <returns>No return behavior.</returns>
void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player, bool eat)
{
    Puts($"Player {player.displayName} is attempting to pick up {collectible.name} (Eat: {eat}).");

    if (collectible.itemList == null)
    {
        Puts("No items to pick up.");
        return;
    }

    if (eat)
    {
        Puts($"Player {player.displayName} will consume the item.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoPickup(BasePlayer reciever, bool eat = false)
	{
		if (itemList == null || Interface.CallHook("OnCollectiblePickup", this, reciever, eat) != null)
		{
			return;
		}
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			if (reciever != null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)
			{
				continue;
			}
			Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
			if (item == null)
			{
				continue;
			}
			if (eat && item.info.category == ItemCategory.Food && reciever != null)
			{
				ItemModConsume component = item.info.GetComponent<ItemModConsume>();
				if (component != null)
				{
					component.DoAction(item, reciever);
					continue;
				}
			}
			if ((bool)reciever)
			{
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);
				Interface.CallHook("OnCollectiblePickedup", this, reciever, item);
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
		}
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(reciever, base.transform.position);
		}
		Kill();
	}

```

## OnBoomboxStationUpdate(BoomBox,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the Boombox station's IP is updated.
/// </summary>
/// <param name="boombox">The Boombox entity that is being updated.</param>
/// <param name="ip">The new IP address for the Boombox station.</param>
/// <param name="player">The player who initiated the update.</param>
/// <returns>No return behavior.</returns>
void OnBoomboxStationUpdate(BoomBox boombox, string ip, BasePlayer player)
{
    Puts($"Boombox station updated by {player.displayName} to IP: {ip}.");
    
    if (ip == "192.168.0.1")
    {
        Puts("Attempt to set an invalid IP address was blocked.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnBoomboxStationUpdate", this, text, msg.player) == null && IsStationValid(text))
		{
			if (msg.player != null)
			{
				ulong assignedRadioBy = msg.player.userID.Get();
				AssignedRadioBy = assignedRadioBy;
			}
			CurrentRadioIp = text;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnRadioIPChanged"), CurrentRadioIp);
			Interface.CallHook("OnBoomboxStationUpdated", this, text, msg.player);
			if (IsOn())
			{
				ServerTogglePlay(play: false);
			}
		}
	}

```

## OnDispenserBonusReceived(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player receives a bonus item from a resource dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser providing the bonus.</param>
/// <param name="player">The player receiving the bonus item.</param>
/// <param name="item">The item that has been granted as a bonus.</param>
/// <returns>No return behavior.</returns>
void OnDispenserBonusReceived(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} received bonus item: {item.info.displayName.english} from dispenser: {dispenser.gameObject.name}.");
    
    if (item.info.shortname == "wood")
    {
        Puts($"Player {player.displayName} received a wood bonus!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", this, player, item);
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base player is attacked.
/// </summary>
/// <param name="player">The player who is being attacked.</param>
/// <param name="info">Information about the attack, including damage and initiator.</param>
/// <returns>
/// Returns a non-null value to prevent the default attack behavior. 
/// If `null` is returned, the default attack logic will proceed.
/// </returns>
object IOnBasePlayerAttacked(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.displayName} is under attack! Damage: {info.damageTypes.Total()} from {info.Initiator?.displayName ?? "unknown"}.");

    if (info.damageTypes.Total() > 50)
    {
        Puts($"Warning: High damage attack detected on {player.displayName}!");
    }

    return null; // Allow default behavior to continue
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float oldHealth = base.health;
		if (InSafeZone() && !IsHostile() && info.Initiator != null && info.Initiator != this)
		{
			info.damageTypes.ScaleAll(0f);
		}
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.Get<List<Item>>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.Free(ref obj, freeElements: false);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortalTo(info))
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			if (isMounted)
			{
				GetMounted().MounteeTookDamage(this, info);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				ClientRPC(RpcTarget.Player("TakeDamageHit", this));
			}
			string text = StringPool.Get(info.HitBone);
			bool flag = Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) > 0.4f;
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer && !info.damageTypes.IsMeleeType())
			{
				initiatorPlayer.LifeStoryShotHit(info.Weapon);
			}
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				if (!initiatorPlayer || !initiatorPlayer.limitNetworking)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new Vector3(0f, 2f, 0f), Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);
				}
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1, (Stats)5);
					if (initiatorPlayer.IsBeingSpectated)
					{
						foreach (BaseEntity child in initiatorPlayer.children)
						{
							if (child is BasePlayer basePlayer)
							{
								basePlayer.ClientRPC(RpcTarget.Player("SpectatedPlayerHeadshot", basePlayer));
							}
						}
					}
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.LogAttack(info, "wounded", oldHealth);
			}
			else if (IsDead())
			{
				stats.combat.LogAttack(info, "killed", oldHealth);
			}
			else
			{
				stats.combat.LogAttack(info, "", oldHealth);
			}
		}
		if (ConVar.Global.cinematicGingerbreadCorpses)
		{
			info.HitMaterial = ConVar.Global.GingerbreadMaterialID();
		}
	}

```

## OnMlrsFire(MLRS,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the MLRS (Multiple Launch Rocket System) is fired.
/// </summary>
/// <param name="mlrs">The MLRS instance that is being fired.</param>
/// <param name="owner">The player who owns and is firing the MLRS.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFire(MLRS mlrs, BasePlayer owner)
{
    Puts($"MLRS fired by player {owner.displayName} (ID: {owner.UserIDString}).");
    
    // Additional logic can be added here, such as logging or triggering events.
}
```
```

### Source Code from the Library

```csharp

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !(_mounted == null) && Interface.CallHook("OnMlrsFire", this, owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			InvokeRepeating(FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", this, owner);
		}
	}

```

## OnFlameThrowerBurn(FlameThrower,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a flame thrower burns an entity.
/// </summary>
/// <param name="flameThrower">The flame thrower that caused the burn.</param>
/// <param name="burnedEntity">The entity that was burned by the flame thrower.</param>
/// <returns>No return behavior.</returns>
void OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity burnedEntity)
{
    Puts($"Flame thrower {flameThrower.net.ID} burned entity {burnedEntity.net.ID} at position {burnedEntity.transform.position}.");
    
    if (burnedEntity is BasePlayer player)
    {
        Puts($"Player {player.displayName} was burned by the flame thrower!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void FlameTick()
	{
		float num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;
		lastFlameTick = UnityEngine.Time.realtimeSinceStartup;
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		ReduceAmmo(num);
		SendNetworkUpdate();
		Ray ray = ownerPlayer.eyes.BodyRay();
		Vector3 origin = ray.origin;
		RaycastHit hitInfo;
		bool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);
		if (!num2)
		{
			hitInfo.point = origin + ray.direction * flameRange;
		}
		float num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);
		float amount = damagePerSec[0].amount;
		damagePerSec[0].amount = amount * num * num3;
		int num4 = 2146305;
		int layers = 133376;
		if (!ownerPlayer.IsNpc)
		{
			num4 |= 0x800;
		}
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, num4, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true);
		damagePerSec[0].amount = damagePerSec[0].amount * playerDamageMultiplier;
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, layers, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true);
		damagePerSec[0].amount = amount;
		if (num2 && UnityEngine.Time.realtimeSinceStartup >= nextFlameTime && hitInfo.distance > 1.1f)
		{
			nextFlameTime = UnityEngine.Time.realtimeSinceStartup + (ownerPlayer.IsNpc ? 0.25f : 0.45f);
			Vector3 point = hitInfo.point;
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, point - ray.direction * 0.25f);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnFlameThrowerBurn", this, baseEntity);
				baseEntity.creatorEntity = ownerPlayer;
				FireBall fireBall = baseEntity as FireBall;
				if (fireBall != null && ownerPlayer.IsNpc)
				{
					fireBall.ignoreNPC = true;
				}
				baseEntity.Spawn();
			}
		}
		if (ammo == 0)
		{
			SetFlameState(wantsOn: false);
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null && !base.UsingInfiniteAmmoCheat && !ownerPlayer.IsNpc)
		{
			ownerItem.LoseCondition(num);
		}
	}

```

## OnPlayerPingsSend(BasePlayer,ProtoBuf.MapNoteList)

```csharp
```csharp
/// <summary>
/// Called when a player's pings are sent to the client.
/// </summary>
/// <param name="player">The player whose pings are being sent.</param>
/// <param name="mapNoteList">The list of map notes containing the pings.</param>
/// <returns>No return behavior.</returns>
void OnPlayerPingsSend(BasePlayer player, ProtoBuf.MapNoteList mapNoteList)
{
    Puts($"Sending {mapNoteList.notes.Count} pings to player {player.displayName} (ID: {player.UserIDString}).");
}
```
```

### Source Code from the Library

```csharp

	public void SendPingsToClient()
	{
		using MapNoteList mapNoteList = Facepunch.Pool.Get<MapNoteList>();
		mapNoteList.notes = Facepunch.Pool.Get<List<MapNote>>();
		mapNoteList.notes.AddRange(State.pings);
		Interface.CallHook("OnPlayerPingsSend", this, mapNoteList);
		ClientRPC(RpcTarget.Player("Client_ReceivePings", this), mapNoteList);
		mapNoteList.notes.Clear();
	}

```

## OnTimedExplosiveExplode(TimedExplosive,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when a timed explosive detonates.
/// </summary>
/// <param name="explosive">The timed explosive that has exploded.</param>
/// <param name="explosionPosition">The position where the explosion occurred.</param>
/// <returns>No return behavior.</returns>
void OnTimedExplosiveExplode(TimedExplosive explosive, Vector3 explosionPosition)
{
    Puts($"Timed explosive {explosive.net.ID} exploded at position {explosionPosition}.");

    // Additional logic can be added here, such as logging or triggering other effects.
    if (explosive.damageTypes.Count > 0)
    {
        Puts("Damage types are present, processing damage.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Explode(Vector3 explosionFxPos)
	{
		Facepunch.Rust.Analytics.Azure.OnExplosion(this);
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(explosionFxPos - new Vector3(0f, 0.25f, 0f), waves: true, volumes: true);
		if (underwaterExplosionEffect.isValid && waterInfo.isValid && waterInfo.currentDepth >= underwaterExplosionDepth)
		{
			Effect.server.Run(underwaterExplosionEffect.resourcePath, explosionFxPos, GetExplosionNormal(), null, broadcast: true);
		}
		else if (explosionEffect.isValid)
		{
			Vector3 posWorld = explosionFxPos;
			if (explosionOffsetMode == ExplosionEffectOffsetMode.Local)
			{
				Vector3 vector = base.transform.TransformPoint(explosionEffectOffset) - base.transform.position;
				posWorld += vector;
			}
			if (explosionOffsetMode == ExplosionEffectOffsetMode.World)
			{
				posWorld += explosionEffectOffset;
			}
			Effect.server.Run(explosionEffect.resourcePath, posWorld, GetExplosionNormal(), null, broadcast: true);
		}
		if (watersurfaceExplosionEffect.isValid && waterInfo.isValid && waterInfo.overallDepth >= watersurfaceExplosionDepth.x && waterInfo.currentDepth <= watersurfaceExplosionDepth.y)
		{
			Effect.server.Run(watersurfaceExplosionEffect.resourcePath, explosionFxPos.WithY(waterInfo.surfaceLevel), GetExplosionNormal(), null, broadcast: true);
		}
		if (damageTypes.Count > 0)
		{
			if (Interface.CallHook("OnTimedExplosiveExplode", this, explosionFxPos) != null)
			{
				return;
			}
			Vector3 vector2 = ExplosionCenter();
			if (onlyDamageParent)
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), vector2, minExplosionRadius, explosionRadius, damageTypes, 166144, useLineOfSight: true, IgnoreAI);
				BaseEntity baseEntity = GetParentEntity();
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				while (baseCombatEntity == null && baseEntity != null && baseEntity.HasParent())
				{
					baseEntity = baseEntity.GetParentEntity();
					baseCombatEntity = baseEntity as BaseCombatEntity;
				}
				if (baseEntity == null || !GameObjectEx.IsOnLayer(baseEntity.gameObject, Layer.Construction))
				{
					List<BuildingBlock> obj = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(vector2, explosionRadius, obj, 2097152, QueryTriggerInteraction.Ignore);
					BuildingBlock buildingBlock = null;
					float num = float.PositiveInfinity;
					foreach (BuildingBlock item in obj)
					{
						if (!item.isClient && !item.IsDestroyed && !(item.healthFraction <= 0f))
						{
							float num2 = Vector3.Distance(item.ClosestPoint(vector2), vector2);
							if (num2 < num && item.IsVisible(vector2, explosionRadius))
							{
								buildingBlock = item;
								num = num2;
							}
						}
					}
					if ((bool)buildingBlock)
					{
						HitInfo hitInfo = new HitInfo();
						hitInfo.Initiator = creatorEntity;
						hitInfo.WeaponPrefab = LookupPrefab();
						hitInfo.damageTypes.Add(damageTypes);
						hitInfo.PointStart = vector2;
						hitInfo.PointEnd = buildingBlock.transform.position;
						float amount = 1f - Mathf.Clamp01((num - minExplosionRadius) / (explosionRadius - minExplosionRadius));
						hitInfo.damageTypes.ScaleAll(amount);
						buildingBlock.Hurt(hitInfo);
					}
					Pool.FreeUnmanaged(ref obj);
				}
				if ((bool)baseCombatEntity)
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.Initiator = creatorEntity;
					hitInfo2.WeaponPrefab = LookupPrefab();
					hitInfo2.damageTypes.Add(damageTypes);
					baseCombatEntity.Hurt(hitInfo2);
				}
				else if (baseEntity != null)
				{
					HitInfo hitInfo3 = new HitInfo();
					hitInfo3.Initiator = creatorEntity;
					hitInfo3.WeaponPrefab = LookupPrefab();
					hitInfo3.damageTypes.Add(damageTypes);
					hitInfo3.PointStart = vector2;
					hitInfo3.PointEnd = baseEntity.transform.position;
					baseEntity.OnAttacked(hitInfo3);
				}
			}
			else
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), vector2, minExplosionRadius, explosionRadius, damageTypes, 1210222849, useLineOfSight: true, IgnoreAI);
			}
			SeismicSensor.Notify(vector2, vibrationLevel);
			BlindAnyAI();
		}
		if (!base.IsDestroyed && !HasFlag(Flags.Broken))
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity, such as a corpse.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="corpse">The lootable corpse being targeted.</param>
/// <returns>
/// Returns `true` if the player is allowed to loot the entity; otherwise, returns `false`.
/// If the method returns a non-null value, it overrides the default looting behavior.
/// </returns>
bool? CanLootEntity(BasePlayer player, LootableCorpse corpse)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot a corpse.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot loot while dead.");
        return false;
    }

    if (corpse.IsLooted())
    {
        Puts($"The corpse has already been looted by another player.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!player || !player.CanInteract() || !CanLoot() || containers == null || Interface.CallHook("CanLootEntity", player, this) != null || !player.inventory.loot.StartLootingEntity(this))
		{
			return;
		}
		SetFlag(Flags.Open, b: true);
		for (int i = 0; i < containers.Length; i++)
		{
			ItemContainer itemContainer = containers[i];
			if (CanLootContainer(itemContainer, i))
			{
				player.inventory.loot.AddContainer(itemContainer);
			}
		}
		player.inventory.loot.SendImmediate();
		player.RadioactiveLootCheck(player.inventory.loot.containers);
		ClientRPC(RpcTarget.Player("RPC_ClientLootCorpse", player));
		SendNetworkUpdate();
	}

```

## OnTeamUpdate(ulong,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's team is updated.
/// </summary>
/// <param name="oldTeam">The player's previous team ID.</param>
/// <param name="newTeam">The player's new team ID.</param>
/// <param name="player">The player whose team is being updated.</param>
/// <returns>No return behavior.</returns>
void OnTeamUpdate(ulong oldTeam, ulong newTeam, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) updated team from {oldTeam} to {newTeam}.");
    
    if (newTeam == 0)
    {
        Puts($"Player {player.displayName} has left the team.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateTeam(ulong newTeam)
	{
		if (Interface.CallHook("OnTeamUpdate", currentTeam, newTeam, this) == null)
		{
			currentTeam = newTeam;
			SendNetworkUpdate();
			if (RelationshipManager.ServerInstance.FindTeam(newTeam) == null)
			{
				ClearTeam();
			}
			else
			{
				TeamUpdate();
			}
		}
	}

```

## IOnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player successfully connects to the server.
/// </summary>
/// <param name="player">The player who has connected.</param>
/// <returns>No return behavior.</returns>
void IOnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has connected to the server.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has connected. Checking anti-hack settings...");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PlayerInit(Network.Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			bots.Remove(this);
			userID = c.userid;
			UserIDString = userID.Get().ToString();
			displayName = c.username;
			c.player = this;
			secondsConnected = 0;
			currentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;
			SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(userID, displayName);
			tickInterpolator.Reset(base.transform.position);
			tickHistory.Reset(base.transform.position);
			eyeHistory.Clear();
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			InvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			GlobalNetworkHandler.server.StartSendingSnapshot(this);
			ClientRPC(RpcTarget.Player("StartLoading", this));
			if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);
			}
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			Interface.CallHook("IOnPlayerConnected", this);
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
			}
			inventory.crafting.SendToOwner();
			if (TerrainMeta.Path != null && TerrainMeta.Path.OceanPatrolFar != null)
			{
				SendCargoPatrolPath();
			}
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable amount for an item.
/// </summary>
/// <param name="item">The item for which the maximum stackable amount is being queried.</param>
/// <returns>
/// Returns the maximum stackable amount for the item. If a non-null value is returned from the hook, that value will be used instead.
/// </returns>
int OnMaxStackable(Item item)
{
    Puts($"Calculating max stackable for item: {item.info.displayName.english} (ID: {item.info.itemid})");
    
    // Example condition to limit stacking
    if (item.info.itemid == 12345) // Replace with actual item ID
    {
        Puts("This item has a custom max stackable limit.");
        return 10; // Custom limit
    }

    return item.info.stackable; // Default behavior
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## OnFireworkDesignChanged(PatternFirework,ProtoBuf.PatternFirework.Design,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the design of a firework is changed by a player.
/// </summary>
/// <param name="firework">The firework whose design is being changed.</param>
/// <param name="design">The new design for the firework.</param>
/// <param name="player">The player who is changing the firework design.</param>
/// <returns>No return behavior.</returns>
void OnFireworkDesignChanged(PatternFirework firework, ProtoBuf.PatternFirework.Design design, BasePlayer player)
{
    Puts($"Firework design changed by {player.displayName}. New design: {design?.ToString() ?? "None"}");
    
    if (design != null && design.stars.Count > 0)
    {
        Puts($"New design has {design.stars.Count} stars.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		ProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);
		if (Interface.CallHook("OnFireworkDesignChange", this, design, rpc.player) != null)
		{
			return;
		}
		if (design?.stars != null)
		{
			while (design.stars.Count > MaxStars)
			{
				int index = design.stars.Count - 1;
				design.stars[index].Dispose();
				design.stars.RemoveAt(index);
			}
			foreach (ProtoBuf.PatternFirework.Star star in design.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			design.editedBy = rpc.player.userID;
		}
		Design?.Dispose();
		Design = design;
		Interface.CallHook("OnFireworkDesignChanged", this, design, rpc.player);
		SendNetworkUpdateImmediate();
	}

```

## OnVendingShopOpen(InvisibleVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to open a vending shop.
/// </summary>
/// <param name="vendingMachine">The invisible vending machine being accessed.</param>
/// <param name="player">The player attempting to open the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpen(InvisibleVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.displayName} is opening the vending shop at {vendingMachine.transform.position}.");
    
    if (vendingMachine.IsOutOfStock())
    {
        Puts($"Vending shop is out of stock for player {player.displayName}.");
        return;
    }

    // Additional logic for opening the vending shop can be added here.
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", vendingMachine, player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!(conversingPlayer == player) && !(conversingPlayer == null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			List<Item> list = player.inventory.FindItemsByItemID(itemDefinition.itemid);
			foreach (Item item in list)
			{
				num -= item.amount;
			}
			if (num > 0)
			{
				int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
				ForceSpeechNode(player, speechNodeIndex2);
				break;
			}
			Facepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
			num = nPCConversationResultAction.scrapCost;
			foreach (Item item2 in list)
			{
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			lastActionPlayer = player;
			BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
			lastActionPlayer = null;
			break;
		}
	}

```

## OnDemoRecordingStarted(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording has started for a player.
/// </summary>
/// <param name="filePath">The file path where the demo is being recorded.</param>
/// <param name="player">The player who started the demo recording.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStarted(string filePath, BasePlayer player)
{
    Puts($"Demo recording started for player {player.displayName} at {filePath}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has started a demo recording.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a healing item is used on a player.
/// </summary>
/// <param name="healingItem">The medical tool being used.</param>
/// <param name="targetPlayer">The player receiving the healing effects.</param>
/// <returns>
/// Returns a non-null value to prevent the healing effects from being applied. 
/// If `null` is returned, the healing effects will be applied as normal.
/// </returns>
object OnHealingItemUse(MedicalTool healingItem, BasePlayer targetPlayer)
{
    Puts($"Healing item {healingItem.name} used on player {targetPlayer.displayName} (ID: {targetPlayer.UserIDString}).");

    if (targetPlayer.health < 20)
    {
        Puts($"Player {targetPlayer.displayName} is too injured to receive healing.");
        return "Player is too injured to heal.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Facepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if (player != ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
					player.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}

```

## OnSleepingBagDestroy(SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The sleeping bag that is being destroyed.</param>
/// <param name="userId">The ID of the user who owns the sleeping bag.</param>
/// <returns>
/// Returns `null` to allow the destruction of the sleeping bag, or any non-null value to prevent it.
/// </returns>
object OnSleepingBagDestroy(SleepingBag sleepingBag, ulong userId)
{
    Puts($"Sleeping bag owned by user {userId} is being destroyed.");
    
    if (sleepingBag.IsInUse)
    {
        Puts($"Sleeping bag owned by user {userId} cannot be destroyed while in use.");
        return "Cannot destroy sleeping bag while in use.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) => x.net.ID == sleepingBag);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, userID) != null)
		{
			return false;
		}
		RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
		sleepingBag2.deployerUserID = 0uL;
		sleepingBag2.SendNetworkUpdate();
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if (basePlayer != null)
		{
			basePlayer.SendRespawnOptions();
			Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, userID);
			Facepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
		}
		return true;
	}

```

## OnBoatPathGenerate()

```csharp
```csharp
/// <summary>
/// Called to generate a patrol path for boats in the ocean.
/// </summary>
/// <returns>
/// Returns a list of <c>Vector3</c> points representing the generated patrol path. 
/// If the hook returns a non-null value, that value will be used instead of the generated path.
/// </returns>
List<Vector3> OnBoatPathGenerate()
{
    Puts("Generating ocean patrol path for boats.");
    object obj = Interface.CallHook("OnBoatPathGenerate");
    if (obj is List<Vector3> customPath)
    {
        Puts("Using custom boat path provided by hook.");
        return customPath;
    }
    Puts("No custom path provided, generating default path.");
    return GenerateOceanPatrolPath();
}
```
```

### Source Code from the Library

```csharp

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float y = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num5 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num5 * (MathF.PI / 180f)) * num4, y, Mathf.Cos(num5 * (MathF.PI / 180f)) * num4));
		}
		float num6 = 4f;
		float num7 = 200f;
		bool flag = true;
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 vector = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 b = list[index2];
				Vector3 b2 = list[index];
				Vector3 origin = vector;
				Vector3 normalized = (Vector3.zero - vector).normalized;
				Vector3 vector2 = vector + normalized * num6;
				if (Vector3.Distance(vector2, b) > num7 || Vector3.Distance(vector2, b2) > num7)
				{
					continue;
				}
				bool flag2 = true;
				int num8 = 16;
				for (int l = 0; l < num8; l++)
				{
					float num9 = (float)l / (float)num8 * 360f;
					Vector3 normalized2 = new Vector3(Mathf.Sin(num9 * (MathF.PI / 180f)), y, Mathf.Cos(num9 * (MathF.PI / 180f))).normalized;
					Vector3 vector3 = vector2 + normalized2 * 1f;
					Vector3 direction = normalized;
					if (vector3 != Vector3.zero)
					{
						direction = (vector3 - vector2).normalized;
					}
					if (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1084293377))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = vector2;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning("Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log("Generated ocean patrol path with node count: " + list.Count);
		return list;
	}

```

## CanUseWires(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use wires in the game.
/// </summary>
/// <param name="player">The player attempting to use wires.</param>
/// <returns>
/// Returns `true` if the player can use wires; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will be used to determine if the player can use wires.
/// </returns>
bool? CanUseWires(BasePlayer player)
{
    Puts($"Checking wire usage for player: {player.displayName} (ID: {player.UserIDString})");

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can use wires without restrictions.");
        return true;
    }

    if (!player.CanBuild())
    {
        Puts($"Player {player.displayName} cannot build and thus cannot use wires.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool CanPlayerUseWires(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseWires", player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player != null && player.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		List<Collider> obj2 = Facepunch.Pool.Get<List<Collider>>();
		GamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);
		bool result = true;
		foreach (Collider item in obj2)
		{
			if (!item.gameObject.CompareTag("IgnoreWireCheck"))
			{
				result = false;
				break;
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj2);
		return result;
	}

```

## OnRackedWeaponUnload(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is unloaded from a weapon rack.
/// </summary>
/// <param name="item">The item representing the weapon being unloaded.</param>
/// <param name="player">The player who is unloading the weapon.</param>
/// <param name="weaponRack">The weapon rack from which the weapon is being unloaded.</param>
/// <returns>
/// Returns a non-null value to prevent the weapon from being unloaded. 
/// If `null` is returned, the weapon unload proceeds as normal.
/// </returns>
object OnRackedWeaponUnload(Item item, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Player {player.displayName} is attempting to unload weapon: {item.info.displayName.english} from the weapon rack.");
    
    if (item.info.shortname == "rifle.semiauto")
    {
        Puts($"Player {player.displayName} is not allowed to unload a semi-auto rifle.");
        return "You cannot unload this weapon.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", slot, player, this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity == null))
		{
			BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
			if (!(component == null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", slot, player, this);
			}
		}
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger area.
/// </summary>
/// <param name="entity">The entity that has entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(BaseEntity entity)
{
    Puts($"Entity {entity?.name} (ID: {entity?.net.ID}) has entered the trigger.");

    if (entity is Player player)
    {
        Puts($"Welcome, player {player.displayName}!");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			if (Interface.CallHook("OnEntityEnter", this, ent) == null)
			{
				entityContents.Add(ent);
				OnEntityEnterTrigger?.Invoke(ent);
			}
		}
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is authorized to use an automated turret.
/// </summary>
/// <param name="turret">The automated turret being authorized.</param>
/// <param name="player">The player being authorized to use the turret.</param>
/// <returns>No return behavior.</returns>
void OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has been authorized to use turret {turret.net.ID}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has been authorized, granting full access.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void AddSelfAuthorize(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!IsOnline() && player2.CanBuild() && !AtMaxAuthCapacity() && Interface.CallHook("OnTurretAuthorize", this, player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)player2.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = player2.userID;
			playerNameID.username = player2.displayName;
			authorizedPlayers.Add(playerNameID);
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, player2, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", player2.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity that has been killed.</param>
/// <returns>
/// Returns `null` to allow the default kill behavior, or any non-null value to prevent the entity from being killed.
/// </returns>
object OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity.net.ID} ({entity.GetType().Name}) has been killed.");
    
    if (entity is SomeSpecificEntity)
    {
        Puts("Preventing the kill of a specific entity type.");
        return true; // Prevent the entity from being killed
    }
    
    return null; // Allow the default kill behavior
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
		}
		else if (Interface.CallHook("OnEntityKill", this) == null)
		{
			EntityProfiler.killed++;
			if (EntityProfiler.mode >= 2)
			{
				EntityProfiler.OnKilled(this);
			}
			OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

```

## OnClothingItemChanged(PlayerInventory,Item,bool)

```csharp
```csharp
/// <summary>
/// Called when a player's clothing item is changed (added or removed).
/// </summary>
/// <param name="inventory">The player's inventory where the change occurred.</param>
/// <param name="item">The clothing item that was added or removed.</param>
/// <param name="bAdded">Indicates whether the item was added (<c>true</c>) or removed (<c>false</c>).</param>
/// <returns>No return behavior.</returns>
void OnClothingItemChanged(PlayerInventory inventory, Item item, bool bAdded)
{
    Puts($"Clothing item changed: {item.info.displayName.english} was {(bAdded ? "added" : "removed")}.");
    
    if (bAdded)
    {
        Puts($"Player {inventory.owner.displayName} has equipped {item.info.displayName.english}.");
    }
    else
    {
        Puts($"Player {inventory.owner.displayName} has unequipped {item.info.displayName.english}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void OnClothingChanged(Item item, bool bAdded)
	{
		base.baseEntity.SV_ClothingChanged();
		if (ItemManager.EnablePooling)
		{
			if (!IsInvoking(DeferredServerUpdateAction))
			{
				Invoke(DeferredServerUpdateAction, 0f);
			}
		}
		else
		{
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
		if (item.position == 7)
		{
			item.RecalulateParentEntity(children: true);
			Invoke(UpdatedVisibleHolsteredItems, 0.1f);
			item?.contents?.onItemAddedRemoved?.Invoke(item, bAdded);
		}
		base.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.CLOTHINGCHANGED, 0, 0f);
		Interface.CallHook("OnClothingItemChanged", this, item, bAdded);
	}

```

## CanCatchFish(BasePlayer,BaseFishingRod,Item)

```csharp
```csharp
/// <summary>
/// Determines if a player can catch a fish using a fishing rod.
/// </summary>
/// <param name="player">The player attempting to catch the fish.</param>
/// <param name="fishingRod">The fishing rod being used.</param>
/// <param name="fishItem">The item representing the fish that is being caught.</param>
/// <returns>
/// Returns `true` if the player can catch the fish, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the fish can be caught.
/// </returns>
bool? CanCatchFish(BasePlayer player, BaseFishingRod fishingRod, Item fishItem)
{
    Puts($"Player {player.displayName} is attempting to catch a fish with {fishingRod.info.displayName.english}.");

    if (player.IsWounded())
    {
        Puts($"Player {player.displayName} cannot catch fish while wounded.");
        return false;
    }

    if (fishingRod.IsBroken())
    {
        Puts($"Player {player.displayName}'s fishing rod is broken.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## OnPhoneNameUpdate(PhoneController,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's phone name is updated.
/// </summary>
/// <param name="phone">The phone controller that is being updated.</param>
/// <param name="newName">The new name for the phone.</param>
/// <param name="player">The player who is updating the phone name.</param>
/// <returns>
/// Returns `null` to allow the name update, or any non-null value to prevent the update.
/// </returns>
object OnPhoneNameUpdate(PhoneController phone, string newName, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to update phone name to: {newName}");

    if (newName.Contains("badword"))
    {
        Puts($"Player {player.displayName} tried to use a prohibited name.");
        return "Name contains prohibited content.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!(msg.player != currentPlayer))
		{
			string text = msg.read.String();
			if (text.Length > 20)
			{
				text = text.Substring(0, 20);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", this, text, msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", this, PhoneName, msg.player);
			}
		}
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a dropped item container.
/// </summary>
/// <param name="player">The player attempting to loot the container.</param>
/// <param name="container">The dropped item container being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the container, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the container.
/// </returns>
bool? CanLootEntity(BasePlayer player, DroppedItemContainer container)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot container: {container.net.ID}.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot loot while dead.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## OnCargoShipHarborLeave(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship leaves the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that is leaving the harbor.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipHarborLeave(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip.net.ID} is leaving the harbor.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	private void LeaveHarbor()
	{
		if (docking_debug)
		{
			Debug.Log("Cargo is leaving harbor.");
		}
		PlayHorn();
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: true);
		currentHarborApproachNode++;
		Interface.CallHook("OnCargoShipHarborLeave", this);
	}

```

## OnXmasStockingFill(Stocking)

```csharp
```csharp
/// <summary>
/// Called when an Xmas stocking is filled with loot.
/// </summary>
/// <param name="stocking">The Xmas stocking that is being filled.</param>
/// <returns>
/// Returns `null` to allow the default filling behavior, or any non-null value to prevent the stocking from being filled.
/// </returns>
object OnXmasStockingFill(Stocking stocking)
{
    Puts($"Filling Xmas stocking: {stocking.name}.");
    
    // Example condition to prevent filling
    if (stocking.IsSpecial())
    {
        Puts($"Stocking {stocking.name} is special and cannot be filled.");
        return "This stocking cannot be filled.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! " + base.name);
		}
		else if (IsEmpty() && Interface.CallHook("OnXmasStockingFill", this) == null)
		{
			base.SpawnLoot();
			SetFlag(Flags.On, b: true);
			Hurt(MaxHealth() * 0.1f, DamageType.Generic, null, useProtection: false);
		}
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player can network to this entity.
/// </summary>
/// <param name="entity">The networkable entity.</param>
/// <param name="player">The player attempting to network to the entity.</param>
/// <returns>
/// Returns `true` if the player can network to the entity; otherwise, returns `false`.
/// If the method returns `null`, the default networking logic will be applied.
/// </returns>
bool? CanNetworkTo(BaseNetworkable entity, BasePlayer player)
{
    Puts($"Checking network access for Player {player.displayName} to Entity ID: {entity.net.ID}");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can network to any entity.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (net.group == null)
		{
			return true;
		}
		return player.net.subscriber.IsSubscribed(net.group);
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player toggles the state of the recycler (on/off).
/// </summary>
/// <param name="recycler">The recycler being toggled.</param>
/// <param name="player">The player who is toggling the recycler.</param>
/// <returns>
/// Returns a non-null value to prevent the toggle action, or `null` to allow it.
/// </returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts($"Player {player.displayName} toggled the recycler (ID: {recycler.net.ID}).");

    if (player.inventory.loot.entitySource == recycler)
    {
        Puts($"Player {player.displayName} is currently looting the recycler and cannot toggle it.");
        return "You cannot toggle the recycler while looting.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || msg.player == null || Interface.CallHook("OnRecyclerToggle", this, msg.player) != null || (!flag && onlyOneUser && msg.player.inventory.loot.entitySource != this) || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

```

## OnThreatLevelUpdate(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to update the threat level of a player based on their current state and inventory.
/// </summary>
/// <param name="player">The player whose threat level is being updated.</param>
/// <returns>
/// Returns `null` to allow the default threat level calculation, or any non-null value to override it.
/// </returns>
object OnThreatLevelUpdate(BasePlayer player)
{
    Puts($"Updating threat level for player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone; threat level remains unchanged.");
        return true; // Prevents threat level increase
    }

    return null; // Allow default threat level calculation
}
```
```

### Source Code from the Library

```csharp

	public void EnsureUpdated()
	{
		if (UnityEngine.Time.realtimeSinceStartup - lastUpdateTime < 30f)
		{
			return;
		}
		lastUpdateTime = UnityEngine.Time.realtimeSinceStartup;
		cachedThreatLevel = 0f;
		if (IsSleeping() || Interface.CallHook("OnThreatLevelUpdate", this) != null)
		{
			return;
		}
		if (inventory.containerWear.itemList.Count > 2)
		{
			cachedThreatLevel += 1f;
		}
		foreach (Item item in inventory.containerBelt.itemList)
		{
			BaseEntity heldEntity = item.GetHeldEntity();
			if ((bool)heldEntity && heldEntity is BaseProjectile && !(heldEntity is BowWeapon))
			{
				cachedThreatLevel += 2f;
				break;
			}
		}
	}

```

## CanBeHomingTargeted(BaseHelicopter)

```csharp
```csharp
/// <summary>
/// Determines whether the specified helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The helicopter to check for homing missile targeting.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the helicopter can be targeted.
/// </returns>
bool? CanBeHomingTargeted(BaseHelicopter helicopter)
{
    Puts($"Checking if helicopter ID: {helicopter.net.ID} can be targeted by homing missiles.");
    return null; // Default behavior will be used
}
```
```

### Source Code from the Library

```csharp

	public virtual bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## CanEntityBeHostile(BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the specified combat entity can be considered hostile.
/// </summary>
/// <param name="entity">The combat entity to check for hostility.</param>
/// <returns>
/// Returns `true` if the entity is considered hostile; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine hostility.
/// </returns>
bool? CanEntityBeHostile(BaseCombatEntity entity)
{
    Puts($"Checking hostility for entity ID: {entity.net.ID}, Type: {entity.GetType().Name}");

    if (entity is AnimalNPC)
    {
        Puts($"Entity {entity.net.ID} is an animal and is not hostile.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnPlayerStudyBlueprint(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player studies a blueprint to unlock its crafting recipe.
/// </summary>
/// <param name="player">The player studying the blueprint.</param>
/// <param name="item">The blueprint item being studied.</param>
/// <returns>
/// Returns `null` to allow the default behavior of studying the blueprint, or any non-null value to prevent it.
/// </returns>
object OnPlayerStudyBlueprint(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is attempting to study blueprint: {item.info.displayName.english}.");

    if (item.info.shortname == "blueprint.special")
    {
        Puts($"Player {player.displayName} is not allowed to study this special blueprint.");
        return "You cannot study this blueprint.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command != "study" || !item.IsBlueprint())
		{
			return;
		}
		if (item.GetOwnerPlayer() != player && player.inventory.GetBackpackWithInventory()?.contents != item.parent)
		{
			bool flag = false;
			foreach (ItemContainer container in player.inventory.loot.containers)
			{
				if (item.GetRootContainer() == container)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (IsBlueprintUnlocked(item, player, out var blueprintTargetDef, out var blueprint) || Interface.CallHook("OnPlayerStudyBlueprint", player, item) != null)
		{
			return;
		}
		Item item2 = item;
		if (item.amount > 1)
		{
			item2 = item.SplitItem(1);
		}
		item2.UseItem();
		player.blueprints.Unlock(blueprintTargetDef);
		Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, "blueprint", ResearchTable.ScrapForResearch(blueprintTargetDef), player);
		if (blueprint != null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				player.blueprints.Unlock(additionalUnlock);
				Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, additionalUnlock, "blueprint", 0, player);
			}
		}
		if (studyEffect.isValid)
		{
			Effect.server.Run(studyEffect.resourcePath, player, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
	}

```

## OnDigitalClockAlarmsSet(DigitalClock,ProtoBuf.DigitalClockMessage)

```csharp
```csharp
/// <summary>
/// Called when alarms are set on a digital clock.
/// </summary>
/// <param name="clock">The digital clock instance where alarms are being set.</param>
/// <param name="message">The message containing the alarm settings.</param>
/// <returns>No return behavior.</returns>
void OnDigitalClockAlarmsSet(DigitalClock clock, ProtoBuf.DigitalClockMessage message)
{
    Puts($"Alarms set on Digital Clock ID: {clock.net.ID} with {message.alarms.Count} alarms.");
    
    foreach (var alarm in message.alarms)
    {
        Puts($"Alarm set for {DigitalClockEx.ToTimeSpan(alarm.time)} - Active: {alarm.active}");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_SetAlarms(RPCMessage msg)
	{
		if (!CanPlayerAdmin(msg.player))
		{
			return;
		}
		DigitalClockMessage digitalClockMessage = DigitalClockMessage.Deserialize(msg.read);
		if (Interface.CallHook("OnDigitalClockAlarmsSet", this, digitalClockMessage) != null)
		{
			return;
		}
		List<DigitalClockAlarm> list = digitalClockMessage.alarms;
		alarms.Clear();
		foreach (DigitalClockAlarm item2 in list)
		{
			Alarm item = new Alarm(DigitalClockEx.ToTimeSpan(item2.time), item2.active);
			alarms.Add(item);
		}
		muted = digitalClockMessage.muted;
		MarkDirty();
		SendNetworkUpdate();
	}

```

## OnSensorDetect(HBHFSensor,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sensor detects a player entity.
/// </summary>
/// <param name="sensor">The sensor that detected the player.</param>
/// <param name="player">The player that was detected by the sensor.</param>
/// <returns>
/// Returns `null` to allow the default detection behavior, or a non-null value to override it.
/// </returns>
object OnSensorDetect(HBHFSensor sensor, BasePlayer player)
{
    Puts($"Sensor {sensor.net.ID} detected player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInvisible())
    {
        Puts($"Player {player.displayName} is invisible and will not be counted.");
        return true; // Prevents counting this player
    }

    return null; // Allow default behavior
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePassthroughAmount()
	{
		if (base.isClient)
		{
			return;
		}
		int num = detectedPlayers;
		detectedPlayers = 0;
		if (myTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in myTrigger.entityContents)
			{
				if (entityContent == null || !entityContent.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f))
				{
					continue;
				}
				BasePlayer component = entityContent.GetComponent<BasePlayer>();
				if (Interface.CallHook("OnSensorDetect", this, component) == null)
				{
					bool flag = component.CanBuild();
					if ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && component != null && component.IsAlive() && !component.IsSleeping() && component.isServer)
					{
						detectedPlayers++;
					}
				}
			}
		}
		if (num != detectedPlayers && IsPowered())
		{
			MarkDirty();
			if (detectedPlayers > num)
			{
				Effect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);
			}
			else if (detectedPlayers < num)
			{
				Effect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnWallpaperRemove(BuildingBlock,int)

```csharp
```csharp
/// <summary>
/// Called when a wallpaper is removed from a building block.
/// </summary>
/// <param name="buildingBlock">The building block from which the wallpaper is being removed.</param>
/// <param name="side">The side of the building block from which the wallpaper is removed (0 for one side, 1 for the other).</param>
/// <returns>No return behavior.</returns>
void OnWallpaperRemove(BuildingBlock buildingBlock, int side)
{
    Puts($"Wallpaper removed from BuildingBlock ID: {buildingBlock.net.ID} on side: {side}.");
    
    if (side == 0)
    {
        Puts("Removing wallpaper from the left side.");
    }
    else if (side == 1)
    {
        Puts("Removing wallpaper from the right side.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RemoveWallpaper(int side)
	{
		if (Interface.CallHook("OnWallpaperRemove", this, side) == null)
		{
			switch (side)
			{
			case 0:
				wallpaperHealth = -1f;
				wallpaperID = 0uL;
				break;
			case 1:
				wallpaperHealth2 = -1f;
				wallpaperID2 = 0uL;
				break;
			}
			if (base.isServer)
			{
				SetConditionalModel(currentSkin.DetermineConditionalModelState(this));
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
			}
		}
	}

```

## OnOvenCook(BaseOven,Item)

```csharp
```csharp
/// <summary>
/// Called when an oven is cooking an item.
/// </summary>
/// <param name="oven">The oven that is performing the cooking.</param>
/// <param name="item">The item being cooked in the oven.</param>
/// <returns>No return behavior.</returns>
void OnOvenCook(BaseOven oven, Item item)
{
    Puts($"Oven {oven.net.ID} is cooking item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "raw.meat")
    {
        Puts("Cooking raw meat! Ensure proper cooking to avoid food poisoning.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		if (HasFlag(Flags.Reserved8))
		{
			return;
		}
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		if (item != null)
		{
			ItemModBurnable itemModBurnable = item.info.ItemModBurnable;
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, itemModBurnable);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnVendingShopOpened(InvisibleVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player opens a vending shop.
/// </summary>
/// <param name="vendingMachine">The invisible vending machine that is being opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpened(InvisibleVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.displayName} has opened the vending shop at {vendingMachine.transform.position}.");
    
    // Additional logic can be added here, such as logging or triggering events.
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", vendingMachine, player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!(conversingPlayer == player) && !(conversingPlayer == null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			List<Item> list = player.inventory.FindItemsByItemID(itemDefinition.itemid);
			foreach (Item item in list)
			{
				num -= item.amount;
			}
			if (num > 0)
			{
				int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
				ForceSpeechNode(player, speechNodeIndex2);
				break;
			}
			Facepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
			num = nPCConversationResultAction.scrapCost;
			foreach (Item item2 in list)
			{
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			lastActionPlayer = player;
			BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
			lastActionPlayer = null;
			break;
		}
	}

```

## OnCodeChange(ModularCar,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player requests to change the code for a modular car's lock.
/// </summary>
/// <param name="car">The modular car whose code is being changed.</param>
/// <param name="player">The player requesting the code change.</param>
/// <param name="newCode">The new code that the player wants to set.</param>
/// <returns>
/// Returns `null` to allow the code change, or any non-null value to prevent the code from being changed.
/// </returns>
object OnCodeChange(ModularCar car, BasePlayer player, string newCode)
{
    Puts($"Player {player.displayName} is attempting to change the lock code for car ID: {car.net.ID} to {newCode}.");

    if (newCode.Length < 4)
    {
        Puts($"Player {player.displayName} provided an invalid code. Code must be at least 4 characters long.");
        return "Invalid code length.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestNewCode(RPCMessage msg)
	{
		if (!HasOccupant || !carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!(player == null))
		{
			string text = msg.read.String();
			if (Interface.CallHook("OnCodeChange", carOccupant, player, text) == null && carOccupant.CarLock.TrySetNewCode(text, player.userID))
			{
				Effect.server.Run(changeLockCodeEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnPatrolHelicopterTakeDamage(PatrolHelicopter,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a patrol helicopter takes damage.
/// </summary>
/// <param name="helicopter">The patrol helicopter that is taking damage.</param>
/// <param name="hitInfo">Information about the hit, including damage type and amount.</param>
/// <returns>
/// Returns a non-null value to prevent further damage processing. 
/// If `null` is returned, the default damage handling will proceed.
/// </returns>
object OnPatrolHelicopterTakeDamage(PatrolHelicopter helicopter, HitInfo hitInfo)
{
    Puts($"Patrol Helicopter (ID: {helicopter.net.ID}) took damage: {hitInfo.damageTypes.Total()} from {hitInfo.Initiator?.displayName ?? "unknown source"}.");

    if (hitInfo.damageTypes.Total() > 500)
    {
        Puts("Damage is too high, preventing further processing.");
        return true; // Prevent further damage processing
    }

    return null; // Allow default damage handling
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnPatrolHelicopterTakeDamage", this, info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			if (Interface.CallHook("OnPatrolHelicopterKill", this, info) != null)
			{
				return;
			}
			base.health = 10000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		myAI.OtherDamaged(info);
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Determines whether the patrol helicopter can perform a strafe maneuver.
/// </summary>
/// <param name="helicopter">The patrol helicopter AI instance checking for strafe capability.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe, `false` if it cannot, 
/// or `null` if the default game logic should be used to determine strafe capability.
/// </returns>
bool? CanHelicopterStrafe(PatrolHelicopterAI helicopter)
{
    Puts($"Checking strafe capability for Helicopter ID: {helicopter.net.ID} at time: {UnityEngine.Time.realtimeSinceStartup}.");

    if (helicopter.lastStrafeTime + 20f > UnityEngine.Time.realtimeSinceStartup)
    {
        Puts("Helicopter is not ready to strafe yet.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= UnityEngine.Random.Range(15f, 25f))
		{
			return CanInterruptState();
		}
		return false;
	}

```

## OnWindmillUpdate(ElectricWindmill)

```csharp
```csharp
/// <summary>
/// Called to update the state of the electric windmill based on current wind conditions.
/// </summary>
/// <param name="windmill">The electric windmill being updated.</param>
/// <returns>No return behavior.</returns>
void OnWindmillUpdate(ElectricWindmill windmill)
{
    Puts($"Updating windmill: {windmill.net.ID}, Current Energy: {windmill.currentEnergy}, Wind Speed: {windmill.GetWindSpeedScale()}");
    
    if (windmill.currentEnergy > windmill.maxPowerGeneration)
    {
        Puts("Warning: Current energy exceeds maximum power generation capacity!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", this);
		}
	}

```

## OnHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter drops a supply crate.
/// </summary>
/// <param name="helicopter">The helicopter that is dropping the crate.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.net.ID} has dropped a crate at position: {helicopter.transform.position}.");
}
```
```

### Source Code from the Library

```csharp

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

```

## OnItemResearch(ResearchTable,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player researches an item at the research table.
/// </summary>
/// <param name="researchTable">The research table where the item is being researched.</param>
/// <param name="item">The item that is being researched.</param>
/// <param name="player">The player who is performing the research.</param>
/// <returns>No return behavior.</returns>
void OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} is researching item: {item.info.displayName.english} (ID: {item.info.itemid}) at {researchTable.gameObject.name}.");
    
    if (item.info.shortname == "blueprint")
    {
        Puts($"Player {player.displayName} has researched a blueprint!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Facepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnCargoShipEgress(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when the cargo ship is starting to egress from the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that is egressing.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipEgress(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip.net.ID} is starting to egress from the harbor.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	public void StartEgress()
	{
		if (!isDoingHarborApproach && !egressing)
		{
			egressing = true;
			if (Interface.CallHook("OnCargoShipEgress", this) == null)
			{
				CancelInvoke(PlayHorn);
				radiation.SetActive(value: true);
				SetFlag(Flags.Reserved8, b: true);
				InvokeRepeating(UpdateRadiation, 10f, 1f);
				Invoke(DelayedDestroy, 60f * egress_duration_minutes);
			}
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
```csharp
/// <summary>
/// Determines whether a player can be targeted by a gun trap.
/// </summary>
/// <param name="player">The player being checked for targeting.</param>
/// <param name="trap">The gun trap attempting to target the player.</param>
/// <returns>
/// Returns `true` if the player can be targeted by the gun trap; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can be targeted.
/// </returns>
bool? CanBeTargeted(BasePlayer player, GunTrap trap)
{
    Puts($"Checking if player {player.displayName} (ID: {player.UserIDString}) can be targeted by the gun trap.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		if (entityContents == null || entityContents.Count == 0)
		{
			return false;
		}
		List<RaycastHit> obj = Pool.Get<List<RaycastHit>>();
		BuildingPrivlidge cachedTc = GetCachedTc();
		bool flag = false;
		foreach (BaseEntity item in entityContents)
		{
			BasePlayer component = item.GetComponent<BasePlayer>();
			if (component.IsSleeping() || !component.IsAlive())
			{
				continue;
			}
			object obj2 = Interface.CallHook("CanBeTargeted", component, this);
			if (obj2 is bool)
			{
				Pool.FreeUnmanaged(ref obj);
				return (bool)obj2;
			}
			if (!(cachedTc == null) && cachedTc.IsAuthed(component))
			{
				continue;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
			for (int i = 0; i < obj.Count; i++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeUnmanaged(ref obj);
		return flag;
	}

```

## CanSamSiteShoot(SamSite)

```csharp
```csharp
/// <summary>
/// Called to determine if a SAM site can shoot at its current target.
/// </summary>
/// <param name="samSite">The SAM site attempting to shoot.</param>
/// <returns>
/// Returns `true` if the SAM site is allowed to shoot, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the SAM site can shoot.
/// </returns>
bool? CanSamSiteShoot(SamSite samSite)
{
    Puts($"SAM Site ID: {samSite.net.ID} is checking if it can shoot.");
    
    if (!samSite.IsPowered())
    {
        Puts("SAM Site is not powered and cannot shoot.");
        return false;
    }

    if (samSite.HasAmmo())
    {
        Puts("SAM Site has ammo and is ready to shoot.");
        return true;
    }

    Puts("SAM Site has no ammo and cannot shoot.");
    return false;
}
```
```

### Source Code from the Library

```csharp

	public void WeaponTick()
	{
		if (IsDead() || UnityEngine.Time.time < lockOnTime || UnityEngine.Time.time < nextBurstTime)
		{
			return;
		}
		if (!IsPowered())
		{
			firedCount = 0;
			return;
		}
		if (firedCount >= 6)
		{
			float timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;
			nextBurstTime = UnityEngine.Time.time + timeBetweenBursts;
			firedCount = 0;
			return;
		}
		EnsureReloaded();
		if (Interface.CallHook("CanSamSiteShoot", this) == null && HasAmmo())
		{
			bool num = ammoItem != null && ammoItem.amount == lowAmmoThreshold;
			if (!staticRespawn && ammoItem != null)
			{
				ammoItem.UseItem();
			}
			firedCount++;
			float speedMultiplier = 1f;
			if (!ObjectEx.IsUnityNull(currentTarget))
			{
				speedMultiplier = currentTarget.SAMTargetType.speedMultiplier;
			}
			FireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);
			Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
			currentTubeIndex++;
			if (currentTubeIndex >= tubes.Length)
			{
				currentTubeIndex = 0;
			}
			if (num)
			{
				MarkIODirty();
			}
		}
	}

```

## OnDispenserGathered(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player gathers resources from a dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser being gathered from.</param>
/// <param name="player">The player who is gathering the resources.</param>
/// <param name="item">The item that was gathered from the dispenser.</param>
/// <returns>No return behavior.</returns>
void OnDispenserGathered(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} gathered {item.amount} of {item.info.displayName.english} from dispenser {dispenser.net.ID}.");
    
    if (item.info.shortname == "wood")
    {
        Puts($"Player {player.displayName} has gathered wood, which is a valuable resource!");
    }
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		f = Mathf.Round(f);
		float num3 = f * destroyFraction * 2f;
		if (itemAmt.amount <= f + num3)
		{
			float num4 = (f + num3) / itemAmt.amount;
			f /= num4;
			num3 /= num4;
		}
		itemAmt.amount -= Mathf.Floor(f);
		itemAmt.amount -= Mathf.Floor(num3);
		if (f < 1f)
		{
			f = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (f >= 1f)
		{
			int num5 = CalculateGatherBonus(entity, itemAmt, f);
			int iAmount = Mathf.FloorToInt(f) + num5;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (Interface.CallHook("OnDispenserGather", this, entity, item) == null && item != null)
			{
				OverrideOwnership(item, attackWeapon);
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
				Interface.CallHook("OnDispenserGathered", this, entity, item);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Determines whether a player can bypass the connection queue.
/// </summary>
/// <param name="connection">The network connection of the player attempting to join.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue, `false` if they cannot, 
/// or `null` if the default queue logic should be applied.
/// </returns>
bool? CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if connection {connection.userid} can bypass the queue.");

    if (connection.userid == 123456) // Example for a specific user ID
    {
        Puts($"Connection {connection.userid} is a special case and can bypass the queue.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.SkipQueue)
		{
			return true;
		}
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			if (reservedSlots[i].UserId == connection.userid && reservedSlots[i].Expiry > UnityEngine.Time.realtimeSinceStartup)
			{
				return true;
			}
		}
		return false;
	}

```

## OnNpcConversationRespond(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
```csharp
/// <summary>
/// Called when a player responds to an NPC conversation.
/// </summary>
/// <param name="npc">The NPC that the player is conversing with.</param>
/// <param name="player">The player responding to the conversation.</param>
/// <param name="conversation">The conversation data associated with the interaction.</param>
/// <param name="response">The specific response node selected by the player.</param>
/// <returns>
/// Returns `null` to allow the response to proceed, or any non-null value to prevent the response from being processed.
/// </returns>
object OnNpcConversationRespond(NPCTalking npc, BasePlayer player, ConversationData conversation, ConversationData.ResponseNode response)
{
    Puts($"Player {player.displayName} responded to NPC {npc.name} with response: {response.text}");

    if (response.text.Contains("attack"))
    {
        Puts($"Player {player.displayName} is attempting to attack the NPC!");
        return "You cannot attack this NPC.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode == null || Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) != null)
		{
			return;
		}
		if (responseNode.conditions.Length != 0)
		{
			UpdateFlags();
		}
		bool flag = responseNode.PassesConditions(player, this);
		if (flag)
		{
			string actionString = responseNode.GetActionString();
			if (!string.IsNullOrEmpty(actionString))
			{
				OnConversationAction(player, actionString);
			}
		}
		int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
		if (speechNodeIndex == -1)
		{
			ForceEndConversation(player);
			return;
		}
		ForceSpeechNode(player, speechNodeIndex);
		Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
	}

```

## OnCrateLaptopAttack(HackableLockedCrate,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when the laptop on a hackable locked crate is attacked.
/// </summary>
/// <param name="crate">The hackable locked crate being attacked.</param>
/// <param name="hitInfo">Information about the hit, including damage and position.</param>
/// <returns>
/// Returns a non-null value to prevent further processing of the attack; otherwise, returns `null` to allow normal processing.
/// </returns>
object OnCrateLaptopAttack(HackableLockedCrate crate, HitInfo hitInfo)
{
    Puts($"Laptop on crate attacked! Damage dealt: {hitInfo.damageTypes.Total()} by {hitInfo.Initiator?.displayName ?? "unknown"}.");
    
    if (hitInfo.damageTypes.Total() > 100)
    {
        Puts("Attack too strong! Laptop is destroyed.");
        return "Laptop destroyed due to excessive damage.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer)
		{
			if (StringPool.Get(info.HitBone) == "laptopcollision")
			{
				if (Interface.CallHook("OnCrateLaptopAttack", this, info) != null)
				{
					return;
				}
				Effect.server.Run(shockEffect.resourcePath, info.HitPositionWorld, Vector3.up);
				hackSeconds -= 8f * (info.damageTypes.Total() / 50f);
				if (hackSeconds < 0f)
				{
					hackSeconds = 0f;
				}
			}
			RefreshDecay();
		}
		base.OnAttacked(info);
	}

```

## OnFindSpawnPoint(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to find a suitable spawn point for a player.
/// </summary>
/// <param name="player">The player for whom the spawn point is being found.</param>
/// <returns>
/// Returns a <c>BasePlayer.SpawnPoint</c> object representing the chosen spawn point.
/// If a custom spawn point is provided by a hook, it will be returned; otherwise, a default spawn point will be determined.
/// </returns>
BasePlayer.SpawnPoint OnFindSpawnPoint(BasePlayer player)
{
    Puts($"Finding spawn point for player: {player.displayName} (ID: {player.UserIDString})");

    if (player.IsInTutorial)
    {
        Puts($"Player {player.displayName} is in tutorial mode. Finding tutorial spawn point.");
    }

    return new BasePlayer.SpawnPoint
    {
        pos = new Vector3(0, 0, 0), // Placeholder for actual spawn logic
        rot = Quaternion.identity // Placeholder for actual rotation logic
    };
}
```
```

### Source Code from the Library

```csharp

	public static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null)
	{
		object obj = Interface.CallHook("OnFindSpawnPoint", forPlayer);
		if (obj is BasePlayer.SpawnPoint)
		{
			return (BasePlayer.SpawnPoint)obj;
		}
		bool flag = false;
		if (forPlayer != null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null)
			{
				BasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();
				if (forPlayer.CurrentTutorialAllowance > BasePlayer.TutorialItemAllowance.Level1_HatchetPickaxe)
				{
					spawnPoint.pos = currentTutorialIsland.MidMissionSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.MidMissionSpawnPoint.rotation;
				}
				else
				{
					spawnPoint.pos = currentTutorialIsland.InitialSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.InitialSpawnPoint.rotation;
				}
				return spawnPoint;
			}
		}
		BaseGameMode baseGameMode = Gamemode();
		if ((bool)baseGameMode && baseGameMode.useCustomSpawns)
		{
			BasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);
			if (playerSpawn != null)
			{
				return playerSpawn;
			}
		}
		if (SingletonComponent<SpawnHandler>.Instance != null && !flag)
		{
			BasePlayer.SpawnPoint spawnPoint2 = SpawnHandler.GetSpawnPoint();
			if (spawnPoint2 != null)
			{
				return spawnPoint2;
			}
		}
		BasePlayer.SpawnPoint spawnPoint3 = new BasePlayer.SpawnPoint();
		if (forPlayer != null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland2 = forPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland2 != null)
			{
				spawnPoint3.pos = currentTutorialIsland2.InitialSpawnPoint.position;
				spawnPoint3.rot = currentTutorialIsland2.InitialSpawnPoint.rotation;
				return spawnPoint3;
			}
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (array.Length != 0)
		{
			GameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];
			spawnPoint3.pos = gameObject.transform.position;
			spawnPoint3.rot = gameObject.transform.rotation;
		}
		else
		{
			UnityEngine.Debug.Log("Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
			if (MainCamera.mainCamera != null)
			{
				spawnPoint3.pos = MainCamera.position;
				spawnPoint3.rot = MainCamera.rotation;
			}
		}
		if (UnityEngine.Physics.Raycast(new Ray(spawnPoint3.pos, Vector3.down), out var hitInfo, 32f, 1537286401))
		{
			spawnPoint3.pos = hitInfo.point;
		}
		return spawnPoint3;
	}

```

## OnEventTrigger(TriggeredEventPrefab)

```csharp
```csharp
/// <summary>
/// Called when an event is triggered to spawn a specified prefab.
/// </summary>
/// <param name="eventPrefab">The prefab associated with the triggered event.</param>
/// <returns>No return behavior.</returns>
void OnEventTrigger(TriggeredEventPrefab eventPrefab)
{
    Puts($"Event triggered for prefab: {eventPrefab.resourcePath}");
    if (eventPrefab.shouldBroadcastSpawn)
    {
        foreach (BasePlayer player in BasePlayer.activePlayerList)
        {
            if (player.IsConnected && !player.IsInTutorial)
            {
                player.ShowToast(GameTip.Styles.Server_Event, "An event has occurred!", false);
            }
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public override void RunEvent()
	{
		if (Interface.CallHook("OnEventTrigger", this) != null)
		{
			return;
		}
		Debug.Log("[event] " + targetPrefab.resourcePath);
		BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
		if (!baseEntity)
		{
			return;
		}
		baseEntity.SendMessage("TriggeredEventSpawn", SendMessageOptions.DontRequireReceiver);
		baseEntity.Spawn();
		spawnedEntity = baseEntity;
		if (!shouldBroadcastSpawn)
		{
			return;
		}
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if ((bool)activePlayer && activePlayer.IsConnected && !activePlayer.IsInTutorial)
			{
				activePlayer.ShowToast(GameTip.Styles.Server_Event, spawnPhrase, false);
			}
		}
	}

```

## OnFuelConsume(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by the oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The fuel item being consumed.</param>
/// <param name="burnable">The burnable item modifier associated with the fuel.</param>
/// <returns>No return behavior.</returns>
void OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel consumed: {fuel.info.displayName.english} in oven ID: {oven.net.ID}.");

    if (fuel.amount < 1)
    {
        Puts("Fuel amount is insufficient for consumption.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Facepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## CanPickupEntity(BasePlayer,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether a player can pick up a specific entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can pick up the entity.
/// </returns>
bool? CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to pick up the entity: {entity.name}.");

    if (player.IsInTutorial)
    {
        Puts($"Player {player.displayName} is in a tutorial and cannot pick up entities.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (pickup.enabled && (!pickup.requireBuildingPrivilege || player.CanBuild()) && (!pickup.requireHammer || player.IsHoldingEntity<Hammer>()))
		{
			if (player != null)
			{
				return !player.IsInTutorial;
			}
			return false;
		}
		return false;
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to buy an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the item is being purchased.</param>
/// <param name="buyer">The player attempting to buy the item.</param>
/// <param name="itemId">The ID of the item being purchased.</param>
/// <param name="amount">The amount of the item being purchased.</param>
/// <returns>
/// Returns `null` to allow the purchase, or any non-null value to prevent the purchase.
/// </returns>
object OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer buyer, int itemId, int amount)
{
    Puts($"Player {buyer.displayName} is attempting to buy {amount} of item ID {itemId} from vending machine {vendingMachine.net.ID}.");

    if (amount > 10)
    {
        Puts($"Purchase denied: {buyer.displayName} tried to buy too many items.");
        return "You cannot buy more than 10 items at once.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void BuyItem(RPCMessage rpc)
	{
		if (OccupiedCheck(rpc.player))
		{
			int num = rpc.read.Int32();
			int num2 = rpc.read.Int32();
			if (IsVending())
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage, false);
			}
			else if (Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2) == null)
			{
				SetPendingOrder(rpc.player, num, num2);
				Invoke(CompletePendingOrder, GetBuyDuration());
			}
		}
	}

```

## OnTurretAssign(AutoTurret,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is assigned to a player.
/// </summary>
/// <param name="turret">The turret being assigned.</param>
/// <param name="playerId">The ID of the player to whom the turret is being assigned.</param>
/// <param name="assigner">The player who is assigning the turret.</param>
/// <returns>
/// Returns `null` to allow the assignment, or any non-null value to prevent the assignment.
/// </returns>
object OnTurretAssign(AutoTurret turret, ulong playerId, BasePlayer assigner)
{
    Puts($"Turret {turret.net.ID} is being assigned to player ID: {playerId} by {assigner.displayName}.");
    
    if (playerId == 123456789) // Example condition to block assignment
    {
        Puts($"Assignment to player ID {playerId} is not allowed.");
        return "You cannot assign this turret to this player.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", this, num, msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = num;
			playerNameID.username = username;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(playerNameID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", this, num, msg.player);
		}
	}

```

## CanCastFishingRod(BasePlayer,BaseFishingRod,Item,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can cast their fishing rod at a specified position.
/// </summary>
/// <param name="player">The player attempting to cast the fishing rod.</param>
/// <param name="fishingRod">The fishing rod being used for the cast.</param>
/// <param name="lure">The lure currently attached to the fishing rod.</param>
/// <param name="castPosition">The position where the player is attempting to cast the fishing rod.</param>
/// <returns>
/// Returns `true` if the player can cast the fishing rod, or `false` if they cannot. 
/// If the method returns `null`, the default game logic will determine if the cast is valid.
/// </returns>
bool? CanCastFishingRod(BasePlayer player, BaseFishingRod fishingRod, Item lure, Vector3 castPosition)
{
    Puts($"Player {player.displayName} is attempting to cast fishing rod at position {castPosition} with lure {lure.info.displayName.english}.");

    if (lure.info.shortname == "special_lure")
    {
        Puts($"Player {player.displayName} cannot use the special lure for casting.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_RequestCast(RPCMessage msg)
	{
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		ItemModCompostable component = (ItemModCompostable)Interface.CallHook("CanCastFishingRod", ownerPlayer, this, currentLure, pos);
		if (!(component is bool) || (bool)(object)component)
		{
			FishingBobber component2 = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();
			component2.transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component2.Spawn();
			component2.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);
			int usedLureAmount = 0;
			if (FishLookup.Instance != null)
			{
				currentFishTarget = FishLookup.Instance.GetFish(component2.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);
			}
			lureUsed = currentLure.info;
			currentLure.UseItem(usedLureAmount);
			lastFish = fishableModifier;
			currentBobber.Set(component2);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReceiveCastPoint"), component2.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));
			catchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;
			float val = (lureUsed.TryGetComponent<ItemModCompostable>(out component) ? component.BaitValue : 0f);
			val = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);
			catchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);
			playerStartPosition = ownerPlayer.transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			InvokeRepeating(CatchProcess, 0f, 0f);
			inQueue = false;
			Interface.CallHook("OnFishingRodCast", this, ownerPlayer, currentLure);
		}
	}

```

## OnFindBurnable(BaseOven)

```csharp
```csharp
/// <summary>
/// Called to find a burnable item in the oven's inventory.
/// </summary>
/// <param name="oven">The oven instance that is searching for a burnable item.</param>
/// <returns>
/// Returns an <c>Item</c> if a burnable item is found; otherwise, returns <c>null</c>.
/// If the method returns a non-null value, it overrides the default item search logic.
/// </returns>
Item OnFindBurnable(BaseOven oven)
{
    Puts($"Searching for burnable items in the oven with ID: {oven.net.ID}.");

    // Example condition to block a specific item
    if (oven.inventory != null && oven.inventory.itemList.Any(i => i.info.shortname == "wood"))
    {
        Puts("Wood is available and will be used as a burnable item.");
        return oven.inventory.itemList.First(i => i.info.shortname == "wood");
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (base.inventory == null)
		{
			return null;
		}
		foreach (Item item in base.inventory.itemList)
		{
			if (IsBurnableItem(item))
			{
				return item;
			}
		}
		return null;
	}

```

## OnVehicleModuleDeselected(ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is deselected by a player in the garage.
/// </summary>
/// <param name="garage">The modular car garage from which the module is being deselected.</param>
/// <param name="player">The player who deselected the vehicle module.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModuleDeselected(ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.displayName} has deselected a module from the garage: {garage.name}.");
    
    if (player.inventory.loot.IsLooting())
    {
        Puts($"Player {player.displayName} is currently looting.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_DeselectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.inventory.loot.IsLooting() && !(player.inventory.loot.entitySource != this))
		{
			if (player.inventory.loot.RemoveContainerAt(3))
			{
				player.inventory.loot.SendImmediate();
			}
			Interface.CallHook("OnVehicleModuleDeselected", this, player);
		}
	}

```

## OnMapMarkersCleared(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's map markers are cleared.
/// </summary>
/// <param name="player">The player whose map markers have been cleared.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkersCleared(BasePlayer player)
{
    Puts($"Map markers cleared for player: {player.displayName} (ID: {player.UserIDString})");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, State.pointsOfInterest) != null)
		{
			return;
		}
		ServerCurrentDeathNote?.Dispose();
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				item?.Dispose();
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", this);
	}

```

## OnTurretClearList(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the authorization list of a turret is cleared.
/// </summary>
/// <param name="turret">The turret whose authorization list is being cleared.</param>
/// <param name="player">The player who initiated the clear action.</param>
/// <returns>
/// Returns `null` to allow the action, or any non-null value to prevent the authorization list from being cleared.
/// </returns>
object OnTurretClearList(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.net.ID} authorization list cleared by player {player.displayName} (ID: {player.UserIDString}).");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} cleared the turret authorization list.");
        return null; // Allow the action
    }
    
    Puts($"Player {player.displayName} is not authorized to clear the turret list.");
    return "You are not authorized to clear this turret's authorization list."; // Prevent the action
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			authDirty = true;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "clear", rpc.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnTeamCreated(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a new team is created by a player.
/// </summary>
/// <param name="player">The player who created the team.</param>
/// <param name="team">The team that was created.</param>
/// <returns>No return behavior.</returns>
void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
{
    Puts($"Team created by player {player.displayName} (ID: {player.UserIDString}). Team ID: {team.teamID}, Members: {team.members.Count}");
    
    if (team.members.Count > 5)
    {
        Puts($"Warning: Team {team.teamID} has exceeded the recommended size with {team.members.Count} members.");
    }
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Facepunch.Rust.Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is initiated.
/// </summary>
/// <param name="task">The item crafting task that is being created.</param>
/// <param name="owner">The player who is crafting the item.</param>
/// <param name="fromTempBlueprint">An optional temporary blueprint used for crafting.</param>
/// <returns>
/// Returns `true` if the crafting process can proceed, or `false` if it cannot. 
/// If the method returns `null`, the default crafting logic will be applied.
/// </returns>
object OnItemCraft(ItemCraftTask task, BasePlayer owner, Item fromTempBlueprint)
{
    Puts($"Player {owner.displayName} is crafting item with Task UID: {task.taskUID}.");

    if (task.blueprint.targetItem.itemid == 12345) // Example item ID
    {
        Puts($"Player {owner.displayName} is attempting to craft a restricted item.");
        return "You cannot craft this item.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)
	{
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		if (!CanCraft(bp, amount, free))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		if (!free)
		{
			CollectIngredients(bp, itemCraftTask, amount, owner);
		}
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			if (fromTempBlueprint != null && itemCraftTask.instanceData != null)
			{
				fromTempBlueprint.instanceData = itemCraftTask.instanceData;
			}
			return (bool)obj;
		}
		queue.AddLast(itemCraftTask);
		if (owner != null)
		{
			owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## OnTerrainInitialized()

```csharp
```csharp
/// <summary>
/// Called when the terrain has been initialized and all components are set up.
/// </summary>
/// <returns>No return behavior.</returns>
void OnTerrainInitialized()
{
    Puts("Terrain has been successfully initialized and all components are set up.");
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

```

## CanPurchaseItem(BasePlayer,Item,System.Action<BasePlayer, Item>,VendingMachine,ItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can purchase an item from a vending machine.
/// </summary>
/// <param name="buyer">The player attempting to purchase the item.</param>
/// <param name="item">The item being purchased.</param>
/// <param name="onItemPurchased">Callback action to invoke when the item is successfully purchased.</param>
/// <param name="vendingMachine">The vending machine from which the item is being purchased.</param>
/// <param name="targetContainer">The container where the item will be placed, if applicable.</param>
/// <returns>
/// Returns `true` if the player can purchase the item, `false` if they cannot, 
/// or a non-null value to override the default purchase behavior.
/// </returns>
object CanPurchaseItem(BasePlayer buyer, Item item, Action<BasePlayer, Item> onItemPurchased, VendingMachine vendingMachine, ItemContainer targetContainer)
{
    Puts($"Player {buyer.displayName} is attempting to purchase {item.info.displayName.english} from vending machine.");

    if (item.info.shortname == "restricted.item")
    {
        Puts($"Player {buyer.displayName} is not allowed to purchase {item.info.displayName.english}.");
        return false;
    }

    return null; // Allow default purchase logic to proceed
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions, targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> obj2 = Facepunch.Pool.Get<List<Item>>();
		GetItemsToSell(sellOrder, obj2);
		if (obj2 == null || obj2.Count == 0)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = obj2.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		List<Item> source = buyer.inventory.FindItemsByItemID(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = (from x in source
			where !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)
			where x.GetItemVolume() <= maxCurrencyVolume
			select x).ToList();
		if (source.Count == 0)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;
		if (num3 < num4)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			TakeCurrencyItem(item);
			onCurrencyRemoved?.Invoke(buyer, item);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		Facepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, num4, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);
		int num7 = 0;
		foreach (Item item4 in obj2)
		{
			int num8 = num - num7;
			Item item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);
			if (item2 == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item2.amount;
				object obj3 = Interface.CallHook("CanPurchaseItem", buyer, item2, onItemPurchased, this, targetContainer);
				if (obj3 != null)
				{
					if (!(obj3 is bool))
					{
						return false;
					}
					return (bool)obj3;
				}
				RecordSaleAnalytics(item2, sellOrderId);
				if (targetContainer == null)
				{
					GiveSoldItem(item2, buyer);
				}
				else if (!item2.MoveToContainer(targetContainer))
				{
					item2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
				}
				onItemPurchased?.Invoke(buyer, item2);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj2);
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## CanDismountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can dismount from an entity.
/// </summary>
/// <param name="player">The player attempting to dismount.</param>
/// <param name="mountable">The mountable entity the player is currently on.</param>
/// <returns>
/// Returns `true` if the player can dismount from the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can dismount.
/// </returns>
bool? CanDismountEntity(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to dismount from {mountable.gameObject.name}.");

    if (player.IsInCombat())
    {
        Puts($"Player {player.displayName} cannot dismount while in combat.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.transform.rotation = Quaternion.identity;
			_mounted.ClientRPC(RpcTarget.Player("ForcePositionTo", _mounted), res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID.Get() + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
		}
		else
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.SendModelState(force: true);
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), res);
			}
			Facepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnSprinklerSplashed(Sprinkler)

```csharp
```csharp
/// <summary>
/// Called when the sprinkler has splashed water on nearby entities.
/// </summary>
/// <param name="sprinkler">The sprinkler that performed the splash.</param>
/// <returns>No return behavior.</returns>
void OnSprinklerSplashed(Sprinkler sprinkler)
{
    Puts($"Sprinkler at position {sprinkler.transform.position} has splashed water.");
    
    // Additional logic can be added here to handle the splash event
    if (sprinkler.cachedSplashables.Count > 0)
    {
        Puts($"Number of entities splashed: {sprinkler.cachedSplashables.Count}");
    }
}
```
```

### Source Code from the Library

```csharp

	private void DoSplash()
	{
		using (TimeWarning.New("SprinklerSplash"))
		{
			int num = WaterPerSplash;
			if ((float)updateSplashableCache > SplashFrequency * 4f || forceUpdateSplashables)
			{
				cachedSplashables.Clear();
				forceUpdateSplashables = false;
				updateSplashableCache = 0f;
				Vector3 position = Eyes.position;
				Vector3 up = base.transform.up;
				float sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;
				float value = Vector3.Angle(up, Vector3.up) / 180f;
				value = Mathf.Clamp(value, 0.2f, 1f);
				sprinklerEyeHeightOffset *= value;
				Vector3 startPosition = position + up * (Server.sprinklerRadius * 0.5f);
				Vector3 endPosition = position + up * sprinklerEyeHeightOffset;
				List<BaseEntity> obj = Facepunch.Pool.Get<List<BaseEntity>>();
				Vis.Entities(startPosition, endPosition, Server.sprinklerRadius, obj, 1237003025);
				if (obj.Count > 0)
				{
					foreach (BaseEntity item in obj)
					{
						if (!item.isClient && item is ISplashable splashable && !cachedSplashables.Contains(splashable) && splashable.WantsSplash(currentFuelType, num) && item.IsVisible(position) && (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)) && (!(item is BasePlayer) || !(currentFuelType.baseRadioactivity > 0f)))
						{
							cachedSplashables.Add(splashable);
						}
					}
				}
				Facepunch.Pool.FreeUnmanaged(ref obj);
			}
			if (cachedSplashables.Count > 0)
			{
				int num2 = num / cachedSplashables.Count;
				float num3 = (float)(num % cachedSplashables.Count) / (float)cachedSplashables.Count;
				foreach (ISplashable cachedSplashable in cachedSplashables)
				{
					int amount = num2 + ((UnityEngine.Random.value < num3) ? 1 : 0);
					if (!ObjectEx.IsUnityNull(cachedSplashable) && cachedSplashable.WantsSplash(currentFuelType, amount))
					{
						int num4 = cachedSplashable.DoSplash(currentFuelType, amount);
						num -= num4;
						if (num <= 0)
						{
							break;
						}
					}
				}
			}
			if (DecayPerSplash > 0f)
			{
				Hurt(DecayPerSplash);
			}
		}
		Interface.CallHook("OnSprinklerSplashed", this);
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The instance of the Bradley APC being initialized.</param>
/// <returns>No return behavior.</returns>
void OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Initializing Bradley APC with ID: {apc.net.ID} at position: {apc.transform.position}");
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## CanDeployItem(BasePlayer,Deployer,NetworkableId)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can deploy a specific item.
/// </summary>
/// <param name="player">The player attempting to deploy the item.</param>
/// <param name="deployer">The deployable item being placed.</param>
/// <param name="networkableId">The networkable ID of the deployable item.</param>
/// <returns>
/// Returns `null` to allow the deployment, or any non-null value to prevent it.
/// </returns>
object CanDeployItem(BasePlayer player, Deployer deployer, NetworkableId networkableId)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to deploy item with Networkable ID: {networkableId}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot deploy items in a safe zone.");
        return "You cannot deploy items in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDeploy(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Deployable deployable = GetDeployable();
		if (deployable == null)
		{
			return;
		}
		Ray ray = msg.read.Ray();
		NetworkableId networkableId = msg.read.EntityID();
		if (Interface.CallHook("CanDeployItem", msg.player, this, networkableId) == null)
		{
			if (deployable.toSlot)
			{
				DoDeploy_Slot(deployable, ray, networkableId);
			}
			else
			{
				DoDeploy_Regular(deployable, ray);
			}
		}
	}

```

## OnMapMarkerAdd(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player adds a new marker to the map.
/// </summary>
/// <param name="player">The player who is adding the map marker.</param>
/// <param name="mapNote">The details of the map marker being added.</param>
/// <returns>
/// Returns `null` to allow the marker to be added, or any non-null value to prevent the addition of the marker.
/// </returns>
object OnMapMarkerAdd(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.displayName} is attempting to add a map marker at position: {mapNote.position}.");

    if (mapNote.title == "Restricted Area")
    {
        Puts($"Player {player.displayName} tried to add a restricted area marker.");
        return "You cannot add markers in restricted areas.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 13L;
			if (State.pointsOfInterest == null)
			{
				State.pointsOfInterest = Facepunch.Pool.Get<List<MapNote>>();
			}
			if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
			{
				msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());
				return;
			}
			MapNote mapNote = MapNote.Deserialize(msg.read);
			ValidateMapNote(mapNote);
			mapNote.colourIndex = FindUnusedPointOfInterestColour();
			State.pointsOfInterest.Add(mapNote);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, mapNote);
		}
	}

```

## CanMountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can mount a specific entity.
/// </summary>
/// <param name="player">The player attempting to mount the entity.</param>
/// <param name="mountable">The mountable entity that the player wants to mount.</param>
/// <returns>
/// Returns `true` if the player can mount the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can mount the entity.
/// </returns>
bool? CanMountEntity(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to mount the entity {mountable.net.ID}.");

    if (player.IsInCombat)
    {
        Puts($"Player {player.displayName} cannot mount while in combat.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform transform = mountAnchor;
			player.SetMounted(this);
			player.MovePosition(transform.position);
			player.transform.rotation = transform.rotation;
			player.ServerRotation = transform.rotation;
			player.OverrideViewAngles(transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(transform.rotation);
			player.SendNetworkUpdateImmediate();
			Facepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
			if (this.IsValid() && player.IsValid())
			{
				player.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);
			}
		}
	}

```

## OnWaterCollect(WaterPump,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when water is collected from a water pump.
/// </summary>
/// <param name="pump">The water pump that is collecting water.</param>
/// <param name="itemDefinition">The definition of the water item being collected.</param>
/// <returns>
/// Returns `null` to allow the water collection, or any non-null value to prevent it.
/// </returns>
object OnWaterCollect(WaterPump pump, ItemDefinition itemDefinition)
{
    Puts($"Water collected from pump at {pump.transform.position}. Item: {itemDefinition.displayName.english}");
    
    if (itemDefinition.shortname == "water.purified")
    {
        Puts("Purified water collection is restricted.");
        return "Collection of purified water is not allowed.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CreateWater()
	{
		if (!IsFull())
		{
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(WaterResourceLocation.position);
			if (itemDefinition != null && Interface.CallHook("OnWaterCollect", this, itemDefinition) == null)
			{
				base.inventory.AddItem(itemDefinition, AmountPerPump, 0uL);
				UpdateOnFlag();
			}
		}
	}

```

## OnEngineStarted(MotorRowboat,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the engine of the motorized rowboat is started.
/// </summary>
/// <param name="rowboat">The motorized rowboat whose engine is being started.</param>
/// <param name="driver">The player who is driving the rowboat.</param>
/// <returns>No return behavior.</returns>
void OnEngineStarted(MotorRowboat rowboat, BasePlayer driver)
{
    Puts($"Engine started for rowboat driven by {driver.displayName} (ID: {driver.UserIDString}).");
    
    // Additional logic can be added here, such as logging or triggering events.
}
```
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.On, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
			if (wantsOn)
			{
				rigidBody.WakeUp();
				buoyancy.Wake();
			}
		}
	}

```

## CanWaterBallSplash(ItemDefinition,UnityEngine.Vector3,float,int)

```csharp
```csharp
/// <summary>
/// Determines if a water splash can occur at a specified position with given parameters.
/// </summary>
/// <param name="liquidDef">The item definition of the liquid being splashed.</param>
/// <param name="position">The position where the splash occurs.</param>
/// <param name="radius">The radius of the splash effect.</param>
/// <param name="amount">The amount of liquid to splash.</param>
/// <returns>
/// Returns `true` if the splash can occur, or `false` if it cannot. 
/// If the method returns `null`, the default game logic will be used to determine if the splash can occur.
/// </returns>
bool? CanWaterBallSplash(ItemDefinition liquidDef, Vector3 position, float radius, int amount)
{
    Puts($"Checking if splash can occur with {liquidDef.displayName.english} at position {position} with radius {radius} and amount {amount}.");

    if (liquidDef.itemid == 12345) // Example item ID for a restricted liquid
    {
        Puts("Splashing this liquid is not allowed.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)
	{
		object obj = Interface.CallHook("CanWaterBallSplash", liquidDef, position, radius, amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		List<BaseEntity> obj2 = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, radius, obj2, 1220225811);
		int num = 0;
		int num2 = amount;
		while (amount > 0 && num < 3)
		{
			List<ISplashable> obj3 = Pool.Get<List<ISplashable>>();
			foreach (BaseEntity item in obj2)
			{
				if (!item.isClient && item is ISplashable splashable && !obj3.Contains(splashable) && splashable.WantsSplash(liquidDef, amount))
				{
					bool flag = true;
					if (item is PlanterBox && !GamePhysics.LineOfSight(item.transform.position + new Vector3(0f, 1f, 0f), position, 2097152))
					{
						flag = false;
					}
					if (flag)
					{
						obj3.Add(splashable);
					}
				}
			}
			if (obj3.Count == 0)
			{
				break;
			}
			int b = Mathf.CeilToInt(amount / obj3.Count);
			foreach (ISplashable item2 in obj3)
			{
				int num3 = item2.DoSplash(liquidDef, Mathf.Min(amount, b));
				amount -= num3;
				if (amount <= 0)
				{
					break;
				}
			}
			Pool.FreeUnmanaged(ref obj3);
			num++;
		}
		Pool.FreeUnmanaged(ref obj2);
		return amount < num2;
	}

```

## OnNpcGiveSoldItem(NPCVendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC vending machine gives a sold item to a player.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that is selling the item.</param>
/// <param name="soldItem">The item that is being sold.</param>
/// <param name="buyer">The player who is buying the item.</param>
/// <returns>No return behavior.</returns>
void OnNpcGiveSoldItem(NPCVendingMachine vendingMachine, Item soldItem, BasePlayer buyer)
{
    Puts($"NPC Vending Machine {vendingMachine.net.ID} is giving item {soldItem.info.displayName.english} to player {buyer.displayName}.");
}
```
```

### Source Code from the Library

```csharp

	public override void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnNpcGiveSoldItem", this, soldItem, buyer) == null)
		{
			base.GiveSoldItem(soldItem, buyer);
		}
	}

```

## OnItemLock(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is locked or unlocked.
/// </summary>
/// <param name="item">The item that is being locked or unlocked.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being locked or unlocked. 
/// If `null` is returned, the lock/unlock action proceeds as normal.
/// </returns>
object OnItemLock(Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.net.ID}) is being locked.");
    if (item.amount > 10)
    {
        Puts($"Item {item.info.displayName.english} cannot be locked because it has more than 10 units.");
        return "Cannot lock items with more than 10 units.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## OnTeamRejectInvite(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a player rejects a team invite.
/// </summary>
/// <param name="player">The player who rejected the invite.</param>
/// <param name="team">The team from which the invite was rejected.</param>
/// <returns>
/// Returns `null` to allow the rejection to proceed, or any non-null value to prevent the rejection.
/// </returns>
object OnTeamRejectInvite(BasePlayer player, RelationshipManager.PlayerTeam team)
{
    Puts($"Player {player.displayName} has rejected the invite from team {team.TeamName}.");

    if (team.TeamName == "VIPs")
    {
        Puts($"Player {player.displayName} cannot reject invites from VIP teams.");
        return "You cannot reject invites from VIP teams.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void rejectinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamRejectInvite", basePlayer, playerTeam) == null)
			{
				playerTeam.RejectInvite(basePlayer);
			}
		}
	}

```

## OnLiquidWeaponFiringStopped(LiquidWeapon)

```csharp
```csharp
/// <summary>
/// Called when the firing of a liquid weapon has stopped.
/// </summary>
/// <param name="liquidWeapon">The liquid weapon that has stopped firing.</param>
/// <returns>No return behavior.</returns>
void OnLiquidWeaponFiringStopped(LiquidWeapon liquidWeapon)
{
    Puts($"Liquid weapon {liquidWeapon.net.ID} has stopped firing.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StopFiring()
	{
		CancelInvoke(FireTick);
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		SetFlag(Flags.On, b: false);
		if (base.isServer)
		{
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnLiquidWeaponFiringStopped", this);
	}

```

## OnFireworkStarted(BaseFirework)

```csharp
```csharp
/// <summary>
/// Called when a firework is started.
/// </summary>
/// <param name="firework">The firework that has been started.</param>
/// <returns>No return behavior.</returns>
void OnFireworkStarted(BaseFirework firework)
{
    Puts($"Firework {firework.net.ID} has been started.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	public virtual void Begin()
	{
		SetFlag(Flags.OnFire, b: false);
		SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkStarted", this);
		Invoke(OnExhausted, activityLength);
	}

```

## OnWildlifeTrap(SurvivalFishTrap,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when a wildlife trap successfully catches an item.
/// </summary>
/// <param name="trap">The wildlife trap that caught the item.</param>
/// <param name="itemDefinition">The definition of the item that was caught.</param>
/// <returns>
/// Returns `null` to allow the default behavior of the trap, or any non-null value to prevent the item from being caught.
/// </returns>
object OnWildlifeTrap(SurvivalFishTrap trap, ItemDefinition itemDefinition)
{
    Puts($"Wildlife trap at {trap.transform.position} caught a {itemDefinition.displayName.english}.");
    
    if (itemDefinition.shortname == "fish.mackerel")
    {
        Puts("Mackerel caught! Special handling applied.");
        return "Caught a mackerel!";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void TrapThink()
	{
		ItemDefinition itemDefinition = null;
		Item item = null;
		int usedLureAmount = 0;
		using (List<Item>.Enumerator enumerator = base.inventory.itemList.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				if ((current.info.TryGetComponent<ItemModCompostable>(out var component) ? component.BaitValue : 0f) > 0f)
				{
					item = current;
					itemDefinition = FishLookup.Instance.GetFish(base.transform.position, cachedWaterBody, current, out var _, current.info.GetComponent<ItemModFishable>(), out usedLureAmount, 5f);
				}
			}
		}
		item?.UseItem(usedLureAmount);
		if (UnityEngine.Random.Range(0f, 1f) <= trapSuccessRate || !(itemDefinition != null))
		{
			return;
		}
		try
		{
			bypassItemFilter = true;
			if (Interface.CallHook("OnWildlifeTrap", this, itemDefinition) == null)
			{
				Item item2 = ItemManager.Create(itemDefinition, 1, 0uL);
				if (!item2.MoveToContainer(base.inventory))
				{
					item2.Drop(base.transform.position, Vector3.zero, Quaternion.identity);
				}
				OnTrappedWildlife(setFlag: true);
			}
		}
		finally
		{
			bypassItemFilter = false;
		}
	}

```

## OnMissionSucceeded(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is successfully completed.
/// </summary>
/// <param name="mission">The mission that was completed.</param>
/// <param name="instance">The instance of the mission that was accomplished.</param>
/// <param name="player">The player who completed the mission.</param>
/// <returns>No return behavior.</returns>
void OnMissionSucceeded(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer player)
{
    Puts($"Mission {mission.missionName} succeeded for player {player.displayName} (ID: {player.UserIDString}).");

    if (player.HasAchievement("MissionMaster"))
    {
        Puts($"Player {player.displayName} has completed a mission and earned the 'MissionMaster' achievement!");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)
	{
		instance.status = MissionStatus.Accomplished;
		MissionEnded(instance, assignee);
		MissionComplete(instance, assignee);
		Interface.CallHook("OnMissionSucceeded", this, instance, assignee);
	}

```

## OnVehicleModuleMove(BaseVehicleModule,BaseModularVehicle,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is moved by a player.
/// </summary>
/// <param name="module">The vehicle module being moved.</param>
/// <param name="vehicle">The vehicle that contains the module.</param>
/// <param name="player">The player attempting to move the module.</param>
/// <returns>
/// Returns `true` if the module can be moved, `false` if it cannot be moved, 
/// or `null` to allow the default game logic to determine the outcome.
/// </returns>
object OnVehicleModuleMove(BaseVehicleModule module, BaseModularVehicle vehicle, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to move module {module.moduleName} from vehicle {vehicle.net.ID}.");

    if (module.IsLocked)
    {
        Puts($"Module {module.moduleName} is locked and cannot be moved.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		BaseVehicleModule moduleForItem = GetModuleForItem(item);
		if (moduleForItem != null)
		{
			object obj = Interface.CallHook("OnVehicleModuleMove", moduleForItem, this, player);
			if (obj != null)
			{
				if (!(obj is bool))
				{
					return false;
				}
				return (bool)obj;
			}
			return moduleForItem.CanBeMovedNow();
		}
		return true;
	}

```

## CanNetworkTo(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether this player can network to another player.
/// </summary>
/// <param name="sourcePlayer">The player attempting to network.</param>
/// <param name="targetPlayer">The player to which the network connection is being evaluated.</param>
/// <returns>
/// Returns `true` if the source player can network to the target player; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine the networking conditions.
/// </returns>
bool? CanNetworkTo(BasePlayer sourcePlayer, BasePlayer targetPlayer)
{
    Puts($"Checking network connection from {sourcePlayer.displayName} to {targetPlayer.displayName}.");

    if (targetPlayer.IsDead())
    {
        Puts($"Cannot network to {targetPlayer.displayName} because they are dead.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return true;
		}
		if (IsSpectating() && player != this)
		{
			return false;
		}
		bool flag = base.ShouldNetworkTo(player);
		if (ServerOcclusion.OcclusionEnabled && flag)
		{
			flag = OcclusionLineOfSight(player);
		}
		return flag;
	}

```

## OnTerrainCreate(TerrainGenerator)

```csharp
```csharp
/// <summary>
/// Called when a new terrain is being created.
/// </summary>
/// <param name="generator">The terrain generator responsible for creating the terrain.</param>
/// <returns>No return behavior.</returns>
void OnTerrainCreate(TerrainGenerator generator)
{
    Puts($"Creating terrain with generator: {generator.GetType().Name}");
    // Additional logic can be added here if needed for terrain creation.
}
```
```

### Source Code from the Library

```csharp

	public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
	{
		Interface.CallHook("OnTerrainCreate", this);
		Terrain component = Terrain.CreateTerrainGameObject(new TerrainData
		{
			baseMapResolution = GetBaseMapRes(),
			heightmapResolution = heightmapResolution,
			alphamapResolution = alphamapResolution,
			size = new Vector3(World.Size, 1000f, World.Size)
		}).GetComponent<Terrain>();
		component.transform.position = base.transform.position + new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);
		component.drawInstanced = false;
		component.castShadows = config.CastShadows;
		component.materialType = Terrain.MaterialType.Custom;
		component.materialTemplate = config.Material;
		component.gameObject.tag = base.gameObject.tag;
		component.gameObject.layer = base.gameObject.layer;
		component.gameObject.GetComponent<TerrainCollider>().sharedMaterial = config.GenericMaterial;
		TerrainMeta terrainMeta = component.gameObject.AddComponent<TerrainMeta>();
		component.gameObject.AddComponent<TerrainPhysics>();
		component.gameObject.AddComponent<TerrainColors>();
		component.gameObject.AddComponent<TerrainCollision>();
		component.gameObject.AddComponent<TerrainBiomeMap>();
		component.gameObject.AddComponent<TerrainAlphaMap>();
		component.gameObject.AddComponent<TerrainHeightMap>();
		component.gameObject.AddComponent<TerrainSplatMap>();
		component.gameObject.AddComponent<TerrainTopologyMap>();
		component.gameObject.AddComponent<TerrainWaterMap>();
		component.gameObject.AddComponent<TerrainPlacementMap>();
		component.gameObject.AddComponent<TerrainPath>();
		component.gameObject.AddComponent<TerrainTexturing>();
		terrainMeta.terrain = component;
		terrainMeta.config = config;
		Object.DestroyImmediate(base.gameObject);
		return component.gameObject;
	}

```

## OnCupboardProtectionCalculated(BuildingPrivlidge,float)

```csharp
```csharp
/// <summary>
/// Called when the cupboard protection time is calculated.
/// </summary>
/// <param name="cupboard">The building privilege associated with the cupboard.</param>
/// <param name="protectedMinutes">The calculated protected minutes for the cupboard.</param>
/// <returns>No return behavior.</returns>
void OnCupboardProtectionCalculated(BuildingPrivlidge cupboard, float protectedMinutes)
{
    Puts($"Cupboard protection calculated: {protectedMinutes} minutes for cupboard at {cupboard.transform.position}.");
    
    if (protectedMinutes < 10f)
    {
        Puts("Warning: Cupboard protection is below the minimum threshold!");
    }
}
```
```

### Source Code from the Library

```csharp

	public float GetProtectedMinutes(bool force = false)
	{
		if (base.isServer)
		{
			if (!force && UnityEngine.Time.realtimeSinceStartup < nextProtectedCalcTime)
			{
				return cachedProtectedMinutes;
			}
			nextProtectedCalcTime = UnityEngine.Time.realtimeSinceStartup + 60f;
			List<ItemAmount> obj = Facepunch.Pool.Get<List<ItemAmount>>();
			CalculateUpkeepCostAmounts(obj);
			float num = CalculateUpkeepPeriodMinutes();
			float num2 = -1f;
			if (base.inventory != null)
			{
				foreach (ItemAmount item in obj)
				{
					int num3 = base.inventory.FindItemsByItemID(item.itemid).Sum((Item x) => x.amount);
					if (num3 > 0 && item.amount > 0f)
					{
						float num4 = (float)num3 / item.amount * num;
						if (num2 == -1f || num4 < num2)
						{
							num2 = num4;
						}
					}
					else
					{
						num2 = 0f;
					}
				}
				if (num2 == -1f)
				{
					num2 = 0f;
				}
			}
			Facepunch.Pool.FreeUnmanaged(ref obj);
			cachedProtectedMinutes = num2;
			Interface.CallHook("OnCupboardProtectionCalculated", this, cachedProtectedMinutes);
			return cachedProtectedMinutes;
		}
		return 0f;
	}

```

## OnBonusItemDrop(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is dropped for a player after an action.
/// </summary>
/// <param name="item">The bonus item that is being dropped.</param>
/// <param name="player">The player who is receiving the bonus item.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being dropped, or `null` to allow the drop to proceed.
/// </returns>
object OnBonusItemDrop(Item item, BasePlayer player)
{
    Puts($"Bonus item {item.info.displayName.english} is being dropped for player {player.displayName} (ID: {player.UserIDString}).");

    if (player.inventory.GetAmount(item.info.itemid) >= 100)
    {
        Puts($"Player {player.displayName} cannot receive more of {item.info.displayName.english} as they already have enough.");
        return "Inventory full for this item.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnFireBallDamage(FireBall,BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a fireball inflicts damage on a target entity.
/// </summary>
/// <param name="fireball">The fireball that is causing the damage.</param>
/// <param name="target">The target entity that is being damaged.</param>
/// <param name="hitInfo">Information about the hit, including damage type and position.</param>
/// <returns>No return behavior.</returns>
void OnFireBallDamage(FireBall fireball, BaseCombatEntity target, HitInfo hitInfo)
{
    Puts($"Fireball from {fireball.creatorEntity?.name ?? "unknown"} hit {target.name} for {hitInfo.damageTypes.Get(DamageType.Heat)} damage.");
    
    if (target is BasePlayer player)
    {
        Puts($"Player {player.displayName} is taking fire damage!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoRadialDamage()
	{
		List<BaseCombatEntity> obj = Pool.Get<List<BaseCombatEntity>>();
		Vector3 position = base.transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Entities(position, radius, obj, AttackLayers, QueryTriggerInteraction.Ignore);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = ((creatorEntity == null) ? GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);
		hitInfo.PointStart = base.transform.position;
		foreach (BaseCombatEntity item in obj)
		{
			if (!(item == null) && item.isServer && item.IsAlive() && (!ignoreNPC || !item.IsNpc) && item.IsVisible(position))
			{
				if (item is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", item, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = item.transform.position;
				hitInfo.HitPositionWorld = item.transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", this, item, hitInfo);
				item.OnAttacked(hitInfo);
			}
		}
		Pool.FreeUnmanaged(ref obj);
	}

```

## OnPhoneNameUpdated(PhoneController,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's phone name is updated.
/// </summary>
/// <param name="phoneController">The phone controller that manages the phone.</param>
/// <param name="newName">The new name for the phone.</param>
/// <param name="player">The player who updated the phone name.</param>
/// <returns>No return behavior.</returns>
void OnPhoneNameUpdated(PhoneController phoneController, string newName, BasePlayer player)
{
    Puts($"Player {player.displayName} updated their phone name to: {newName}");
    
    if (newName == "Emergency")
    {
        Puts("Warning: Player has set their phone name to 'Emergency'.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!(msg.player != currentPlayer))
		{
			string text = msg.read.String();
			if (text.Length > 20)
			{
				text = text.Substring(0, 20);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", this, text, msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", this, PhoneName, msg.player);
			}
		}
	}

```

## OnLiquidVesselFill(BaseLiquidVessel,BasePlayer,LiquidContainer)

```csharp
```csharp
/// <summary>
/// Called when a liquid vessel is filled by a player or a liquid container.
/// </summary>
/// <param name="vessel">The liquid vessel being filled.</param>
/// <param name="player">The player attempting to fill the vessel.</param>
/// <param name="liquidContainer">The liquid container being used to fill the vessel.</param>
/// <returns>
/// Returns a non-null value to prevent the filling action, or `null` to allow it.
/// </returns>
object OnLiquidVesselFill(BaseLiquidVessel vessel, BasePlayer player, LiquidContainer liquidContainer)
{
    Puts($"Player {player.displayName} is attempting to fill the vessel with liquid from {liquidContainer?.name ?? "world"}.");

    if (liquidContainer != null && !liquidContainer.HasLiquidItem())
    {
        Puts($"Filling failed: {liquidContainer.name} has no liquid.");
        return "No liquid available in the container.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FillCheck()
	{
		if (base.isClient)
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		float f = (UnityEngine.Time.realtimeSinceStartup - lastFillTime) * fillMlPerSec;
		Vector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);
		LiquidContainer facingLiquidContainer = GetFacingLiquidContainer();
		if (Interface.CallHook("OnLiquidVesselFill", this, ownerPlayer, facingLiquidContainer) != null)
		{
			return;
		}
		if (facingLiquidContainer == null && CanFillFromWorld())
		{
			Item contents = GetContents();
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(pos);
			if (contents != null && contents.info.itemid != itemDefinition.itemid)
			{
				if ((float)timeSinceLastToast > 5f)
				{
					Debug.Log("pushing toast");
					timeSinceLastToast = 0f;
					ownerPlayer.ShowToast(GameTip.Styles.Red_Normal, DifferentLiquidType, false);
				}
				return;
			}
			AddLiquid(itemDefinition, Mathf.FloorToInt(f));
		}
		else if (facingLiquidContainer != null && facingLiquidContainer.HasLiquidItem())
		{
			int num = Mathf.CeilToInt((1f - HeldFraction()) * (float)MaxHoldable());
			if (num > 0)
			{
				GetContents();
				Item liquidItem = facingLiquidContainer.GetLiquidItem();
				int num2 = Mathf.Min(Mathf.CeilToInt(f), Mathf.Min(liquidItem.amount, num));
				AddLiquid(liquidItem.info, num2);
				liquidItem.UseItem(num2);
				facingLiquidContainer.OpenTap(2f);
			}
		}
		lastFillTime = UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnTurretModeToggle(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the turret mode is toggled by a player.
/// </summary>
/// <param name="turret">The auto turret whose mode is being toggled.</param>
/// <param name="player">The player who is toggling the turret mode.</param>
/// <returns>
/// Returns `null` to allow the mode toggle, or any non-null value to prevent the toggle action.
/// </returns>
object OnTurretModeToggle(AutoTurret turret, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) toggled turret mode for turret ID: {turret.net.ID}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} is allowed to toggle turret mode.");
        return null;
    }
    
    Puts($"Player {player.displayName} is not authorized to toggle turret mode.");
    return "You are not authorized to toggle this turret.";
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SERVER_Peacekeeper(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player) && Interface.CallHook("OnTurretModeToggle", this, rpc.player) == null)
		{
			SetPeacekeepermode(isOn: true);
		}
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player performs a melee attack.
/// </summary>
/// <param name="attacker">The player who is attacking.</param>
/// <param name="hitInfo">Information about the hit, including the target and damage details.</param>
/// <returns>
/// Returns `null` to allow the attack to proceed, or any non-null value to prevent the attack.
/// </returns>
object OnMeleeAttack(BasePlayer attacker, HitInfo hitInfo)
{
    Puts($"Player {attacker.displayName} is attempting a melee attack on {hitInfo.HitEntity?.ShortPrefabName ?? "an unknown target"}.");

    if (hitInfo.HitEntity is BasePlayer targetPlayer && targetPlayer.IsSleeping())
    {
        Puts($"Player {attacker.displayName} cannot attack a sleeping player.");
        return "Cannot attack sleeping players.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo obj = Facepunch.Pool.Get<HitInfo>();
			obj.LoadFromAttack(playerAttack.attack, serverSide: true);
			obj.Initiator = player;
			obj.Weapon = this;
			obj.WeaponPrefab = this;
			obj.Predicted = msg.connection;
			obj.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, obj) != null)
			{
				return;
			}
			if (obj.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.LogInvalid(obj, "melee_nan");
				return;
			}
			BaseEntity hitEntity = obj.HitEntity;
			BasePlayer basePlayer = obj.HitEntity as BasePlayer;
			bool flag = basePlayer != null;
			bool flag2 = flag && basePlayer.IsSleeping();
			bool flag3 = flag && basePlayer.IsWounded();
			bool flag4 = flag && basePlayer.isMounted;
			bool flag5 = flag && basePlayer.HasParent();
			bool flag6 = hitEntity != null;
			bool flag7 = flag6 && hitEntity.IsNpc;
			bool flag8;
			int num5;
			Vector3 center;
			Vector3 position;
			Vector3 pointStart;
			Vector3 hitPositionWorld;
			Vector3 vector;
			int num16;
			if (ConVar.AntiHack.melee_protection > 0)
			{
				flag8 = true;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTimeClamped + num2 + num3) * num;
				num5 = 1075904512;
				if (ConVar.AntiHack.melee_terraincheck)
				{
					num5 |= 0x800000;
				}
				if (ConVar.AntiHack.melee_vehiclecheck)
				{
					num5 |= 0x8000000;
				}
				if (flag && obj.boneArea == (HitArea)(-1))
				{
					string shortPrefabName2 = base.ShortPrefabName;
					string shortPrefabName3 = basePlayer.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.MeleeHack, "Bone is invalid  (" + shortPrefabName2 + " on " + shortPrefabName3 + " bone " + obj.HitBone + ")");
					player.stats.combat.LogInvalid(obj, "melee_bone");
					flag8 = false;
				}
				if (ConVar.AntiHack.melee_protection >= 2)
				{
					if (flag6)
					{
						float num6 = hitEntity.MaxVelocity() + hitEntity.GetParentVelocity().magnitude;
						float num7 = hitEntity.BoundsPadding() + num4 * num6;
						float num8 = hitEntity.Distance(obj.HitPositionWorld);
						if (num8 > num7)
						{
							string shortPrefabName4 = base.ShortPrefabName;
							string shortPrefabName5 = hitEntity.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num8 + "m > " + num7 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(obj, "melee_target");
							flag8 = false;
						}
					}
					if (ConVar.AntiHack.melee_protection >= 4 && flag8 && flag && !flag7 && !flag2 && !flag3 && !flag4 && !flag5)
					{
						float magnitude = basePlayer.GetParentVelocity().magnitude;
						float num9 = basePlayer.BoundsPadding() + num4 * magnitude + ConVar.AntiHack.tickhistoryforgiveness;
						float num10 = basePlayer.tickHistory.Distance(basePlayer, obj.HitPositionWorld);
						if (num10 > num9)
						{
							string shortPrefabName6 = base.ShortPrefabName;
							string shortPrefabName7 = basePlayer.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.MeleeHack, "Player too far away (" + shortPrefabName6 + " on " + shortPrefabName7 + " with " + num10 + "m > " + num9 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(obj, "player_distance");
							flag8 = false;
						}
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					if (ConVar.AntiHack.melee_protection >= 4)
					{
						float magnitude2 = player.GetParentVelocity().magnitude;
						float num11 = player.BoundsPadding() + num4 * magnitude2 + num * maxDistance;
						float num12 = player.tickHistory.Distance(player, obj.HitPositionWorld);
						if (num12 > num11)
						{
							string shortPrefabName8 = base.ShortPrefabName;
							string text = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName8 + " on " + text + " with " + num12 + "m > " + num11 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(obj, "melee_initiator");
							flag8 = false;
						}
					}
					else
					{
						float num13 = player.MaxVelocity() + player.GetParentVelocity().magnitude;
						float num14 = player.BoundsPadding() + num4 * num13 + num * maxDistance;
						float num15 = player.Distance(obj.HitPositionWorld);
						if (num15 > num14)
						{
							string shortPrefabName9 = base.ShortPrefabName;
							string text2 = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName9 + " on " + text2 + " with " + num15 + "m > " + num14 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(obj, "melee_initiator");
							flag8 = false;
						}
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					if (flag6)
					{
						center = player.eyes.center;
						position = player.eyes.position;
						pointStart = obj.PointStart;
						hitPositionWorld = obj.HitPositionWorld;
						hitPositionWorld -= (hitPositionWorld - pointStart).normalized * 0.001f;
						vector = obj.PositionOnRay(hitPositionWorld);
						Vector3 vector2 = Vector3.zero;
						Vector3 vector3 = Vector3.zero;
						Vector3 vector4 = Vector3.zero;
						if (ConVar.AntiHack.melee_backtracking > 0f)
						{
							vector2 = (position - center).normalized * ConVar.AntiHack.melee_backtracking;
							vector3 = (pointStart - position).normalized * ConVar.AntiHack.melee_backtracking;
							vector4 = (vector - pointStart).normalized * ConVar.AntiHack.melee_backtracking;
						}
						if (GamePhysics.LineOfSight(center - vector2, position + vector2, num5) && GamePhysics.LineOfSight(position - vector3, pointStart + vector3, num5) && GamePhysics.LineOfSight(pointStart - vector4, vector, num5))
						{
							num16 = (GamePhysics.LineOfSight(vector, hitPositionWorld, num5) ? 1 : 0);
							if (num16 != 0)
							{
								player.stats.Add("hit_" + hitEntity.Categorize() + "_direct_los", 1, Stats.Server);
								goto IL_07c7;
							}
						}
						else
						{
							num16 = 0;
						}
						player.stats.Add("hit_" + hitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
						goto IL_07c7;
					}
					goto IL_08b5;
				}
				goto IL_0a1c;
			}
			goto IL_0a2e;
			IL_07c7:
			if (num16 == 0)
			{
				string shortPrefabName10 = base.ShortPrefabName;
				string shortPrefabName11 = hitEntity.ShortPrefabName;
				string[] obj2 = new string[14]
				{
					"Line of sight (", shortPrefabName10, " on ", shortPrefabName11, ") ", null, null, null, null, null,
					null, null, null, null
				};
				Vector3 vector5 = center;
				obj2[5] = vector5.ToString();
				obj2[6] = " ";
				vector5 = position;
				obj2[7] = vector5.ToString();
				obj2[8] = " ";
				vector5 = pointStart;
				obj2[9] = vector5.ToString();
				obj2[10] = " ";
				vector5 = vector;
				obj2[11] = vector5.ToString();
				obj2[12] = " ";
				vector5 = hitPositionWorld;
				obj2[13] = vector5.ToString();
				AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj2));
				player.stats.combat.LogInvalid(obj, "melee_los");
				flag8 = false;
			}
			goto IL_08b5;
			IL_0a2e:
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50))
			{
				DoAttackShared(obj);
			}
			Facepunch.Pool.Free(ref obj);
			return;
			IL_0a1c:
			if (!flag8)
			{
				AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
				return;
			}
			goto IL_0a2e;
			IL_08b5:
			if (flag8 && flag && !flag7)
			{
				Vector3 hitPositionWorld2 = obj.HitPositionWorld;
				Vector3 position2 = basePlayer.eyes.position;
				Vector3 vector6 = basePlayer.CenterPoint();
				float melee_losforgiveness = ConVar.AntiHack.melee_losforgiveness;
				bool flag9 = GamePhysics.LineOfSight(hitPositionWorld2, position2, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(position2, hitPositionWorld2, num5, melee_losforgiveness, 0f);
				if (!flag9)
				{
					flag9 = GamePhysics.LineOfSight(hitPositionWorld2, vector6, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(vector6, hitPositionWorld2, num5, melee_losforgiveness, 0f);
				}
				if (!flag9)
				{
					string shortPrefabName12 = base.ShortPrefabName;
					string shortPrefabName13 = basePlayer.ShortPrefabName;
					string[] obj3 = new string[12]
					{
						"Line of sight (", shortPrefabName12, " on ", shortPrefabName13, ") ", null, null, null, null, null,
						null, null
					};
					Vector3 vector5 = hitPositionWorld2;
					obj3[5] = vector5.ToString();
					obj3[6] = " ";
					vector5 = position2;
					obj3[7] = vector5.ToString();
					obj3[8] = " or ";
					vector5 = hitPositionWorld2;
					obj3[9] = vector5.ToString();
					obj3[10] = " ";
					vector5 = vector6;
					obj3[11] = vector5.ToString();
					AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj3));
					player.stats.combat.LogInvalid(obj, "melee_los");
					flag8 = false;
				}
			}
			goto IL_0a1c;
		}
	}

```

## OnTeamLeave(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player leaves a team.
/// </summary>
/// <param name="team">The team that the player is leaving.</param>
/// <param name="player">The player who is leaving the team.</param>
/// <returns>
/// Returns `null` to allow the player to leave the team, or any non-null value to prevent the action.
/// </returns>
object OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has left the team {team.TeamID}.");
    
    if (player.IsBannedFromTeam(team.TeamID))
    {
        Puts($"Player {player.displayName} is banned from leaving team {team.TeamID}.");
        return "You are banned from leaving this team.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void leaveteam(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam != 0L)
		{
			PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
			if (playerTeam != null && Interface.CallHook("OnTeamLeave", playerTeam, basePlayer) == null)
			{
				playerTeam.RemovePlayer(basePlayer.userID);
				basePlayer.ClearTeam();
			}
		}
	}

```

## OnMapMarkerRemove(BasePlayer,System.Collections.Generic.List<ProtoBuf.MapNote>,int)

```csharp
```csharp
/// <summary>
/// Called when a player removes a map marker from their map.
/// </summary>
/// <param name="player">The player who is removing the map marker.</param>
/// <param name="markers">The list of current map markers.</param>
/// <param name="index">The index of the marker to be removed.</param>
/// <returns>
/// Returns `null` to allow the removal of the marker, or any non-null value to prevent it.
/// </returns>
object OnMapMarkerRemove(BasePlayer player, List<ProtoBuf.MapNote> markers, int index)
{
    Puts($"Player {player.displayName} is attempting to remove map marker at index {index}.");

    if (index < 0 || index >= markers.Count)
    {
        Puts($"Invalid index {index} for player {player.displayName}. No marker removed.");
        return "Invalid marker index.";
    }

    Puts($"Map marker at index {index} removed by player {player.displayName}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server.FromOwner]
	[RPC_Server]
	public void Server_RemovePointOfInterest(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (State.pointsOfInterest != null && State.pointsOfInterest.Count > num && num >= 0 && Interface.CallHook("OnMapMarkerRemove", this, State.pointsOfInterest, num) == null)
		{
			State.pointsOfInterest[num].Dispose();
			State.pointsOfInterest.RemoveAt(num);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
		}
	}

```

## OnEntityControl(AutoTurret,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can control the specified auto turret.
/// </summary>
/// <param name="turret">The auto turret being controlled.</param>
/// <param name="playerId">The ID of the player attempting to control the turret.</param>
/// <returns>
/// Returns `true` if the player can control the turret; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine control permissions.
/// </returns>
bool? OnEntityControl(AutoTurret turret, ulong playerId)
{
    Puts($"Player with ID {playerId} is attempting to control the turret {turret.net.ID}.");

    if (turret.IsPowered() && !turret.PeacekeeperMode())
    {
        Puts($"Player {playerId} can control the turret.");
        return true;
    }

    Puts($"Player {playerId} cannot control the turret due to power or peacekeeper mode.");
    return false;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", this, playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (booting)
		{
			return false;
		}
		if (IsPowered())
		{
			return !PeacekeeperMode();
		}
		return false;
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player is hurt by an attack.
/// </summary>
/// <param name="player">The player who is being hurt.</param>
/// <param name="info">Information about the hit, including damage types and initiator.</param>
/// <returns>
/// Returns a non-null value to prevent further processing of the hurt event. 
/// If `null` is returned, the default hurt logic will proceed.
/// </returns>
object IOnBasePlayerHurt(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.displayName} is being hurt by {info.InitiatorPlayer?.displayName ?? "unknown"} with damage: {info.damageTypes.Total()}.");

    if (info.damageTypes.Has(DamageType.Explosion))
    {
        Puts($"Explosion damage detected on player {player.displayName}.");
        return "Explosion damage is not allowed.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || IsTransferProtected() || (IsImmortalTo(info) && info.damageTypes.Total() >= 0f) || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && !IsNpc && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		if (info.damageTypes.Has(DamageType.Fun_Water))
		{
			bool flag = true;
			Item activeItem = GetActiveItem();
			if (activeItem != null && (activeItem.info.shortname == "gun.water" || activeItem.info.shortname == "pistol.water"))
			{
				float value = metabolism.wetness.value;
				metabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);
				bool flag2 = metabolism.wetness.value >= ConVar.Server.funWaterDamageThreshold;
				flag = !flag2;
				if (info.InitiatorPlayer != null)
				{
					if (flag2 && value < ConVar.Server.funWaterDamageThreshold)
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_SOAKED");
					}
					if (metabolism.radiation_level.Fraction() > 0.2f && !string.IsNullOrEmpty("SUMMER_RADICAL"))
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_RADICAL");
					}
				}
			}
			if (flag)
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
		}
		if (info.damageTypes.Get(DamageType.Drowned) > 5f && drownEffect.isValid)
		{
			Effect.server.Run(drownEffect.resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
		if (modifiers != null)
		{
			if (info.damageTypes.Has(DamageType.Radiation))
			{
				info.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));
			}
			if (info.damageTypes.Has(DamageType.RadiationExposure))
			{
				info.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));
			}
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((bool)initiatorPlayer && initiatorPlayer != this)
		{
			if (initiatorPlayer.InSafeZone() || InSafeZone())
			{
				initiatorPlayer.MarkHostileFor(300f);
			}
			if (initiatorPlayer.InSafeZone() && !initiatorPlayer.IsNpc)
			{
				info.damageTypes.ScaleAll(0f);
				return;
			}
			if (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(DamageType.Explosion) > 0f)
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);
			}
		}
		base.Hurt(info);
		if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
		{
			BasePlayer instigator = info?.InitiatorPlayer;
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerHurt(instigator, this, info);
		}
		if (IsRestrained && info.damageTypes.GetMajorityDamageType().InterruptsRestraintMinigame())
		{
			Handcuffs handcuffs = GetHeldEntity() as Handcuffs;
			if (handcuffs != null)
			{
				handcuffs.InterruptUnlockMiniGame(wasPushedOrDamaged: true);
			}
		}
		EACServer.LogPlayerTakeDamage(this, info);
		metabolism.SendChangesToClient();
		if (info.PointStart != Vector3.zero && (info.damageTypes.Total() >= 0f || IsGod()))
		{
			int arg = (int)info.damageTypes.GetMajorityDamageType();
			if (info.Weapon != null && info.damageTypes.Has(DamageType.Bullet))
			{
				BaseProjectile component = info.Weapon.GetComponent<BaseProjectile>();
				if (component != null && component.IsSilenced())
				{
					arg = 12;
				}
			}
			ClientRPC(RpcTarget.PlayerAndSpectators("DirectionalDamage", this), info.PointStart, arg, Mathf.CeilToInt(info.damageTypes.Total()));
		}
		DeathBlow.From(info, out cachedNonSuicideHit);
	}

```

## OnResearchCostDetermine(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the scrap cost for researching an item.
/// </summary>
/// <param name="item">The item for which the research cost is being determined.</param>
/// <returns>
/// Returns the amount of scrap required to research the item. 
/// If the method returns `null`, the default research cost logic will be applied.
/// </returns>
int OnResearchCostDetermine(Item item)
{
    Puts($"Determining research cost for item: {item.info.displayName.english} (ID: {item.info.itemid})");
    
    // Example condition to override default research cost
    if (item.info.itemid == 12345) // Replace with actual item ID
    {
        Puts("Custom research cost applied for this item.");
        return 50; // Custom scrap cost
    }

    return 0; // Default case, no custom cost applied
}
```
```

### Source Code from the Library

```csharp

	public static int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", item);
		if (obj is int)
		{
			return (int)obj;
		}
		return ScrapForResearch(item.info);
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves a trigger area.
/// </summary>
/// <param name="entity">The entity that has left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.displayName} (ID: {entity.net.ID}) has left the trigger area: {trigger.name}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			entityContents.Remove(ent);
			OnEntityLeaveTrigger?.Invoke(ent);
		}
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Determines whether a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="buildingBlock">The building block whose grade is being changed.</param>
/// <param name="newGrade">The new grade to which the building block is being changed.</param>
/// <param name="skinId">The skin ID for the building block.</param>
/// <returns>
/// Returns `true` if the player can change the grade, `false` if they cannot, 
/// or `null` if the default game logic should be used to determine the outcome.
/// </returns>
bool? CanChangeGrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum newGrade, ulong skinId)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to change grade to {newGrade} for {buildingBlock.name}.");

    if (newGrade == BuildingGrade.Enum.Stone)
    {
        Puts($"Player {player.displayName} is not allowed to change to stone grade.");
        return false;
    }

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can change grades freely.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade, iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (HasUpgradePrivilege(iGrade, iSkin, player))
		{
			return !IsUpgradeBlocked();
		}
		return false;
	}

```

## OnVehicleModulesAssign(ModularCar,Rust.Modular.ItemModVehicleModule[])

```csharp
```csharp
/// <summary>
/// Called when modules are assigned to a modular vehicle.
/// </summary>
/// <param name="vehicle">The modular vehicle to which modules are being assigned.</param>
/// <param name="modules">An array of vehicle modules being assigned to the vehicle.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModulesAssign(ModularCar vehicle, Rust.Modular.ItemModVehicleModule[] modules)
{
    Puts($"Assigning modules to vehicle ID: {vehicle.net.ID} with {modules.Length} modules.");

    foreach (var module in modules)
    {
        Puts($"Module assigned: {module?.GetType().Name ?? "Unknown Module"}");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", this, modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				Item item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);
				float num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", this, modularCarPresetConfig.socketItemDefs);
		Invoke(HandleAdminBonus, 0f);
	}

```

## CanBeHomingTargeted(RoadFlare)

```csharp
```csharp
/// <summary>
/// Determines whether the specified road flare can be targeted by homing missiles.
/// </summary>
/// <param name="flare">The road flare to check for homing missile targeting.</param>
/// <returns>
/// Returns `true` if the road flare can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the flare can be targeted.
/// </returns>
bool? CanBeHomingTargeted(RoadFlare flare)
{
    Puts($"Checking homing target status for Road Flare ID: {flare.net.ID}, Position: {flare.transform.position}");
    return true; // Allow targeting by default
}
```
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## IOnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to approve a user connection to the server.
/// </summary>
/// <param name="connection">The network connection of the user attempting to connect.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object IOnUserApprove(Network.Connection connection)
{
    Puts($"User {connection.userid} is attempting to connect with token: {connection.token}.");

    if (connection.token == "malicious_token")
    {
        Puts($"User {connection.userid} has been rejected due to a malicious token.");
        return "Connection rejected: Invalid token.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0L)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2564)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)");
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			ServerUsers.User user = ServerUsers.Get(connection.userid);
			string text = user?.notes ?? "no reason given";
			string text2 = ((user != null && user.expiry > 0) ? (" for " + (user.expiry - Epoch.Current).FormatSecondsLong()) : "");
			Reject(connection, "You are banned from this server" + text2 + " (" + text + ")");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log(connection.ToString() + " has auth level 1");
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log(connection.ToString() + " has auth level 2");
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log(connection.ToString() + " is a developer");
			connection.authLevel = 3u;
		}
		if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used, allowing for custom behavior before consumption.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amount">The amount to consume from the item.</param>
/// <returns>No return behavior.</returns>
void OnItemUse(Item item, int amount)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) is being used. Amount to consume: {amount}.");

    if (item.info.shortname == "healthkit")
    {
        Puts("Health kit is being used! Restoring health.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", this, amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## CanLootEntity(BasePlayer,IndustrialCrafter)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="crafter">The industrial crafter being looted.</param>
/// <returns>
/// Returns `true` if the player is allowed to loot the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, IndustrialCrafter crafter)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot the Industrial Crafter.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot loot while dead.");
        return false;
    }

    if (crafter.IsLocked())
    {
        Puts($"The Industrial Crafter is locked and cannot be looted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (NeedsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if (OnlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(_inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), LootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to loot another player.
/// </summary>
/// <param name="looter">The player who is looting.</param>
/// <param name="target">The player being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"{looter.displayName} is attempting to loot {target.displayName}.");
    
    if (target.IsDead())
    {
        Puts($"{target.displayName} has been successfully looted.");
    }
    else
    {
        Puts($"{target.displayName} is not dead and cannot be looted.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_LootPlayer(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))
		{
			player.inventory.loot.AddContainer(inventory.containerMain);
			player.inventory.loot.AddContainer(inventory.containerWear);
			player.inventory.loot.AddContainer(inventory.containerBelt);
			Interface.CallHook("OnLootPlayer", this, player);
			player.inventory.loot.SendImmediate();
			player.RadioactiveLootCheck(player.inventory.loot.containers);
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "player_corpse");
		}
	}

```

## OnTurretAssigned(AutoTurret,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is assigned to a player.
/// </summary>
/// <param name="turret">The turret that is being assigned.</param>
/// <param name="playerId">The unique identifier of the player to whom the turret is assigned.</param>
/// <param name="player">The player who is being assigned to the turret.</param>
/// <returns>No return behavior.</returns>
void OnTurretAssigned(AutoTurret turret, ulong playerId, BasePlayer player)
{
    Puts($"Turret {turret.net.ID} has been assigned to player {player.displayName} (ID: {playerId}).");
    
    if (playerId == 0)
    {
        Puts("Attempted to assign turret to an invalid player ID.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", this, num, msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = num;
			playerNameID.username = username;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(playerNameID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", this, num, msg.player);
		}
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when an auto turret is shutting down.
/// </summary>
/// <param name="turret">The auto turret that is shutting down.</param>
/// <returns>No return behavior.</returns>
void OnTurretShutdown(AutoTurret turret)
{
    Puts($"Auto turret {turret.net.ID} is shutting down.");
    if (turret.IsOffline())
    {
        Puts($"Turret {turret.net.ID} is already offline.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if ((!IsOffline() || booting) && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			CancelInvoke(SetOnline);
			booting = false;
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## OnSurveyGather(SurveyCharge,Item)

```csharp
```csharp
/// <summary>
/// Called when resources are gathered from a survey charge explosion.
/// </summary>
/// <param name="surveyCharge">The survey charge that triggered the gathering.</param>
/// <param name="item">The item that was gathered as a result of the survey.</param>
/// <returns>No return behavior.</returns>
void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts($"Survey charge at {surveyCharge.transform.position} gathered item: {item.info.displayName.english} (ID: {item.info.itemid})");
    
    if (item.info.shortname == "scrap")
    {
        Puts("Scrap has been gathered from the survey!");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		base.Explode();
		if (WaterLevel.Test(base.transform.position, waves: true, volumes: true, this))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))
		{
			return;
		}
		Vector3 point = hitOut.point;
		_ = hitOut.normal;
		List<SurveyCrater> obj = Pool.Get<List<SurveyCrater>>();
		Vis.Entities(base.transform.position, 10f, obj, 1);
		bool num = obj.Count > 0;
		Pool.FreeUnmanaged(ref obj);
		if (num)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag = true;
				if (resource.isLiquid)
				{
					flag2 = true;
				}
				for (int i = 0; i < num2; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", this, item);
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);
					item.Drop(base.transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
				}
			}
		}
		if (flag)
		{
			string strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);
			BaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if ((bool)baseEntity)
			{
				baseEntity.Spawn();
			}
		}
	}

```

## OnPlayerMarkersSend(BasePlayer,ProtoBuf.MapNoteList)

```csharp
```csharp
/// <summary>
/// Called when sending player markers to the client.
/// </summary>
/// <param name="player">The player receiving the markers.</param>
/// <param name="mapNoteList">The list of map notes to be sent to the client.</param>
/// <returns>No return behavior.</returns>
void OnPlayerMarkersSend(BasePlayer player, ProtoBuf.MapNoteList mapNoteList)
{
    Puts($"Sending {mapNoteList.notes.Count} markers to player {player.displayName} (ID: {player.UserIDString}).");
    
    if (mapNoteList.notes.Count == 0)
    {
        Puts($"No markers available to send to player {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SendMarkersToClient()
	{
		using MapNoteList mapNoteList = Facepunch.Pool.Get<MapNoteList>();
		mapNoteList.notes = Facepunch.Pool.Get<List<MapNote>>();
		if (ServerCurrentDeathNote != null)
		{
			mapNoteList.notes.Add(ServerCurrentDeathNote);
		}
		if (State.pointsOfInterest != null)
		{
			mapNoteList.notes.AddRange(State.pointsOfInterest);
		}
		Interface.CallHook("OnPlayerMarkersSend", this, mapNoteList);
		ClientRPC(RpcTarget.Player("Client_ReceiveMarkers", this), mapNoteList);
		mapNoteList.notes.Clear();
	}

```

## OnInventoryAmmoFind(PlayerInventory,System.Collections.Generic.List<Item>,Rust.AmmoTypes)

```csharp
```csharp
/// <summary>
/// Called to find ammunition of a specified type in the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory where the search is conducted.</param>
/// <param name="ammoList">A list to populate with found ammunition items.</param>
/// <param name="ammoType">The type of ammunition to search for.</param>
/// <returns>No return behavior.</returns>
void OnInventoryAmmoFind(PlayerInventory inventory, List<Item> ammoList, AmmoTypes ammoType)
{
    Puts($"Searching for {ammoType} ammunition in inventory of player {inventory.Owner.displayName}.");
    
    // Example logic to handle specific ammo types
    if (ammoType == AmmoTypes.Rifle)
    {
        Puts("Rifle ammunition search initiated.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		if (Interface.CallHook("OnInventoryAmmoFind", this, list, ammoType) == null)
		{
			containerMain?.FindAmmo(list, ammoType);
			containerBelt?.FindAmmo(list, ammoType);
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player disconnects from the server.
/// </summary>
/// <param name="player">The player who has disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has disconnected. Reason: {reason}");
    
    if (reason == "timeout")
    {
        Puts($"Player {player.displayName} disconnected due to timeout.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void OnDisconnected(string strReason, Network.Connection connection)
	{
		Facepunch.Rust.Analytics.Azure.OnPlayerDisconnected(connection, strReason);
		GlobalNetworkHandler.server.OnClientDisconnected(connection);
		connectionQueue.TryAddReservedSlot(connection);
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		if (connection.authStatusSteam == "ok")
		{
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
		if (connection.authStatusNexus == "ok")
		{
			NexusServer.Logout(connection.userid);
		}
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player toggles the vending machine's broadcast setting.
/// </summary>
/// <param name="vendingMachine">The vending machine whose broadcast setting is being toggled.</param>
/// <param name="player">The player who toggled the broadcast setting.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) toggled the broadcast for vending machine {vendingMachine.net.ID}.");
    
    if (vendingMachine.HasFlag(Flags.Reserved4))
    {
        Puts("Broadcast is now enabled.");
    }
    else
    {
        Puts("Broadcast is now disabled.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## OnPhoneDialFail(PhoneController,Telephone.DialFailReason,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing attempt fails.
/// </summary>
/// <param name="phone">The phone controller that initiated the call.</param>
/// <param name="reason">The reason for the dialing failure.</param>
/// <param name="player">The player who attempted to make the call.</param>
/// <returns>
/// Returns `null` to allow the default failure handling, or any non-null value to override it.
/// </returns>
object OnPhoneDialFail(PhoneController phone, Telephone.DialFailReason reason, BasePlayer player)
{
    Puts($"Player {player.displayName} failed to dial with reason: {reason}.");
    
    if (reason == Telephone.DialFailReason.NoSignal)
    {
        Puts("Dial failed due to no signal. Please try again later.");
        return "No signal available.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", this, reason, currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientOnDialFailed"), (int)reason);
			activeCallTo = null;
			if (IsInvoking(TimeOutCall))
			{
				CancelInvoke(TimeOutCall);
			}
			if (IsInvoking(TriggerTimeOut))
			{
				CancelInvoke(TriggerTimeOut);
			}
			if (IsInvoking(TimeOutDialing))
			{
				CancelInvoke(TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", this, reason, currentPlayer);
		}
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has respawned.");
    
    if (player.IsWounded())
    {
        Puts($"Player {player.displayName} was wounded and has now respawned.");
    }
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity = null)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((bool)activeGameMode && !activeGameMode.CanPlayerRespawn(this))
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		respawnId = Guid.NewGuid().ToString("N");
		ServerPerformance.spawns++;
		SetParent(null, worldPositionStays: true);
		base.transform.SetPositionAndRotation(position, rotation);
		tickInterpolator.Reset(position);
		tickHistory.Reset(position);
		eyeHistory.Clear();
		estimatedVelocity = Vector3.zero;
		estimatedSpeed = 0f;
		estimatedSpeed2D = 0f;
		lastTickTime = 0f;
		StopWounded();
		ResetWoundingVars();
		StopSpectating();
		UpdateNetworkGroup();
		EnablePlayerCollider();
		RemovePlayerRigidbody();
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		if (modifiers != null)
		{
			modifiers.RemoveAll();
		}
		InitializeHealth(StartHealth(), StartMaxHealth());
		bool flag = false;
		if (ConVar.Server.respawnWithLoadout)
		{
			string infoString = GetInfoString("client.respawnloadout", string.Empty);
			if (!string.IsNullOrEmpty(infoString) && Inventory.LoadLoadout(infoString, out var so))
			{
				so.LoadItemsOnTo(this);
				flag = true;
			}
		}
		if (!flag)
		{
			inventory.GiveDefaultItems();
		}
		SendNetworkUpdateImmediate();
		ClientRPC(RpcTarget.Player("StartLoading", this));
		Facepunch.Rust.Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);
		if ((bool)activeGameMode)
		{
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);
		}
		if (IsConnected)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", this);
		ProcessMissionEvent(BaseMission.MissionEventType.RESPAWN, 0, 0f);
	}

```

## OnHelicopterStrafeEnter(PatrolHelicopterAI,UnityEngine.Vector3,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the helicopter begins a strafe maneuver targeting a player.
/// </summary>
/// <param name="helicopter">The helicopter initiating the strafe.</param>
/// <param name="targetPosition">The position of the target player.</param>
/// <param name="targetPlayer">The player being targeted by the helicopter.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterStrafeEnter(PatrolHelicopterAI helicopter, Vector3 targetPosition, BasePlayer targetPlayer)
{
    Puts($"Helicopter {helicopter.net.ID} is strafing towards player {targetPlayer.displayName} at position {targetPosition}.");
    
    if (targetPlayer.IsInSafeZone())
    {
        Puts($"Strafe action canceled: {targetPlayer.displayName} is in a safe zone.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		if (Interface.CallHook("OnHelicopterStrafeEnter", this, strafeTarget.transform.position, strafeTarget) == null)
		{
			strafe_target = strafeTarget;
			get_out_of_strafe_distance = UnityEngine.Random.Range(13f, 17f);
			if (CanUseNapalm() && shouldUseNapalm)
			{
				passNapalm = shouldUseNapalm;
				useNapalm = true;
				lastNapalmTime = UnityEngine.Time.realtimeSinceStartup;
			}
			lastStrafeTime = UnityEngine.Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			RefreshTargetPosition();
			numRocketsLeft = 12 + UnityEngine.Random.Range(-1, 1);
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafe_target_position, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

```

## OnFireworkDamage(BaseFirework,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a firework is damaged.
/// </summary>
/// <param name="firework">The firework that has been damaged.</param>
/// <param name="hitInfo">Information about the hit, including damage type and amount.</param>
/// <returns>
/// Returns `null` to allow the default damage behavior, or any non-null value to prevent further processing.
/// </returns>
object OnFireworkDamage(BaseFirework firework, HitInfo hitInfo)
{
    Puts($"Firework {firework.net.ID} was damaged with {hitInfo.damageTypes.Get(DamageType.Heat)} damage.");
    
    if (hitInfo.damageTypes.Has(DamageType.Explosion))
    {
        Puts("Firework damage caused by an explosion, triggering special effects.");
        // Additional logic for explosion damage can be added here.
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Interface.CallHook("OnFireworkDamage", this, info) == null && info.damageTypes.Has(DamageType.Heat))
		{
			StaggeredTryLightFuse();
		}
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is in hunt mode to determine its behavior.
/// </summary>
/// <param name="apc">The Bradley APC that is hunting.</param>
/// <returns>
/// Returns a non-null value to override the default hunting behavior. 
/// If `null` is returned, the APC will proceed with its normal hunting logic.
/// </returns>
object OnBradleyApcHunt(BradleyAPC apc)
{
    Puts($"Bradley APC (ID: {apc.net.ID}) is attempting to hunt for targets.");
    
    // Example condition to prevent hunting
    if (apc.IsUnderRepair)
    {
        Puts("Bradley APC is under repair and cannot hunt.");
        return true; // Prevents hunting
    }

    return null; // Allows normal hunting behavior
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			IAIPathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<IAIPathNode> nodes = Facepunch.Pool.Get<List<IAIPathNode>>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			IAIPathNode iAIPathNode = null;
			List<IAIPathNode> nearNodes = Facepunch.Pool.Get<List<IAIPathNode>>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<IAIPathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (IAIPathNode item2 in nearNodes)
			{
				Stack<IAIPathNode> path = new Stack<IAIPathNode>();
				if (targetInfo.entity.IsVisible(item2.Position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					iAIPathNode = item2;
				}
			}
			if (stack == null && nearNodes.Count > 0)
			{
				Stack<IAIPathNode> path2 = new Stack<IAIPathNode>();
				IAIPathNode iAIPathNode2 = nearNodes[UnityEngine.Random.Range(0, nearNodes.Count)];
				if (AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) && pathCost2 < num)
				{
					stack = path2;
					iAIPathNode = iAIPathNode2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].Position);
					}
				}
				foreach (IAIPathNode item3 in stack)
				{
					currentPath.Add(item3.Position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = iAIPathNode.Position;
			}
			Facepunch.Pool.FreeUnmanaged(ref nearNodes);
			Facepunch.Pool.FreeUnmanaged(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## OnRackedWeaponMount(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is mounted on a weapon rack.
/// </summary>
/// <param name="item">The weapon item being mounted.</param>
/// <param name="player">The player who is mounting the weapon.</param>
/// <param name="rack">The weapon rack where the weapon is being mounted.</param>
/// <returns>
/// Returns `true` if the weapon was successfully mounted, or `false` if it was not.
/// If a non-null value is returned from the hook, it will override the default behavior.
/// </returns>
bool OnRackedWeaponMount(Item item, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player.displayName} is attempting to mount weapon: {item.info.displayName.english} on the rack.");
    
    if (item.info.shortname == "pistol.revolver")
    {
        Puts("Revolvers cannot be mounted on this rack.");
        return false;
    }

    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", item, player, this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			Debug.LogWarning("no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if (player != null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", item, player, this);
		return true;
	}

```

## OnPlayerWantsMount(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player expresses a desire to mount a vehicle or mountable object.
/// </summary>
/// <param name="player">The player who wants to mount the object.</param>
/// <param name="mountable">The mountable object the player wants to interact with.</param>
/// <returns>No return behavior.</returns>
void OnPlayerWantsMount(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) wants to mount {mountable.GetType().Name}.");
    
    if (!player.IsValid())
    {
        Puts($"Player {player.displayName} is not a valid player.");
        return;
    }

    if (!player.CanInteract())
    {
        Puts($"Player {player.displayName} cannot interact with the mountable.");
        return;
    }
}
```
```

### Source Code from the Library

```csharp

	public void WantsMount(BasePlayer player)
	{
		if (!player.IsValid() || !player.CanInteract() || Interface.CallHook("OnPlayerWantsMount", player, this) != null)
		{
			return;
		}
		if (!DirectlyMountable())
		{
			BaseVehicle baseVehicle = VehicleParent();
			if (baseVehicle != null)
			{
				baseVehicle.WantsMount(player);
				return;
			}
		}
		AttemptMount(player);
	}

```

## OnDigitalClockRingStop(DigitalClock)

```csharp
```csharp
/// <summary>
/// Called when the digital clock stops ringing.
/// </summary>
/// <param name="clock">The digital clock that has stopped ringing.</param>
/// <returns>No return behavior.</returns>
void OnDigitalClockRingStop(DigitalClock clock)
{
    Puts($"Digital clock {clock.net.ID} has stopped ringing.");
}
```
```

### Source Code from the Library

```csharp

	private void StopRinging()
	{
		if (Interface.CallHook("OnDigitalClockRingStop", this) == null)
		{
			isRinging = false;
			ClientRPC(RpcTarget.NetworkGroup("RPC_StopRinging"));
			MarkDirty();
		}
	}

```

## OnEntityLoaded(BaseNetworkable,BaseNetworkable.LoadInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is loaded from a save file or during server startup.
/// </summary>
/// <param name="entity">The entity that is being loaded.</param>
/// <param name="loadInfo">The load information containing data about the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityLoaded(BaseNetworkable entity, BaseNetworkable.LoadInfo loadInfo)
{
    Puts($"Entity {entity.prefabID} is being loaded with LoadInfo: {loadInfo}");
    
    if (loadInfo.msg.baseNetworkable == null)
    {
        Puts("LoadInfo does not contain a valid BaseNetworkable.");
        return;
    }

    Puts($"Entity {entity.prefabID} loaded successfully.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Load(LoadInfo info)
	{
		if (info.msg.baseNetworkable != null)
		{
			LoadInfo loadInfo = info;
			Interface.CallHook("OnEntityLoaded", this, info);
			ProtoBuf.BaseNetworkable baseNetworkable = loadInfo.msg.baseNetworkable;
			if (prefabID != baseNetworkable.prefabID)
			{
				Debug.LogError("Prefab IDs don't match! " + prefabID + "/" + baseNetworkable.prefabID + " -> " + base.gameObject, base.gameObject);
			}
		}
	}

```

## OnBuildingSplit(BuildingManager.Building,uint)

```csharp
```csharp
/// <summary>
/// Called when a building is split into separate parts.
/// </summary>
/// <param name="building">The building that is being split.</param>
/// <param name="newBuildingID">The new unique identifier for the split building.</param>
/// <returns>No return behavior.</returns>
void OnBuildingSplit(BuildingManager.Building building, uint newBuildingID)
{
    Puts($"Building with ID {building.ID} has been split. New Building ID: {newBuildingID}");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	private void Split(Building building)
	{
		while (building.HasBuildingBlocks())
		{
			BuildingBlock buildingBlock = building.buildingBlocks[0];
			uint newID = BuildingManager.server.NewBuildingID();
			Interface.CallHook("OnBuildingSplit", building, newID);
			buildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)
			{
				b.AttachToBuilding(newID);
			});
		}
		while (building.HasBuildingPrivileges())
		{
			BuildingPrivlidge buildingPrivlidge = building.buildingPrivileges[0];
			BuildingBlock nearbyBuildingBlock = buildingPrivlidge.GetNearbyBuildingBlock();
			buildingPrivlidge.AttachToBuilding(nearbyBuildingBlock ? nearbyBuildingBlock.buildingID : 0u);
		}
		while (building.HasDecayEntities())
		{
			DecayEntity decayEntity = building.decayEntities[0];
			BuildingBlock nearbyBuildingBlock2 = decayEntity.GetNearbyBuildingBlock();
			decayEntity.AttachToBuilding(nearbyBuildingBlock2 ? nearbyBuildingBlock2.buildingID : 0u);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(building, ref ticks, 0);
		}
	}

```

## OnPortalUsed(BasePlayer,BasePortal)

```csharp
```csharp
/// <summary>
/// Called when a player uses a portal to teleport to another location.
/// </summary>
/// <param name="player">The player using the portal.</param>
/// <param name="portal">The portal being used.</param>
/// <returns>No return behavior.</returns>
void OnPortalUsed(BasePlayer player, BasePortal portal)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has used the portal: {portal.name}.");
    
    if (player.IsInCombat)
    {
        Puts($"Player {player.displayName} cannot use the portal while in combat.");
        return;
    }

    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public virtual void UsePortal(BasePlayer player)
	{
		if (Interface.CallHook("OnPortalUse", player, this) != null)
		{
			return;
		}
		LinkPortal();
		if (targetPortal != null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			Vector3 position = player.transform.position;
			Vector3 vector = targetPortal.GetLocalEntryExitPosition();
			Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 vector3 = vector2;
			if (isMirrored)
			{
				Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);
				vector = targetPortal.relativeAnchor.transform.TransformPoint(position2);
				vector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);
			}
			else
			{
				vector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, vector, Vector3.up);
			}
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(vector);
			player.ForceUpdateTriggers();
			player.ClientRPC(RpcTarget.Player("ForceViewAnglesTo", player), vector3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			player.ClientRPC(RpcTarget.Player("StartLoading_Quick", player), arg1: true);
			Interface.CallHook("OnPortalUsed", player, this);
		}
		else
		{
			Debug.Log("No portal...");
		}
	}

```

## CanHackCrate(BasePlayer,HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hack a locked crate.
/// </summary>
/// <param name="player">The player attempting to hack the crate.</param>
/// <param name="crate">The hackable locked crate being targeted.</param>
/// <returns>
/// Returns `true` if the player can hack the crate, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can hack the crate.
/// </returns>
bool? CanHackCrate(BasePlayer player, HackableLockedCrate crate)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to hack a crate.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot hack crates.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", msg.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);
			originalHackerPlayerId = msg.player.userID;
			originalHackerPlayer = msg.player;
			StartHacking();
		}
	}

```

## OnTurretToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the state of an auto turret is toggled (online/offline).
/// </summary>
/// <param name="turret">The auto turret whose state is being toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret.net.ID} has been toggled. Current state: {(turret.IsOn() ? "Online" : "Offline")}");
    
    if (turret.IsOn())
    {
        Puts($"Turret {turret.net.ID} is now active and ready to engage targets.");
    }
    else
    {
        Puts($"Turret {turret.net.ID} is now inactive and will not engage targets.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != IsOn() && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			if (online)
			{
				TryRegisterForInterferenceUpdate();
			}
			else
			{
				SetFlag(Flags.OnFire, b: false);
				UpdateInterferenceOnOthers();
			}
			booting = false;
			GetAttachedWeapon()?.SetLightsOn(online);
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
				authDirty = true;
			}
		}
	}

```

## OnPlayerInput(BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player provides input during their tick update.
/// </summary>
/// <param name="player">The player providing the input.</param>
/// <param name="inputState">The current state of the player's input.</param>
/// <returns>
/// Returns `null` to allow the default input processing, or any non-null value to override the default behavior.
/// </returns>
object OnPlayerInput(BasePlayer player, InputState inputState)
{
    Puts($"Player {player.displayName} is providing input: {inputState.ToString()}");

    if (inputState.IsJumping)
    {
        Puts($"Player {player.displayName} is attempting to jump.");
    }

    if (inputState.IsMoving)
    {
        Puts($"Player {player.displayName} is moving.");
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		if (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)
		{
			UpdateActiveItem(restraintItemId.Value);
		}
		else
		{
			UpdateActiveItem(msg.activeItem);
		}
		UpdateModelStateFromTick(msg);
		if (IsIncapacitated())
		{
			return;
		}
		if (isMounted)
		{
			GetMounted().PlayerServerInput(serverInput, this);
		}
		UpdatePositionFromTick(msg, wasPlayerStalled);
		UpdateRotationFromTick(msg);
		int activeMission = GetActiveMission();
		if (activeMission >= 0 && activeMission < missions.Count)
		{
			BaseMission.MissionInstance missionInstance = missions[activeMission];
			if (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())
			{
				ProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);
			}
		}
		if (TutorialIsland.EnforceTrespassChecks && !IsAdmin && !IsNpc && net != null && net.group != null)
		{
			if (net.group.restricted)
			{
				bool flag = false;
				if (!IsInTutorial)
				{
					flag = true;
				}
				else
				{
					TutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();
					if (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)
					{
						flag = true;
					}
				}
				if (flag)
				{
					tutorialKickTime += UnityEngine.Time.deltaTime;
					if (tutorialKickTime > 3f)
					{
						Debug.LogWarning($"Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn't belong them");
						Hurt(999f);
						tutorialKickTime = 0f;
					}
				}
				else
				{
					tutorialKickTime = 0f;
				}
			}
			else if (IsInTutorial && !net.group.restricted)
			{
				bool flag2 = false;
				TutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();
				if (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)
				{
					flag2 = true;
				}
				if (flag2)
				{
					tutorialKickTime += UnityEngine.Time.deltaTime;
					if (tutorialKickTime > 3f)
					{
						Debug.LogWarning($"Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial");
						Hurt(999f);
						tutorialKickTime = 0f;
					}
				}
				else
				{
					tutorialKickTime = 0f;
				}
			}
		}
		using (TimeWarning.New("AnalyticsTick"))
		{
			Facepunch.Rust.Analytics.Azure.OnPlayerTick(this);
		}
	}

```

## CanTrainCarCouple(TrainCar,TrainCar)

```csharp
```csharp
/// <summary>
/// Called to determine if two train cars can couple together.
/// </summary>
/// <param name="thisCar">The train car attempting to couple.</param>
/// <param name="otherCar">The train car being coupled to.</param>
/// <returns>
/// Returns `true` if the train cars can couple, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the coupling is allowed.
/// </returns>
bool? CanTrainCarCouple(TrainCar thisCar, TrainCar otherCar)
{
    Puts($"Attempting to couple TrainCar ID: {thisCar.net.ID} with TrainCar ID: {otherCar.net.ID}.");

    if (thisCar.IsCoupled)
    {
        Puts($"TrainCar ID: {thisCar.net.ID} is already coupled.");
        return false;
    }

    if (otherCar.IsCoupled)
    {
        Puts($"TrainCar ID: {otherCar.net.ID} is already coupled.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool TryCouple(TrainCoupling theirCoupling, bool reflect)
	{
		if (!isValid)
		{
			return false;
		}
		if (CoupledTo == theirCoupling)
		{
			return true;
		}
		if (IsCoupled)
		{
			return false;
		}
		object obj = Interface.CallHook("CanTrainCarCouple", owner, theirCoupling.owner);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (reflect && !theirCoupling.TryCouple(this, reflect: false))
		{
			return false;
		}
		CoupledTo = theirCoupling;
		owner.SetFlag(flag, b: true, recursive: false, networkupdate: false);
		owner.SendNetworkUpdate();
		return true;
	}

```

## OnFlameExplosion(FlameExplosive,UnityEngine.Collider)

```csharp
```csharp
/// <summary>
/// Called when a flame explosive detonates, triggering an explosion effect.
/// </summary>
/// <param name="explosive">The flame explosive that triggered the explosion.</param>
/// <param name="collider">The collider associated with the explosion.</param>
/// <returns>No return behavior.</returns>
void OnFlameExplosion(FlameExplosive explosive, UnityEngine.Collider collider)
{
    Puts($"Flame explosion triggered by {explosive.gameObject.name} at position {explosive.transform.position}.");
    
    if (collider != null)
    {
        Puts($"Explosion collider: {collider.gameObject.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void FlameExplode(Vector3 surfaceNormal)
	{
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = base.transform.position;
		if (blockCreateUnderwater && WaterLevel.Test(position, waves: true, volumes: false))
		{
			base.Explode();
			return;
		}
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);
			if ((bool)baseEntity)
			{
				float num = (float)i / numToCreate;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);
				float y = UnityEngine.Random.Range(0f, 360f);
				Quaternion rotation = Quaternion.Euler(0f, y, 0f);
				baseEntity.transform.SetPositionAndRotation(position, rotation);
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				baseEntity.Spawn();
				Interface.CallHook("OnFlameExplosion", this, component);
				Vector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * UnityEngine.Random.Range(1f, 1.1f));
				FireBall component2 = baseEntity.GetComponent<FireBall>();
				if (component2 != null)
				{
					component2.SetDelayedVelocity(vector);
				}
				else
				{
					baseEntity.SetVelocity(vector);
				}
			}
		}
		base.Explode();
	}

```

## OnEntityMounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player mounts an entity.
/// </summary>
/// <param name="mountable">The mountable entity being used.</param>
/// <param name="player">The player who is mounting the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityMounted(BaseMountable mountable, BasePlayer player)
{
    Puts($"Player {player.displayName} has mounted the entity: {mountable.GetType().Name} (ID: {mountable.net.ID}).");
    
    if (mountable is Vehicle)
    {
        Puts($"Player {player.displayName} is now driving the vehicle.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform transform = mountAnchor;
			player.SetMounted(this);
			player.MovePosition(transform.position);
			player.transform.rotation = transform.rotation;
			player.ServerRotation = transform.rotation;
			player.OverrideViewAngles(transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(transform.rotation);
			player.SendNetworkUpdateImmediate();
			Facepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
			if (this.IsValid() && player.IsValid())
			{
				player.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);
			}
		}
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that is being locked.</param>
/// <param name="player">The player who is locking the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.net.ID} has been locked by player {player.displayName} (ID: {player.UserIDString}).");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} locked the sign, bypassing any restrictions.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## CanUpdateSign(BasePlayer,PhotoFrame)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update the sign associated with this object.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="sign">The sign that the player wants to update.</param>
/// <returns>
/// Returns `true` if the player is allowed to update the sign; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the player can update the sign.
/// </returns>
bool? CanUpdateSign(BasePlayer player, PhotoFrame sign)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to update a sign.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can update the sign.");
        return true;
    }

    if (sign.IsLocked() && (ulong)player.userID != sign.OwnerID)
    {
        Puts($"Player {player.displayName} cannot update the sign because it is locked.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

```

## CanHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Determines whether the helicopter can drop a supply crate.
/// </summary>
/// <param name="helicopter">The helicopter attempting to drop a crate.</param>
/// <returns>
/// Returns `true` if the helicopter can drop a crate; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if a crate can be dropped.
/// </returns>
bool? CanHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.net.ID} is checking if it can drop a crate.");
    
    if (helicopter.numCrates <= 0)
    {
        Puts($"Helicopter {helicopter.net.ID} has no crates to drop.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player toggles the state of an oven (turns it on or off).
/// </summary>
/// <param name="oven">The oven being toggled.</param>
/// <param name="player">The player who is toggling the oven.</param>
/// <returns>No return behavior.</returns>
void OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts($"Player {player.displayName} toggled the oven (ID: {oven.net.ID}). Current state: {(oven.IsOn() ? "On" : "Off")}");
    
    if (oven.IsOn())
    {
        Puts($"Oven (ID: {oven.net.ID}) is now cooking.");
    }
    else
    {
        Puts($"Oven (ID: {oven.net.ID}) has stopped cooking.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	protected virtual void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnOvenToggle", this, msg.player) != null || flag == IsOn() || (needsBuildingPrivilegeToUse && !msg.player.CanBuild()))
		{
			return;
		}
		if (flag)
		{
			StartCooking();
			if (msg.player != null)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.STARTOVEN, new BaseMission.MissionEventPayload
				{
					UintIdentifier = prefabID,
					NetworkIdentifier = net.ID
				}, 1f);
			}
		}
		else
		{
			StopCooking();
		}
	}

```

## OnExplosiveDud(DudTimedExplosive)

```csharp
```csharp
/// <summary>
/// Called when a timed explosive becomes a dud instead of detonating.
/// </summary>
/// <param name="dud">The dud timed explosive that failed to detonate.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or any non-null value to prevent the explosive from becoming a dud.
/// </returns>
object OnExplosiveDud(DudTimedExplosive dud)
{
    Puts($"Explosive {dud.net.ID} has become a dud and will not detonate.");
    return null; // Allow the default behavior unless overridden
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		if (creatorEntity != null && creatorEntity.IsNpc)
		{
			base.Explode();
		}
		else if (UnityEngine.Random.Range(0f, 1f) < dudChance && Interface.CallHook("OnExplosiveDud", this) == null)
		{
			BecomeDud();
		}
		else
		{
			base.Explode();
		}
	}

```

## OnGiveSoldItem(VendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is given to a player from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine dispensing the item.</param>
/// <param name="soldItem">The item being sold.</param>
/// <param name="buyer">The player purchasing the item.</param>
/// <returns>No return behavior.</returns>
void OnGiveSoldItem(VendingMachine vendingMachine, Item soldItem, BasePlayer buyer)
{
    Puts($"Item {soldItem.info.displayName.english} is being given to {buyer.displayName} from vending machine {vendingMachine.net.ID}.");

    if (soldItem.info.shortname == "special.item")
    {
        Puts($"Player {buyer.displayName} has received a special item!");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", this, soldItem, buyer) == null)
		{
			while (soldItem.amount > soldItem.MaxStackable())
			{
				Item item = soldItem.SplitItem(soldItem.MaxStackable());
				buyer.GiveItem(item, GiveItemReason.PickedUp);
			}
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

```

## OnPlayerCorpseSpawned(BasePlayer,PlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player's corpse is spawned after their death.
/// </summary>
/// <param name="player">The player whose corpse is being spawned.</param>
/// <param name="corpse">The corpse that has been created.</param>
/// <returns>No return behavior.</returns>
void OnPlayerCorpseSpawned(BasePlayer player, PlayerCorpse corpse)
{
    Puts($"Corpse spawned for player {player.displayName} (ID: {player.UserIDString}).");
    
    if (corpse != null)
    {
        Puts($"Corpse details: Name: {corpse.playerName}, SteamID: {corpse.playerSteamID}");
    }
    else
    {
        Puts("Corpse creation failed.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? "assets/prefabs/player/player_corpse.prefab" : "assets/prefabs/player/player_corpse_new.prefab");
			bool flag = false;
			if (ConVar.Global.cinematicGingerbreadCorpses)
			{
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);
						flag = component.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.streamerName = RandomUsernames.Get(userID);
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				if (!CollectionEx.IsNullOrEmpty(triggersOnDeath))
				{
					foreach (TriggerBase item2 in triggersOnDeath)
					{
						if (item2 is TriggerParent triggerParent)
						{
							triggerParent.ForceParentEarly(playerCorpse);
						}
					}
				}
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			UnityEngine.Random.State state = UnityEngine.Random.state;
			UnityEngine.Random.InitState((int)(seed + steamid));
			float result = UnityEngine.Random.Range(0f, 1f);
			UnityEngine.Random.state = state;
			return result;
		}
	}

```

## OnNpcTargetSense(BaseEntity,BaseEntity,AIBrainSenses)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses a target entity.
/// </summary>
/// <param name="target">The entity that is being sensed.</param>
/// <param name="owner">The NPC that is sensing the target.</param>
/// <param name="brainSenses">The AI brain senses associated with the NPC.</param>
/// <returns>
/// Returns a non-null value to override the default sensing behavior. 
/// If `null` is returned, the NPC will proceed with its normal sensing logic.
/// </returns>
object OnNpcTargetSense(BaseEntity target, BaseEntity owner, AIBrainSenses brainSenses)
{
    Puts($"NPC {owner?.name} is sensing target: {target?.name}");

    if (target is BasePlayer player && player.IsInvisible)
    {
        Puts($"NPC {owner?.name} cannot sense invisible player: {player.name}");
        return true; // Prevents further processing
    }

    return null; // Allow default behavior
}
```
```

### Source Code from the Library

```csharp

	public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)
	{
		if (Interface.CallHook("OnNpcTargetSense", owner, ent, brainSenses) != null)
		{
			return;
		}
		IAISenses iAISenses = owner as IAISenses;
		BasePlayer basePlayer = ent as BasePlayer;
		if (basePlayer != null && PlayerIgnoreList.Contains(basePlayer))
		{
			return;
		}
		bool flag = false;
		if (iAISenses != null && iAISenses.IsThreat(ent))
		{
			flag = true;
			if (brainSenses != null)
			{
				brainSenses.LastThreatTimestamp = UnityEngine.Time.realtimeSinceStartup;
			}
		}
		for (int i = 0; i < All.Count; i++)
		{
			if (All[i].Entity == ent)
			{
				SeenInfo value = All[i];
				value.Position = ent.transform.position;
				value.Timestamp = Mathf.Max(UnityEngine.Time.realtimeSinceStartup, value.Timestamp);
				All[i] = value;
				return;
			}
		}
		if (basePlayer != null)
		{
			if (ConVar.AI.ignoreplayers && !basePlayer.IsNpc)
			{
				return;
			}
			Players.Add(ent);
		}
		if (iAISenses != null)
		{
			if (iAISenses.IsTarget(ent))
			{
				Targets.Add(ent);
			}
			if (iAISenses.IsFriendly(ent))
			{
				Friendlies.Add(ent);
			}
			if (flag)
			{
				Threats.Add(ent);
			}
		}
		All.Add(new SeenInfo
		{
			Entity = ent,
			Position = ent.transform.position,
			Timestamp = UnityEngine.Time.realtimeSinceStartup
		});
	}

```

## OnCorpsePopulate(NPCPlayer,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when populating a corpse with items and data after an NPC player dies.
/// </summary>
/// <param name="npc">The NPC player that has died.</param>
/// <param name="corpse">The corpse that is being populated.</param>
/// <returns>
/// Returns a modified corpse if the hook alters the default behavior; otherwise, returns the original corpse.
/// </returns>
BaseCorpse OnCorpsePopulate(NPCPlayer npc, NPCPlayerCorpse corpse)
{
    Puts($"Populating corpse for NPC {npc.displayName} with SteamID {npc.userID}.");

    // Example modification: Add a special item to the corpse
    if (npc.HasSpecialItem)
    {
        corpse.AddItem(specialItem);
        Puts($"Added special item to {npc.displayName}'s corpse.");
    }

    return corpse; // Return the modified or original corpse
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse(CorpsePath, flagsOnDeath, modelState) as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				if (NavAgent != null)
				{
					nPCPlayerCorpse.transform.position += Vector3.down * NavAgent.baseOffset;
				}
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				if (CopyInventoryToCorpse)
				{
					nPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);
				}
				else
				{
					nPCPlayerCorpse.CreateEmptyContainer(base.inventory.containerMain.capacity);
				}
				nPCPlayerCorpse.playerName = OverrideCorpseName;
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				if (ShouldCorpseTakeChildren)
				{
					nPCPlayerCorpse.TakeChildren(this);
				}
				for (int i = 0; i < nPCPlayerCorpse.containers.Length; i++)
				{
					ItemContainer itemContainer = nPCPlayerCorpse.containers[i];
					if (!KeepCorpseClothingIntact || i != 1)
					{
						itemContainer.Clear();
					}
				}
				object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
				if (obj is BaseCorpse)
				{
					return (BaseCorpse)obj;
				}
				ApplyLoot(nPCPlayerCorpse);
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnSleepingBagValidCheck(SleepingBag,ulong,bool)

```csharp
```csharp
/// <summary>
/// Called to check if a sleeping bag is valid for a specific player.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being checked.</param>
/// <param name="playerID">The ID of the player attempting to use the sleeping bag.</param>
/// <param name="ignoreTimers">Whether to ignore any timers associated with the sleeping bag.</param>
/// <returns>
/// Returns `true` if the sleeping bag is valid for the player, or `false` if it is not.
/// If the method returns `null`, the default game logic will determine the validity.
/// </returns>
bool? OnSleepingBagValidCheck(SleepingBag sleepingBag, ulong playerID, bool ignoreTimers)
{
    Puts($"Checking validity of sleeping bag for player ID: {playerID}, ignoreTimers: {ignoreTimers}");

    if (sleepingBag.deployerUserID == playerID)
    {
        Puts($"Player {playerID} is the deployer of this sleeping bag.");
        return !ignoreTimers || sleepingBag.unlockTime < UnityEngine.Time.realtimeSinceStartup;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		object obj = Interface.CallHook("OnSleepingBagValidCheck", this, playerID, ignoreTimers);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (deployerUserID == playerID)
		{
			if (!ignoreTimers)
			{
				return unlockTime < UnityEngine.Time.realtimeSinceStartup;
			}
			return true;
		}
		return false;
	}

```

## CanTakeCutting(BasePlayer,GrowableEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can take a cutting from a growable entity.
/// </summary>
/// <param name="player">The player attempting to take a cutting.</param>
/// <param name="growable">The growable entity from which the cutting is being taken.</param>
/// <returns>
/// Returns `null` to allow the player to take a cutting, or any non-null value to prevent the action.
/// </returns>
object CanTakeCutting(BasePlayer player, GrowableEntity growable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to take a cutting from {growable.displayName}.");

    if (player.inventory.GetAmount("scissors") < 1)
    {
        Puts($"Player {player.displayName} does not have scissors to take a cutting.");
        return "You need scissors to take a cutting.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TakeClones(BasePlayer player)
	{
		if (player == null || !CanClone() || Interface.CallHook("CanTakeCutting", player, this) != null)
		{
			return;
		}
		int num = Properties.BaseCloneCount + Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;
		if (num > 0)
		{
			Item item = ItemManager.Create(Properties.CloneItem, num, 0uL);
			GrowableGeneEncoding.EncodeGenesToItem(this, item);
			Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
			if (Properties.pickEffect.isValid)
			{
				Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
			}
			TellPlanter();
			Die();
		}
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the NPC can eat the specified entity.
/// </summary>
/// <param name="npc">The NPC attempting to eat.</param>
/// <param name="entity">The entity that may be eaten.</param>
/// <returns>
/// Returns `true` if the NPC can eat the entity, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the NPC can eat the entity.
/// </returns>
bool? CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc.displayName} is evaluating whether to eat {entity.displayName}.");

    if (entity.HasTrait(TraitFlag.Food))
    {
        Puts($"{entity.displayName} is considered food.");
        return true;
    }

    Puts($"{entity.displayName} is not food or is alive, NPC cannot eat.");
    return false;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnMlrsTargetSet(MLRS,UnityEngine.Vector3,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a target position is set for the Multiple Launch Rocket System (MLRS).
/// </summary>
/// <param name="mlrs">The MLRS instance setting the target.</param>
/// <param name="targetPosition">The world position being set as the target.</param>
/// <param name="player">The player who set the target position.</param>
/// <returns>No return behavior.</returns>
void OnMlrsTargetSet(MLRS mlrs, Vector3 targetPosition, BasePlayer player)
{
    Puts($"MLRS target set by {player.displayName} at position: {targetPosition}.");
    
    if (Vector3.Distance(targetPosition, mlrs.UserTargetHitPos) < 5f)
    {
        Puts($"Target position {targetPosition} is too close to the previous target.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 vector = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", this, worldPos, _mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Vector3 center = allSafeZone.triggerCollider.bounds.center;
				center.y = 0f;
				float num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 vector2 = trueTargetHitPos - center;
					trueTargetHitPos = center + vector2.normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", this, trueTargetHitPos, _mounted);
	}

```

## OnBookmarkDelete(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a bookmark is deleted from a computer station.
/// </summary>
/// <param name="station">The computer station from which the bookmark is being deleted.</param>
/// <param name="player">The player who is deleting the bookmark.</param>
/// <param name="bookmarkId">The identifier of the bookmark being deleted.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkDelete(ComputerStation station, BasePlayer player, string bookmarkId)
{
    Puts($"Bookmark '{bookmarkId}' deleted by player {player.displayName} (ID: {player.UserIDString}) from station {station.name}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DeleteBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		string text = msg.read.String();
		if (IsValidIdentifier(text) && controlBookmarks.Contains(text) && Interface.CallHook("OnBookmarkDelete", this, player, text) == null)
		{
			controlBookmarks.Remove(text);
			SendControlBookmarks(player);
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if (baseEntity != null && baseEntity.TryGetComponent<IRemoteControllable>(out var component) && component.GetIdentifier() == text)
			{
				StopControl(player);
			}
		}
	}

```

## OnStashHidden(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a stash container is hidden by a player.
/// </summary>
/// <param name="stash">The stash container that is being hidden.</param>
/// <param name="player">The player who is hiding the stash.</param>
/// <returns>No return behavior.</returns>
void OnStashHidden(StashContainer stash, BasePlayer player)
{
    Puts($"Stash container {stash.net.ID} has been hidden by player {player.displayName} (ID: {player.UserIDString}).");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", rpc.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", this, rpc.player);
		}
	}

```

## OnExperimentEnd(Workbench)

```csharp
```csharp
/// <summary>
/// Called when an experiment at the workbench is completed.
/// </summary>
/// <param name="workbench">The workbench where the experiment was conducted.</param>
/// <returns>No return behavior.</returns>
void OnExperimentEnd(Workbench workbench)
{
    Puts($"Experiment completed at Workbench ID: {workbench.net.ID}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after a fall, allowing for custom fall damage handling.
/// </summary>
/// <param name="player">The player who has landed.</param>
/// <param name="fallVelocity">The velocity at which the player landed.</param>
/// <returns>
/// Returns `null` to allow the default fall damage calculation, or any non-null value to override it.
/// </returns>
object OnPlayerLand(BasePlayer player, float fallVelocity)
{
    Puts($"Player {player.displayName} landed with a velocity of {fallVelocity}.");

    if (fallVelocity < -20f)
    {
        Puts($"Player {player.displayName} experienced a hard landing!");
        return true; // Prevent default damage handling
    }

    return null; // Allow default damage handling
}
```
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		if (IsGod())
		{
			return;
		}
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Facepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned in the game world.
/// </summary>
/// <param name="entity">The entity that has been spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity of type {entity.GetType().Name} has been spawned with ID: {entity.net.ID}.");
    
    if (entity is BaseEntity baseEntity)
    {
        Puts($"Entity {baseEntity.displayName} has been initialized and is now active.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		EntityProfiler.spawned++;
		if (EntityProfiler.mode >= 2)
		{
			EntityProfiler.OnSpawned(this);
		}
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		ServerInitPostNetworkGroupAssign();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		Invoke(SendGlobalNetworkUpdate, 0f);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death, including the initiator.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.prefabID} has died. Initiator: {hitInfo?.InitiatorPlayer?.displayName ?? "Unknown"}");

    if (hitInfo != null && hitInfo.InitiatorPlayer != null)
    {
        Puts($"Player {hitInfo.InitiatorPlayer.displayName} was responsible for the death of entity {entity.prefabID}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		LogEntry(RustLog.EntryType.Combat, 2, "died");
		health = 0f;
		lifestate = LifeState.Dead;
		Interface.CallHook("OnEntityDeath", this, info);
		if (info != null && (bool)info.InitiatorPlayer)
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)
			{
				initiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, prefabID, 1f);
			}
		}
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## CanResearchItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can research a specific item.
/// </summary>
/// <param name="player">The player attempting to research the item.</param>
/// <param name="item">The item that the player wants to research.</param>
/// <returns>
/// Returns `true` if the player can research the item, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the item can be researched.
/// </returns>
bool? CanResearchItem(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to research item: {item.info.displayName.english}.");

    if (item.info.shortname == "blueprint")
    {
        Puts($"Player {player.displayName} cannot research blueprints.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Facepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnBonusItemDropped(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is dropped for a player after crafting or other actions.
/// </summary>
/// <param name="item">The bonus item that has been dropped.</param>
/// <param name="player">The player who receives the bonus item.</param>
/// <returns>No return behavior.</returns>
void OnBonusItemDropped(Item item, BasePlayer player)
{
    Puts($"Bonus item {item.info.displayName.english} has been dropped for player {player.displayName} (ID: {player.UserIDString}).");

    if (item.info.shortname == "scrap")
    {
        Puts($"Player {player.displayName} received bonus scrap!");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player hits an entity with a hammer.
/// </summary>
/// <param name="player">The player who performed the hammer hit.</param>
/// <param name="hitInfo">Information about the hit, including the target entity and damage details.</param>
/// <returns>No return behavior.</returns>
void OnHammerHit(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} hit an entity with a hammer. Target: {hitInfo.HitEntity?.ShortPrefabName ?? "None"}");

    if (hitInfo.HitEntity is BaseCombatEntity entity)
    {
        Puts($"Entity {entity.ShortPrefabName} was hit for repair.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null && ownerPlayer != null && base.isServer)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			using (TimeWarning.New("DoRepair", 50))
			{
				baseCombatEntity.DoRepair(ownerPlayer);
			}
		}
		info.DoDecals = false;
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## OnBuildingPrivilege(BaseEntity,OBB)

```csharp
```csharp
/// <summary>
/// Called to retrieve the building privilege associated with a given bounding box.
/// </summary>
/// <param name="entity">The entity requesting the building privilege.</param>
/// <param name="obb">The oriented bounding box used to check for building privileges.</param>
/// <returns>
/// Returns a <c>BuildingPrivlidge</c> object if a privilege is found; otherwise, returns <c>null</c>.
/// If the method returns a non-null value, it overrides the default privilege retrieval logic.
/// </returns>
BuildingPrivlidge OnBuildingPrivilege(BaseEntity entity, OBB obb)
{
    Puts($"Checking building privilege for entity {entity.net.ID} in area defined by OBB at position {obb.position}.");
    
    // Example condition to restrict building privilege
    if (obb.position.y < 0)
    {
        Puts("Building privilege denied: Position is below ground level.");
        return null;
    }

    return null; // Allow default behavior if no specific privilege is found
}
```
```

### Source Code from the Library

```csharp

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
	{
		object obj = Interface.CallHook("OnBuildingPrivilege", this, obb);
		if (obj is BuildingPrivlidge)
		{
			return (BuildingPrivlidge)obj;
		}
		BuildingBlock other = null;
		BuildingPrivlidge result = null;
		List<BuildingBlock> obj2 = Facepunch.Pool.Get<List<BuildingBlock>>();
		Vis.Entities(obb.position, 16f + obb.extents.magnitude, obj2, 2097152);
		for (int i = 0; i < obj2.Count; i++)
		{
			BuildingBlock buildingBlock = obj2[i];
			if (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) > 16f)
			{
				continue;
			}
			BuildingManager.Building building = buildingBlock.GetBuilding();
			if (building != null)
			{
				BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
				if (!(dominatingBuildingPrivilege == null))
				{
					other = buildingBlock;
					result = dominatingBuildingPrivilege;
				}
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj2);
		return result;
	}

```

## OnTeamAcceptInvite(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player accepts an invitation to join a team.
/// </summary>
/// <param name="team">The team that the player is accepting an invitation to join.</param>
/// <param name="player">The player who is accepting the invitation.</param>
/// <returns>
/// Returns `null` to allow the player to join the team, or any non-null value to prevent the action.
/// </returns>
object OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.displayName} is accepting an invite to team {team.TeamName}.");

    if (team.IsFull())
    {
        Puts($"Player {player.displayName} cannot join team {team.TeamName} because it is full.");
        return "Team is full.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void acceptinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamAcceptInvite", playerTeam, basePlayer) == null)
			{
				playerTeam.AcceptInvite(basePlayer);
			}
		}
	}

```

## OnBradleyApcThink(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called periodically to update the AI behavior of the Bradley APC.
/// </summary>
/// <param name="apc">The Bradley APC instance being updated.</param>
/// <returns>No return behavior.</returns>
void OnBradleyApcThink(BradleyAPC apc)
{
    Puts($"Updating AI for Bradley APC at position: {apc.transform.position}");

    if (apc.IsOnFire())
    {
        Puts("Bradley APC is on fire! Taking necessary actions.");
    }
    else if (apc.IsEngagedInCombat())
    {
        Puts("Bradley APC is engaged in combat. Adjusting tactics.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoSimpleAI()
	{
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
		if (Interface.CallHook("OnBradleyApcThink", this) != null || !DoAI)
		{
			return;
		}
		SetTarget();
		if (mountingScientists || inDeployedState)
		{
			ClearPath();
		}
		else if (!IsOnSpline())
		{
			if (targetList.Count > 0)
			{
				UpdateMovement_Hunt();
			}
			else
			{
				UpdateMovement_Patrol();
			}
		}
		if (!IsOnSpline())
		{
			AdvancePathMovement(force: false);
			float num = Vector3.Distance(base.transform.position, destination);
			float value = Vector3.Distance(base.transform.position, finalDestination);
			if (num > stoppingDist)
			{
				Vector3 lhs = Direction2D(destination, base.transform.position);
				float num2 = Vector3.Dot(lhs, base.transform.right);
				float num3 = Vector3.Dot(lhs, base.transform.right);
				float num4 = Vector3.Dot(lhs, -base.transform.right);
				if (Vector3.Dot(lhs, -base.transform.forward) > num2)
				{
					if (num3 >= num4)
					{
						turning = 1f;
					}
					else
					{
						turning = -1f;
					}
				}
				else
				{
					turning = Mathf.Clamp(num2 * 3f, -1f, 1f);
				}
				float throttleScaleFromTurn = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));
				AvoidObstacles(ref throttleScaleFromTurn);
				float num5 = Vector3.Dot(myRigidBody.velocity, base.transform.forward);
				if (!(throttle > 0f) || !(num5 < 0.5f))
				{
					timeSinceSeemingStuck = 0f;
				}
				else if ((float)timeSinceSeemingStuck > 10f)
				{
					timeSinceStuckReverseStart = 0f;
					timeSinceSeemingStuck = 0f;
				}
				float num6 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(base.transform.forward, Vector3.up));
				if ((float)timeSinceStuckReverseStart < 3f)
				{
					throttle = -0.75f;
					turning = 1f;
				}
				else
				{
					throttle = (0.1f + Mathf.InverseLerp(0f, 20f, value) * 1f) * throttleScaleFromTurn + num6;
				}
			}
		}
		DoWeaponAiming();
		SendNetworkUpdate();
	}

```

## OnPlayerDeath(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player dies in the game.
/// </summary>
/// <param name="player">The player who has died.</param>
/// <param name="hitInfo">Information about the hit that caused the death.</param>
/// <returns>
/// Returns `null` to allow the default death behavior, or any non-null value to override it.
/// </returns>
object OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has died due to {hitInfo?.damageTypes?.Get(0)?.type}.");

    if (hitInfo?.damageTypes?.Get(0)?.type == DamageType.Explosion)
    {
        Puts($"Player {player.displayName} was killed by an explosion!");
        return "You have been killed by an explosion.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead())
			{
				Handcuffs restraintItem = Belt.GetRestraintItem();
				if (restraintItem != null)
				{
					restraintItem.HeldWhenOwnerDied(this);
				}
				if (InGesture)
				{
					Server_CancelGesture();
				}
				if (Belt != null && ShouldDropActiveItem())
				{
					Vector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + vector.normalized * 3f);
					inventory.DropBackpackOnDeath();
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDeath", this, info) == null)
				{
					SleepingBag.OnPlayerDeath(this);
					base.Die(info);
				}
			}
		}
	}

```

## OnVendingShopOpened(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop is opened by a player.
/// </summary>
/// <param name="vendingMachine">The vending machine that is being opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpened(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending shop opened by player {player.displayName} (ID: {player.UserIDString}) at machine {vendingMachine.net.ID}.");
    
    // Additional logic can be added here, such as logging or triggering events.
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", this, msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", this, msg.player);
		}
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to loot an entity.
/// </summary>
/// <param name="player">The player who is looting the entity.</param>
/// <param name="targetEntity">The entity being looted.</param>
/// <returns>
/// Returns `true` if the looting process can proceed; otherwise, returns `false`. 
/// If the method returns a non-null value, it will override the default looting behavior.
/// </returns>
object OnLootEntity(BasePlayer player, BaseEntity targetEntity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot {targetEntity.name}.");

    if (targetEntity is LootableCorpse)
    {
        Puts($"Player {player.displayName} cannot loot corpses.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!targetEntity)
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		MarkDirty();
		if (targetEntity is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = base.baseEntity.userID;
		}
		return true;
	}

```

## OnMissionFailed(BaseMission,BaseMission.MissionInstance,BasePlayer,BaseMission.MissionFailReason)

```csharp
```csharp
/// <summary>
/// Called when a mission fails for a player.
/// </summary>
/// <param name="mission">The mission that has failed.</param>
/// <param name="instance">The instance of the mission that failed.</param>
/// <param name="assignee">The player who was assigned the mission.</param>
/// <param name="failReason">The reason for the mission failure.</param>
/// <returns>No return behavior.</returns>
void OnMissionFailed(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee, BaseMission.MissionFailReason failReason)
{
    Puts($"Mission '{mission.missionName.english}' failed for player {assignee.displayName}. Reason: {failReason}.");

    if (failReason == BaseMission.MissionFailReason.TimeExpired)
    {
        Puts($"Player {assignee.displayName} ran out of time to complete the mission.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
	{
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have failed the mission : " + missionName.english);
		}
		DoMissionEffect(failedEffect.resourcePath, assignee);
		Facepunch.Rust.Analytics.Server.MissionFailed(this, failReason);
		Facepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, failReason);
		instance.status = MissionStatus.Failed;
		MissionEnded(instance, assignee);
		Interface.CallHook("OnMissionFailed", this, instance, assignee, failReason);
	}

```

## OnReactiveTargetReset(ReactiveTarget)

```csharp
```csharp
/// <summary>
/// Called when a reactive target is reset.
/// </summary>
/// <param name="target">The reactive target that is being reset.</param>
/// <returns>No return behavior.</returns>
void OnReactiveTargetReset(ReactiveTarget target)
{
    Puts($"Reactive target {target.gameObject.name} has been reset.");
}
```
```

### Source Code from the Library

```csharp

	public void ResetTarget()
	{
		if (IsLowered() && CanToggle() && CanReset())
		{
			CancelInvoke(ResetTarget);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			knockdownHealth = 100f;
			SendPowerBurst();
			Interface.CallHook("OnReactiveTargetReset", this);
		}
	}

```

## CanDeployScientists(BradleyAPC,BaseEntity,System.Collections.Generic.List<GameObjectRef>,System.Collections.Generic.List<UnityEngine.Vector3>)

```csharp
```csharp
/// <summary>
/// Determines whether scientists can be deployed at the specified positions.
/// </summary>
/// <param name="attacker">The entity attempting to deploy the scientists.</param>
/// <param name="scientistPrefabs">A list of scientist prefab references to be deployed.</param>
/// <param name="spawnPositions">A list to store valid spawn positions for the scientists.</param>
/// <returns>
/// Returns `true` if scientists can be deployed; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if deployment is allowed.
/// </returns>
bool? CanDeployScientists(BaseEntity attacker, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
{
    Puts($"Attempting to deploy scientists by {attacker?.gameObject.name ?? "unknown entity"}.");

    if (scientistPrefabs.Count == 0)
    {
        Puts("No scientist prefabs provided for deployment.");
        return false;
    }

    if (Vector3.Distance(attacker.transform.position, transform.position) > DeployAttackDistanceMax)
    {
        Puts("Attacker is too far away to deploy scientists.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanDeployScientists(BaseEntity attacker, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
	{
		object obj = Interface.CallHook("CanDeployScientists", this, attacker, scientistPrefabs, spawnPositions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int count = scientistPrefabs.Count;
		if (!inDeployedState && Vector3.Distance(attacker.transform.position, base.transform.position) > DeployAttackDistanceMax)
		{
			return false;
		}
		spawnPositions.Clear();
		bool flag = false;
		int num = 0;
		int num2 = 0;
		int layerMask = 8454144;
		while (!flag)
		{
			if (UnityEngine.Physics.Raycast(ScientistSpawnPoints[num2 % ScientistSpawnPoints.Count].transform.position + Vector3.up * 1f, Vector3.down, out var hitInfo, 2f, layerMask) && NavMesh.SamplePosition(hitInfo.point + Vector3.up * 0.3f, out var _, 6f, walkableAreaMask))
			{
				spawnPositions.Add(hitInfo.point + Vector3.up * 0.1f);
				num2++;
				if (num2 >= count)
				{
					break;
				}
			}
			else
			{
				num++;
				if (num > count * 2)
				{
					flag = true;
				}
			}
		}
		return !flag;
	}

```

## OnTeamInvite(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player invites another player to join their team.
/// </summary>
/// <param name="inviter">The player who is sending the team invite.</param>
/// <param name="invitee">The player being invited to join the team.</param>
/// <returns>
/// Returns `null` to allow the invite to proceed, or any non-null value to prevent the invite.
/// </returns>
object OnTeamInvite(BasePlayer inviter, BasePlayer invitee)
{
    Puts($"Player {inviter.displayName} is inviting {invitee.displayName} to join their team.");
    
    if (invitee.IsBannedFromTeams)
    {
        Puts($"Player {invitee.displayName} is banned from joining teams.");
        return "You are banned from joining teams.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void sendinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer)
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			return;
		}
		BasePlayer basePlayer2 = BaseNetworkable.serverEntities.Find(new NetworkableId(uLong)) as BasePlayer;
		if ((bool)basePlayer2 && basePlayer2 != basePlayer && !basePlayer2.IsNpc && basePlayer2.currentTeam == 0L)
		{
			float num = 7f;
			if (!(Vector3.Distance(basePlayer2.transform.position, basePlayer.transform.position) > num) && Interface.CallHook("OnTeamInvite", basePlayer, basePlayer2) == null)
			{
				playerTeam.SendInvite(basePlayer2);
			}
		}
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player has landed after a fall.
/// </summary>
/// <param name="player">The player who has landed.</param>
/// <param name="fallImpact">The impact force of the fall.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanded(BasePlayer player, float fallImpact)
{
    Puts($"Player {player.displayName} has landed with an impact force of {fallImpact}.");
    
    if (fallImpact > 50f)
    {
        Puts($"Warning: Player {player.displayName} landed hard! Potential fall damage.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		if (IsGod())
		{
			return;
		}
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Facepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnPlayerSetInfo(Network.Connection,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player sets their information, such as username or other attributes.
/// </summary>
/// <param name="connection">The network connection of the player setting the information.</param>
/// <param name="key">The key representing the type of information being set.</param>
/// <param name="val">The value being assigned to the specified key.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSetInfo(Network.Connection connection, string key, string val)
{
    Puts($"Player {connection.username} is setting info: {key} = {val}");
    
    if (key == "username" && string.IsNullOrWhiteSpace(val))
    {
        Puts("Username cannot be empty.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void SetInfo(string key, string val)
	{
		if (IsConnected)
		{
			Interface.CallHook("OnPlayerSetInfo", net.connection, key, val);
			net.connection.info.Set(key, val);
		}
	}

```

## OnStructureDemolish(StabilityEntity,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a structure is being demolished by a player.
/// </summary>
/// <param name="structure">The structure that is being demolished.</param>
/// <param name="player">The player who is demolishing the structure.</param>
/// <param name="isInstant">Indicates whether the demolition is instant.</param>
/// <returns>
/// Returns `null` to allow the demolition, or any non-null value to prevent it.
/// </returns>
object OnStructureDemolish(StabilityEntity structure, BasePlayer player, bool isInstant)
{
    Puts($"Player {player.displayName} is attempting to demolish structure {structure.net.ID}.");

    if (structure.IsProtected())
    {
        Puts($"Demolition of structure {structure.net.ID} is blocked for player {player.displayName}.");
        return "You cannot demolish this structure.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);
			Kill(DestroyMode.Gib);
		}
	}

```

## OnEntityStabilityCheck(StabilityEntity)

```csharp
```csharp
/// <summary>
/// Called to perform a stability check on the entity.
/// </summary>
/// <param name="entity">The stability entity being checked.</param>
/// <returns>No return behavior.</returns>
void OnEntityStabilityCheck(StabilityEntity entity)
{
    Puts($"Stability check initiated for entity ID: {entity.net.ID}.");
    
    if (entity.IsDestroyed)
    {
        Puts($"Entity ID: {entity.net.ID} is already destroyed. Stability check aborted.");
        return;
    }

    // Additional logic can be added here to handle specific stability conditions
    Puts($"Entity ID: {entity.net.ID} is undergoing stability evaluation.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void StabilityCheck()
	{
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			cachedDistanceFromGround = num;
			flag = true;
		}
		float num2 = SupportValue();
		if (Mathf.Abs(cachedStability - num2) > Stability.accuracy)
		{
			cachedStability = num2;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability();
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num2 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				UpdateStability();
				stabilityStrikes++;
			}
			else
			{
				Kill(DestroyMode.Gib);
			}
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

```

## CanSetBedPublic(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can set a sleeping bag to public.
/// </summary>
/// <param name="player">The player attempting to set the sleeping bag as public.</param>
/// <param name="sleepingBag">The sleeping bag being modified.</param>
/// <returns>
/// Returns `true` if the player can set the sleeping bag to public; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can set the sleeping bag public.
/// </returns>
bool? CanSetBedPublic(BasePlayer player, SleepingBag sleepingBag)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to set sleeping bag {sleepingBag.ID} to public.");

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can set the sleeping bag to public.");
        return true;
    }

    if (sleepingBag.IsPublic())
    {
        Puts($"Sleeping bag {sleepingBag.ID} is already public.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public virtual void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != (ulong)msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag == IsPublic() || Interface.CallHook("CanSetBedPublic", msg.player, this) != null)
		{
			return;
		}
		SetPublic(flag);
		if (!IsPublic())
		{
			if (ConVar.Server.max_sleeping_bags > 0)
			{
				CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
				if (canAssignBedResult.HasValue)
				{
					if (canAssignBedResult.Value.Result == BagResultType.Ok)
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					else
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					if (canAssignBedResult.Value.Result != 0)
					{
						return;
					}
				}
			}
			ulong num = deployerUserID;
			deployerUserID = msg.player.userID;
			NotifyPlayer(num);
			NotifyPlayer(deployerUserID);
			OnBagChangedOwnership(this, num);
			Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);
		}
		else
		{
			Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);
		}
		SendNetworkUpdate();
	}

```

## OnPatrolHelicopterKill(PatrolHelicopter,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a patrol helicopter is killed.
/// </summary>
/// <param name="helicopter">The patrol helicopter that was killed.</param>
/// <param name="hitInfo">Information about the hit that caused the helicopter's death.</param>
/// <returns>No return behavior.</returns>
void OnPatrolHelicopterKill(PatrolHelicopter helicopter, HitInfo hitInfo)
{
    Puts($"Patrol helicopter {helicopter.net.ID} has been killed by {hitInfo.Initiator?.displayName ?? "unknown"} with damage type: {hitInfo.damageTypes.GetMajority()}.");
    
    // Additional logic can be added here, such as spawning loot or triggering events.
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnPatrolHelicopterTakeDamage", this, info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			if (Interface.CallHook("OnPatrolHelicopterKill", this, info) != null)
			{
				return;
			}
			base.health = 10000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		myAI.OtherDamaged(info);
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

```

## OnRespawnInformationGiven(BasePlayer,System.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions>)

```csharp
```csharp
/// <summary>
/// Called to provide respawn options to a player after they have died.
/// </summary>
/// <param name="player">The player receiving the respawn information.</param>
/// <param name="spawnOptions">A list of available spawn options for the player.</param>
/// <returns>No return behavior.</returns>
void OnRespawnInformationGiven(BasePlayer player, List<ProtoBuf.RespawnInformation.SpawnOptions> spawnOptions)
{
    Puts($"Respawn information sent to player {player.displayName} (ID: {player.UserIDString}). " +
         $"Available spawn options: {spawnOptions.Count}.");

    if (spawnOptions.Count == 0)
    {
        Puts($"No spawn options available for player {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SendRespawnOptions()
	{
		if (NexusServer.Started && ZoneController.Instance.CanRespawnAcrossZones(this))
		{
			CollectExternalAndSend();
			return;
		}
		List<RespawnInformation.SpawnOptions> list = Facepunch.Pool.Get<List<RespawnInformation.SpawnOptions>>();
		GetRespawnOptionsForPlayer(list, userID);
		Interface.CallHook("OnRespawnInformationGiven", this, list);
		SendToPlayer(list, loading: false);
		async void CollectExternalAndSend()
		{
			List<RespawnInformation.SpawnOptions> list2 = Facepunch.Pool.Get<List<RespawnInformation.SpawnOptions>>();
			GetRespawnOptionsForPlayer(list2, userID);
			List<RespawnInformation.SpawnOptions> allSpawnOptions = Facepunch.Pool.Get<List<RespawnInformation.SpawnOptions>>();
			foreach (RespawnInformation.SpawnOptions item in list2)
			{
				allSpawnOptions.Add(item.Copy());
			}
			SendToPlayer(list2, loading: true);
			try
			{
				Request request = Facepunch.Pool.Get<Request>();
				request.spawnOptions = Facepunch.Pool.Get<SpawnOptionsRequest>();
				request.spawnOptions.userId = userID;
				using (NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(request, 10f))
				{
					foreach (KeyValuePair<string, Response> response in nexusRpcResult.Responses)
					{
						string key = response.Key;
						SpawnOptionsResponse spawnOptions2 = response.Value.spawnOptions;
						if (spawnOptions2 != null && spawnOptions2.spawnOptions.Count != 0)
						{
							foreach (RespawnInformation.SpawnOptions spawnOption in spawnOptions2.spawnOptions)
							{
								RespawnInformation.SpawnOptions spawnOptions3 = spawnOption.Copy();
								spawnOptions3.nexusZone = key;
								allSpawnOptions.Add(spawnOptions3);
							}
						}
					}
				}
				SendToPlayer(allSpawnOptions, loading: false);
			}
			catch (Exception exception)
			{
				Debug.LogException(exception);
			}
		}
		void SendToPlayer(List<RespawnInformation.SpawnOptions> spawnOptions, bool loading)
		{
			using RespawnInformation respawnInformation = Facepunch.Pool.Get<RespawnInformation>();
			respawnInformation.spawnOptions = spawnOptions;
			respawnInformation.loading = loading;
			if (ConVar.Server.max_shelters == LegacyShelter.FpShelterDefault && LegacyShelter.SheltersPerPlayer.ContainsKey(userID) && LegacyShelter.SheltersPerPlayer[userID].Count > 0)
			{
				respawnInformation.shelterPositions = Facepunch.Pool.Get<List<Vector3>>();
				foreach (LegacyShelter item2 in LegacyShelter.SheltersPerPlayer[userID])
				{
					respawnInformation.shelterPositions.Add(item2.transform.position);
				}
			}
			if (IsDead())
			{
				respawnInformation.previousLife = previousLifeStory;
				if (!ConVar.Server.skipDeathScreenFade)
				{
					respawnInformation.fadeIn = previousLifeStory != null && previousLifeStory.timeDied > Epoch.Current - 5;
				}
				else
				{
					respawnInformation.fadeIn = false;
				}
			}
			ClientRPC(RpcTarget.Player("OnRespawnInformation", this), respawnInformation);
		}
	}

```

## OnPlayerWantsDismount(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player requests to dismount from a mountable object.
/// </summary>
/// <param name="player">The player who wants to dismount.</param>
/// <param name="mountable">The mountable object the player is currently on.</param>
/// <returns>
/// Returns `null` to allow the dismount action, or any non-null value to prevent the dismount.
/// </returns>
object OnPlayerWantsDismount(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) wants to dismount from {mountable.gameObject.name}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot dismount while in a safe zone.");
        return "You cannot dismount in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", player, this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", player, this) == null && (!(player != null) || !player.IsRestrained))
		{
			AttemptDismount(player);
		}
	}

```

## OnFuelAmountCheck(EntityFuelSystem,Item)

```csharp
```csharp
/// <summary>
/// Called to check the amount of fuel available in the fuel system.
/// </summary>
/// <param name="fuelSystem">The entity fuel system being checked.</param>
/// <param name="fuelItem">The item representing the fuel.</param>
/// <returns>
/// Returns the amount of fuel available. If the hook returns a non-null integer, that value is used; otherwise, 
/// the amount of the fuel item is returned, or 0 if no fuel item is present.
/// </returns>
int OnFuelAmountCheck(EntityFuelSystem fuelSystem, Item fuelItem)
{
    Puts($"Checking fuel amount for {fuelSystem.gameObject.name}. Current fuel item: {fuelItem?.info.displayName.english ?? "None"}");

    if (fuelItem != null && fuelItem.amount > 10)
    {
        Puts("Fuel amount is sufficient.");
        return fuelItem.amount; // Example condition
    }

    return 0; // Default return if no fuel or insufficient amount
}
```
```

### Source Code from the Library

```csharp

	public int GetFuelAmount()
	{
		Item fuelItem = GetFuelItem();
		object obj = Interface.CallHook("OnFuelAmountCheck", this, fuelItem);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0;
		}
		return fuelItem.amount;
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
```csharp
/// <summary>
/// Called when a weapon is fired by a player.
/// </summary>
/// <param name="projectile">The projectile being fired.</param>
/// <param name="player">The player who fired the weapon.</param>
/// <param name="itemMod">The item modification associated with the projectile.</param>
/// <param name="projectileShoot">The data related to the projectile shoot action.</param>
/// <returns>No return behavior.</returns>
void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile itemMod, ProtoBuf.ProjectileShoot projectileShoot)
{
    Puts($"Player {player.displayName} fired {projectile.ShortPrefabName} with {projectileShoot.projectiles.Count} projectiles.");
    
    if (projectileShoot.projectiles.Count > itemMod.numProjectiles)
    {
        Puts($"Warning: Player {player.displayName} attempted to fire more projectiles than allowed.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner]
	[RPC_Server]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !base.UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_missing");
			return;
		}
		ItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (primaryMagazineAmmo.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_mismatch");
			return;
		}
		if (!base.UsingInfiniteAmmoCheat)
		{
			ModifyAmmoCount(-1);
		}
		ItemModProjectile component = primaryMagazineAmmo.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		if (player.InGesture)
		{
			return;
		}
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection, GetAttackEffect());
		player.CleanupExpiredProjectiles();
		Guid projectileGroupId = Guid.NewGuid();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.LogInvalid(player, this, "duplicate_id");
				continue;
			}
			Vector3 positionOffset = Vector3.zero;
			if (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))
			{
				if (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))
				{
					continue;
				}
				Vector3 position = player.eyes.position;
				positionOffset = position - projectile.startPos;
				projectile.startPos = position;
			}
			else if (!ValidateEyePos(player, projectile.startPos))
			{
				continue;
			}
			player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId, positionOffset);
			if (!player.limitNetworking)
			{
				CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
			}
		}
		player.MakeNoise(player.transform.position, BaseCombatEntity.ActionVolume.Loud);
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count(), (Stats)5);
		player.LifeStoryShotFired(this);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);
		player.MarkHostileFor();
		UpdateItemCondition();
		DidAttackServerside();
		float num = 0f;
		if (component.projectileObject != null)
		{
			GameObject gameObject = component.projectileObject.Get();
			if (gameObject != null)
			{
				Projectile component2 = gameObject.GetComponent<Projectile>();
				if (component2 != null)
				{
					foreach (DamageTypeEntry damageType in component2.damageTypes)
					{
						num += damageType.amount;
					}
				}
			}
		}
		BaseMountable mounted = player.GetMounted();
		if (mounted != null)
		{
			mounted.OnWeaponFired(this);
		}
		EACServer.LogPlayerUseWeapon(player, this);
	}

```

## OnSamSiteTarget(SamSite,SamSite.ISamSiteTarget)

```csharp
```csharp
/// <summary>
/// Called when the SAM site scans for potential targets.
/// </summary>
/// <param name="samSite">The SAM site performing the target scan.</param>
/// <param name="target">The potential target detected by the SAM site.</param>
/// <returns>No return behavior.</returns>
void OnSamSiteTarget(SamSite samSite, ISamSiteTarget target)
{
    Puts($"SAM Site {samSite.net.ID} has detected a target: {target.GetType().Name} at position {target.CenterPoint()}.");

    if (target.IsVisible(samSite.eyePoint.transform.position, samSite.targetTypeVehicle.scanRadius))
    {
        Puts($"Target {target.GetType().Name} is visible and valid for engagement.");
    }
    else
    {
        Puts($"Target {target.GetType().Name} is not visible or valid.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (UnityEngine.Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> obj = Facepunch.Pool.Get<List<ISamSiteTarget>>();
		if (Interface.CallHook("OnSamSiteTargetScan", this, obj) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(obj, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(obj, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in obj)
		{
			if (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!ObjectEx.IsUnityNull(samSiteTarget) && currentTarget != samSiteTarget)
		{
			lockOnTime = UnityEngine.Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!ObjectEx.IsUnityNull(currentTarget))
		{
			lastTargetVisibleTime = UnityEngine.Time.time;
		}
		Facepunch.Pool.FreeUnmanaged(ref obj);
		if (ObjectEx.IsUnityNull(currentTarget))
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

```

## OnItemRemove(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from the game.
/// </summary>
/// <param name="item">The item that is being removed.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being removed. 
/// If `null` is returned, the item will be removed as normal.
/// </returns>
object OnItemRemove(Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.net.ID}) is being removed from the game.");
    
    if (item.amount > 0)
    {
        Puts($"Item {item.info.displayName.english} cannot be removed because there are still {item.amount} left.");
        return true; // Prevent removal
    }
    
    return null; // Allow removal
}
```
```

### Source Code from the Library

```csharp

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = UnityEngine.Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		ItemManager.RemoveItem(this, fTime);
	}

```

## OnSignUpdated(Signage,BasePlayer,int)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated by a player.
/// </summary>
/// <param name="sign">The sign that has been updated.</param>
/// <param name="player">The player who updated the sign.</param>
/// <param name="textureIndex">The index of the texture being updated.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(Signage sign, BasePlayer player, int textureIndex)
{
    Puts($"Sign updated by {player.displayName} (ID: {player.UserIDString}) at texture index {textureIndex}.");
    
    if (textureIndex < 0)
    {
        Puts("Invalid texture index provided.");
    }
    else
    {
        Puts($"Texture index {textureIndex} successfully updated for sign ID: {sign.net.ID}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			UnityEngine.Debug.LogWarning($"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", this, msg.player, num);
	}

```

## OnInventoryAmmoItemFind(PlayerInventory,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to find an ammo item in a player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory being searched.</param>
/// <param name="ammoType">The type of ammo being searched for.</param>
/// <returns>
/// Returns the found <c>Item</c> if an ammo item is located; otherwise, returns <c>null</c>.
/// If the method returns a non-null value, it overrides the default search behavior.
/// </returns>
Item OnInventoryAmmoItemFind(PlayerInventory inventory, ItemDefinition ammoType)
{
    Puts($"Searching for ammo of type: {ammoType.shortname} in inventory of player: {inventory.GetOwnerPlayer().displayName}");
    
    // Example condition to block certain ammo types
    if (ammoType.shortname == "explosive.satchel")
    {
        Puts("Explosive satchel ammo cannot be found.");
        return null;
    }

    return null; // Allow default behavior to find the item
}
```
```

### Source Code from the Library

```csharp

	public Item GetAmmo()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		object obj = Interface.CallHook("OnInventoryAmmoItemFind", ownerPlayer.inventory, fuelType);
		if (obj is Item)
		{
			return (Item)obj;
		}
		return ownerPlayer.inventory.FindItemByItemName(fuelType.shortname);
	}

```

## OnNoGoZoneAdded(PatrolHelicopterAI,PatrolHelicopterAI.DangerZone)

```csharp
```csharp
/// <summary>
/// Called when a new no-go zone is added to the patrol helicopter's AI.
/// </summary>
/// <param name="helicopter">The patrol helicopter AI that is affected by the no-go zone.</param>
/// <param name="zone">The danger zone that has been added.</param>
/// <returns>No return behavior.</returns>
void OnNoGoZoneAdded(PatrolHelicopterAI helicopter, PatrolHelicopterAI.DangerZone zone)
{
    Puts($"No-go zone added: {zone.name} for Helicopter ID: {helicopter.net.ID} at position: {helicopter.transform.position}");
    
    if (zone.IsPointInside(helicopter.transform.position))
    {
        Puts($"Helicopter ID: {helicopter.net.ID} is currently inside the no-go zone: {zone.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void NoGoZoneAdded(DangerZone zone)
	{
		if (use_danger_zones && Interface.CallHook("OnNoGoZoneAdded", this, zone) == null && zone.IsPointInside(base.transform.position))
		{
			_targetList.Clear();
			ExitCurrentState();
			Vector3 nearestEdge = zone.GetNearestEdge(base.transform.position);
			nearestEdge.y = UnityEngine.Random.Range(35f, 45f);
			State_Flee_Enter(nearestEdge);
		}
	}

```

## OnDieselEngineToggle(DieselEngine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off by a player.
/// </summary>
/// <param name="engine">The diesel engine being toggled.</param>
/// <param name="player">The player who is toggling the engine.</param>
/// <returns>No return behavior.</returns>
void OnDieselEngineToggle(DieselEngine engine, BasePlayer player)
{
    Puts($"Player {player.displayName} toggled the diesel engine (ID: {engine.net.ID}).");

    if (engine.IsRunning())
    {
        Puts($"The diesel engine is currently running.");
    }
    else
    {
        Puts($"The diesel engine is currently off.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnDieselEngineToggle", this, msg.player) != null)
		{
			return;
		}
		if (msg.read.Bit())
		{
			if (GetFuelAmount() > 0)
			{
				EngineOn();
				startedByPlayer = msg.player;
				if (Rust.GameInfo.HasAchievements && msg.player != null)
				{
					msg.player.stats.Add("excavator_activated", 1, Stats.All);
					msg.player.stats.Save(forceSteamSave: true);
				}
			}
		}
		else
		{
			EngineOff();
		}
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to loot an item.
/// </summary>
/// <param name="player">The player who is looting the item.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootItem(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is looting item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "forbidden.item")
    {
        Puts($"Player {player.displayName} attempted to loot a forbidden item.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
			MarkDirty();
		}
	}

```

## OnPlanterBoxFertilize(PlanterBox)

```csharp
```csharp
/// <summary>
/// Called when a planter box is fertilized.
/// </summary>
/// <param name="planterBox">The planter box being fertilized.</param>
/// <returns>No return behavior.</returns>
void OnPlanterBoxFertilize(PlanterBox planterBox)
{
    Puts($"Planter box {planterBox.net.ID} is being fertilized.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void FertilizeGrowables()
	{
		if (Interface.CallHook("OnPlanterBoxFertilize", this) != null)
		{
			return;
		}
		int num = GetFertilizerCount();
		if (num <= 0)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			if (child == null)
			{
				continue;
			}
			GrowableEntity growableEntity = child as GrowableEntity;
			if (!(growableEntity == null) && !growableEntity.Fertilized && ConsumeFertilizer())
			{
				growableEntity.Fertilize();
				num--;
				if (num == 0)
				{
					break;
				}
			}
		}
	}

```

## OnVendingShopOpened(NPCVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop is opened by a player.
/// </summary>
/// <param name="vendingMachine">The vending machine that is being opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpened(NPCVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending shop opened by {player.displayName} at machine {vendingMachine.net.ID}.");
    
    if (player.inventory.GetAmount("special_token") > 0)
    {
        Puts($"{player.displayName} has a special token and receives a bonus item!");
        // Logic to give bonus item can be added here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if (vendingMachine == null)
		{
			vendingMachine = GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", vendingMachine, msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", vendingMachine, msg.player);
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
```csharp
/// <summary>
/// Called on each tick for a player to process input and game state updates.
/// </summary>
/// <param name="player">The player whose tick is being processed.</param>
/// <param name="msg">The input state and other relevant data for the tick.</param>
/// <param name="wasPlayerStalled">Indicates if the player was stalled during the last tick.</param>
/// <returns>No return behavior.</returns>
void OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
{
    Puts($"Processing tick for player {player.displayName} (ID: {player.UserIDString}).");

    if (wasPlayerStalled)
    {
        Puts($"Player {player.displayName} was stalled during the last tick.");
    }

    // Additional logic can be added here to handle player-specific tick events.
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		if (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)
		{
			UpdateActiveItem(restraintItemId.Value);
		}
		else
		{
			UpdateActiveItem(msg.activeItem);
		}
		UpdateModelStateFromTick(msg);
		if (IsIncapacitated())
		{
			return;
		}
		if (isMounted)
		{
			GetMounted().PlayerServerInput(serverInput, this);
		}
		UpdatePositionFromTick(msg, wasPlayerStalled);
		UpdateRotationFromTick(msg);
		int activeMission = GetActiveMission();
		if (activeMission >= 0 && activeMission < missions.Count)
		{
			BaseMission.MissionInstance missionInstance = missions[activeMission];
			if (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())
			{
				ProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);
			}
		}
		if (TutorialIsland.EnforceTrespassChecks && !IsAdmin && !IsNpc && net != null && net.group != null)
		{
			if (net.group.restricted)
			{
				bool flag = false;
				if (!IsInTutorial)
				{
					flag = true;
				}
				else
				{
					TutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();
					if (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)
					{
						flag = true;
					}
				}
				if (flag)
				{
					tutorialKickTime += UnityEngine.Time.deltaTime;
					if (tutorialKickTime > 3f)
					{
						Debug.LogWarning($"Killing player {displayName}/{userID.Get()} as they are on a tutorial island that doesn't belong them");
						Hurt(999f);
						tutorialKickTime = 0f;
					}
				}
				else
				{
					tutorialKickTime = 0f;
				}
			}
			else if (IsInTutorial && !net.group.restricted)
			{
				bool flag2 = false;
				TutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();
				if (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)
				{
					flag2 = true;
				}
				if (flag2)
				{
					tutorialKickTime += UnityEngine.Time.deltaTime;
					if (tutorialKickTime > 3f)
					{
						Debug.LogWarning($"Killing player {displayName}/{userID.Get()} as they are no longer on a tutorial island and are marked as being in a tutorial");
						Hurt(999f);
						tutorialKickTime = 0f;
					}
				}
				else
				{
					tutorialKickTime = 0f;
				}
			}
		}
		using (TimeWarning.New("AnalyticsTick"))
		{
			Facepunch.Rust.Analytics.Azure.OnPlayerTick(this);
		}
	}

```

## OnFishingStopped(BaseFishingRod,BaseFishingRod.FailReason)

```csharp
```csharp
/// <summary>
/// Called when fishing is stopped, either due to a successful catch or a failure.
/// </summary>
/// <param name="rod">The fishing rod that was used for fishing.</param>
/// <param name="reason">The reason for stopping the fishing process.</param>
/// <returns>No return behavior.</returns>
void OnFishingStopped(BaseFishingRod rod, BaseFishingRod.FailReason reason)
{
    Puts($"Fishing stopped on rod {rod.net.ID} due to reason: {reason}.");
    
    if (reason == BaseFishingRod.FailReason.Success)
    {
        Puts("A fish was successfully caught!");
    }
    else
    {
        Puts("Fishing failed, no catch was made.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void Server_Cancel(FailReason reason)
	{
		if (GetItem() != null)
		{
			GetItem().LoseCondition((reason == FailReason.Success) ? ConditionLossOnSuccess : ConditionLossOnFail);
		}
		SetFlag(Flags.Busy, b: false);
		UpdateFlags();
		CancelInvoke(CatchProcess);
		CurrentState = CatchState.None;
		SetFlag(Flags.Reserved1, b: false);
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		if (fishingBobber != null)
		{
			fishingBobber.Kill();
			currentBobber.Set(null);
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ResetLine"), (int)reason);
		Interface.CallHook("OnFishingStopped", this, reason);
	}

```

## OnBoomboxStationUpdated(BoomBox,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the boombox station is updated with a new IP address.
/// </summary>
/// <param name="boombox">The boombox entity that is being updated.</param>
/// <param name="ipAddress">The new IP address for the boombox station.</param>
/// <param name="player">The player who initiated the update.</param>
/// <returns>No return behavior.</returns>
void OnBoomboxStationUpdated(BoomBox boombox, string ipAddress, BasePlayer player)
{
    Puts($"Boombox updated by {player.displayName} to new IP: {ipAddress}.");
    
    if (ipAddress == "192.168.0.1")
    {
        Puts("Warning: Attempt to set boombox to a restricted IP address.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnBoomboxStationUpdate", this, text, msg.player) == null && IsStationValid(text))
		{
			if (msg.player != null)
			{
				ulong assignedRadioBy = msg.player.userID.Get();
				AssignedRadioBy = assignedRadioBy;
			}
			CurrentRadioIp = text;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnRadioIPChanged"), CurrentRadioIp);
			Interface.CallHook("OnBoomboxStationUpdated", this, text, msg.player);
			if (IsOn())
			{
				ServerTogglePlay(play: false);
			}
		}
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item is being removed.</param>
/// <param name="item">The item that is being removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) has been removed from container {container.name}.");
    
    if (item.info.itemid == 12345) // Example item ID for a specific action
    {
        Puts("Special item removed, triggering additional effects.");
        // Additional logic for special item removal can be added here
    }
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		onPreItemRemove?.Invoke(item);
		itemList.Remove(item);
		item.parent = null;
		onItemParentChanged?.Invoke(parent, item);
		onItemAddedRemoved?.Invoke(item, arg2: false);
		MarkDirty();
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## OnMlrsFiringEnded(MLRS)

```csharp
```csharp
/// <summary>
/// Called when the Multiple Launch Rocket System (MLRS) has finished firing.
/// </summary>
/// <param name="mlrs">The MLRS instance that has completed its firing sequence.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFiringEnded(MLRS mlrs)
{
    Puts($"MLRS firing has ended for instance ID: {mlrs.net.ID}. All rockets have been fired.");
}
```
```

### Source Code from the Library

```csharp

	public void EndFiring()
	{
		CancelInvoke(FireNextRocket);
		rocketOwnerRef.Set(null);
		if (TryGetAimingModule(out var item))
		{
			item.LoseCondition(1f);
		}
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Broken, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		timeSinceBroken = 0f;
		Interface.CallHook("OnMlrsFiringEnded", this);
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when an item's condition is reduced.
/// </summary>
/// <param name="item">The item whose condition is being reduced.</param>
/// <param name="amount">The amount by which the item's condition is being reduced.</param>
/// <returns>
/// Returns a non-null value to prevent the condition loss, or `null` to allow the condition to be reduced.
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Condition loss event for item {item.info.displayName.english} (ID: {item.net.ID}) by {amount}.");

    if (item.info.shortname == "special.item")
    {
        Puts($"Condition loss for {item.info.displayName.english} is blocked.");
        return true; // Prevent condition loss for this specific item
    }

    return null; // Allow condition loss for all other items
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## OnDroppedItemCombined(DroppedItem)

```csharp
```csharp
/// <summary>
/// Called when two dropped items are combined into one.
/// </summary>
/// <param name="droppedItem">The dropped item that is being combined with another item.</param>
/// <returns>No return behavior.</returns>
void OnDroppedItemCombined(DroppedItem droppedItem)
{
    Puts($"Dropped item {droppedItem.item.info.displayName.english} combined with {item.info.displayName.english}.");

    if (item.amount > item.MaxStackable())
    {
        Puts($"Combination failed: {item.info.displayName.english} exceeds max stackable limit.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.DestroyItem();
			di.Kill();
			Interface.CallHook("OnDroppedItemCombined", this);
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(base.transform.position, Vector3.zero, base.transform.rotation);
			}
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped in the game world.
/// </summary>
/// <param name="item">The item that is being dropped.</param>
/// <param name="entity">The entity that represents the dropped item in the world.</param>
/// <returns>No return behavior.</returns>
void OnItemDropped(Item item, BaseEntity entity)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.info.itemid}) has been dropped by player {item.GetOwnerPlayer()?.displayName}.");
    
    if (entity != null)
    {
        Puts($"Dropped item is now represented by entity ID: {entity.net.ID}.");
    }
    else
    {
        Puts("The item could not be dropped as it is not valid.");
    }
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		ulong droppedBy = GetRootContainer()?.playerOwner?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
		RemoveFromWorld();
		if (info.AlignWorldModelOnDrop)
		{
			rotation = Quaternion.Euler(0f, Quaternion.LookRotation(vVelocity.normalized, Vector3.up).eulerAngles.y, 0f);
			rotation = Quaternion.Euler(info.WorldModelDropOffset) * rotation;
		}
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
			if (baseEntity is DroppedItem droppedItem)
			{
				droppedItem.DroppedBy = droppedBy;
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## OnPhoneDialFailed(PhoneController,Telephone.DialFailReason,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing attempt fails.
/// </summary>
/// <param name="phoneController">The phone controller that initiated the dialing attempt.</param>
/// <param name="reason">The reason for the dialing failure.</param>
/// <param name="player">The player who attempted to dial.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialFailed(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer player)
{
    Puts($"Player {player.displayName} failed to dial due to reason: {reason}.");
    // Additional logic can be added here based on the failure reason.
}
```
```

### Source Code from the Library

```csharp

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", this, reason, currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientOnDialFailed"), (int)reason);
			activeCallTo = null;
			if (IsInvoking(TimeOutCall))
			{
				CancelInvoke(TimeOutCall);
			}
			if (IsInvoking(TriggerTimeOut))
			{
				CancelInvoke(TriggerTimeOut);
			}
			if (IsInvoking(TimeOutDialing))
			{
				CancelInvoke(TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", this, reason, currentPlayer);
		}
	}

```

## IOnPlayerBanned(Network.Connection,AuthResponse)

```csharp
```csharp
/// <summary>
/// Called when a player is banned based on their authentication response from Steam.
/// </summary>
/// <param name="connection">The network connection of the banned player.</param>
/// <param name="status">The authentication response indicating the reason for the ban.</param>
/// <returns>No return behavior.</returns>
void IOnPlayerBanned(Network.Connection connection, AuthResponse status)
{
    Puts($"Player {connection.username} (ID: {connection.userid}) has been banned. Reason: {status}.");
    
    if (status == AuthResponse.VACBanned)
    {
        Puts($"Player {connection.username} is VAC banned.");
    }
    else if (status == AuthResponse.PublisherBanned)
    {
        Puts($"Player {connection.username} is banned by the publisher.");
    }
}
```
```

### Source Code from the Library

```csharp

	internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
	{
		if (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))
		{
			return;
		}
		Network.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) => x.userid == SteamId);
		if (connection == null)
		{
			UnityEngine.Debug.LogWarning($"Steam gave us a {Status} ticket response for unconnected id {SteamId}");
			return;
		}
		switch (Status)
		{
		case AuthResponse.OK:
			UnityEngine.Debug.LogWarning($"Steam gave us a 'ok' ticket response for already connected id {SteamId}");
			return;
		case AuthResponse.TimedOut:
			return;
		case AuthResponse.VACBanned:
		case AuthResponse.PublisherBanned:
			if (!bannedPlayerNotices.Contains(SteamId))
			{
				Interface.CallHook("IOnPlayerBanned", connection, Status);
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + connection.username.EscapeRichText() + " (banned by anticheat)");
				bannedPlayerNotices.Add(SteamId);
			}
			break;
		}
		UnityEngine.Debug.Log($"Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \"{Status.ToString()}\")");
		connection.authStatusSteam = Status.ToString();
		Network.Net.sv.Kick(connection, "Steam: " + Status);
	}

```

## OnTick()

```csharp
```csharp
/// <summary>
/// Called every tick to perform regular updates and checks.
/// </summary>
/// <returns>No return behavior.</returns>
void OnTick()
{
    Puts("OnTick event triggered, performing updates.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		Interface.CallHook("OnTick");
		RCon.Update();
		CompanionServer.Server.Update();
		NexusServer.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Network.Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## OnPayForPlacement(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Called when a player pays for the placement of a construction item.
/// </summary>
/// <param name="player">The player who is placing the construction.</param>
/// <param name="planner">The planner used for the construction placement.</param>
/// <param name="construction">The construction being placed.</param>
/// <returns>No return behavior.</returns>
void OnPayForPlacement(BasePlayer player, Planner planner, Construction construction)
{
    Puts($"Player {player.displayName} is paying for placement of {construction.fullName}.");

    if (player.IsInTutorial)
    {
        Puts($"Player {player.displayName} is in tutorial mode; placement will be handled differently.");
    }
    
    if (construction.isTypeDeployable)
    {
        Puts($"Deployable item {construction.fullName} placed by {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", player, this, component) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		if (player.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null)
			{
				currentTutorialIsland.OnPlayerBuiltConstruction(player);
			}
		}
		if (isTypeDeployable)
		{
			GetItem().UseItem();
			return;
		}
		List<Item> obj = Facepunch.Pool.Get<List<Item>>();
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			player.inventory.Take(obj, item.itemDef.itemid, (int)item.amount);
			player.Command("note.inv", item.itemDef.itemid, item.amount * -1f);
		}
		foreach (Item item2 in obj)
		{
			item2.Remove();
		}
		Facepunch.Pool.Free(ref obj, freeElements: false);
	}

```

## OnPlayerRecover(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from a wounded state.
/// </summary>
/// <param name="player">The player who is recovering.</param>
/// <returns>
/// Returns `null` to allow the recovery process to continue, or any non-null value to prevent recovery.
/// </returns>
object OnPlayerRecover(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to recover from being wounded.");
    
    if (player.health < 10)
    {
        Puts($"Player {player.displayName} cannot recover due to low health.");
        return "Health too low to recover.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			if (IsCrawling())
			{
				base.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if ((bool)BaseGameMode.GetActiveGameMode(base.isServer))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", this);
		}
	}

```

## CanBeAwardedAdventGift(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines if a player can be awarded today's advent gift.
/// </summary>
/// <param name="calendar">The advent calendar instance.</param>
/// <param name="player">The player being checked for gift eligibility.</param>
/// <returns>
/// Returns `true` if the player can be awarded today's gift, or `false` if they cannot.
/// If the method returns `null`, the default logic will be used to determine eligibility.
/// </returns>
bool? CanBeAwardedAdventGift(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Checking advent gift eligibility for player {player.displayName} (ID: {player.userID}).");

    if (player.IsBannedFromGifts)
    {
        Puts($"Player {player.displayName} is banned from receiving advent gifts.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool WasAwardedTodaysGift(BasePlayer player)
	{
		object obj = Interface.CallHook("CanBeAwardedAdventGift", this, player);
		if (obj is bool)
		{
			return !(bool)obj;
		}
		if (!playerRewardHistory.ContainsKey(player.userID))
		{
			return false;
		}
		DateTime now = DateTime.Now;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) != startMonth)
		{
			return true;
		}
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (num < 0 || num >= days.Length)
		{
			return true;
		}
		if (playerRewardHistory[player.userID].Contains(num))
		{
			return true;
		}
		return false;
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed by a player.
/// </summary>
/// <param name="trap">The bear trap that is being armed.</param>
/// <param name="player">The player who is arming the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to be armed, or any non-null value to prevent it from being armed.
/// </returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to arm a bear trap.");
    
    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot arm a trap in a safe zone.");
        return "You cannot arm traps in a safe zone.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## OnEntityEnter(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger area.
/// </summary>
/// <param name="entity">The entity that has entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity?.name} has entered the trigger area of {trigger?.name}.");

    if (entity is BasePlayer player)
    {
        Puts($"Player {player.displayName} has entered the comfort zone.");
        _players.Add(player);
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityEnter(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityEnter", this, ent) == null)
		{
			_players.Add(basePlayer);
		}
	}

```

## OnVehicleHornPressed(VehicleModuleSeating,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the horn of a vehicle is pressed by a player.
/// </summary>
/// <param name="seating">The seating module of the vehicle where the horn is being pressed.</param>
/// <param name="player">The player who pressed the horn.</param>
/// <returns>No return behavior.</returns>
void OnVehicleHornPressed(VehicleModuleSeating seating, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) pressed the vehicle horn.");
    
    // Additional logic can be added here, such as playing a sound or triggering an event.
}
```
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (hornLoop != null && IsOnThisModule(player))
		{
			bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
			if (flag != HasFlag(Flags.Reserved8))
			{
				SetFlag(Flags.Reserved8, flag);
			}
			if (flag)
			{
				Interface.CallHook("OnVehicleHornPressed", this, player);
				hornPlayer = player;
			}
		}
	}

```

## OnConnectionQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a connection is added to the queue for joining the server.
/// </summary>
/// <param name="connection">The network connection that is being queued.</param>
/// <returns>
/// Returns a non-null value to prevent the connection from joining the queue. 
/// If `null` is returned, the connection will be added to the queue as normal.
/// </returns>
object OnConnectionQueue(Network.Connection connection)
{
    Puts($"Connection from {connection.ipaddress} is attempting to join the queue.");
    
    if (connection.ipaddress == "192.168.0.100")
    {
        Puts("Connection from this IP is blocked from joining the queue.");
        return "You are not allowed to join the server.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal void Join(Connection connection)
	{
		if (Interface.CallHook("OnConnectionQueue", connection) == null)
		{
			connection.state = Connection.State.InQueue;
			queue.Add(connection);
			nextMessageTime = 0f;
			if (CanJumpQueue(connection))
			{
				JoinGame(connection);
			}
		}
	}

```

## OnProjectileRicochet(BasePlayer,ProtoBuf.PlayerProjectileRicochet)

```csharp
```csharp
/// <summary>
/// Called when a projectile ricochets off a surface.
/// </summary>
/// <param name="player">The player who fired the projectile.</param>
/// <param name="ricochetData">Data related to the ricochet event, including position and velocity.</param>
/// <returns>No return behavior.</returns>
void OnProjectileRicochet(BasePlayer player, ProtoBuf.PlayerProjectileRicochet ricochetData)
{
    Puts($"Projectile ricochet detected for player {player.displayName} with ID: {ricochetData.projectileID}.");

    if (ricochetData.hitPosition.IsNaNOrInfinity())
    {
        Puts("Ricochet data contains invalid hit position.");
        return;
    }

    // Additional logic can be added here to handle the ricochet event.
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void OnProjectileRicochet(RPCMessage msg)
	{
		PlayerProjectileRicochet playerProjectileRicochet = PlayerProjectileRicochet.Deserialize(msg.read);
		if (playerProjectileRicochet != null)
		{
			FiredProjectile value;
			if (playerProjectileRicochet.hitPosition.IsNaNOrInfinity() || playerProjectileRicochet.inVelocity.IsNaNOrInfinity() || playerProjectileRicochet.outVelocity.IsNaNOrInfinity() || playerProjectileRicochet.hitNormal.IsNaNOrInfinity() || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + playerProjectileRicochet.projectileID + ")", logToAnalytics: false);
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (value.firedTime < UnityEngine.Time.realtimeSinceStartup - 8f)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (Interface.CallHook("OnProjectileRicochet", this, playerProjectileRicochet) == null)
			{
				value.ricochets++;
				firedProjectiles[playerProjectileRicochet.projectileID] = value;
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
		}
	}

```

## OnEntityPickedUp(BaseCombatEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is picked up by a player.
/// </summary>
/// <param name="entity">The entity that was picked up.</param>
/// <param name="item">The item that was created as a result of the pickup.</param>
/// <param name="player">The player who picked up the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityPickedUp(BaseCombatEntity entity, Item item, BasePlayer player)
{
    Puts($"Entity {entity.net.ID} picked up by {player.displayName} (ID: {player.UserIDString}).");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnPickedUp(Item createdItem, BasePlayer player)
	{
		Interface.CallHook("OnEntityPickedUp", this, createdItem, player);
	}

```

## OnNpcConversationResponded(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
```csharp
/// <summary>
/// Called when a player responds to an NPC conversation.
/// </summary>
/// <param name="npc">The NPC that the player is conversing with.</param>
/// <param name="player">The player who responded to the conversation.</param>
/// <param name="conversation">The conversation data associated with the interaction.</param>
/// <param name="response">The specific response node chosen by the player.</param>
/// <returns>No return behavior.</returns>
void OnNpcConversationResponded(NPCTalking npc, BasePlayer player, ConversationData conversation, ConversationData.ResponseNode response)
{
    Puts($"Player {player.displayName} responded to NPC {npc.name} with response: {response.text}");

    if (response.text.Contains("goodbye"))
    {
        Puts($"Player {player.displayName} ended the conversation with NPC {npc.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode == null || Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) != null)
		{
			return;
		}
		if (responseNode.conditions.Length != 0)
		{
			UpdateFlags();
		}
		bool flag = responseNode.PassesConditions(player, this);
		if (flag)
		{
			string actionString = responseNode.GetActionString();
			if (!string.IsNullOrEmpty(actionString))
			{
				OnConversationAction(player, actionString);
			}
		}
		int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
		if (speechNodeIndex == -1)
		{
			ForceEndConversation(player);
			return;
		}
		ForceSpeechNode(player, speechNodeIndex);
		Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
	}

```

## OnWorldProjectileCreate(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="info">The hit information related to the projectile's creation.</param>
/// <param name="item">The item associated with the projectile.</param>
/// <returns>No return behavior.</returns>
void OnWorldProjectileCreate(HitInfo info, Item item)
{
    Puts($"World projectile created at position: {info.HitPositionWorld}, by item: {item.info.displayName.english}.");

    if (item.info.shortname == "rocket.launcher")
    {
        Puts("A rocket launcher projectile has been created!");
    }
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if (droppedItem != null)
			{
				droppedItem.StickIn();
			}
			else
			{
				baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			Rigidbody component = baseEntity.GetComponent<Rigidbody>();
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## OnCrateLanded(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate has successfully landed.
/// </summary>
/// <param name="crate">The hackable locked crate that has landed.</param>
/// <returns>No return behavior.</returns>
void OnCrateLanded(HackableLockedCrate crate)
{
    Puts($"Hackable locked crate has landed at position: {crate.transform.position}.");
    // Additional logic can be added here, such as spawning loot or notifying players.
}
```
```

### Source Code from the Library

```csharp

	public void LandCheck()
	{
		RaycastHit hitInfo;
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", this);
		}
		else if (UnityEngine.Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1084293377))
		{
			Effect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);
			hasLanded = true;
			CancelInvoke(LandCheck);
		}
	}

```

## OnExplosiveFuseSet(TimedExplosive,float)

```csharp
```csharp
/// <summary>
/// Called when the fuse of a timed explosive is set.
/// </summary>
/// <param name="explosive">The timed explosive whose fuse is being set.</param>
/// <param name="fuseLength">The length of the fuse in seconds.</param>
/// <returns>
/// Returns the adjusted fuse length as a float. If the method returns `null`, the default fuse length will be used.
/// </returns>
float? OnExplosiveFuseSet(TimedExplosive explosive, float fuseLength)
{
    Puts($"Setting fuse for explosive {explosive.net.ID} to {fuseLength} seconds.");
    
    if (fuseLength < 1.0f)
    {
        Puts("Fuse length is too short, setting to minimum of 1 second.");
        return 1.0f;
    }

    return null; // Allow the default fuse length to be used if no adjustments are made.
}
```
```

### Source Code from the Library

```csharp

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			object obj = Interface.CallHook("OnExplosiveFuseSet", this, fuseLength);
			if (obj is float)
			{
				fuseLength = (float)obj;
			}
			Invoke(Explode, fuseLength);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

```

## CanEquipItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be equipped in a specified slot of the player's inventory.
/// </summary>
/// <param name="item">The item to be equipped.</param>
/// <param name="targetSlot">The slot in which the item is to be equipped.</param>
/// <returns>
/// Returns `true` if the item can be equipped in the specified slot; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the item can be equipped.
/// </returns>
bool? CanEquipItem(Item item, int targetSlot)
{
    Puts($"Checking if item {item.info.displayName.english} can be equipped in slot {targetSlot}.");

    if (item.info.shortname == "restricted.item")
    {
        Puts($"Item {item.info.displayName.english} is restricted and cannot be equipped.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanEquipItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanEquipItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((item.info.flags & ItemDefinition.Flag.NotAllowedInBelt) != 0)
		{
			return false;
		}
		if (base.baseEntity != null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if (restraintItem != null && restraintItem.GetItem().position == targetSlot)
			{
				return false;
			}
		}
		ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
		if (component == null)
		{
			return true;
		}
		Item[] array = containerBelt.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
				}
			}
		}
		return true;
	}

```

## OnRackedWeaponMounted(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is successfully mounted on a weapon rack.
/// </summary>
/// <param name="item">The weapon item being mounted.</param>
/// <param name="player">The player who is mounting the weapon.</param>
/// <param name="rack">The weapon rack where the weapon is being mounted.</param>
/// <returns>
/// Returns `true` if the weapon was successfully mounted; otherwise, returns `false`.
/// If a non-null value is returned from the hook, it will override the default behavior.
/// </returns>
bool OnRackedWeaponMounted(Item item, BasePlayer player, WeaponRack rack)
{
    Puts($"Weapon {item.info.displayName.english} mounted by {player.displayName} on rack {rack.net.ID}.");
    
    if (item.info.shortname == "rifle.semiauto")
    {
        Puts("A semi-automatic rifle has been mounted!");
    }
    
    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", item, player, this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			Debug.LogWarning("no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if (player != null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", item, player, this);
		return true;
	}

```

## CanLootEntity(BasePlayer,ResourceContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="container">The resource container being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, ResourceContainer container)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot the container.");

    if (container.IsLocked())
    {
        Puts($"Container is locked. Player {player.displayName} cannot loot.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.IsVisible(3f)]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}

```

## InitLogging()

```csharp
```csharp
/// <summary>
/// Initializes the logging system for the application.
/// </summary>
/// <returns>No return behavior.</returns>
void InitLogging()
{
    Puts("Logging system initialized successfully.");
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

```

## OnPlayerColliderEnable(BasePlayer,UnityEngine.CapsuleCollider)

```csharp
```csharp
/// <summary>
/// Called when a player's collider is enabled.
/// </summary>
/// <param name="player">The player whose collider is being enabled.</param>
/// <param name="collider">The collider being enabled for the player.</param>
/// <returns>
/// Returns a non-null value to prevent the collider from being enabled; otherwise, returns `null` to allow enabling.
/// </returns>
object OnPlayerColliderEnable(BasePlayer player, UnityEngine.CapsuleCollider collider)
{
    Puts($"Enabling collider for player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone; collider will not be enabled.");
        return true; // Prevent enabling the collider
    }

    return null; // Allow enabling the collider
}
```
```

### Source Code from the Library

```csharp

	public void EnablePlayerCollider()
	{
		if (!playerCollider.enabled && Interface.CallHook("OnPlayerColliderEnable", this, playerCollider) == null)
		{
			RefreshColliderSize(forced: true);
			playerCollider.enabled = true;
		}
	}

```

## OnNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC initiates an attack on a target.
/// </summary>
/// <param name="npc">The NPC that is attacking.</param>
/// <param name="target">The entity that is being attacked.</param>
/// <returns>
/// Returns `null` to allow the attack to proceed, or any non-null value to prevent the attack.
/// </returns>
object OnNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is attempting to attack {target.displayName} (ID: {target.net.ID}).");

    if (target is PlayerEntity)
    {
        Puts($"NPC {npc.displayName} cannot attack players.");
        return true; // Prevent the attack
    }

    return null; // Allow the attack
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if ((bool)AttackTarget && AttackReady() && Interface.CallHook("OnNpcAttack", this, AttackTarget) == null && !((AttackTarget.ServerPosition - ServerPosition).magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(RpcTarget.NetworkGroup("Attack"), AttackTarget.ServerPosition);
			}
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client attempts to authenticate with the server.
/// </summary>
/// <param name="connection">The network connection of the client attempting to authenticate.</param>
/// <returns>No return behavior.</returns>
void OnClientAuth(Network.Connection connection)
{
    Puts($"Client {connection.username} (ID: {connection.userid}) is attempting to authenticate.");

    if (connection.state != Network.Connection.State.Connecting)
    {
        Puts($"Client {connection.username} has an invalid connection state.");
        Network.Net.sv.Kick(connection, "Invalid connection state");
        return;
    }

    // Additional checks and logic can be added here as needed
    Puts($"Client {connection.username} authenticated successfully.");
}
```
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Network.Connection.State.Connecting;
		if (packet.read.UInt8() != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String(128);
		packet.connection.username = packet.read.String();
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.Unread >= 4)
		{
			text = packet.read.String(128);
		}
		Interface.CallHook("OnClientAuth", packet.connection);
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their branch is '" + text + "' not '" + branch + "'");
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2564)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2564);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2564)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2564);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize(512u);
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
				return;
			}
			packet.connection.anticheatId = packet.read.StringRaw(128);
			packet.connection.anticheatToken = packet.read.StringRaw(2048);
			packet.connection.clientChangeset = packet.read.Int32();
			packet.connection.clientBuildTime = packet.read.Int64();
			auth.OnNewConnection(packet.connection);
		}
	}

```

## OnInventoryItemsFind(PlayerInventory,int)

```csharp
```csharp
/// <summary>
/// Called to find items in the player's inventory by their item ID.
/// </summary>
/// <param name="inventory">The player's inventory being searched.</param>
/// <param name="itemId">The ID of the item to find.</param>
/// <returns>
/// Returns a list of items that match the specified item ID. 
/// If the hook returns a non-null value, that value will be used instead of the default search logic.
/// </returns>
List<Item> OnInventoryItemsFind(PlayerInventory inventory, int itemId)
{
    Puts($"Searching for items with ID: {itemId} in inventory of {inventory.Owner.displayName}.");
    return new List<Item>(); // Placeholder for actual implementation
}
```
```

### Source Code from the Library

```csharp

	public List<Item> FindItemsByItemID(int id)
	{
		object obj = Interface.CallHook("OnInventoryItemsFind", this, id);
		if (obj is List<Item>)
		{
			return (List<Item>)obj;
		}
		List<Item> list = new List<Item>();
		if (containerMain != null)
		{
			list.AddRange(containerMain.FindItemsByItemID(id));
		}
		if (containerBelt != null)
		{
			list.AddRange(containerBelt.FindItemsByItemID(id));
		}
		if (containerWear != null)
		{
			list.AddRange(containerWear.FindItemsByItemID(id));
		}
		return list;
	}

```

## OnNpcConversationEnded(NPCTalking,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a conversation with an NPC has ended for a player.
/// </summary>
/// <param name="npc">The NPC that the player was conversing with.</param>
/// <param name="player">The player who ended the conversation.</param>
/// <returns>No return behavior.</returns>
void OnNpcConversationEnded(NPCTalking npc, BasePlayer player)
{
    Puts($"Conversation ended between NPC {npc.name} and player {player.displayName} (ID: {player.UserIDString}).");
    
    if (conversingPlayers.Contains(player))
    {
        Puts($"Removing player {player.displayName} from the conversation list.");
        conversingPlayers.Remove(player);
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnConversationEnded(BasePlayer player)
	{
		Interface.CallHook("OnNpcConversationEnded", this, player);
		if (conversingPlayers.Contains(player))
		{
			conversingPlayers.Remove(player);
		}
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
```csharp
/// <summary>
/// Called when a new resource deposit is created in the world.
/// </summary>
/// <param name="deposit">The resource deposit that has been created.</param>
/// <returns>No return behavior.</returns>
void OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit deposit)
{
    Puts($"Resource deposit created at position: {deposit.origin}. Contains: {deposit.GetContents()}.");
    
    if (deposit.GetContents().Contains("crude.oil"))
    {
        Puts("A crude oil deposit has been created!");
    }
}
```
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		UnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)
		};
		if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else
		{
			bool flag = false;
			float num = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)
				{
					num += 0.25f;
				}
			}
			else
			{
				num += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(8f, 10f), ResourceDeposit.surveySpawnType.ITEM, liquid: true);
				flag = true;
			}
			if (!flag)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
				float num2 = 0f;
				num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num3 = 0f;
				num3 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num3)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num4 = 0f;
				if (World.Procedural)
				{
					if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
					{
						num4 += 0.25f;
					}
				}
				else
				{
					num4 += 0.15f;
				}
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num4)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
				}
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnHuntEventEnd(EggHuntEvent)

```csharp
```csharp
/// <summary>
/// Called when the egg hunt event ends.
/// </summary>
/// <param name="event">The egg hunt event that has just concluded.</param>
/// <returns>
/// Returns a non-null value to override the default end behavior of the event. 
/// If `null` is returned, the event will end normally.
/// </returns>
object OnHuntEventEnd(EggHuntEvent event)
{
    Puts($"Egg Hunt Event has ended. Event ID: {event.eventID}, Duration: {event.durationSeconds} seconds.");
    
    // Example condition to prevent the event from ending
    if (event.participants.Count < 1)
    {
        Puts("Event cannot end as there are no participants.");
        return "No participants to conclude the event.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Update()
	{
		timeAlive += UnityEngine.Time.deltaTime;
		if (base.isServer && !base.IsDestroyed)
		{
			if (timeAlive - warmupTime > durationSeconds - warnTime)
			{
				SetFlag(Flags.Reserved1, b: true);
			}
			if (timeAlive - warmupTime > durationSeconds && !IsInvoking(Cooldown) && Interface.CallHook("OnHuntEventEnd", this) == null)
			{
				SetFlag(Flags.Reserved2, b: true);
				CleanupEggs();
				PrintWinnersAndAward();
				Invoke(Cooldown, 10f);
			}
		}
	}

```

## OnItemRepair(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to repair an item.
/// </summary>
/// <param name="player">The player attempting to repair the item.</param>
/// <param name="item">The item that is being repaired.</param>
/// <returns>
/// Returns `null` to allow the repair process to continue, or any non-null value to prevent the repair.
/// </returns>
object OnItemRepair(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is attempting to repair item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.condition == item.maxCondition)
    {
        Puts($"Item {item.info.displayName.english} is already in perfect condition.");
        return "Item is already fully repaired.";
    }

    if (!player.HasPermission("repair.items"))
    {
        Puts($"Player {player.displayName} does not have permission to repair items.");
        return "You do not have permission to repair items.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
	{
		if (itemToRepair == null)
		{
			return;
		}
		ItemDefinition info = itemToRepair.info;
		ItemBlueprint component = info.GetComponent<ItemBlueprint>();
		if (!component)
		{
			return;
		}
		ItemModRepair component2 = itemToRepair.info.GetComponent<ItemModRepair>();
		if (!info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)
		{
			return;
		}
		if (mustKnowBlueprint)
		{
			ItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);
			if (!player.blueprints.HasUnlocked(itemDefinition) && (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))
			{
				return;
			}
		}
		if (Interface.CallHook("OnItemRepair", player, itemToRepair) != null)
		{
			return;
		}
		float num = RepairCostFraction(itemToRepair);
		bool flag = false;
		List<ItemAmount> obj = Facepunch.Pool.Get<List<ItemAmount>>();
		GetRepairCostList(component, obj);
		foreach (ItemAmount item in obj)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				if (Mathf.CeilToInt(item.amount * num) > amount)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj);
			return;
		}
		foreach (ItemAmount item2 in obj)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
				Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "repair", item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair);
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj);
		float conditionNormalized = itemToRepair.conditionNormalized;
		float maxConditionNormalized = itemToRepair.maxConditionNormalized;
		itemToRepair.DoRepair(maxConditionLostOnRepair);
		Facepunch.Rust.Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);
		if (Global.developer > 0)
		{
			Debug.Log("Item repaired! condition : " + itemToRepair.condition + "/" + itemToRepair.maxCondition);
		}
		string strName = "assets/bundled/prefabs/fx/repairbench/itemrepair.prefab";
		if (component2 != null && component2.successEffect?.Get() != null)
		{
			strName = component2.successEffect.resourcePath;
		}
		Effect.server.Run(strName, repairBenchEntity, 0u, Vector3.zero, Vector3.zero);
	}

```

## OnSignContentCopied(SignContent,ISignage,IUGCBrowserEntity)

```csharp
```csharp
/// <summary>
/// Called when the content of a sign is copied to another sign or entity.
/// </summary>
/// <param name="sourceSign">The sign from which the content is copied.</param>
/// <param name="targetSign">The sign that will receive the copied content.</param>
/// <param name="browserEntity">The UGC browser entity associated with the sign content.</param>
/// <returns>No return behavior.</returns>
void OnSignContentCopied(SignContent sourceSign, ISignage targetSign, IUGCBrowserEntity browserEntity)
{
    Puts($"Content copied from sign {sourceSign.NetworkID} to sign {targetSign.NetworkID}.");
    
    if (browserEntity.EditingHistory.Count > 0)
    {
        Puts($"Editing history for sign {targetSign.NetworkID} has been updated.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)
	{
		FileStorage.server.ReassignEntityId(net.ID, s.NetworkID);
		s.SetTextureCRCs(textureIDs);
		b.EditingHistory.Clear();
		foreach (ulong item in editHistory)
		{
			b.EditingHistory.Add(item);
		}
		Interface.CallHook("OnSignContentCopied", this, s, b);
	}

```

## OnRackedWeaponTake(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a player takes a weapon from a weapon rack.
/// </summary>
/// <param name="item">The item being taken from the weapon rack.</param>
/// <param name="player">The player taking the weapon.</param>
/// <param name="weaponRack">The weapon rack from which the weapon is taken.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponTake(Item item, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Player {player.displayName} has taken the weapon: {item.info.displayName.english} from the weapon rack.");
    
    if (item.info.shortname == "rifle.semiauto")
    {
        Puts($"Warning: Player {player.displayName} took a semi-auto rifle!");
    }
}
```
```

### Source Code from the Library

```csharp

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", slot, player, this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		if (slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex))
		{
			if ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1)
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", slot, player, this);
	}

```

## OnBookmarkControlStarted(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a player starts controlling a remote bookmark entity.
/// </summary>
/// <param name="station">The computer station initiating the control.</param>
/// <param name="player">The player who is starting to control the bookmark.</param>
/// <param name="identifier">The identifier of the bookmark being controlled.</param>
/// <param name="remoteEntity">The remote controllable entity being accessed.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string identifier, IRemoteControllable remoteEntity)
{
    Puts($"Player {player.displayName} has started controlling bookmark: {identifier} from station: {station.name}.");

    if (remoteEntity is CCTV_RC)
    {
        Puts($"Player {player.displayName} is controlling a CCTV remote control.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## OnPlayerWound(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player is wounded.
/// </summary>
/// <param name="player">The player who has been wounded.</param>
/// <param name="hitInfo">Information about the hit that caused the wound.</param>
/// <returns>
/// Returns a non-null value to prevent the default wounding behavior. 
/// If `null` is returned, the player will proceed to the wounded state as normal.
/// </returns>
object OnPlayerWound(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has been wounded. Damage Type: {hitInfo.damageTypes.GetMajorityDamageType()}");

    if (hitInfo.damageTypes.GetMajorityDamageType() == DamageType.Bullet)
    {
        Puts($"Player {player.displayName} was wounded by a bullet.");
        return "Wounding prevented due to bullet damage.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void BecomeWounded(HitInfo info = null)
	{
		if (IsWounded() || Interface.CallHook("OnPlayerWound", this, info) != null)
		{
			return;
		}
		bool flag = info != null && info.damageTypes.GetMajorityDamageType() == DamageType.Fall;
		if (IsCrawling())
		{
			woundedByFallDamage |= flag;
			GoToIncapacitated(info);
			return;
		}
		woundedByFallDamage = flag;
		if (flag || !ConVar.Server.crawlingenabled)
		{
			GoToIncapacitated(info);
		}
		else
		{
			GoToCrawling(info);
		}
	}

```

## CanWearItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether a player can wear a specified item in a given slot.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The item to be worn.</param>
/// <param name="targetSlot">The slot where the item is intended to be worn.</param>
/// <returns>
/// Returns `true` if the item can be worn in the specified slot; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the item can be worn.
/// </returns>
bool? CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
{
    Puts($"Checking if item {item.info.displayName.english} can be worn in slot {targetSlot}.");
    
    if (item.info.shortname == "hat")
    {
        Puts("Hats can always be worn.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanWearItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanWearItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CanWearItem(item, canAdjustClothing: true, targetSlot);
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the active item can be dropped by the player.
/// </summary>
/// <param name="player">The player attempting to drop the active item.</param>
/// <returns>
/// Returns `true` if the active item can be dropped; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the item can be dropped.
/// </returns>
bool? CanDropActiveItem(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to drop their active item.");
    
    if (player.inventory.GetActiveItem() == null)
    {
        Puts($"Player {player.displayName} has no active item to drop.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnDebrisSpawn(DecayEntity,UnityEngine.Vector3,UnityEngine.Quaternion,bool)

```csharp
```csharp
/// <summary>
/// Called when debris is spawned from a decaying entity.
/// </summary>
/// <param name="decayEntity">The entity that is decaying and causing debris to spawn.</param>
/// <param name="position">The local position where the debris will spawn.</param>
/// <param name="rotation">The rotation of the debris when spawned.</param>
/// <param name="dropToTerrain">Indicates whether the debris should drop to the terrain.</param>
/// <returns>No return behavior.</returns>
void OnDebrisSpawn(DecayEntity decayEntity, Vector3 position, Quaternion rotation, bool dropToTerrain)
{
    Puts($"Debris spawned from {decayEntity?.name} at position {position} with rotation {rotation}.");

    if (dropToTerrain)
    {
        Puts("Debris will drop to terrain.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)
	{
		if (Interface.CallHook("OnDebrisSpawn", this, localPos, rot, dropToTerrain) != null)
		{
			return;
		}
		Vector3 vector = base.transform.TransformPoint(localPos);
		if (dropToTerrain && UnityEngine.Physics.Raycast(vector, Vector3.down, out var hitInfo, 6f, 8388608))
		{
			float num = vector.y - hitInfo.point.y;
			vector.y = hitInfo.point.y;
			localPos.y -= num;
		}
		List<DebrisEntity> list = Facepunch.Pool.Get<List<DebrisEntity>>();
		Vis.Entities(vector, 0.1f, list, 256);
		if (list.Count <= 0)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(debrisPrefab.resourcePath, base.transform.TransformPoint(localPos), base.transform.rotation * rot);
			if ((bool)baseEntity)
			{
				baseEntity.SetParent(parentEntity.Get(serverside: true), worldPositionStays: true);
				baseEntity.Spawn();
			}
		}
	}

```

## OnBookmarkAdd(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player adds a bookmark to a computer station.
/// </summary>
/// <param name="station">The computer station where the bookmark is being added.</param>
/// <param name="player">The player who is adding the bookmark.</param>
/// <param name="bookmarkName">The name of the bookmark being added.</param>
/// <returns>
/// Returns `null` to allow the bookmark to be added, or any non-null value to prevent the addition.
/// </returns>
object OnBookmarkAdd(ComputerStation station, BasePlayer player, string bookmarkName)
{
    Puts($"Player {player.displayName} is adding a bookmark: {bookmarkName} to station {station.name}.");

    if (bookmarkName.Contains("forbidden"))
    {
        Puts($"Bookmark '{bookmarkName}' is not allowed.");
        return "This bookmark name is forbidden.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void AddBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		if (UnityEngine.Time.realtimeSinceStartup < nextAddTime)
		{
			player.ChatMessage("Slow down...");
			return;
		}
		if (controlBookmarks.Count >= 128)
		{
			player.ChatMessage("Too many bookmarks, delete some");
			return;
		}
		nextAddTime = UnityEngine.Time.realtimeSinceStartup + 1f;
		string text = msg.read.String();
		if (Interface.CallHook("OnBookmarkAdd", this, player, text) == null)
		{
			ForceAddBookmark(text);
			SendControlBookmarks(player);
		}
	}

```

## OnVendingShopRename(VendingMachine,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop's name is updated.
/// </summary>
/// <param name="vendingMachine">The vending machine whose name is being changed.</param>
/// <param name="newName">The new name for the vending shop.</param>
/// <param name="player">The player who is renaming the shop.</param>
/// <returns>
/// Returns `null` to allow the name change, or any non-null value to prevent the renaming.
/// </returns>
object OnVendingShopRename(VendingMachine vendingMachine, string newName, BasePlayer player)
{
    Puts($"Vending shop renamed to '{newName}' by player {player.displayName} (ID: {player.UserIDString}).");

    if (newName.Length < 3)
    {
        Puts("Shop name is too short. Renaming denied.");
        return "Shop name must be at least 3 characters long.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_UpdateShopName(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string obj = msg.read.String(32);
		if (CanPlayerAdmin(player) && Interface.CallHook("OnVendingShopRename", this, obj, player) == null)
		{
			shopName = obj;
			UpdateMapMarker();
		}
	}

```

## OnSignUpdated(PhotoFrame,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated with a new image by a player.
/// </summary>
/// <param name="photoFrame">The photo frame sign that is being updated.</param>
/// <param name="player">The player who is updating the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(PhotoFrame photoFrame, BasePlayer player)
{
    Puts($"Sign updated by player {player.displayName} (ID: {player.UserIDString}) on PhotoFrame ID: {photoFrame.net.ID}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} updated the sign.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	public void UpdateSign(RPCMessage msg)
	{
		if (!(msg.player == null) && CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				LogEdit(msg.player);
				SendNetworkUpdate();
				Interface.CallHook("OnSignUpdated", this, msg.player);
			}
		}
	}

```

## OnPhoneCallStart(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone call is initiated between two phone controllers.
/// </summary>
/// <param name="caller">The phone controller initiating the call.</param>
/// <param name="receiver">The phone controller receiving the call.</param>
/// <param name="player">The player involved in the call.</param>
/// <returns>
/// Returns a non-null value to prevent the call from starting. 
/// If `null` is returned, the call proceeds as normal.
/// </returns>
object OnPhoneCallStart(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone call initiated from {caller} to {receiver} by player {player.displayName}.");
    
    if (receiver.IsBusy)
    {
        Puts($"Call from {caller} to {receiver} rejected: receiver is busy.");
        return "The receiver is currently busy.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", this, activeCallTo, currentPlayer) == null)
		{
			if (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)
			{
				_ = currentPlayer != null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			Invoke(TimeOutCall, TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", this, activeCallTo, currentPlayer);
		}
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Determines whether the Bradley APC can target a specified entity.
/// </summary>
/// <param name="apc">The Bradley APC attempting to target the entity.</param>
/// <param name="entity">The entity being checked for targeting.</param>
/// <returns>
/// Returns `true` if the APC can target the entity, or `false` if it cannot.
/// If the method returns `null`, the default targeting logic will be applied.
/// </returns>
bool? CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
{
    Puts($"Checking if Bradley APC can target entity: {entity?.name ?? "null"}");

    if (entity is BasePlayer player)
    {
        Puts($"Entity is a player: {player.displayName}");
        // Additional checks for player targeting can be added here
    }
    else
    {
        Puts($"Entity is of type: {entity.GetType().Name}");
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.transform.position, base.transform.position) < viewDistance))
		{
			return false;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			flag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position + Vector3.up * 0.1f, position);
			if (!flag && basePlayer.isMounted && basePlayer.GetMounted().VehicleParent() != null && basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)
			{
				flag = IsVisible(basePlayer.GetMounted().VehicleParent().bounds.center, position);
			}
			if (flag)
			{
				flag = !UnityEngine.Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);
			}
		}
		else
		{
			Debug.LogWarning("Standard vis test!");
			flag = IsVisible(ent.CenterPoint());
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return flag;
	}

```

## CanDesignFirework(BasePlayer,PatternFirework)

```csharp
```csharp
/// <summary>
/// Determines whether a player can design a firework pattern.
/// </summary>
/// <param name="player">The player attempting to design the firework.</param>
/// <param name="fireworkPattern">The firework pattern being designed.</param>
/// <returns>
/// Returns `true` if the player can design the firework pattern; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can design the firework.
/// </returns>
bool? CanDesignFirework(BasePlayer player, PatternFirework fireworkPattern)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to design a firework pattern.");

    if (!player.CanInteract())
    {
        Puts($"Player {player.displayName} cannot interact with the firework design.");
        return false;
    }

    if (fireworkPattern.IsRestricted)
    {
        Puts($"Player {player.displayName} is trying to design a restricted firework pattern.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool PlayerCanModify(BasePlayer player)
	{
		if (player == null || !player.CanInteract())
		{
			return false;
		}
		object obj = Interface.CallHook("CanDesignFirework", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		if (buildingPrivilege != null && !buildingPrivilege.CanAdministrate(player))
		{
			return false;
		}
		return true;
	}

```

## OnDispenserGather(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player gathers resources from a resource dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser from which resources are being gathered.</param>
/// <param name="player">The player gathering the resources.</param>
/// <param name="item">The item being gathered.</param>
/// <returns>No return behavior.</returns>
void OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} gathered {item.amount} of {item.info.displayName.english} from dispenser {dispenser.gameObject.name}.");
    
    if (item.info.shortname == "wood")
    {
        Puts($"Player {player.displayName} has gathered wood, which is a common resource.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		f = Mathf.Round(f);
		float num3 = f * destroyFraction * 2f;
		if (itemAmt.amount <= f + num3)
		{
			float num4 = (f + num3) / itemAmt.amount;
			f /= num4;
			num3 /= num4;
		}
		itemAmt.amount -= Mathf.Floor(f);
		itemAmt.amount -= Mathf.Floor(num3);
		if (f < 1f)
		{
			f = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (f >= 1f)
		{
			int num5 = CalculateGatherBonus(entity, itemAmt, f);
			int iAmount = Mathf.FloorToInt(f) + num5;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (Interface.CallHook("OnDispenserGather", this, entity, item) == null && item != null)
			{
				OverrideOwnership(item, attackWeapon);
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
				Interface.CallHook("OnDispenserGathered", this, entity, item);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnElevatorMove(Elevator,int)

```csharp
```csharp
/// <summary>
/// Called when an elevator is requested to move to a specific floor.
/// </summary>
/// <param name="elevator">The elevator that is moving.</param>
/// <param name="targetFloor">The floor to which the elevator is requested to move.</param>
/// <returns>
/// Returns `true` if the elevator can move to the target floor; otherwise, returns `false`.
/// If the method returns a non-null value, it indicates that the movement is blocked or not allowed.
/// </returns>
bool OnElevatorMove(Elevator elevator, int targetFloor)
{
    Puts($"Elevator {elevator.ID} is requested to move to floor {targetFloor}.");
    
    if (targetFloor < 0)
    {
        Puts("Invalid floor request: Floor cannot be negative.");
        return false;
    }

    return null; // Allow default behavior to determine if the elevator can move.
}
```
```

### Source Code from the Library

```csharp

	public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)
	{
		timeToTravel = 0f;
		if (Interface.CallHook("OnElevatorMove", this, targetFloor) != null)
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (!IsStatic && ioEntity != null && !ioEntity.IsPowered())
		{
			return false;
		}
		if (!IsValidFloor(targetFloor))
		{
			return false;
		}
		int num = LiftPositionToFloor();
		if (num == targetFloor)
		{
			OpenDoorsAtFloor(num);
			return false;
		}
		if (!liftEntity.IsValid(base.isServer))
		{
			return false;
		}
		ElevatorLift elevatorLift = liftEntity.Get(base.isServer);
		if (!elevatorLift.CanMove())
		{
			return false;
		}
		Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);
		if (!GamePhysics.LineOfSight(elevatorLift.transform.position, worldSpaceFloorPosition, 2097152))
		{
			return false;
		}
		OnMoveBegin();
		timeToTravel = TimeToTravelDistance(Mathf.Abs(elevatorLift.transform.position.y - worldSpaceFloorPosition.y));
		LeanTween.moveY(elevatorLift.gameObject, worldSpaceFloorPosition.y, timeToTravel).delay = LiftMoveDelay;
		timeToTravel += LiftMoveDelay;
		SetFlag(Flags.Busy, b: true);
		if (targetFloor < Floor)
		{
			elevatorLift.ToggleHurtTrigger(state: true);
		}
		elevatorLift.SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, timeToTravel + 1f);
		elevatorLift.NotifyNewFloor(targetFloor, Floor);
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			elevatorEnt.SetFlag(Flags.Busy, b: true);
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
		if (ioEntity != null)
		{
			ioEntity.SetFlag(Flags.Busy, b: true);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		return true;
	}

```

## OnEngineStatsRefreshed(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called when the performance stats of a vehicle engine are refreshed.
/// </summary>
/// <param name="engine">The engine module whose stats are being refreshed.</param>
/// <param name="engineStorage">The storage containing the engine's performance data.</param>
/// <returns>No return behavior.</returns>
void OnEngineStatsRefreshed(VehicleModuleEngine engine, Rust.Modular.EngineStorage engineStorage)
{
    Puts($"Engine stats refreshed for {engine.GetType().Name}. Usable: {engineStorage?.isUsable ?? false}");
    
    if (engineStorage != null)
    {
        Puts($"Acceleration Boost: {engineStorage.accelerationBoostPercent}, Top Speed Boost: {engineStorage.topSpeedBoostPercent}, Fuel Economy Boost: {engineStorage.fuelEconomyBoostPercent}");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## OnPlayerVoice(BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a player sends voice data.
/// </summary>
/// <param name="player">The player who sent the voice data.</param>
/// <param name="data">The voice data sent by the player.</param>
/// <returns>
/// Returns `null` to allow the default voice handling, or any non-null value to override the default behavior.
/// </returns>
object OnPlayerVoice(BasePlayer player, byte[] data)
{
    Puts($"Voice data received from player {player.displayName} (ID: {player.UserIDString}). Data length: {data.Length} bytes.");

    if (data.Length == 0)
    {
        Puts($"Player {player.displayName} sent empty voice data.");
        return "Voice data cannot be empty.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnReceivedVoice(byte[] data)
	{
		if (Interface.CallHook("OnPlayerVoice", this, data) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.VoiceData);
			netWrite.EntityID(net.ID);
			netWrite.BytesWithSize(data);
			float num = 0f;
			if (HasPlayerFlag(PlayerFlags.VoiceRangeBoost))
			{
				num = Voice.voiceRangeBoostAmount;
			}
			netWrite.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f + num))
			{
				priority = Priority.Immediate
			});
			if (activeTelephone != null)
			{
				activeTelephone.OnReceivedVoiceFromUser(data);
			}
		}
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is rotated by a player.
/// </summary>
/// <param name="structure">The building block structure being rotated.</param>
/// <param name="player">The player who is rotating the structure.</param>
/// <returns>
/// Returns `null` to allow the rotation, or any non-null value to prevent the rotation.
/// </returns>
object OnStructureRotate(BuildingBlock structure, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to rotate structure: {structure.name}.");

    if (structure.IsLocked())
    {
        Puts($"Rotation denied: Structure {structure.name} is locked.");
        return "Structure is locked and cannot be rotated.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotateAfterPlacement && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			UpdateSkin(force: true);
			RefreshNeighbours(linkToNeighbours: false);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
			if (!globalNetworkCooldown)
			{
				globalNetworkCooldown = true;
				GlobalNetworkHandler.server.TrySendNetworkUpdate(this);
				CancelInvoke(ResetGlobalNetworkCooldown);
				Invoke(ResetGlobalNetworkCooldown, 15f);
			}
		}
	}

```

## OnCargoShipSpawnCrate(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship is about to spawn a crate.
/// </summary>
/// <param name="cargoShip">The cargo ship that is spawning the crate.</param>
/// <returns>
/// Returns `null` to allow the crate to spawn, or any non-null value to prevent the spawning of the crate.
/// </returns>
object OnCargoShipSpawnCrate(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip.net.ID} is attempting to spawn a crate.");
    
    // Example condition to prevent crate spawning
    if (cargoShip.IsUnderAttack)
    {
        Puts($"Cargo ship {cargoShip.net.ID} cannot spawn crates while under attack.");
        return true; // Prevent crate spawning
    }

    return null; // Allow crate spawning
}
```
```

### Source Code from the Library

```csharp

	public void RespawnLoot()
	{
		if (Interface.CallHook("OnCargoShipSpawnCrate", this) == null)
		{
			InvokeRepeating(PlayHorn, 0f, 8f);
			SpawnCrate(lockedCratePrefab.resourcePath);
			SpawnCrate(eliteCratePrefab.resourcePath);
			for (int i = 0; i < 4; i++)
			{
				SpawnCrate(militaryCratePrefab.resourcePath);
			}
			for (int j = 0; j < 4; j++)
			{
				SpawnCrate(junkCratePrefab.resourcePath);
			}
			lootRoundsPassed++;
			if (lootRoundsPassed >= loot_rounds)
			{
				CancelInvoke(RespawnLoot);
			}
		}
	}

```

## OnNpcEquipWeapon(NPCPlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon.
/// </summary>
/// <param name="npc">The NPC that is equipping the weapon.</param>
/// <param name="item">The item being equipped as a weapon.</param>
/// <returns>No return behavior.</returns>
void OnNpcEquipWeapon(NPCPlayer npc, Item item)
{
    Puts($"NPC {npc.displayName} is equipping weapon: {item.info.displayName.english} (Item ID: {item.info.itemid}).");

    if (item.info.shortname == "rifle.semiauto")
    {
        Puts($"NPC {npc.displayName} has equipped a semi-automatic rifle.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void EquipWeapon(bool skipDeployDelay = false)
	{
		if (base.inventory == null || base.inventory.containerBelt == null)
		{
			return;
		}
		Item slot = base.inventory.containerBelt.GetSlot(0);
		if (Interface.CallHook("OnNpcEquipWeapon", this, slot) != null || slot == null)
		{
			return;
		}
		UpdateActiveItem(base.inventory.containerBelt.GetSlot(0).uid);
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		AttackEntity component = heldEntity.GetComponent<AttackEntity>();
		if (component != null)
		{
			if (skipDeployDelay)
			{
				component.ResetAttackCooldown();
			}
			component.TopUpAmmo();
		}
	}

```

## OnExcavatorGather(ExcavatorArm,Item)

```csharp
```csharp
/// <summary>
/// Called when the excavator gathers resources.
/// </summary>
/// <param name="excavator">The excavator arm that is gathering resources.</param>
/// <param name="item">The item being produced by the excavator.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being produced. 
/// If `null` is returned, the item will be produced and processed as normal.
/// </returns>
object OnExcavatorGather(ExcavatorArm excavator, Item item)
{
    Puts($"Excavator {excavator.net.ID} is gathering item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "metal.fragments")
    {
        Puts("Production of metal fragments is currently disabled.");
        return true; // Prevents the item from being produced.
    }

    return null; // Allows the item to be produced.
}
```
```

### Source Code from the Library

```csharp

	public void ProduceResources()
	{
		float num = resourceProductionTickRate / timeForFullResources;
		float num2 = resourcesToMine[resourceMiningIndex].amount * num;
		pendingResources[resourceMiningIndex].amount += num2;
		ItemAmount[] array = pendingResources;
		foreach (ItemAmount itemAmount in array)
		{
			if (!(itemAmount.amount >= (float)outputPiles.Count))
			{
				continue;
			}
			int num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);
			itemAmount.amount -= num3 * 2;
			foreach (ExcavatorOutputPile outputPile in outputPiles)
			{
				Item item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);
				if (Interface.CallHook("OnExcavatorGather", this, item) != null)
				{
					return;
				}
				Facepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);
				if (!item.MoveToContainer(outputPile.inventory))
				{
					item.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());
				}
			}
		}
	}

```

## CanSpectateTarget(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can spectate a target based on the provided name.
/// </summary>
/// <param name="player">The player attempting to spectate a target.</param>
/// <param name="targetName">The name of the target the player wishes to spectate.</param>
/// <returns>
/// Returns `null` to allow the player to spectate the target, or any non-null value to prevent them from doing so.
/// </returns>
object CanSpectateTarget(BasePlayer player, string targetName)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to spectate target: {targetName}.");

    if (targetName == "admin")
    {
        Puts($"Player {player.displayName} is not allowed to spectate admins.");
        return "You cannot spectate admin players.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateSpectateTarget(string strName)
	{
		if (Interface.CallHook("CanSpectateTarget", this, strName) != null)
		{
			return;
		}
		spectateFilter = strName;
		IEnumerable<BaseEntity> enumerable = null;
		if (spectateFilter.StartsWith("@"))
		{
			string filter = spectateFilter.Substring(1);
			enumerable = (from x in BaseNetworkable.serverEntities
				where x.name.Contains(filter, CompareOptions.IgnoreCase)
				where x != this
				select x).Cast<BaseEntity>();
		}
		else
		{
			IEnumerable<BasePlayer> source = activePlayerList.Where((BasePlayer x) => !x.IsSpectating() && !x.IsDead() && !x.IsSleeping());
			if (strName.Length > 0)
			{
				source = from x in source
					where x.displayName.Contains(spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)
					where x != this
					select x;
			}
			source = source.OrderBy((BasePlayer x) => x.displayName);
			enumerable = source.Cast<BaseEntity>();
		}
		BaseEntity[] array = enumerable.ToArray();
		if (array.Length == 0)
		{
			ChatMessage("No valid spectate targets!");
			return;
		}
		BaseEntity baseEntity = array[SpectateOffset % array.Length];
		if (baseEntity != null)
		{
			SpectatePlayer(baseEntity);
		}
	}

```

## OnShopCancelClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player clicks the cancel button on the shop interface.
/// </summary>
/// <param name="shopFront">The shop front where the cancel action occurred.</param>
/// <param name="player">The player who clicked the cancel button.</param>
/// <returns>
/// Returns `null` to allow the cancel action to proceed, or any non-null value to prevent the cancellation.
/// </returns>
object OnShopCancelClick(ShopFront shopFront, BasePlayer player)
{
    Puts($"Player {player.displayName} has clicked cancel on shop {shopFront.name}.");
    
    if (player.inventory.IsFull())
    {
        Puts($"Player {player.displayName} cannot cancel the shop action because their inventory is full.");
        return "Inventory full, cannot cancel.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", this, msg.player) == null)
		{
			_ = (bool)vendorPlayer;
			_ = (bool)customerPlayer;
			ResetTrade();
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed at the shop front.
/// </summary>
/// <param name="shopFront">The shop front where the trade is taking place.</param>
/// <returns>
/// Returns a non-null value to prevent the trade from completing. 
/// If `null` is returned, the trade will proceed as normal.
/// </returns>
object OnShopCompleteTrade(ShopFront shopFront)
{
    Puts($"Trade completed at shop front: {shopFront.name}. Vendor: {shopFront.vendorPlayer.displayName}, Customer: {shopFront.customerPlayer.displayName}.");
    
    // Example condition to prevent trade
    if (shopFront.customerPlayer.inventory.GetAmount("restricted.item") > 0)
    {
        Puts($"Trade blocked: {shopFront.customerPlayer.displayName} has restricted items.");
        return "Trade cannot be completed due to restricted items.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			try
			{
				swappingItems = true;
				for (int num = vendorInventory.capacity - 1; num >= 0; num--)
				{
					Item slot = vendorInventory.GetSlot(num);
					Item slot2 = customerInventory.GetSlot(num);
					if ((bool)customerPlayer && slot != null)
					{
						customerPlayer.GiveItem(slot);
					}
					if ((bool)vendorPlayer && slot2 != null)
					{
						vendorPlayer.GiveItem(slot2);
					}
				}
			}
			finally
			{
				swappingItems = false;
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnLootEntityEnd(BasePlayer,ItemBasedFlowRestrictor)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="restrictor">The item-based flow restrictor associated with the looting process.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ItemBasedFlowRestrictor restrictor)
{
    Puts($"Player {player.displayName} has stopped looting the entity.");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
	}

```

## OnPlayerCorpseSpawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's corpse is about to be spawned.
/// </summary>
/// <param name="player">The player whose corpse is being spawned.</param>
/// <returns>
/// Returns `null` to allow the corpse to spawn, or any non-null value to prevent the spawning of the corpse.
/// </returns>
object OnPlayerCorpseSpawn(BasePlayer player)
{
    Puts($"Corpse spawn requested for player: {player.displayName} (ID: {player.UserIDString})");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone; preventing corpse spawn.");
        return "Corpse spawn is not allowed in safe zones.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? "assets/prefabs/player/player_corpse.prefab" : "assets/prefabs/player/player_corpse_new.prefab");
			bool flag = false;
			if (ConVar.Global.cinematicGingerbreadCorpses)
			{
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);
						flag = component.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.streamerName = RandomUsernames.Get(userID);
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				if (!CollectionEx.IsNullOrEmpty(triggersOnDeath))
				{
					foreach (TriggerBase item2 in triggersOnDeath)
					{
						if (item2 is TriggerParent triggerParent)
						{
							triggerParent.ForceParentEarly(playerCorpse);
						}
					}
				}
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			UnityEngine.Random.State state = UnityEngine.Random.state;
			UnityEngine.Random.InitState((int)(seed + steamid));
			float result = UnityEngine.Random.Range(0f, 1f);
			UnityEngine.Random.state = state;
			return result;
		}
	}

```

## OnTechTreeNodeUnlock(Workbench,TechTreeData.NodeInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a technology tree node is unlocked by a player.
/// </summary>
/// <param name="workbench">The workbench associated with the unlocking action.</param>
/// <param name="node">The technology tree node that has been unlocked.</param>
/// <param name="player">The player who unlocked the technology tree node.</param>
/// <returns>No return behavior.</returns>
void OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
{
    Puts($"Player {player.displayName} unlocked tech tree node: {node.itemDef?.shortname ?? "Unknown"} at workbench: {workbench.name}.");
    
    if (node.itemDef != null)
    {
        Puts($"Node {node.itemDef.shortname} unlocked successfully.");
    }
    else
    {
        Puts($"Node unlock failed: Item definition is null.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if (techTreeForLevel == null)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log("Node for unlock not found :" + id);
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && byID2.itemDef != null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log("Player unlocked group :" + byID.groupName);
			}
			else if (byID.itemDef != null && Interface.CallHook("OnTechTreeNodeUnlock", this, byID, player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", this, byID, player);
					Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

```

## OnBedMade(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is made by a player.
/// </summary>
/// <param name="sleepingBag">The sleeping bag that was made.</param>
/// <param name="player">The player who made the sleeping bag.</param>
/// <returns>No return behavior.</returns>
void OnBedMade(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Sleeping bag made by {player.displayName} (ID: {player.UserIDString}). Bag ID: {sleepingBag.net.ID}");
    
    if (player.IsSleeping())
    {
        Puts($"Player {player.displayName} is currently sleeping in the bag.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_MakeBed(RPCMessage msg)
	{
		if (!canBePublic || !IsPublic() || !msg.player.CanInteract())
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
			if (canAssignBedResult.HasValue)
			{
				if (canAssignBedResult.Value.Result != 0)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, cannotMakeBedPhrase, false);
				}
				else
				{
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num = deployerUserID;
		deployerUserID = msg.player.userID;
		NotifyPlayer(num);
		NotifyPlayer(deployerUserID);
		OnBagChangedOwnership(this, num);
		Interface.CallHook("OnBedMade", this, msg.player);
		SendNetworkUpdate();
	}

```

## OnEngineStart(MotorRowboat,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the engine of the motorized rowboat is requested to start.
/// </summary>
/// <param name="rowboat">The motorized rowboat attempting to start its engine.</param>
/// <param name="driver">The player attempting to start the engine.</param>
/// <returns>
/// Returns `null` to allow the engine to start, or any non-null value to prevent the engine from starting.
/// </returns>
object OnEngineStart(MotorRowboat rowboat, BasePlayer driver)
{
    Puts($"Player {driver.displayName} (ID: {driver.UserIDString}) is attempting to start the engine of the rowboat.");
    
    if (driver.IsInSafeZone())
    {
        Puts($"Player {driver.displayName} is in a safe zone and cannot start the engine.");
        return "Cannot start engine in safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.On, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
			if (wantsOn)
			{
				rigidBody.WakeUp();
				buoyancy.Wake();
			}
		}
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int,ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when a vending transaction is completed.
/// </summary>
/// <param name="vendingMachine">The vending machine involved in the transaction.</param>
/// <param name="buyer">The player who is buying items from the vending machine.</param>
/// <param name="sellOrderId">The ID of the sell order being processed.</param>
/// <param name="numberOfTransactions">The number of items being purchased.</param>
/// <param name="targetContainer">The container where purchased items will be placed, if any.</param>
/// <returns>
/// Returns `true` if the transaction was successful, or `false` if it failed.
/// If the method returns a non-null value, it overrides the default transaction behavior.
/// </returns>
bool OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions, ItemContainer targetContainer)
{
    Puts($"Player {buyer.displayName} is attempting to purchase from vending machine with sell order ID: {sellOrderId}.");

    if (sellOrderId < 0)
    {
        Puts("Invalid sell order ID.");
        return false;
    }

    // Additional checks can be added here
    return null; // Allow default transaction logic to proceed
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions, targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> obj2 = Facepunch.Pool.Get<List<Item>>();
		GetItemsToSell(sellOrder, obj2);
		if (obj2 == null || obj2.Count == 0)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = obj2.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		List<Item> source = buyer.inventory.FindItemsByItemID(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = (from x in source
			where !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)
			where x.GetItemVolume() <= maxCurrencyVolume
			select x).ToList();
		if (source.Count == 0)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;
		if (num3 < num4)
		{
			Facepunch.Pool.FreeUnmanaged(ref obj2);
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			TakeCurrencyItem(item);
			onCurrencyRemoved?.Invoke(buyer, item);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		Facepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, num4, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);
		int num7 = 0;
		foreach (Item item4 in obj2)
		{
			int num8 = num - num7;
			Item item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);
			if (item2 == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item2.amount;
				object obj3 = Interface.CallHook("CanPurchaseItem", buyer, item2, onItemPurchased, this, targetContainer);
				if (obj3 != null)
				{
					if (!(obj3 is bool))
					{
						return false;
					}
					return (bool)obj3;
				}
				RecordSaleAnalytics(item2, sellOrderId);
				if (targetContainer == null)
				{
					GiveSoldItem(item2, buyer);
				}
				else if (!item2.MoveToContainer(targetContainer))
				{
					item2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
				}
				onItemPurchased?.Invoke(buyer, item2);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		Facepunch.Pool.FreeUnmanaged(ref obj2);
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## OnClientCommand(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client sends a command to the server.
/// </summary>
/// <param name="connection">The network connection of the client sending the command.</param>
/// <param name="command">The command sent by the client.</param>
/// <returns>No return behavior.</returns>
void OnClientCommand(Network.Connection connection, string command)
{
    Puts($"Received command from client {connection.userid}: {command}");
    if (command.StartsWith("admin"))
    {
        Puts($"Admin command detected from {connection.userid}. Processing with caution.");
    }
}
```
```

### Source Code from the Library

```csharp

	internal static void OnClientCommand(Message packet)
	{
		if (packet.read.Unread > ConVar.Server.maxpacketsize_command)
		{
			UnityEngine.Debug.LogWarning("Dropping client command due to size");
			return;
		}
		timer.Restart();
		string text = packet.read.StringRaw();
		if (packet.connection == null || !packet.connection.connected)
		{
			UnityEngine.Debug.LogWarning("Client without connection tried to run command: " + text);
		}
		else if (Interface.CallHook("OnClientCommand", packet.connection, text) == null)
		{
			string text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text);
			if (!string.IsNullOrEmpty(text2))
			{
				SendClientReply(packet.connection, text2);
			}
			if (timer.Elapsed > RuntimeProfiler.ConsoleCommandWarningThreshold)
			{
				LagSpikeProfiler.ConsoleCommand(timer.Elapsed, packet, text);
			}
		}
	}

```

## OnResearchCostDetermine(ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine the scrap cost required for researching an item.
/// </summary>
/// <param name="itemDefinition">The item definition for which the research cost is being determined.</param>
/// <returns>
/// Returns the amount of scrap required to research the item. 
/// If a non-null value is returned from the hook, that value will be used as the cost.
/// </returns>
int OnResearchCostDetermine(ItemDefinition itemDefinition)
{
    Puts($"Determining research cost for item: {itemDefinition.displayName.english} (ID: {itemDefinition.itemid})");

    if (itemDefinition.rarity == Rarity.Common)
    {
        return 20;
    }
    else if (itemDefinition.rarity == Rarity.Uncommon)
    {
        return 75;
    }
    else if (itemDefinition.rarity == Rarity.Rare)
    {
        return 125;
    }
    else if (itemDefinition.rarity == Rarity.VeryRare || itemDefinition.rarity == Rarity.None)
    {
        return 500;
    }

    return 0; // Default case if no rarity matches
}
```
```

### Source Code from the Library

```csharp

	public static int ScrapForResearch(ItemDefinition info)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", info);
		if (obj is int)
		{
			return (int)obj;
		}
		if (info.isRedirectOf != null)
		{
			return ScrapForResearch(info.isRedirectOf);
		}
		int result = 0;
		if (info.rarity == Rarity.Common)
		{
			result = 20;
		}
		if (info.rarity == Rarity.Uncommon)
		{
			result = 75;
		}
		if (info.rarity == Rarity.Rare)
		{
			result = 125;
		}
		if (info.rarity == Rarity.VeryRare || info.rarity == Rarity.None)
		{
			result = 500;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(info);
		if (itemBlueprint != null && itemBlueprint.defaultBlueprint)
		{
			return ConVar.Server.defaultBlueprintResearchCost;
		}
		return result;
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player who is going to sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has started sleeping.");
    
    if (player.IsRestrained)
    {
        Puts($"Player {player.displayName} is restrained and will be released from restraints upon sleeping.");
    }
    
    if (player.InSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone while sleeping.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping())
		{
			Interface.CallHook("OnPlayerSleep", this);
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: false);
			}
			if (InSafeZone() && !IsInvoking(ScheduledDeath))
			{
				Invoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);
			}
			BaseMountable baseMountable = GetMounted();
			if (baseMountable != null && !AllowSleeperMounting(baseMountable))
			{
				EnsureDismounted();
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			sleepStartTime = UnityEngine.Time.time;
			sleepingPlayerList.TryAdd(this);
			bots.Remove(this);
			CancelInvoke(InventoryUpdate);
			CancelInvoke(TeamUpdate);
			CancelInvoke(UpdateClanLastSeen);
			inventory.loot.Clear();
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			EnablePlayerCollider();
			if (!IsLoadingAfterTransfer())
			{
				RemovePlayerRigidbody();
				TurnOffAllLights();
			}
			SetServerFall(wantsOn: true);
		}
	}

```

## OnXmasLootDistribute(XMasRefill)

```csharp
```csharp
/// <summary>
/// Called when distributing Christmas loot to players.
/// </summary>
/// <param name="refill">The reference object containing information about the Christmas loot distribution.</param>
/// <returns>No return behavior.</returns>
void OnXmasLootDistribute(XMasRefill refill)
{
    Puts("Distributing Christmas loot to players.");
    foreach (BasePlayer player in BasePlayer.activePlayerList)
    {
        Puts($"Distributing loot to player: {player.displayName} (ID: {player.UserIDString})");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ServerInit()
	{
		base.ServerInit();
		if (!XMas.enabled)
		{
			Invoke(RemoveMe, 0.1f);
			return;
		}
		goodKids = ((BasePlayer.activePlayerList != null) ? new List<BasePlayer>(BasePlayer.activePlayerList) : new List<BasePlayer>());
		stockings = ((Stocking.stockings != null) ? new List<Stocking>(Stocking.stockings.Values) : new List<Stocking>());
		Invoke(RemoveMe, 60f);
		if (Interface.CallHook("OnXmasLootDistribute", this) == null)
		{
			InvokeRepeating(DistributeLoot, 3f, 0.02f);
			Invoke(SendBells, 0.5f);
		}
	}

```

## OnItemStacked(Item,Item,ItemContainer,int)

```csharp
```csharp
/// <summary>
/// Called when two items are stacked together in a container.
/// </summary>
/// <param name="stackedItem">The item that is being stacked on top.</param>
/// <param name="sourceItem">The item that is being stacked.</param>
/// <param name="container">The container where the stacking occurs.</param>
/// <param name="amount">The amount of the source item that is being stacked.</param>
/// <returns>No return behavior.</returns>
void OnItemStacked(Item stackedItem, Item sourceItem, ItemContainer container, int amount)
{
    Puts($"Stacking {amount} of {sourceItem.info.displayName.english} onto {stackedItem.info.displayName.english} in container {container.name}.");
    
    if (amount > 10)
    {
        Puts("Warning: Stacking a large amount of items!");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		using (TimeWarning.New("MoveToContainer"))
		{
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					foreach (Item item3 in from x in newcontainer.FindItemsByItemID(info.itemid)
						orderby x.position
						select x)
					{
						if (item3.CanStack(this) && (ignoreStackLimit || item3.amount < item3.MaxStackable()))
						{
							iTargetPos = item3.position;
						}
					}
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.HasAvailableSlotsDefined && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", slot2, this, newcontainer, num2);
						MarkDirty();
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", item2, this, newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
	}

```

## OnCargoShipHarborArrived(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when the cargo ship arrives at the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that has arrived at the harbor.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipHarborArrived(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip.net.ID} has arrived at the harbor.");
    if (cargoShip.harborIndex == 0)
    {
        Puts("Cargo ship is docking at Harbor 1.");
    }
    else
    {
        Puts("Cargo ship is docking at Harbor 2.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void OnArrivedAtHarbor()
	{
		SetFlag(Flags.Reserved1, b: true);
		List<Transform> obj = Pool.Get<List<Transform>>();
		float num = UnityEngine.Random.Range(dock_time * 0.05f, dock_time * 0.1f);
		foreach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)
		{
			if (allCrane == null || allCrane.isClient || allCrane.Distance2D(this) > 150f)
			{
				continue;
			}
			obj.Clear();
			CargoShipContainerDestination[] array = containerDestinations;
			foreach (CargoShipContainerDestination cargoShipContainerDestination in array)
			{
				if (allCrane.IsDestinationValidForCrane(cargoShipContainerDestination))
				{
					obj.Add(cargoShipContainerDestination.transform);
				}
			}
			if (obj.Count > 0)
			{
				allCrane.AssignDestination(obj, this, num);
				num += dock_time * UnityEngine.Random.Range(0.1f, 0.15f);
			}
		}
		Pool.FreeUnmanaged(ref obj);
		Invoke(PreHarborLeaveHorn, dock_time - 60f);
		if (refresh_loot_on_dock)
		{
			RespawnLoot();
		}
		if (harborIndex == 0)
		{
			SetFlag(Flags.Reserved3, b: true);
		}
		else if (harborIndex == 1)
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		Invoke(LeaveHarbor, dock_time);
		Interface.CallHook("OnCargoShipHarborArrived", this);
	}

```

## OnPhoneAnswered(PhoneController,PhoneController)

```csharp
```csharp
/// <summary>
/// Called when a phone call is answered by a player.
/// </summary>
/// <param name="caller">The phone controller of the player who answered the call.</param>
/// <param name="receiver">The phone controller of the player who initiated the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneAnswered(PhoneController caller, PhoneController receiver)
{
    Puts($"Phone answered: Caller ID {caller.GetInstanceID()}, Receiver ID {receiver.GetInstanceID()}.");
    
    // Additional logic can be added here, such as notifying players or updating call status.
}
```
```

### Source Code from the Library

```csharp

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (IsInvoking(TimeOutDialing))
		{
			CancelInvoke(TimeOutDialing);
		}
		if (!(activeCallTo == null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", this, activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", this, activeCallTo);
			}
		}
	}

```

## IOnRconInitialize()

```csharp
```csharp
/// <summary>
/// Called to initialize the RCON (Remote Console) system.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRconInitialize()
{
    Puts("Initializing RCON system...");
    if (Port == 0)
    {
        Puts("Using default server port for RCON.");
    }
    else
    {
        Puts($"RCON will use port: {Port}");
    }
}
```
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", ""));
		if (Password == "password" || Password == "")
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)
			{
				Command item = JsonConvert.DeserializeObject<Command>(msg);
				item.Ip = ip;
				item.ConnectionId = id;
				Commands.Enqueue(item);
			};
			listenerNew.Start();
			UnityEngine.Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			UnityEngine.Debug.Log("RCon Started on " + Port);
			UnityEngine.Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## CanUseHBHFSensor(BasePlayer,HBHFSensor)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use the HBHF sensor.
/// </summary>
/// <param name="player">The player attempting to use the HBHF sensor.</param>
/// <param name="sensor">The HBHF sensor being accessed.</param>
/// <returns>
/// Returns `true` if the player can use the sensor; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can use the sensor.
/// </returns>
bool? CanUseHBHFSensor(BasePlayer player, HBHFSensor sensor)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use the HBHF sensor.");
    
    if (!player.CanBuild())
    {
        Puts($"Player {player.displayName} cannot use the HBHF sensor due to building restrictions.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUse(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseHBHFSensor", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnTeamCreate(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to create a new team.
/// </summary>
/// <param name="player">The player who is trying to create a team.</param>
/// <returns>No return behavior.</returns>
void OnTeamCreate(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to create a team.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Facepunch.Rust.Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a rocket is launched by a player.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="rocket">The rocket entity that was launched.</param>
/// <returns>No return behavior.</returns>
void OnRocketLaunched(BasePlayer player, BaseEntity rocket)
{
    Puts($"Player {player.displayName} has launched a rocket: {rocket.ShortPrefabName}.");
    
    if (rocket is ServerProjectile)
    {
        Puts($"Rocket launched successfully with ID: {rocket.net.ID}.");
    }
    else
    {
        Puts("Failed to launch rocket: Invalid entity.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (!base.UsingInfiniteAmmoCheat)
		{
			if (primaryMagazine.contents <= 0)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "magazine_empty");
				return;
			}
			ModifyAmmoCount(-1);
		}
		SignalBroadcast(Signal.Attack, string.Empty, player.net.connection);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		bool num = msg.read.Bit();
		BaseEntity mounted = player.GetParentEntity();
		if (mounted == null)
		{
			mounted = player.GetMounted();
		}
		if (num)
		{
			if (mounted != null)
			{
				vector = mounted.transform.TransformPoint(vector);
				vector2 = mounted.transform.TransformDirection(vector2);
			}
			else
			{
				vector = player.eyes.position;
				vector2 = player.eyes.BodyForward();
			}
		}
		if (!ValidateEyePos(player, vector))
		{
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		float num2 = GetAimCone() + component.projectileSpread;
		if (num2 > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);
		}
		float num3 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1237003025))
		{
			num3 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num3);
		if (baseEntity == null)
		{
			return;
		}
		baseEntity.creatorEntity = player;
		ServerProjectile component2 = baseEntity.GetComponent<ServerProjectile>();
		if ((bool)component2)
		{
			component2.InitializeVelocity(GetInheritedVelocity(player, vector2) + vector2 * component2.speed * initialSpeedMultiplier);
		}
		baseEntity.Spawn();
		ProjectileLaunched_Server(component2);
		Facepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity, this);
		Interface.CallHook("OnRocketLaunched", player, baseEntity);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			if (!base.UsingInfiniteAmmoCheat)
			{
				ownerItem.LoseCondition(UnityEngine.Random.Range(1f, 2f));
			}
			BaseMountable mounted2 = player.GetMounted();
			if (mounted2 != null)
			{
				mounted2.OnWeaponFired(this);
			}
		}
	}

```

## OnPlayerKicked(BasePlayer,string,bool)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="player">The player who was kicked.</param>
/// <param name="reason">The reason for the kick.</param>
/// <param name="reserveSlot">Indicates whether a slot should be reserved for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason, bool reserveSlot)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has been kicked. Reason: {reason}. " +
         $"Reserve slot: {reserveSlot}");
}
```
```

### Source Code from the Library

```csharp

	public void Kick(string reason, bool reserveSlot = true)
	{
		if (IsConnected)
		{
			net.connection.canReserveSlot = reserveSlot;
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason, reserveSlot);
		}
	}

```

## OnDigitalClockRing(DigitalClock)

```csharp
```csharp
/// <summary>
/// Called when the digital clock rings.
/// </summary>
/// <param name="clock">The digital clock that is ringing.</param>
/// <returns>No return behavior.</returns>
void OnDigitalClockRing(DigitalClock clock)
{
    Puts($"Digital clock {clock.net.ID} is ringing!");
}
```
```

### Source Code from the Library

```csharp

	private void Ring()
	{
		if (Interface.CallHook("OnDigitalClockRing", this) == null)
		{
			isRinging = true;
			ClientRPC(RpcTarget.NetworkGroup("RPC_StartRinging"));
			Invoke(StopRinging, 5f);
			MarkDirty();
		}
	}

```

## OnHorseHitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is hitched to a hitching spot.
/// </summary>
/// <param name="horse">The horse that is being hitched.</param>
/// <param name="hitch">The hitching spot where the horse is being hitched.</param>
/// <returns>
/// Returns `true` if the horse was successfully hitched, or `false` if it could not be hitched.
/// If the method returns a non-null value, it overrides the default hitching behavior.
/// </returns>
bool OnHorseHitch(RidableHorse horse, HitchSpot hitch)
{
    Puts($"Attempting to hitch horse {horse.name} to hitch spot {hitch.spot.name}.");
    
    if (hitch.IsOccupied())
    {
        Puts($"Hitch spot {hitch.spot.name} is already occupied.");
        return false;
    }

    return null; // Allow default behavior if no conditions are met
}
```
```

### Source Code from the Library

```csharp

	public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch = null)
	{
		if (horse == null)
		{
			return false;
		}
		if (hitch == null)
		{
			hitch = GetClosest(horse.transform.position);
		}
		if (hitch != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", horse, hitch);
			if (obj is bool)
			{
				return (bool)obj;
			}
			hitch.SetOccupiedBy(horse);
			horse.SetHitch(this);
			horse.transform.SetPositionAndRotation(hitch.spot.position, hitch.spot.rotation);
			horse.DismountAllPlayers();
			return true;
		}
		return false;
	}

```

## OnCoalingTowerGather(CoalingTower,Item)

```csharp
```csharp
/// <summary>
/// Called when items are gathered from a coaling tower.
/// </summary>
/// <param name="tower">The coaling tower from which items are being gathered.</param>
/// <param name="item">The item that is being gathered.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being gathered, or `null` to allow the gathering process to continue.
/// </returns>
object OnCoalingTowerGather(CoalingTower tower, Item item)
{
    Puts($"Gathering item {item.info.displayName.english} from Coaling Tower ID: {tower.net.ID}.");

    if (item.info.shortname == "coal")
    {
        Puts("Gathering coal is not allowed from this tower.");
        return true; // Prevent gathering
    }

    return null; // Allow gathering
}
```
```

### Source Code from the Library

```csharp

	private void EmptyTenPercent()
	{
		if (!IsPowered())
		{
			EndEmptyProcess(ActionAttemptStatus.GenericError);
			return;
		}
		if (!HasUnloadableLinedUp)
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if (tcUnloadingNow == null || activeUnloadable != tcUnloadingNow)
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		StorageContainer storageContainer = tcUnloadingNow.GetStorageContainer();
		if (storageContainer.inventory == null || !TrainWagonLootData.instance.TryGetLootFromIndex(LootTypeIndex, out var lootOption))
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		bool flag = tcUnloadingNow.wagonType != TrainCarUnloadable.WagonType.Fuel;
		ItemContainer itemContainer = null;
		PercentFullStorageContainer percentFullStorageContainer = (flag ? GetOreStorage() : GetFuelStorage());
		if (percentFullStorageContainer != null)
		{
			itemContainer = percentFullStorageContainer.inventory;
		}
		if (itemContainer == null)
		{
			EndEmptyProcess(ActionAttemptStatus.GenericError);
			return;
		}
		ItemContainer inventory = storageContainer.inventory;
		ItemContainer newcontainer = itemContainer;
		int iAmount = Mathf.RoundToInt((float)lootOption.maxLootAmount / 10f);
		List<Item> obj = Facepunch.Pool.Get<List<Item>>();
		int num = inventory.Take(obj, lootOption.lootItem.itemid, iAmount);
		bool flag2 = true;
		if (num > 0)
		{
			foreach (Item item in obj)
			{
				if (tcUnloadingNow.wagonType == TrainCarUnloadable.WagonType.Lootboxes)
				{
					item.Remove();
					continue;
				}
				if (Interface.CallHook("OnCoalingTowerGather", this, item) != null)
				{
					item.Remove();
					continue;
				}
				bool flag3 = item.MoveToContainer(newcontainer);
				if (!flag2 || flag3)
				{
					continue;
				}
				item.MoveToContainer(inventory);
				flag2 = false;
				break;
			}
		}
		Facepunch.Pool.Free(ref obj, freeElements: false);
		float orePercent = tcUnloadingNow.GetOrePercent();
		if (orePercent == 0f)
		{
			EndEmptyProcess(ActionAttemptStatus.NoError);
		}
		else if (!flag2)
		{
			EndEmptyProcess(ActionAttemptStatus.OutputIsFull);
		}
		else if (flag)
		{
			tcUnloadingNow.SetVisualOreLevel(orePercent);
		}
	}

```

## OnBookmarkControl(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a player begins controlling a remote entity via a bookmark.
/// </summary>
/// <param name="station">The computer station initiating the control.</param>
/// <param name="player">The player who is attempting to control the remote entity.</param>
/// <param name="bookmarkId">The identifier for the bookmark being used.</param>
/// <param name="remoteEntity">The remote controllable entity being accessed.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControl(ComputerStation station, BasePlayer player, string bookmarkId, IRemoteControllable remoteEntity)
{
    Puts($"Player {player.displayName} is controlling bookmark {bookmarkId} on station {station.name}.");

    if (remoteEntity is CCTV_RC)
    {
        Puts($"Player {player.displayName} is controlling a CCTV remote.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## OnCollectiblePickedup(CollectibleEntity,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a collectible entity is picked up by a player.
/// </summary>
/// <param name="collectible">The collectible entity that was picked up.</param>
/// <param name="player">The player who picked up the collectible.</param>
/// <param name="item">The item that was collected.</param>
/// <returns>No return behavior.</returns>
void OnCollectiblePickedup(CollectibleEntity collectible, BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} picked up {item.info.displayName.english} from {collectible.gameObject.name}.");

    if (item.info.category == ItemCategory.Food)
    {
        Puts($"Player {player.displayName} has collected food: {item.info.shortname}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoPickup(BasePlayer reciever, bool eat = false)
	{
		if (itemList == null || Interface.CallHook("OnCollectiblePickup", this, reciever, eat) != null)
		{
			return;
		}
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			if (reciever != null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)
			{
				continue;
			}
			Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
			if (item == null)
			{
				continue;
			}
			if (eat && item.info.category == ItemCategory.Food && reciever != null)
			{
				ItemModConsume component = item.info.GetComponent<ItemModConsume>();
				if (component != null)
				{
					component.DoAction(item, reciever);
					continue;
				}
			}
			if ((bool)reciever)
			{
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);
				Interface.CallHook("OnCollectiblePickedup", this, reciever, item);
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
		}
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(reciever, base.transform.position);
		}
		Kill();
	}

```

## CanAssignBed(BasePlayer,SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Determines if a player can assign a sleeping bag to another player.
/// </summary>
/// <param name="player">The player attempting to assign the sleeping bag.</param>
/// <param name="sleepingBag">The sleeping bag being assigned.</param>
/// <param name="targetUserId">The user ID of the player to whom the sleeping bag is being assigned.</param>
/// <returns>
/// Returns a result indicating whether the assignment is allowed. 
/// If the result is `null`, the default game logic will determine if the assignment can proceed.
/// </returns>
CanAssignBedResult? CanAssignBed(BasePlayer player, SleepingBag sleepingBag, ulong targetUserId)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to assign sleeping bag to player ID: {targetUserId}.");

    if (targetUserId == 0)
    {
        Puts("Cannot assign sleeping bag to an invalid player ID.");
        return BagResultType.InvalidTarget;
    }

    int currentBagCount = GetSleepingBagCount(player.userID);
    int maxBagsAllowed = ConVar.Server.max_sleeping_bags;

    if (currentBagCount >= maxBagsAllowed)
    {
        Puts($"Player {player.displayName} has reached the maximum number of sleeping bags.");
        return new CanAssignBedResult { Result = BagResultType.TooManyBags, Count = currentBagCount, Max = maxBagsAllowed };
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AssignToFriend(RPCMessage msg)
	{
		if (!msg.player.CanInteract() || deployerUserID != (ulong)msg.player.userID)
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num == 0L || Interface.CallHook("CanAssignBed", msg.player, this, num) != null)
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, num);
			if (canAssignBedResult.HasValue)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(num);
				if (canAssignBedResult.Value.Result == BagResultType.TooManyBags)
				{
					if (basePlayer == null)
					{
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedNoPlayerPhrase, false);
					}
					else
					{
						string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
						msg.player.ShowToast(GameTip.Styles.Error, cannotAssignBedPhrase, false, playerNameStreamSafe);
					}
				}
				else if (canAssignBedResult.Value.Result == BagResultType.BagBlocked)
				{
					msg.player.ShowToast(GameTip.Styles.Error, bedAssigningBlocked, false);
				}
				else if (canAssignBedResult.Value.Result == BagResultType.TargetIsPlayingTutorial)
				{
					msg.player.ShowToast(GameTip.Styles.Error, tutorialPhrase, false);
				}
				else
				{
					basePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, false, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, false, (GetSleepingBagCount(msg.player.userID) - 1).ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num2 = deployerUserID;
		deployerUserID = num;
		NotifyPlayer(num2);
		NotifyPlayer(deployerUserID);
		OnBagChangedOwnership(this, num2);
		Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);
		SendNetworkUpdate();
	}

```

## CanSwapToSeat(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Determines whether a player can swap to a seat on the mountable entity.
/// </summary>
/// <param name="player">The player attempting to swap to the seat.</param>
/// <param name="mountable">The mountable entity the player is trying to access.</param>
/// <returns>
/// Returns `true` if the player can swap to the seat, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can swap seats.
/// </returns>
bool? CanSwapToSeat(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to swap to a seat on {mountable.gameObject.name}.");

    if (player.IsDead())
    {
        Puts($"Player {player.displayName} cannot swap to seat while dead.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnEntityDestroy(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is destroyed.
/// </summary>
/// <param name="info">Information about the hit that caused the destruction.</param>
/// <returns>No return behavior.</returns>
void OnEntityDestroy(BradleyAPC bradley, HitInfo info)
{
    Puts($"Bradley APC destroyed at position: {bradley.transform.position} by {info?.InitiatorPlayer?.displayName ?? "unknown"}.");

    if (info != null && info.InitiatorPlayer != null)
    {
        Puts($"Destruction initiated by player: {info.InitiatorPlayer.displayName}");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (base.isClient || Interface.CallHook("OnEntityDestroy", this) != null)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);
		Vector3 zero = Vector3.zero;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);
		for (int i = 0; i < 12 - maxCratesToSpawn; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);
			if (!baseEntity)
			{
				continue;
			}
			float minInclusive = 3f;
			float maxInclusive = 10f;
			Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
			baseEntity.transform.position = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * UnityEngine.Random.Range(-4f, 4f);
			Collider component = baseEntity.GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(zero + onUnitSphere * UnityEngine.Random.Range(minInclusive, maxInclusive));
			foreach (ServerGib item in list)
			{
				UnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;
			onUnitSphere2.y = 0f;
			onUnitSphere2.Normalize();
			Vector3 pos = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if ((bool)lootContainer)
			{
				lootContainer.Invoke(lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = baseEntity2.GetComponent<Collider>();
			Rigidbody rigidbody = baseEntity2.gameObject.AddComponent<Rigidbody>();
			rigidbody.useGravity = true;
			rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
			rigidbody.mass = 2f;
			rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
			rigidbody.velocity = zero + onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);
			rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
			rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if ((bool)fireBall)
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				fireBall.GetComponent<Rigidbody>().isKinematic = true;
				fireBall.GetComponent<Collider>().enabled = false;
			}
			baseEntity2.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);
			foreach (ServerGib item2 in list)
			{
				UnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);
			}
		}
		KillSpawnedScientists();
		if (info != null && info.InitiatorPlayer != null && info.InitiatorPlayer.serverClan != null)
		{
			info.InitiatorPlayer.AddClanScore(ClanScoreEventType.DestroyedBradley);
		}
		base.OnKilled(info);
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be accepted into the specified item container at the given position.
/// </summary>
/// <param name="item">The item to be checked for acceptance.</param>
/// <param name="targetPos">The target position in the container where the item is to be placed.</param>
/// <returns>
/// Returns <c>CanAcceptResult.CanAccept</c> if the item can be accepted, 
/// <c>CanAcceptResult.CannotAccept</c> if it cannot, 
/// or <c>CanAcceptResult.CannotAcceptRightNow</c> if it cannot be accepted at this moment.
/// </returns>
CanAcceptResult CanAcceptItem(Item item, int targetPos)
{
    Puts($"Checking if item {item.info.displayName.english} can be accepted into the container at position {targetPos}.");

    if (item.info.itemType == ItemType.Weapon)
    {
        Puts("Weapons cannot be accepted in this container.");
        return CanAcceptResult.CannotAccept;
    }

    return CanAcceptResult.CanAccept;
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (isServer && availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			if (item.isBroken)
			{
				return CanAcceptResult.CannotAccept;
			}
			int num = 0;
			foreach (ItemSlot availableSlot in availableSlots)
			{
				num |= (int)availableSlot;
			}
			if (((uint)num & (uint)item.info.occupySlots) != (uint)item.info.occupySlots)
			{
				return CanAcceptResult.CannotAcceptRightNow;
			}
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (HasLimitedAllowedItems)
		{
			bool flag = false;
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if (onlyAllowedItems[i] == item.info)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return CanAcceptResult.CannotAccept;
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		if (blockedItems != null && blockedItems.Contains(item.info))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (item.GetItemVolume() > containerVolume)
		{
			return CanAcceptResult.CannotAccept;
		}
		return CanAcceptResult.CanAccept;
	}

```

## OnItemSplit(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is split into a smaller quantity.
/// </summary>
/// <param name="item">The item being split.</param>
/// <param name="splitAmount">The amount to split from the original item.</param>
/// <returns>
/// Returns the new item created from the split, or <c>null</c> if the split was not successful.
/// </returns>
Item OnItemSplit(Item item, int splitAmount)
{
    Puts($"Item {item.info.displayName.english} is being split. Amount to split: {splitAmount}");
    
    if (splitAmount <= 0)
    {
        Puts("Split amount must be greater than zero.");
        return null;
    }

    if (item.amount < splitAmount)
    {
        Puts("Not enough item amount to split.");
        return null;
    }

    return null; // Allow the default split logic to proceed
}
```
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		item.skin = skin;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		if (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
		}
		if (instanceData != null && instanceData.dataInt > 0 && info != null && info.Blueprint != null && info.Blueprint.workbenchLevelRequired == 3)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
			item.SetFlag(Flag.IsOn, IsOn());
		}
		MarkDirty();
		return item;
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is upgraded successfully.
/// </summary>
/// <param name="originalItem">The original item before the upgrade.</param>
/// <param name="upgradedItem">The new item after the upgrade.</param>
/// <param name="player">The player who performed the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnItemUpgrade(Item originalItem, Item upgradedItem, BasePlayer player)
{
    Puts($"Player {player.displayName} upgraded {originalItem.info.displayName.english} to {upgradedItem.info.displayName.english}.");
    
    if (upgradedItem.info.shortname == "better.item")
    {
        Puts($"Congratulations {player.displayName}, you have crafted a better item!");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (UnityEngine.Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnHelicopterDropDoorOpen(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the drop door of a helicopter is opened or closed.
/// </summary>
/// <param name="helicopter">The helicopter whose drop door state is being changed.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropDoorOpen(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter drop door state changed for Helicopter ID: {helicopter.net.ID}. Door is now {(helicopter.HasFlag(Flags.Reserved8) ? "open" : "closed")}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting a storage container.
/// </summary>
/// <param name="player">The player who has stopped looting.</param>
/// <param name="container">The storage container that was looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.displayName} has stopped looting the container: {container.ShortPrefabName}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnExperimentStarted(Workbench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an experiment is started at the workbench by a player.
/// </summary>
/// <param name="workbench">The workbench where the experiment is initiated.</param>
/// <param name="player">The player who started the experiment.</param>
/// <returns>No return behavior.</returns>
void OnExperimentStarted(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment started at workbench by player: {player.displayName} (ID: {player.UserIDString})");

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can start experiments freely.");
    }
    else
    {
        Puts($"Player {player.displayName} is starting a regular experiment.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## OnItemCraft(IndustrialCrafter,ItemBlueprint)

```csharp
```csharp
/// <summary>
/// Called when an item crafting process begins in the industrial crafter.
/// </summary>
/// <param name="crafter">The industrial crafter that is performing the crafting.</param>
/// <param name="blueprint">The blueprint of the item being crafted.</param>
/// <returns>
/// Returns a non-null value to prevent the crafting process from starting. 
/// If `null` is returned, the crafting process will proceed as normal.
/// </returns>
object OnItemCraft(IndustrialCrafter crafter, ItemBlueprint blueprint)
{
    Puts($"Crafting initiated for {blueprint.targetItem.shortname} in Industrial Crafter ID: {crafter.net.ID}.");
    
    if (blueprint.targetItem.shortname == "explosive.timed")
    {
        Puts("Crafting of timed explosives is restricted!");
        return "Crafting of this item is not allowed.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected override void RunJob()
	{
		base.RunJob();
		if (ConVar.Server.industrialCrafterFrequency <= 0f || HasFlag(Flags.Reserved1) || currentlyCrafting != null)
		{
			return;
		}
		for (int i = 0; i <= 3; i++)
		{
			Item targetBlueprint = GetTargetBlueprint(i);
			if (targetBlueprint == null || GetWorkbench() == null || GetWorkbench().Workbenchlevel < targetBlueprint.blueprintTargetDef.Blueprint.workbenchLevelRequired)
			{
				continue;
			}
			ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;
			if (Interface.CallHook("OnItemCraft", this, blueprint) != null)
			{
				break;
			}
			bool flag = true;
			foreach (ItemAmount ingredient in blueprint.ingredients)
			{
				if ((float)GetInputAmount(ingredient.itemDef) < ingredient.amount)
				{
					flag = false;
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			flag = false;
			for (int j = 8; j <= 11; j++)
			{
				Item slot = _inventory.GetSlot(j);
				if (slot == null || (slot.info == targetBlueprint.blueprintTargetDef && slot.amount + blueprint.amountToCreate <= slot.MaxStackable()))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				SetFlag(Flags.Reserved2, b: true);
				continue;
			}
			SetFlag(Flags.Reserved2, b: false);
			foreach (ItemAmount ingredient2 in blueprint.ingredients)
			{
				ConsumeInputIngredient(ingredient2);
			}
			currentlyCrafting = targetBlueprint.blueprintTargetDef;
			currentlyCraftingAmount = blueprint.amountToCreate;
			float time = blueprint.time;
			Invoke(CompleteCraft, time);
			jobFinishes = time;
			SetFlag(Flags.Reserved1, b: true);
			ClientRPC(RpcTarget.NetworkGroup("ClientUpdateCraftTimeRemaining"), (float)jobFinishes, jobFinishes.Duration);
			break;
		}
	}

```

## CanChangeCode(BasePlayer,CodeLock,string,bool)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the code of a CodeLock.
/// </summary>
/// <param name="player">The player attempting to change the code.</param>
/// <param name="codeLock">The CodeLock being modified.</param>
/// <param name="newCode">The new code to set.</param>
/// <param name="isGuestCode">Indicates if the new code is for guest access.</param>
/// <returns>
/// Returns `true` if the player is allowed to change the code, or `false` if they are not.
/// If the method returns `null`, the default game logic will determine if the code can be changed.
/// </returns>
bool? CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
{
    Puts($"Player {player.displayName} is attempting to change the code of a CodeLock to '{newCode}' (Guest Code: {isGuestCode}).");

    if (newCode.Length != 4 || !newCode.IsNumeric())
    {
        Puts($"Player {player.displayName} provided an invalid code: '{newCode}'.");
        return false;
    }

    if (isGuestCode && !player.HasPermission("codelock.change.guest"))
    {
        Puts($"Player {player.displayName} does not have permission to set a guest code.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (!IsLocked() && text.Length == 4 && text.IsNumeric() && !(!hasCode && flag) && Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!hasCode && !flag)
			{
				SetFlag(Flags.Locked, b: true);
			}
			Facepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			Interface.CallHook("OnCodeChanged", rpc.player, this, text, flag);
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when an auto turret is starting up.
/// </summary>
/// <param name="turret">The auto turret that is initiating startup.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally. 
/// Any non-null value will prevent the turret from starting up.
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"AutoTurret ID: {turret.net.ID} is attempting to start up.");
    
    if (turret.IsUnderMaintenance)
    {
        Puts($"AutoTurret ID: {turret.net.ID} cannot start up while under maintenance.");
        return "Turret is under maintenance.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnEntityReskin(BaseEntity,ItemSkinDirectory.Skin,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is reskinned.
/// </summary>
/// <param name="entity">The entity that is being reskinned.</param>
/// <param name="skin">The new skin being applied to the entity.</param>
/// <param name="player">The player who initiated the reskin action.</param>
/// <returns>
/// Returns a non-null value to prevent the reskin action from proceeding. 
/// If `null` is returned, the reskin will be applied as normal.
/// </returns>
object OnEntityReskin(BaseEntity entity, ItemSkinDirectory.Skin skin, BasePlayer player)
{
    Puts($"Entity {entity.net.ID} is being reskinned to skin ID: {skin.id} by player {player.displayName}.");
    
    if (skin.id == 12345) // Example skin ID that is not allowed
    {
        Puts($"Player {player.displayName} attempted to apply a restricted skin.");
        return "This skin cannot be applied.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	private void ChangeItemSkin(RPCMessage msg)
	{
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))
		{
			return;
		}
		if (baseNetworkable != null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if ((object)baseEntity2 != null)
			{
				if (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))
				{
					FailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin((def.isRedirectOf != null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", baseEntity2, skin, msg.player) != null)
				{
					return;
				}
				if (skin.invItem != null && skin.invItem is ItemSkin itemSkin)
				{
					if (itemSkin.Redirect != null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if ((bool)def && def.isRedirectOf != null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if (def.isRedirectOf != null || ((bool)def && def.isRedirectOf != null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if (itemDefinition == null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2))
					{
						FailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning("Cannot find resource path of redirect entity to spawn! " + itemDefinition.gameObject.name);
						FailResponse(SprayFailReason.InvalidItem);
						return;
					}
					Vector3 localPosition = baseEntity2.transform.localPosition;
					Quaternion localRotation = baseEntity2.transform.localRotation;
					BaseEntity baseEntity3 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					HashSet<PlayerNameID> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> obj = Facepunch.Pool.Get<List<ChildPreserveInfo>>();
					if (flag)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							obj.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = child.transform.localPosition,
								LocalRotation = child.transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in obj)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity3);
					baseEntity2.transform.localPosition = localPosition;
					baseEntity2.transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity)
					{
						decayEntity.AttachToBuilding(null);
					}
					baseEntity2.Spawn();
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag)
						{
							for (int j = 0; j < baseEntity2.children.Count; j++)
							{
								RestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item2 in dictionary2)
						{
							foreach (Item item3 in item2.Value)
							{
								Debug.Log($"Deleting {item3} as it has no new container");
								item3.Remove();
							}
						}
						Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
					}
					if (flag)
					{
						foreach (ChildPreserveInfo item4 in obj)
						{
							item4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);
							item4.TargetEntity.transform.localPosition = item4.LocalPosition;
							item4.TargetEntity.transform.localRotation = item4.LocalRotation;
							item4.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Interface.CallHook("OnEntityReskinned", baseEntity2, skin, msg.player);
					Facepunch.Pool.FreeUnmanaged(ref obj);
				}
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		LoseCondition(ConditionLossPerReskin);
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		void FailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (copy.ContainsKey(key))
				{
					foreach (Item item5 in copy[key])
					{
						item5.MoveToContainer(itemContainerEntity.inventory);
					}
					copy.Remove(key);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (!dictionary.ContainsKey(key2))
				{
					dictionary.Add(key2, new List<Item>());
					foreach (Item item6 in itemContainerEntity2.inventory.itemList)
					{
						dictionary[key2].Add(item6);
					}
					{
						foreach (Item item7 in dictionary[key2])
						{
							item7.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log("Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
	}

```

## OnPlayerSpawn(BasePlayer,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a player spawns into the game.
/// </summary>
/// <param name="player">The player that is spawning.</param>
/// <param name="connection">The network connection of the player.</param>
/// <returns>
/// Returns `null` to allow the player to spawn normally, or any non-null value to prevent spawning.
/// </returns>
object OnPlayerSpawn(BasePlayer player, Network.Connection connection)
{
    Puts($"Player {player.displayName} is attempting to spawn with connection ID: {connection?.userid ?? 0}.");

    if (player.health <= 0)
    {
        Puts($"Player {player.displayName} cannot spawn because they are dead.");
        return "You cannot spawn while dead.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public BasePlayer SpawnNewPlayer(Network.Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer, connection) != null)
		{
			return basePlayer;
		}
		basePlayer.health = 0f;
		basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
		basePlayer.ResetLifeStateOnSpawn = false;
		basePlayer.limitNetworking = true;
		if (connection == null)
		{
			basePlayer.EnableTransferProtection();
		}
		basePlayer.Spawn();
		basePlayer.limitNetworking = false;
		if (connection != null)
		{
			basePlayer.PlayerInit(connection);
			if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer);
			}
			else if (UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife))
			{
				basePlayer.Respawn();
			}
			DebugEx.Log($"{basePlayer.displayName} with steamid {basePlayer.userID.Get()} joined from ip {basePlayer.net.connection.ipaddress}");
			DebugEx.Log($"\tNetworkId {basePlayer.userID.Get()} is {basePlayer.net.ID} ({basePlayer.displayName})");
			if (basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
			{
				DebugEx.Log($"\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}");
			}
		}
		return basePlayer;
	}

```

## CanFastTrackCraftTask(ItemCrafter,ItemCraftTask,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a crafting task can be fast-tracked.
/// </summary>
/// <param name="craftingStation">The item crafter attempting to fast-track the task.</param>
/// <param name="task">The crafting task to be fast-tracked.</param>
/// <param name="taskID">The unique identifier of the crafting task.</param>
/// <returns>
/// Returns `true` if the task can be fast-tracked, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the task can be fast-tracked.
/// </returns>
bool? CanFastTrackCraftTask(ItemCrafter craftingStation, ItemCraftTask task, int taskID)
{
    Puts($"Attempting to fast-track crafting task ID: {taskID} for crafting station: {craftingStation?.gameObject.name ?? "Unknown"}.");

    if (task.cancelled)
    {
        Puts($"Task ID: {taskID} has been cancelled and cannot be fast-tracked.");
        return false;
    }

    if (task.amount <= 0)
    {
        Puts($"Task ID: {taskID} has no remaining items to craft.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool FastTrackTask(int taskID)
	{
		int taskID2 = taskID;
		if (queue.Count == 0)
		{
			return false;
		}
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask value = queue.First.Value;
		if (value == null)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == taskID2 && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		if (itemCraftTask == value)
		{
			return false;
		}
		object obj = Interface.CallHook("CanFastTrackCraftTask", this, itemCraftTask, taskID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		value.endTime = 0f;
		queue.Remove(itemCraftTask);
		queue.AddFirst(itemCraftTask);
		owner.Command("note.craft_fasttracked", taskID2);
		return true;
	}

```

## CanRenameBed(BasePlayer,SleepingBag,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can rename a sleeping bag.
/// </summary>
/// <param name="player">The player attempting to rename the sleeping bag.</param>
/// <param name="sleepingBag">The sleeping bag being renamed.</param>
/// <param name="newName">The new name for the sleeping bag.</param>
/// <returns>
/// Returns `null` to allow the renaming, or a non-null value to prevent it. 
/// If a string is returned, it can be used as a rejection message.
/// </returns>
object CanRenameBed(BasePlayer player, SleepingBag sleepingBag, string newName)
{
    Puts($"Player {player.displayName} is attempting to rename a sleeping bag to '{newName}'.");

    if (newName.Contains("restricted"))
    {
        Puts($"Player {player.displayName} is not allowed to use the name '{newName}'.");
        return "This name is not allowed.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("CanRenameBed", msg.player, this, text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
			NotifyPlayer(deployerUserID);
		}
	}

```

## OnAirdrop(CargoPlane,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an airdrop is initiated, providing the cargo plane and its drop position.
/// </summary>
/// <param name="cargoPlane">The cargo plane responsible for the airdrop.</param>
/// <param name="dropPosition">The position where the airdrop will occur.</param>
/// <returns>No return behavior.</returns>
void OnAirdrop(CargoPlane cargoPlane, Vector3 dropPosition)
{
    Puts($"Airdrop initiated from CargoPlane ID: {cargoPlane.net.ID} at position: {dropPosition}");
    
    if (dropPosition.y < 0)
    {
        Puts("Airdrop position is below ground level, adjusting to a safe height.");
        dropPosition.y = 10f; // Adjust to a safe height
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		startPos.Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);
		base.transform.position = startPos;
		base.transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", this, newDropPosition);
	}

```

## CanFireLiquidWeapon(BasePlayer,LiquidWeapon)

```csharp
```csharp
/// <summary>
/// Determines whether a player can fire a liquid weapon.
/// </summary>
/// <param name="player">The player attempting to fire the liquid weapon.</param>
/// <param name="liquidWeapon">The liquid weapon being fired.</param>
/// <returns>
/// Returns `true` if the player can fire the liquid weapon; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can fire the weapon.
/// </returns>
bool? CanFireLiquidWeapon(BasePlayer player, LiquidWeapon liquidWeapon)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to fire a liquid weapon.");

    if (player.IsIncapacitated())
    {
        Puts($"Player {player.displayName} cannot fire while incapacitated.");
        return false;
    }

    if (liquidWeapon.RequiresPumping && liquidWeapon.pressure < liquidWeapon.PressureLossPerTick)
    {
        Puts($"Player {player.displayName} cannot fire due to insufficient pressure.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanFire(BasePlayer player)
	{
		object obj = Interface.CallHook("CanFireLiquidWeapon", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequiresPumping && pressure < PressureLossPerTick)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		if (HasFlag(Flags.Open))
		{
			return false;
		}
		if (AmountHeld() <= 0)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (!player.CanAttack() || player.IsRunning())
		{
			return false;
		}
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return false;
		}
		return true;
	}

```

## OnNetworkGroupLeft(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network group is left by a networkable entity.
/// </summary>
/// <param name="networkable">The networkable entity that left the group.</param>
/// <param name="group">The network visibility group that was left.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupLeft(BaseNetworkable networkable, Network.Visibility.Group group)
{
    Puts($"Networkable entity {networkable.net.ID} has left the visibility group: {group.name}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", this, group);
	}

```

## OnBigWheelLoss(BigWheelGame,Item,BigWheelBettingTerminal)

```csharp
```csharp
/// <summary>
/// Called when a player loses in the Big Wheel game.
/// </summary>
/// <param name="game">The Big Wheel game instance.</param>
/// <param name="item">The item associated with the loss.</param>
/// <param name="terminal">The betting terminal where the game took place.</param>
/// <returns>
/// Returns a non-null value to override the default loss behavior. If `null` is returned, the default loss logic will be executed.
/// </returns>
object OnBigWheelLoss(BigWheelGame game, Item item, BigWheelBettingTerminal terminal)
{
    Puts($"Player lost at terminal {terminal.id} with item {item.info.displayName.english}.");
    
    // Example condition to prevent loss
    if (item.info.shortname == "special.token")
    {
        Puts("Player cannot lose special tokens.");
        return "You cannot lose special tokens!";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) == null)
				{
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanAssignMission(BasePlayer,BaseMission,IMissionProvider)

```csharp
```csharp
/// <summary>
/// Determines if a mission can be assigned to a player.
/// </summary>
/// <param name="assignee">The player to whom the mission is being assigned.</param>
/// <param name="mission">The mission that is being assigned.</param>
/// <param name="provider">The provider of the mission.</param>
/// <returns>
/// Returns `true` if the mission can be assigned, `false` if it cannot, 
/// or `null` if the assignment is subject to additional checks via hooks.
/// </returns>
bool? CanAssignMission(BasePlayer assignee, BaseMission mission, IMissionProvider provider)
{
    Puts($"Checking if mission {mission.id} can be assigned to player {assignee.displayName}.");

    if (!assignee.IsAlive())
    {
        Puts($"Player {assignee.displayName} is not alive and cannot be assigned a mission.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", assignee, mission, provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = assignee.missions.FindIndexWith((MissionInstance i) => i.missionID, mission.id);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", mission, provider, assignee);
		return true;
	}

```

## CanLootEntity(BasePlayer,WorldItem)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot a specific entity in the game world.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity that is being looted.</param>
/// <returns>
/// Returns `true` if the player can loot the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can loot the entity.
/// </returns>
bool? CanLootEntity(BasePlayer player, WorldItem entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to loot entity: {entity.name}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot loot in a safe zone.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (item == null || item.contents == null)
		{
			return;
		}
		ItemModContainer component = item.info.GetComponent<ItemModContainer>();
		if (!(component == null) && component.canLootInWorld)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && CanOpenInSafeZone(player) && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(item.contents);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "generic_resizable");
				SendNetworkUpdate();
			}
		}
	}

```

## OnWeaponModChange(BaseProjectile,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the weapon modifications change for a projectile weapon.
/// </summary>
/// <param name="projectile">The projectile weapon whose modifications have changed.</param>
/// <param name="player">The player who owns the projectile weapon.</param>
/// <returns>No return behavior.</returns>
void OnWeaponModChange(BaseProjectile projectile, BasePlayer player)
{
    Puts($"Weapon modifications changed for {projectile.name} owned by {player.displayName} (ID: {player.UserIDString}).");
    
    // Additional logic can be added here to handle specific mod changes
    if (projectile.primaryMagazine.capacity < 10)
    {
        Puts($"Warning: {player.displayName}'s weapon magazine capacity is below the minimum threshold.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DelayedModsChanged()
	{
		if (Interface.CallHook("OnWeaponModChange", this, GetOwnerPlayer()) != null)
		{
			return;
		}
		int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)primaryMagazine.definition.builtInSize);
		if (num == primaryMagazine.capacity)
		{
			return;
		}
		if (primaryMagazine.contents > 0 && primaryMagazine.contents > num)
		{
			_ = primaryMagazine.ammoType;
			int contents = primaryMagazine.contents;
			BasePlayer ownerPlayer = GetOwnerPlayer();
			ItemContainer itemContainer = null;
			if (ownerPlayer != null)
			{
				itemContainer = ownerPlayer.inventory.containerMain;
			}
			else if (GetCachedItem() != null)
			{
				itemContainer = GetCachedItem().parent;
			}
			SetAmmoCount(0);
			if (itemContainer != null)
			{
				Item item = ItemManager.Create(primaryMagazine.ammoType, contents, 0uL);
				if (!item.MoveToContainer(itemContainer))
				{
					Vector3 vPos = base.transform.position;
					if (itemContainer.entityOwner != null)
					{
						vPos = itemContainer.entityOwner.transform.position + Vector3.up * 0.25f;
					}
					item.Drop(vPos, Vector3.up * 5f);
				}
			}
		}
		primaryMagazine.capacity = num;
		SendNetworkUpdate();
	}

```

## OnVehicleModulesAssigned(ModularCar,Rust.Modular.ItemModVehicleModule[])

```csharp
```csharp
/// <summary>
/// Called when vehicle modules are assigned to a modular car.
/// </summary>
/// <param name="car">The modular car to which the modules are being assigned.</param>
/// <param name="modules">The array of vehicle modules being assigned.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModulesAssigned(ModularCar car, Rust.Modular.ItemModVehicleModule[] modules)
{
    Puts($"Modules assigned to vehicle {car.net.ID}: {modules.Length} modules assigned.");
    
    foreach (var module in modules)
    {
        Puts($"Module assigned: {module?.GetType().Name ?? "Unknown Module"}");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", this, modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				Item item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);
				float num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", this, modularCarPresetConfig.socketItemDefs);
		Invoke(HandleAdminBonus, 0f);
	}

```

## OnRackedWeaponSwap(Item,WeaponRackSlot,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is swapped on a weapon rack.
/// </summary>
/// <param name="item">The item being swapped (the weapon).</param>
/// <param name="slot">The slot on the weapon rack where the weapon is being placed.</param>
/// <param name="player">The player performing the swap.</param>
/// <param name="rack">The weapon rack involved in the swap.</param>
/// <returns>
/// Returns `null` to allow the swap to proceed, or any non-null value to prevent the swap.
/// </returns>
object OnRackedWeaponSwap(Item item, WeaponRackSlot slot, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player.displayName} is swapping weapon: {item.info.displayName.english} into slot: {slot.index} on rack: {rack.net.ID}.");

    if (item.info.shortname == "weapon.sword")
    {
        Puts("Swords cannot be swapped onto the weapon rack.");
        return "Swords are not allowed on the rack.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", item, weaponAtIndex, player, this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", item, weaponAtIndex, player, this);
			}
		}
	}

```

## OnTakeCurrencyItem(NPCVendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is taken as currency by the vending machine.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that is taking the currency item.</param>
/// <param name="currencyItem">The item being taken as currency.</param>
/// <returns>No return behavior.</returns>
void OnTakeCurrencyItem(NPCVendingMachine vendingMachine, Item currencyItem)
{
    Puts($"Currency item {currencyItem.info.displayName.english} taken by vending machine {vendingMachine.net.ID}.");
}
```
```

### Source Code from the Library

```csharp

	public override void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null)
		{
			takenCurrencyItem.MoveToContainer(base.inventory);
			takenCurrencyItem.RemoveFromContainer();
			takenCurrencyItem.Remove();
		}
	}

```

## OnItemAction(Item,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an action is performed on an item by a player.
/// </summary>
/// <param name="item">The item on which the action is performed.</param>
/// <param name="action">The action being performed (e.g., "drop").</param>
/// <param name="player">The player performing the action.</param>
/// <returns>
/// Returns `null` to allow the action to proceed, or any non-null value to prevent the action.
/// </returns>
object OnItemAction(Item item, string action, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to perform action '{action}' on item {item.info.displayName.english}.");

    if (action == "drop" && item.amount > 10)
    {
        Puts($"Player {player.displayName} cannot drop more than 10 items at once.");
        return "Cannot drop more than 10 items.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server.FromOwner]
	[BaseEntity.RPC_Server]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		if ((msg.player != null && msg.player.IsWounded()) || base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		string text = msg.read.String();
		Item item = FindItemByUID(id);
		if (item == null || Interface.CallHook("OnItemAction", item, text, msg.player) != null)
		{
			return;
		}
		BaseEntity entityOwner = item.GetEntityOwner();
		if ((entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering) || item.IsLocked() || (item.parent != null && item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item))
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.Unread >= 4)
			{
				num = msg.read.Int32();
			}
			if (!msg.player.isMounted && !msg.player.HasParent() && !GamePhysics.LineOfSight(msg.player.transform.position, msg.player.eyes.position, 1218519041))
			{
				return;
			}
			base.baseEntity.stats.Add("item_drop", 1, (Stats)5);
			if (num < item.amount)
			{
				Item item2 = item.SplitItem(num);
				ItemContainer parent = item.parent;
				if (item2 != null)
				{
					DroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DropReason = DroppedItem.DropReasonEnum.Player;
						droppedItem.DroppedBy = base.baseEntity.userID;
						droppedItem.DroppedTime = DateTime.UtcNow;
						Facepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);
					}
				}
				parent?.onItemRemovedFromStack?.Invoke(item, num);
			}
			else
			{
				ItemContainer parent2 = item.parent;
				DroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;
				if (droppedItem2 != null)
				{
					droppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;
					droppedItem2.DroppedBy = base.baseEntity.userID;
					droppedItem2.DroppedTime = DateTime.UtcNow;
					Facepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);
				}
				parent2?.onItemAddedRemoved?.Invoke(item, arg2: false);
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnItemUnwrap(Item,BasePlayer,ItemModUnwrap)

```csharp
```csharp
/// <summary>
/// Called when an item is unwrapped by a player.
/// </summary>
/// <param name="item">The item being unwrapped.</param>
/// <param name="player">The player who is unwrapping the item.</param>
/// <param name="itemMod">The item modification associated with the unwrapping process.</param>
/// <returns>
/// Returns `null` to allow the unwrapping process to continue. 
/// Any non-null value will prevent the item from being unwrapped.
/// </returns>
object OnItemUnwrap(Item item, BasePlayer player, ItemModUnwrap itemMod)
{
    Puts($"Player {player.displayName} is unwrapping item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.itemid == 12345) // Example item ID for a restricted item
    {
        Puts($"Player {player.displayName} attempted to unwrap a restricted item.");
        return "You cannot unwrap this item.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "unwrap" && item.amount > 0 && Interface.CallHook("OnItemUnwrap", item, player, this) == null)
		{
			item.UseItem();
			int num = UnityEngine.Random.Range(minTries, maxTries + 1);
			for (int i = 0; i < num; i++)
			{
				revealList.SpawnIntoContainer(player.inventory.containerMain);
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnItemDeployed(Deployer,ItemModDeployable,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is successfully deployed in the game world.
/// </summary>
/// <param name="deployer">The player who is deploying the item.</param>
/// <param name="deployable">The deployable item being placed.</param>
/// <param name="entity">The entity that is being created as a result of the deployment.</param>
/// <returns>No return behavior.</returns>
void OnItemDeployed(BasePlayer deployer, ItemModDeployable deployable, BaseEntity entity)
{
    Puts($"Item {deployable.itemName} deployed by {deployer.displayName} (ID: {deployer.UserIDString}) at position {entity.transform.position}.");
    
    if (entity is BuildingBlock)
    {
        Puts($"A building block has been deployed by {deployer.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Regular(Deployable deployable, Ray ray)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
		}
		else if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.Antihack, false);
		}
		else
		{
			if (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))
			{
				return;
			}
			Vector3 point = hitInfo.point;
			Quaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);
			Item ownerItem = GetOwnerItem();
			ItemModDeployable modDeployable = GetModDeployable();
			if (ownerPlayer.Distance(point) > 3f)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.TooFarAway, false);
				return;
			}
			if (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
				return;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);
			if (!baseEntity)
			{
				Debug.LogWarning("Couldn't create prefab:" + modDeployable.entityPrefab.resourcePath);
				return;
			}
			baseEntity.skinID = ownerItem.skin;
			baseEntity.SendMessage("SetDeployedBy", ownerPlayer, SendMessageOptions.DontRequireReceiver);
			baseEntity.OwnerID = ownerPlayer.userID;
			baseEntity.Spawn();
			modDeployable.OnDeployed(baseEntity, ownerPlayer);
			Interface.CallHook("OnItemDeployed", this, modDeployable, baseEntity);
			Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
			UseItemAmount(1);
		}
	}

```

## OnMissionStarted(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is started for a player.
/// </summary>
/// <param name="mission">The mission that is starting.</param>
/// <param name="instance">The instance of the mission being started.</param>
/// <param name="assignee">The player assigned to the mission.</param>
/// <returns>No return behavior.</returns>
void OnMissionStarted(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts($"Mission {mission.missionName} has started for player {assignee.displayName} (ID: {assignee.UserIDString}).");

    if (assignee.IsInSafeZone())
    {
        Puts($"Player {assignee.displayName} is in a safe zone and cannot start missions.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", this, instance, assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", this, instance, assignee);
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="message">The chat message sent by the player.</param>
/// <param name="player">The player who sent the message.</param>
/// <returns>
/// Returns `null` to allow the message to be sent, or any non-null value to prevent the message from being sent.
/// </returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Player {player.displayName} sent a message: {message}");
    
    if (message.Contains("forbidden"))
    {
        Puts($"Message from {player.displayName} contains forbidden content and will not be sent.");
        return "Your message contains forbidden content.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 2, 0, msg);
		}
	}

```

## OnStashOcclude(StashContainer)

```csharp
```csharp
/// <summary>
/// Called when a stash container is occluded, indicating that it is no longer accessible.
/// </summary>
/// <param name="stashContainer">The stash container that is occluded.</param>
/// <returns>
/// Returns `null` to allow the default occlusion behavior, or any non-null value to prevent the occlusion action.
/// </returns>
object OnStashOcclude(StashContainer stashContainer)
{
    Puts($"Stash container at {stashContainer.transform.position} has been occluded.");
    return null; // Allow default behavior
}
```
```

### Source Code from the Library

```csharp

	public void DoOccludedCheck()
	{
		if (UnityEngine.Physics.SphereCast(new Ray(base.transform.position + Vector3.up * 5f, Vector3.down), 0.25f, 5f, 2097152) && Interface.CallHook("OnStashOcclude", this) == null)
		{
			DropItems();
			Kill();
		}
	}

```

## OnFireBallSpread(FireBall,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a fireball spreads to create a new fireball entity.
/// </summary>
/// <param name="fireBall">The original fireball that is spreading.</param>
/// <param name="newEntity">The new fireball entity that is created as a result of the spread.</param>
/// <returns>No return behavior.</returns>
void OnFireBallSpread(FireBall fireBall, BaseEntity newEntity)
{
    Puts($"Fireball spread from {fireBall.net.ID} to new entity {newEntity.net.ID} at position {newEntity.transform.position}.");
    
    if (newEntity is FireBall)
    {
        Puts("A new fireball has been created!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void TryToSpread()
	{
		float num = 0.9f - generation * 0.1f;
		if (UnityEngine.Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", this, baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));
				baseEntity.SendMessage("SetGeneration", generation + 1f);
			}
		}
	}

```

## OnRackedWeaponLoaded(Item,ItemDefinition,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is loaded with ammo on a weapon rack.
/// </summary>
/// <param name="weaponItem">The item representing the weapon being loaded.</param>
/// <param name="ammoDefinition">The definition of the ammo being loaded into the weapon.</param>
/// <param name="player">The player who is loading the weapon.</param>
/// <param name="weaponRack">The weapon rack where the weapon is stored.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponLoaded(Item weaponItem, ItemDefinition ammoDefinition, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Player {player.displayName} loaded {ammoDefinition.displayName.english} into weapon {weaponItem.info.displayName.english} on rack {weaponRack.net.ID}.");
    
    if (ammoDefinition == null)
    {
        Puts("Attempted to load null ammo definition.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!player)
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (heldEntity == null)
		{
			return;
		}
		BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
		if (component == null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null || Interface.CallHook("OnRackedWeaponLoad", slot, itemDefinition, player, this) != null)
		{
			return;
		}
		if (itemDefinition == SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!(itemDefinition != null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component2 = itemDefinition.GetComponent<ItemModProjectile>();
		if (!(component2 == null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", slot, itemDefinition, player, this);
		}
	}

```

## OnBoomboxStationValidate(string)

```csharp
```csharp
/// <summary>
/// Validates whether a given URL is a valid boombox station.
/// </summary>
/// <param name="url">The URL of the boombox station to validate.</param>
/// <returns>
/// Returns `true` if the station is valid, `false` if it is not valid. 
/// If the method returns `null`, the default validation logic will be applied.
/// </returns>
bool? OnBoomboxStationValidate(string url)
{
    Puts($"Validating boombox station URL: {url}");

    if (url.Contains("restricted"))
    {
        Puts($"The URL {url} is restricted and cannot be used.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool IsStationValid(string url)
	{
		ParseServerUrlList();
		object obj = Interface.CallHook("OnBoomboxStationValidate", url);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ValidStations == null || !ValidStations.ContainsValue(url))
		{
			if (ServerValidStations != null)
			{
				return ServerValidStations.ContainsValue(url);
			}
			return false;
		}
		return true;
	}

```

## OnPortalUse(BasePlayer,BasePortal)

```csharp
```csharp
/// <summary>
/// Called when a player uses a portal to teleport to another location.
/// </summary>
/// <param name="player">The player using the portal.</param>
/// <param name="portal">The portal being used.</param>
/// <returns>No return behavior.</returns>
void OnPortalUse(BasePlayer player, BasePortal portal)
{
    Puts($"Player {player.displayName} is attempting to use portal {portal.name}.");

    if (player.IsInCombat())
    {
        Puts($"Player {player.displayName} cannot use the portal while in combat.");
        return; // Prevent portal use if the player is in combat
    }

    Puts($"Player {player.displayName} successfully used the portal {portal.name}.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void UsePortal(BasePlayer player)
	{
		if (Interface.CallHook("OnPortalUse", player, this) != null)
		{
			return;
		}
		LinkPortal();
		if (targetPortal != null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			Vector3 position = player.transform.position;
			Vector3 vector = targetPortal.GetLocalEntryExitPosition();
			Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 vector3 = vector2;
			if (isMirrored)
			{
				Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);
				vector = targetPortal.relativeAnchor.transform.TransformPoint(position2);
				vector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);
			}
			else
			{
				vector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, vector, Vector3.up);
			}
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(vector);
			player.ForceUpdateTriggers();
			player.ClientRPC(RpcTarget.Player("ForceViewAnglesTo", player), vector3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			player.ClientRPC(RpcTarget.Player("StartLoading_Quick", player), arg1: true);
			Interface.CallHook("OnPortalUsed", player, this);
		}
		else
		{
			Debug.Log("No portal...");
		}
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an object triggers the bear trap.
/// </summary>
/// <param name="trap">The bear trap that was triggered.</param>
/// <param name="triggeredObject">The game object that triggered the trap.</param>
/// <returns>No return behavior.</returns>
void OnTrapTrigger(BearTrap trap, UnityEngine.GameObject triggeredObject)
{
    Puts($"Trap triggered by object: {triggeredObject.name} at position: {triggeredObject.transform.position}");
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## OnRidableAnimalClaim(BaseRidableAnimal,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player claims a ridable animal using a purchase token.
/// </summary>
/// <param name="animal">The ridable animal being claimed.</param>
/// <param name="player">The player claiming the animal.</param>
/// <param name="item">The item used for the claim, typically a purchase token.</param>
/// <returns>
/// Returns `null` to allow the claim to proceed, or any non-null value to prevent the claim.
/// </returns>
object OnRidableAnimalClaim(BaseRidableAnimal animal, BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} is attempting to claim a {animal.ShortPrefabName} using item: {item.info.displayName.english}.");

    if (item.info.itemid == 12345) // Example token ID
    {
        Puts($"Player {player.displayName} successfully claimed the {animal.ShortPrefabName}.");
        return null; // Allow the claim
    }

    Puts($"Player {player.displayName} failed to claim the {animal.ShortPrefabName} due to invalid token.");
    return "Invalid token used for claiming.";
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsForSale())
		{
			int tokenItemID = msg.read.Int32();
			Item item = GetPurchaseToken(player, tokenItemID);
			if (item != null && Interface.CallHook("OnRidableAnimalClaim", this, player, item) == null)
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(item);
				item.UseItem();
				Facepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);
				Facepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## OnWallpaperSet(BuildingBlock,ulong,int)

```csharp
```csharp
/// <summary>
/// Called when a wallpaper is set on a building block.
/// </summary>
/// <param name="buildingBlock">The building block on which the wallpaper is being set.</param>
/// <param name="wallpaperId">The ID of the wallpaper being applied.</param>
/// <param name="side">The side of the building block where the wallpaper is applied (0 for front, 1 for back).</param>
/// <returns>No return behavior.</returns>
void OnWallpaperSet(BuildingBlock buildingBlock, ulong wallpaperId, int side)
{
    Puts($"Wallpaper with ID {wallpaperId} set on {buildingBlock.name} at side {side}.");
    
    if (side == 0)
    {
        Puts($"Front wallpaper set to ID {wallpaperId}.");
    }
    else
    {
        Puts($"Back wallpaper set to ID {wallpaperId}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetWallpaper(ulong id, int side = 0)
	{
		if (Interface.CallHook("OnWallpaperSet", this, id, side) != null)
		{
			return;
		}
		if (side == 0)
		{
			if (HasWallpaper(side) && wallpaperID == id)
			{
				return;
			}
			wallpaperID = id;
			wallpaperHealth = 100f;
		}
		else
		{
			if (HasWallpaper(side) && wallpaperID2 == id)
			{
				return;
			}
			wallpaperID2 = id;
			wallpaperHealth2 = 100f;
		}
		if (base.isServer)
		{
			SetConditionalModel(currentSkin.DetermineConditionalModelState(this));
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
		}
	}

```

## CanLock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Determines whether a player can lock the specified key lock.
/// </summary>
/// <param name="player">The player attempting to lock the key lock.</param>
/// <param name="keyLock">The key lock that the player is trying to lock.</param>
/// <returns>
/// Returns `null` to allow the locking action, or any non-null value to prevent the player from locking the key lock.
/// </returns>
object CanLock(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to lock the key lock.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can lock anything.");
        return null;
    }

    if (keyLock.IsLocked())
    {
        Puts($"Key lock is already locked. Player {player.displayName} cannot lock it.");
        return "The lock is already engaged.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void Lock(BasePlayer player)
	{
		if (!(player == null) && player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", player, this) == null && HasLockPermission(player))
		{
			LockLock(player);
			SendNetworkUpdate();
		}
	}

```

## OnNpcDuck(HumanNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC is instructed to duck or stand up.
/// </summary>
/// <param name="npc">The NPC that is ducking or standing up.</param>
/// <returns>No return behavior.</returns>
void OnNpcDuck(HumanNPC npc)
{
    Puts($"NPC {npc.displayName} is now ducking.");
}
```
```

### Source Code from the Library

```csharp

	public void SetDucked(bool flag)
	{
		if (Interface.CallHook("OnNpcDuck", this) == null)
		{
			modelState.ducked = flag;
			SendNetworkUpdate();
		}
	}

```

## OnElevatorButtonPress(ElevatorLift,BasePlayer,Elevator.Direction,bool)

```csharp
```csharp
/// <summary>
/// Called when a player presses the button on the elevator to raise or lower the floor.
/// </summary>
/// <param name="elevator">The elevator that is being controlled.</param>
/// <param name="player">The player who pressed the button.</param>
/// <param name="direction">The direction in which the elevator is to move.</param>
/// <param name="isEmergency">Indicates if the button press is for an emergency stop.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or a non-null value to override it.
/// </returns>
object OnElevatorButtonPress(ElevatorLift elevator, BasePlayer player, Elevator.Direction direction, bool isEmergency)
{
    Puts($"Player {player.displayName} pressed the elevator button. Direction: {direction}, Emergency: {isEmergency}");

    if (isEmergency)
    {
        Puts("Emergency stop activated!");
        return "Elevator stopped for emergency.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Server_RaiseLowerFloor(RPCMessage msg)
	{
		Elevator.Direction direction = (Elevator.Direction)msg.read.Int32();
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnElevatorButtonPress", this, msg.player, direction, flag) == null)
		{
			SetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);
			owner.Server_RaiseLowerElevator(direction, flag);
			Invoke(ClearDirection, 0.7f);
			if (liftButtonPressedEffect.isValid)
			{
				Effect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an object triggers the trap, such as a landmine.
/// </summary>
/// <param name="trap">The landmine that was triggered.</param>
/// <param name="triggeredObject">The game object that triggered the trap.</param>
/// <returns>No return behavior.</returns>
void OnTrapTrigger(Landmine trap, UnityEngine.GameObject triggeredObject)
{
    Puts($"Trap triggered by object: {triggeredObject.name}. Trap ID: {trap.net.ID}");
    
    BasePlayer player = GameObjectEx.ToBaseEntity(triggeredObject) as BasePlayer;
    if (player != null)
    {
        Puts($"Player {player.displayName} has triggered the trap!");
    }
    else
    {
        Puts($"Non-player object {triggeredObject.name} has triggered the trap.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## OnRidableAnimalClaimed(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a ridable animal is claimed by a player.
/// </summary>
/// <param name="animal">The ridable animal that is being claimed.</param>
/// <param name="player">The player who is claiming the animal.</param>
/// <returns>No return behavior.</returns>
void OnRidableAnimalClaimed(BaseRidableAnimal animal, BasePlayer player)
{
    Puts($"Player {player.displayName} has claimed the ridable animal: {animal.ShortPrefabName}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has claimed the animal, granting special privileges.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsForSale())
		{
			int tokenItemID = msg.read.Int32();
			Item item = GetPurchaseToken(player, tokenItemID);
			if (item != null && Interface.CallHook("OnRidableAnimalClaim", this, player, item) == null)
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(item);
				item.UseItem();
				Facepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);
				Facepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## OnTeamKick(RelationshipManager.PlayerTeam,BasePlayer,ulong)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from a team.
/// </summary>
/// <param name="team">The team from which the player is being kicked.</param>
/// <param name="player">The player who is being kicked.</param>
/// <param name="playerId">The user ID of the player being kicked.</param>
/// <returns>No return behavior.</returns>
void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong playerId)
{
    Puts($"Player {player.displayName} (ID: {player.userID}) has been kicked from team {team.TeamName} (ID: {team.TeamID}).");
    
    if (playerId == 1234567890) // Example check for a specific player ID
    {
        Puts("Attempt to kick a special player was blocked.");
    }
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void kickmember(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer == null)
		{
			return;
		}
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam != null && !(playerTeam.GetLeader() != basePlayer))
		{
			ulong uLong = arg.GetULong(0, 0uL);
			if ((ulong)basePlayer.userID != uLong && Interface.CallHook("OnTeamKick", playerTeam, basePlayer, uLong) == null)
			{
				playerTeam.RemovePlayer(uLong);
			}
		}
	}

```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
```csharp
/// <summary>
/// Determines whether a player can be targeted by a flame turret.
/// </summary>
/// <param name="player">The player being checked for targeting.</param>
/// <param name="turret">The flame turret attempting to target the player.</param>
/// <returns>
/// Returns `true` if the player can be targeted by the turret; otherwise, returns `false`.
/// If the method returns `null`, the default targeting logic will be applied.
/// </returns>
bool? CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts($"Checking if player {player.displayName} (ID: {player.UserIDString}) can be targeted by turret {turret.net.ID}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot be targeted.");
        return false;
    }

    if (player.HasActiveBuff("invisibility"))
    {
        Puts($"Player {player.displayName} is invisible and cannot be targeted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> obj = Pool.Get<List<RaycastHit>>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = item.GetComponent<BasePlayer>();
				if (component.IsSleeping() || !component.IsAlive())
				{
					continue;
				}
				object obj2 = Interface.CallHook("CanBeTargeted", component, this);
				if (obj2 is bool)
				{
					Pool.FreeUnmanaged(ref obj);
					return (bool)obj2;
				}
				if (!(component.transform.position.y <= GetEyePosition().y + 0.5f) || component.IsBuildingAuthed())
				{
					continue;
				}
				obj.Clear();
				GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
				for (int i = 0; i < obj.Count; i++)
				{
					BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
					if (entity != null && (entity == this || entity.EqualNetID(this)))
					{
						flag = true;
						break;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeUnmanaged(ref obj);
		return flag;
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player stops spectating.
/// </summary>
/// <param name="player">The player who is ending their spectating session.</param>
/// <param name="filter">The filter used for the spectating session, which could be a player name or other identifier.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player.displayName} has stopped spectating with filter: {filter}");
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## CanUseVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use the vending machine.
/// </summary>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <param name="vendingMachine">The vending machine being accessed.</param>
/// <returns>
/// Returns `true` if the player can use the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine access.
/// </returns>
bool? CanUseVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use the vending machine.");

    if (player.IsBannedFromVending())
    {
        Puts($"Player {player.displayName} is banned from using vending machines.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		object obj = Interface.CallHook("CanUseVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

```

## OnServerInitialize()

```csharp
```csharp
/// <summary>
/// Called when the server is initialized, setting up necessary components and loading the world state.
/// </summary>
/// <returns>
/// Returns <c>true</c> if the server was loaded from a save file, and <c>false</c> otherwise.
/// </returns>
bool OnServerInitialize()
{
    Puts("Server is initializing...");

    // Additional initialization logic can be added here

    return true; // Indicating successful initialization
}
```
```

### Source Code from the Library

```csharp

	public bool Initialize(bool loadSave = true, string saveFile = "", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)
	{
		Interface.CallHook("OnServerInitialize");
		persistance = new UserPersistance(ConVar.Server.rootFolder);
		playerStateManager = new PlayerStateManager(persistance);
		TutorialIsland.GenerateIslandSpawnPoints(loadingSave: true);
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			using (TimeWarning.New("SpawnHandler.UpdateDistributions"))
			{
				SingletonComponent<SpawnHandler>.Instance.UpdateDistributions();
			}
		}
		if (loadSave)
		{
			World.LoadedFromSave = true;
			World.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));
		}
		else
		{
			SaveRestore.SaveCreatedTime = DateTime.UtcNow;
			World.LoadedFromSave = false;
		}
		if (!World.LoadedFromSave)
		{
			SaveRestore.SpawnMapEntities(SaveRestore.FindMapEntities());
		}
		SaveRestore.InitializeWipeId();
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			if (!skipInitialSpawn)
			{
				using (TimeWarning.New("SpawnHandler.InitialSpawn", 200))
				{
					SingletonComponent<SpawnHandler>.Instance.InitialSpawn();
				}
			}
			using (TimeWarning.New("SpawnHandler.StartSpawnTick", 200))
			{
				SingletonComponent<SpawnHandler>.Instance.StartSpawnTick();
			}
		}
		CreateImportantEntities();
		auth = GetComponent<ConnectionAuth>();
		Facepunch.Rust.Analytics.Azure.Initialize();
		return World.LoadedFromSave;
	}

```

## IOnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved to the stream.
/// </summary>
/// <param name="entity">The entity that is being saved.</param>
/// <param name="saveInfo">Information related to the save operation.</param>
/// <returns>No return behavior.</returns>
void IOnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity?.ToString()} is being saved with SaveInfo: {saveInfo?.ToString()}.");
    
    if (entity == null)
    {
        Puts("Warning: Attempted to save a null entity.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ToStream(Stream stream, SaveInfo saveInfo)
	{
		using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError(this?.ToString() + ": ToStream - no BaseEntity!?");
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError(this?.ToString() + ": ToStream - no baseNetworkable!?");
			}
			Interface.CallHook("IOnEntitySaved", this, saveInfo);
			saveInfo.msg.ToProto(stream);
			PostSave(saveInfo);
		}
	}

```

## OnTeamDisbanded(RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team has been disbanded.
/// </summary>
/// <param name="team">The team that has been disbanded.</param>
/// <returns>No return behavior.</returns>
void OnTeamDisbanded(RelationshipManager.PlayerTeam team)
{
    Puts($"Team with ID {team.teamID} has been disbanded. Members: {string.Join(", ", team.members)}");
    
    foreach (var member in team.members)
    {
        Puts($"Notifying member {member.displayName} of team disbandment.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Facepunch.Pool.Free(ref teamToDisband);
		}
	}

```

## OnHorseUnhitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is unhitched from a hitching spot.
/// </summary>
/// <param name="horse">The horse that is being unhitched.</param>
/// <param name="hitchSpot">The hitching spot from which the horse is being unhitched.</param>
/// <returns>No return behavior.</returns>
void OnHorseUnhitch(RidableHorse horse, HitchSpot hitchSpot)
{
    Puts($"Horse {horse.name} has been unhitched from {hitchSpot.name}.");
    
    if (horse.IsTired())
    {
        Puts($"Warning: Horse {horse.name} is tired after unhitching.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Unhitch(RidableHorse horse)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHorse(base.isServer) == horse)
			{
				if (Interface.CallHook("OnHorseUnhitch", horse, hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				horse.SetHitch(null);
			}
		}
	}

```

## OnMissionAssigned(BaseMission,IMissionProvider,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is assigned to a player.
/// </summary>
/// <param name="mission">The mission being assigned.</param>
/// <param name="provider">The provider of the mission.</param>
/// <param name="assignee">The player to whom the mission is assigned.</param>
/// <returns>No return behavior.</returns>
void OnMissionAssigned(BaseMission mission, IMissionProvider provider, BasePlayer assignee)
{
    Puts($"Mission {mission.id} has been assigned to player {assignee.displayName} (ID: {assignee.UserIDString}) by provider {provider.ProviderID()}.");

    if (mission.id == "special_mission")
    {
        Puts($"Player {assignee.displayName} has been assigned a special mission!");
    }
}
```
```

### Source Code from the Library

```csharp

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", assignee, mission, provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = assignee.missions.FindIndexWith((MissionInstance i) => i.missionID, mission.id);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", mission, provider, assignee);
		return true;
	}

```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to refresh the stock level of items available for sale in a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine whose stock is being refreshed.</param>
/// <param name="itemDef">The item definition to refresh stock for. If null, refreshes all items.</param>
/// <returns>No return behavior.</returns>
void OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDef)
{
    Puts($"Refreshing stock for Vending Machine ID: {vendingMachine.net.ID}, Item: {itemDef?.shortname ?? "All Items"}");

    if (itemDef != null && itemDef.itemid == 12345) // Example item ID check
    {
        Puts($"Item {itemDef.shortname} is not available for sale in this vending machine.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		int num = 0;
		foreach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (!(itemDef == null) && itemDef.itemid != sellOrder.itemToSellID)
			{
				continue;
			}
			List<Item> obj = Facepunch.Pool.Get<List<Item>>();
			GetItemsToSell(sellOrder, obj);
			int inStock;
			if (obj.Count < 0)
			{
				inStock = 0;
			}
			else
			{
				List<Item> source = obj;
				Func<Item, int> selector = (Item x) => x.amount;
				Interface.CallHook("OnRefreshVendingStock", this, itemDef);
				inStock = source.Sum(selector) / sellOrder.itemToSellAmount;
			}
			sellOrder.inStock = inStock;
			float itemCondition = 0f;
			float itemConditionMax = 0f;
			int instanceData = 0;
			List<int> list = Facepunch.Pool.Get<List<int>>();
			int totalAttachmentSlots = 0;
			int ammoType = 0;
			int ammoCount = 0;
			if (obj.Count > 0)
			{
				if (obj[0].hasCondition)
				{
					itemCondition = obj[0].condition;
					itemConditionMax = obj[0].maxCondition;
				}
				if (obj[0].info != null && obj[0].info.amountType == ItemDefinition.AmountType.Genetics && obj[0].instanceData != null)
				{
					instanceData = obj[0].instanceData.dataInt;
					sellOrder.inStock = obj[0].amount;
				}
				if (obj[0].contents != null && obj[0].contents.capacity > 0 && obj[0].contents.HasFlag(ItemContainer.Flag.ShowSlotsOnIcon))
				{
					foreach (Item item in obj[0].contents.itemList)
					{
						list.Add(item.info.itemid);
					}
					totalAttachmentSlots = obj[0].contents.capacity;
				}
				if (obj[0].ammoCount.HasValue)
				{
					ammoCount = obj[0].ammoCount.Value;
					BaseEntity heldEntity = obj[0].GetHeldEntity();
					if ((bool)heldEntity)
					{
						BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
						if ((bool)component)
						{
							ammoType = component.primaryMagazine.ammoType.itemid;
						}
					}
				}
			}
			sellOrder.ammoType = ammoType;
			sellOrder.ammoCount = ammoCount;
			sellOrder.itemCondition = itemCondition;
			sellOrder.itemConditionMax = itemConditionMax;
			sellOrder.instanceData = instanceData;
			if (sellOrder.attachmentsList != null)
			{
				Facepunch.Pool.FreeUnmanaged(ref sellOrder.attachmentsList);
			}
			sellOrder.attachmentsList = list;
			sellOrder.totalAttachmentSlots = totalAttachmentSlots;
			sellOrder.priceMultiplier = GetDiscountForSlot(num, sellOrder);
			num++;
			Facepunch.Pool.Free(ref obj, freeElements: false);
		}
	}

```

## OnTreeMarkerHit(TreeEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a tree marker is hit by a player or object.
/// </summary>
/// <param name="tree">The tree entity that was hit.</param>
/// <param name="hitInfo">Information about the hit event, including position and normal.</param>
/// <returns>
/// Returns `true` if the hit was registered on the tree marker; otherwise, returns `false`.
/// If the method returns `null`, the default hit logic will be applied.
/// </returns>
bool? OnTreeMarkerHit(TreeEntity tree, HitInfo hitInfo)
{
    Puts($"Tree marker hit detected on tree ID: {tree.net.ID} at position: {hitInfo.HitPositionWorld}.");

    if (hitInfo.HitPositionWorld.y < 0)
    {
        Puts("Hit position is below ground level, ignoring hit.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool DidHitMarker(HitInfo info)
	{
		if (xMarker == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnTreeMarkerHit", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PrefabAttribute.server.Find<TreeMarkerData>(prefabID) != null)
		{
			if (new Bounds(xMarker.transform.position, Vector3.one * 0.2f).Contains(info.HitPositionWorld))
			{
				return true;
			}
		}
		else
		{
			Vector3 lhs = Vector3Ex.Direction2D(base.transform.position, xMarker.transform.position);
			Vector3 attackNormal = info.attackNormal;
			float num = Vector3.Dot(lhs, attackNormal);
			float num2 = Vector3.Distance(xMarker.transform.position, info.HitPositionWorld);
			if (num >= 0.3f && num2 <= 0.2f)
			{
				return true;
			}
		}
		return false;
	}

```

## OnShopAcceptClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player clicks to accept a trade in the shop interface.
/// </summary>
/// <param name="shop">The shop front where the trade is taking place.</param>
/// <param name="player">The player who clicked to accept the trade.</param>
/// <returns>
/// Returns `null` to allow the trade to proceed, or any non-null value to prevent the trade from being accepted.
/// </returns>
object OnShopAcceptClick(ShopFront shop, BasePlayer player)
{
    Puts($"Player {player.displayName} has accepted the trade at shop {shop.name}.");

    if (player.inventory.GetAmount("currency") < 100)
    {
        Puts($"Player {player.displayName} does not have enough currency to complete the trade.");
        return "Not enough currency to complete the trade.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !(vendorPlayer == null) && !(customerPlayer == null) && Interface.CallHook("OnShopAcceptClick", this, msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				Invoke(CompleteTrade, 2f);
			}
		}
	}

```

## OnEngineLoadoutRefresh(Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called to refresh the loadout data for the engine storage.
/// </summary>
/// <param name="engineStorage">The engine storage whose loadout data is being refreshed.</param>
/// <returns>No return behavior.</returns>
void OnEngineLoadoutRefresh(Rust.Modular.EngineStorage engineStorage)
{
    Puts($"Refreshing loadout data for engine storage ID: {engineStorage.net.ID}");
}
```
```

### Source Code from the Library

```csharp

	public void RefreshLoadoutData()
	{
		if (Interface.CallHook("OnEngineLoadoutRefresh", this) == null)
		{
			isUsable = base.inventory.IsFull() && base.inventory.itemList.All((Item item) => !item.isBroken);
			accelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;
			topSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;
			fuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;
			SendNetworkUpdate();
			GetEngineModule()?.RefreshPerformanceStats(this);
		}
	}

```

## OnItemRecycle(Item,Recycler)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled in the recycler.
/// </summary>
/// <param name="item">The item being recycled.</param>
/// <param name="recycler">The recycler that is processing the item.</param>
/// <returns>
/// Returns a non-null value to prevent the item from being recycled, or `null` to allow the recycling process to continue.
/// </returns>
object OnItemRecycle(Item item, Recycler recycler)
{
    Puts($"Item {item.info.displayName.english} (Shortname: {item.info.shortname}) is being recycled in {recycler.gameObject.name}.");

    if (item.info.shortname == "explosive.timed")
    {
        Puts("Recycling of timed explosives is not allowed.");
        return true; // Prevent recycling
    }

    return null; // Allow recycling
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", slot, this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", slot, num3, this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					float num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 *= slot.conditionNormalized;
					}
					float num5 = num / 0.5f;
					num4 *= num5;
					int num6 = Mathf.FloorToInt(num4);
					float num7 = num4 - (float)num6;
					scrapRemainder += num7;
					if (scrapRemainder >= 1f)
					{
						int num8 = Mathf.FloorToInt(scrapRemainder);
						scrapRemainder -= num8;
						num6 += num8;
					}
					if (num6 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num6, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj2 = Facepunch.Pool.Get<List<BasePlayer>>();
					Vis.Entities(base.transform.position, 3f, obj2, 131072);
					foreach (BasePlayer item3 in obj2)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Facepunch.Pool.FreeUnmanaged(ref obj2);
				}
				Facepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;
					int num10 = Mathf.FloorToInt(num9);
					float num11 = num9 - (float)num10;
					if (num11 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num11)
					{
						num10++;
					}
					if (num10 <= 0)
					{
						continue;
					}
					int num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);
					for (int i = 0; i < num12; i++)
					{
						int num13 = ((num10 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);
						Item item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
						if (!MoveItemToOutput(item2))
						{
							flag = true;
						}
						num10 -= num13;
						if (num10 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int,bool)

```csharp
```csharp
/// <summary>
/// Determines if the item crafter can craft a specified item blueprint.
/// </summary>
/// <param name="crafter">The item crafter attempting to craft the item.</param>
/// <param name="blueprint">The item blueprint to craft.</param>
/// <param name="amount">The amount of items to craft.</param>
/// <param name="free">Indicates if crafting should be free of resource checks.</param>
/// <returns>
/// Returns `true` if the crafter can craft the item, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if crafting is allowed.
/// </returns>
bool? CanCraft(ItemCrafter crafter, ItemBlueprint blueprint, int amount = 1, bool free = false)
{
    Puts($"Crafter {crafter?.gameObject.name} is attempting to craft {amount} of {blueprint.targetItem.shortname}.");

    if (amount > 5)
    {
        Puts("Crafting amount exceeds the limit of 5.");
        return false;
    }

    if (free)
    {
        Puts("Crafting is free, allowing crafting without checks.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)
	{
		if (base.baseEntity != null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if (restraintItem != null && restraintItem.BlockCrafting)
			{
				return false;
			}
		}
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount, free);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
			if (ingredient.itemDef.condition.enabled && !DoesHaveOKConditionItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="keyLock">The key lock associated with the entity.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can use the entity.
/// </returns>
bool? CanUseLockedEntity(BasePlayer player, KeyLock keyLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to use a locked entity with KeyLock ID: {keyLock.net.ID}.");

    if (keyLock.IsLocked())
    {
        Puts($"Entity is currently locked. Player {player.displayName} cannot access it.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## OnElevatorCall(Elevator,Elevator)

```csharp
```csharp
/// <summary>
/// Called when an elevator is requested to move to a specific floor.
/// </summary>
/// <param name="caller">The entity that is calling the elevator.</param>
/// <param name="elevator">The elevator that is being called.</param>
/// <returns>No return behavior.</returns>
void OnElevatorCall(Elevator caller, Elevator elevator)
{
    Puts($"Elevator called by {caller?.gameObject.name} to move to floor {caller.Floor}.");
    
    if (elevator.IsTop)
    {
        Puts($"Elevator {elevator.gameObject.name} is at the top and ready to move.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void CallElevator()
	{
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.IsTop && Interface.CallHook("OnElevatorCall", this, elevatorEnt) == null)
			{
				elevatorEnt.RequestMoveLiftTo(Floor, out var _, this);
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

```

## OnBookmarkControlEnd(ComputerStation,BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player stops controlling a bookmark on a computer station.
/// </summary>
/// <param name="station">The computer station being controlled.</param>
/// <param name="player">The player who is stopping control.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnd(ComputerStation station, BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player.displayName} has stopped controlling the entity: {entity?.name ?? "Unknown Entity"} on station: {station?.name ?? "Unknown Station"}.");
    
    if (entity != null)
    {
        Puts($"Entity {entity.name} control has ended.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if ((bool)ply)
		{
			ply.net.SwitchSecondaryGroup(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
		CancelInvoke(CheckCCTVAchievement);
		Interface.CallHook("OnBookmarkControlEnded", this, ply, baseEntity);
	}

```

## CanHideStash(BasePlayer,StashContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hide a stash container.
/// </summary>
/// <param name="player">The player attempting to hide the stash.</param>
/// <param name="stash">The stash container being hidden.</param>
/// <returns>
/// Returns `null` to allow the stash to be hidden, or any non-null value to prevent it from being hidden.
/// </returns>
object CanHideStash(BasePlayer player, StashContainer stash)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to hide a stash.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot hide a stash while in a safe zone.");
        return "You cannot hide a stash in a safe zone.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", rpc.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", this, rpc.player);
		}
	}

```

## OnPlayerDismountFailed(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player fails to dismount from a mountable entity.
/// </summary>
/// <param name="player">The player attempting to dismount.</param>
/// <param name="mountable">The mountable entity the player is trying to dismount from.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDismountFailed(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) failed to dismount from {mountable.gameObject.name}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", player, this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", player, this) == null && (!(player != null) || !player.IsRestrained))
		{
			AttemptDismount(player);
		}
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player picks up an item.
/// </summary>
/// <param name="item">The item that is being picked up.</param>
/// <param name="player">The player who is picking up the item.</param>
/// <returns>No return behavior.</returns>
void OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) picked up item: {item.info.displayName.english}.");
    
    if (item.info.shortname == "wood")
    {
        Puts($"Player {player.displayName} has picked up wood, which is a common resource.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && this.item != null && allowPickup && Interface.CallHook("OnItemPickup", this.item, msg.player) == null && CanOpenInSafeZone(msg.player))
		{
			ClientRPC(RpcTarget.NetworkGroup("PickupSound"));
			Item item = this.item;
			Facepunch.Rust.Analytics.Azure.OnItemPickup(msg.player, this);
			RemoveItem();
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is deauthorized from an auto turret.
/// </summary>
/// <param name="turret">The auto turret from which the player is being deauthorized.</param>
/// <param name="player">The player being deauthorized.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has been deauthorized from turret {turret.net.ID}.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			authDirty = true;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnItemDespawn(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is about to despawn from the world.
/// </summary>
/// <param name="item">The item that is being despawned.</param>
/// <returns>No return behavior.</returns>
void OnItemDespawn(Item item)
{
    Puts($"Item {item.info.displayName.english} (ID: {item.net.ID}) is about to despawn.");
    
    if (item.info.shortname == "wood")
    {
        Puts("Warning: A wood item is being despawned!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void IdleDestroy()
	{
		Interface.CallHook("OnItemDespawn", item);
		Facepunch.Rust.Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);
		DestroyItem();
		Kill();
	}

```

## OnNpcTarget(HumanNPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC can target a specific player entity.
/// </summary>
/// <param name="npc">The NPC attempting to target the player.</param>
/// <param name="target">The player entity being considered as a target.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the player, or any non-null value to prevent targeting.
/// </returns>
object OnNpcTarget(HumanNPC npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is evaluating target: {target.displayName} (ID: {target.net.ID})");

    if (target.IsSleeping())
    {
        Puts($"NPC {npc.displayName} cannot target a sleeping player: {target.displayName}.");
        return true; // Prevent targeting
    }

    return null; // Allow targeting
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity GetBestTarget()
	{
		BaseEntity result = null;
		float num = -1f;
		foreach (BaseEntity player in Brain.Senses.Players)
		{
			if (!(player == null) && !(player.Health() <= 0f) && Interface.CallHook("OnNpcTarget", this, player) == null)
			{
				float value = Vector3.Distance(player.transform.position, base.transform.position);
				float num2 = 1f - Mathf.InverseLerp(1f, Brain.SenseRange, value);
				float value2 = Vector3.Dot((player.transform.position - base.eyes.position).normalized, base.eyes.BodyForward());
				num2 += Mathf.InverseLerp(Brain.VisionCone, 1f, value2) / 2f;
				num2 += (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);
				if (num2 > num)
				{
					result = player;
					num = num2;
				}
			}
		}
		return result;
	}

```

## OnSprayCreate(SprayCan,UnityEngine.Vector3,UnityEngine.Quaternion)

```csharp
```csharp
/// <summary>
/// Called when a spray is created in the game world.
/// </summary>
/// <param name="sprayCan">The spray can used to create the spray.</param>
/// <param name="position">The position where the spray is created.</param>
/// <param name="rotation">The rotation of the spray when created.</param>
/// <returns>Returns `null` to allow the spray creation, or any non-null value to prevent it.</returns>
object OnSprayCreate(SprayCan sprayCan, Vector3 position, Quaternion rotation)
{
    Puts($"Spray created at position: {position} with rotation: {rotation} using spray can: {sprayCan.itemID}.");
    
    // Example condition to prevent spray creation
    if (position.y < 0)
    {
        Puts("Spray creation failed: Invalid position.");
        return "Cannot spray below ground level.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void CreateSpray(RPCMessage msg)
	{
		if (IsBusy())
		{
			return;
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3();
		Vector3 point = msg.read.Vector3();
		int num = msg.read.Int32();
		if (!(Vector3.Distance(vector, base.transform.position) > 4.5f))
		{
			Quaternion quaternion = Quaternion.LookRotation((new Plane(vector2, vector).ClosestPointOnPlane(point) - vector).normalized, vector2);
			quaternion *= Quaternion.Euler(0f, 0f, 90f);
			bool flag = false;
			if (msg.player.IsDeveloper)
			{
				flag = true;
			}
			if (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))
			{
				Debug.Log($"SprayCan.ChangeItemSkin player does not have item :{num}:");
			}
			else if (Interface.CallHook("OnSprayCreate", this, vector, quaternion) == null)
			{
				ulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);
				BaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, vector, quaternion);
				baseEntity.skinID = num2;
				baseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());
				baseEntity.Spawn();
				CheckAchievementPosition(vector);
				LoseCondition(ConditionLossPerSpray);
			}
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="sign">The sign being updated.</param>
/// <returns>
/// Returns `true` if the player can update the sign; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can update the sign.
/// </returns>
bool? CanUpdateSign(BasePlayer player, Signage sign)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to update a sign.");

    if (sign.IsLocked())
    {
        Puts($"Sign is locked. Only the owner can update it.");
        return (ulong)player.userID == sign.OwnerID;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return true;
	}

```

## OnPlayerRespawn(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called when a player respawns at a sleeping bag.
/// </summary>
/// <param name="player">The player who is respawning.</param>
/// <param name="sleepingBag">The sleeping bag the player is respawning from.</param>
/// <returns>
/// Returns a <c>SleepingBag</c> object if the respawn is successful, or <c>null</c> if the respawn fails.
/// </returns>
object OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag)
{
    Puts($"Player {player.displayName} is attempting to respawn at sleeping bag ID: {sleepingBag.net.ID}.");

    if (!sleepingBag.IsValidForPlayer(player.userID))
    {
        Puts($"Player {player.displayName} cannot respawn at this sleeping bag.");
        return null;
    }

    Puts($"Player {player.displayName} has successfully respawned at sleeping bag ID: {sleepingBag.net.ID}.");
    return sleepingBag;
}
```
```

### Source Code from the Library

```csharp

	public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)
	{
		BasePlayer player2 = player;
		SleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);
		SleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) => x.ValidForPlayer(player2.userID, ignoreTimers: false) && x.net.ID == sleepingBag && x.unlockTime < UnityEngine.Time.realtimeSinceStartup);
		if (sleepingBag2 == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", player, sleepingBag2);
		if (obj is SleepingBag)
		{
			sleepingBag2 = (SleepingBag)obj;
		}
		if (sleepingBag2.GetRespawnState(player2.userID) != RespawnInformation.SpawnOptions.RespawnState.OK)
		{
			return false;
		}
		sleepingBag2.GetSpawnPos(out var pos, out var rot);
		player2.RespawnAt(pos, rot, sleepingBag2);
		sleepingBag2.PostPlayerSpawn(player2);
		SleepingBag[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			SetBagTimer(array2[i], pos, SleepingBagResetReason.Respawned, player2);
		}
		return true;
	}

```

## CanUnlockTechTreeNodePath(BasePlayer,TechTreeData.NodeInstance,TechTreeData)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a specific path in the tech tree.
/// </summary>
/// <param name="player">The player attempting to unlock the tech tree node path.</param>
/// <param name="node">The tech tree node instance that the player wants to unlock.</param>
/// <param name="techTree">The tech tree data containing the nodes and paths.</param>
/// <returns>
/// Returns `true` if the player can unlock the specified tech tree node path; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can unlock the path.
/// </returns>
bool? CanUnlockTechTreeNodePath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to unlock node: {node.nodeName}.");

    if (node.nodeName == "advancedCrafting")
    {
        Puts($"Player {player.displayName} does not have permission to unlock advanced crafting.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNodePath", player, node, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		NodeInstance entryNode = GetEntryNode();
		if (entryNode == null)
		{
			return false;
		}
		return CheckChainRecursive(player, entryNode, node);
	}

```

## OnRackedWeaponSwapped(Item,WeaponRackSlot,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is swapped on a weapon rack.
/// </summary>
/// <param name="item">The item being swapped (the weapon).</param>
/// <param name="slot">The slot on the weapon rack where the weapon is being placed.</param>
/// <param name="player">The player performing the swap.</param>
/// <param name="rack">The weapon rack involved in the swap.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponSwapped(Item item, WeaponRackSlot slot, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player.displayName} swapped weapon {item.info.displayName.english} into slot {slot.index} on rack {rack.net.ID}.");
    
    if (item.info.shortname == "rifle.semiauto")
    {
        Puts("A semi-auto rifle has been swapped! Ensure safety protocols are followed.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", item, weaponAtIndex, player, this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", item, weaponAtIndex, player, this);
			}
		}
	}

```

## OnEntityReskinned(BaseEntity,ItemSkinDirectory.Skin,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is reskinned.
/// </summary>
/// <param name="entity">The entity that has been reskinned.</param>
/// <param name="skin">The new skin applied to the entity.</param>
/// <param name="player">The player who initiated the reskin action.</param>
/// <returns>No return behavior.</returns>
void OnEntityReskinned(BaseEntity entity, ItemSkinDirectory.Skin skin, BasePlayer player)
{
    Puts($"Entity {entity.net.ID} has been reskinned to skin ID: {skin.id} by player {player.displayName}.");
    
    if (skin.id == 12345) // Example skin ID check
    {
        Puts($"Player {player.displayName} applied a special skin!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	private void ChangeItemSkin(RPCMessage msg)
	{
		NetworkableId uid = msg.read.EntityID();
		int targetSkin = msg.read.Int32();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		if (!ValidateEntityAndSkin(msg.player, baseNetworkable, targetSkin))
		{
			return;
		}
		if (baseNetworkable != null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if ((object)baseEntity2 != null)
			{
				if (!GetItemDefinitionForEntity(baseEntity2, out var def, useRedirect: false))
				{
					FailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin((def.isRedirectOf != null) ? def.isRedirectOf.itemid : def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", baseEntity2, skin, msg.player) != null)
				{
					return;
				}
				if (skin.invItem != null && skin.invItem is ItemSkin itemSkin)
				{
					if (itemSkin.Redirect != null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if ((bool)def && def.isRedirectOf != null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if (def.isRedirectOf != null || ((bool)def && def.isRedirectOf != null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if (itemDefinition == null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2))
					{
						FailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning("Cannot find resource path of redirect entity to spawn! " + itemDefinition.gameObject.name);
						FailResponse(SprayFailReason.InvalidItem);
						return;
					}
					Vector3 localPosition = baseEntity2.transform.localPosition;
					Quaternion localRotation = baseEntity2.transform.localRotation;
					BaseEntity baseEntity3 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					HashSet<PlayerNameID> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> obj = Facepunch.Pool.Get<List<ChildPreserveInfo>>();
					if (flag)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							obj.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = child.transform.localPosition,
								LocalRotation = child.transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in obj)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity3);
					baseEntity2.transform.localPosition = localPosition;
					baseEntity2.transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity)
					{
						decayEntity.AttachToBuilding(null);
					}
					baseEntity2.Spawn();
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag)
						{
							for (int j = 0; j < baseEntity2.children.Count; j++)
							{
								RestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item2 in dictionary2)
						{
							foreach (Item item3 in item2.Value)
							{
								Debug.Log($"Deleting {item3} as it has no new container");
								item3.Remove();
							}
						}
						Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
					}
					if (flag)
					{
						foreach (ChildPreserveInfo item4 in obj)
						{
							item4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);
							item4.TargetEntity.transform.localPosition = item4.LocalPosition;
							item4.TargetEntity.transform.localRotation = item4.LocalRotation;
							item4.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Interface.CallHook("OnEntityReskinned", baseEntity2, skin, msg.player);
					Facepunch.Pool.FreeUnmanaged(ref obj);
				}
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		LoseCondition(ConditionLossPerReskin);
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		void FailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (copy.ContainsKey(key))
				{
					foreach (Item item5 in copy[key])
					{
						item5.MoveToContainer(itemContainerEntity.inventory);
					}
					copy.Remove(key);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (!dictionary.ContainsKey(key2))
				{
					dictionary.Add(key2, new List<Item>());
					foreach (Item item6 in itemContainerEntity2.inventory.itemList)
					{
						dictionary[key2].Add(item6);
					}
					{
						foreach (Item item7 in dictionary[key2])
						{
							item7.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log("Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
	}

```

## OnPlayerDig(BasePlayer,BaseDiggableEntity)

```csharp
```csharp
/// <summary>
/// Called when a player digs at a diggable entity.
/// </summary>
/// <param name="player">The player performing the digging action.</param>
/// <param name="diggableEntity">The diggable entity being interacted with.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDig(BasePlayer player, BaseDiggableEntity diggableEntity)
{
    Puts($"Player {player.displayName} is digging at {diggableEntity.name}.");
    
    if (diggableEntity.health <= 0)
    {
        Puts($"The entity {diggableEntity.name} has already been fully dug.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Dig(BasePlayer player)
	{
		if (Interface.CallHook("OnPlayerDig", player, this) != null)
		{
			return;
		}
		if (digsRemaining == RequiredDigCount)
		{
			OnFirstDig(player);
		}
		ClientRPC(RpcTarget.NetworkGroup("RPC_OnDig"), RequiredDigCount - digsRemaining, RequiredDigCount);
		digsRemaining--;
		base.health = digsRemaining;
		SendNetworkUpdate();
		OnSingleDig(player);
		if (digsRemaining <= 0)
		{
			OnFullyDug(player);
			if (DestroyOnDug)
			{
				Kill();
			}
		}
	}

```

## OnPlayerAddModifiers(BasePlayer,Item,ItemModConsumable)

```csharp
```csharp
/// <summary>
/// Called when a player consumes an item that adds modifiers to their stats.
/// </summary>
/// <param name="player">The player who is consuming the item.</param>
/// <param name="item">The item being consumed.</param>
/// <param name="consumable">The consumable item modifier being applied.</param>
/// <returns>
/// Returns `null` to allow the default behavior of adding modifiers, or any non-null value to prevent it.
/// </returns>
object OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable)
{
    Puts($"Player {player.displayName} is adding modifiers from consumable: {item.info.displayName.english}.");

    if (player.health < 20)
    {
        Puts($"Player {player.displayName} is too low on health to receive modifiers.");
        return "Health too low to apply modifiers.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount < 1)
		{
			return;
		}
		GameObjectRef gameObjectRef = GetConsumeEffect();
		if (gameObjectRef.isValid)
		{
			Vector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));
			Effect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);
		}
		player.metabolism.MarkConsumption();
		ItemModConsumable consumable = GetConsumable();
		if (!string.IsNullOrEmpty(consumable.achievementWhenEaten))
		{
			player.GiveAchievement(consumable.achievementWhenEaten);
		}
		Facepunch.Rust.Analytics.Azure.OnConsumableUsed(player, item);
		float num = Mathf.Max(consumable.amountToConsume, 1);
		float num2 = Mathf.Min(item.amount, num);
		float num3 = num2 / num;
		float num4 = item.conditionNormalized;
		if (consumable.conditionFractionToLose > 0f)
		{
			num4 = consumable.conditionFractionToLose;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
		{
			if (Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)
			{
				continue;
			}
			if (effect.type == MetabolismAttribute.Type.Health)
			{
				if (effect.amount < 0f)
				{
					player.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, player.transform.position + player.transform.forward * 1f));
				}
				else
				{
					player.health += effect.amount * num3 * num4;
				}
			}
			else
			{
				player.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);
			}
		}
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);
		if (player.modifiers != null && Interface.CallHook("OnPlayerAddModifiers", player, item, consumable) == null)
		{
			player.modifiers.Add(consumable.modifiers);
		}
		if (product != null)
		{
			ItemAmountRandom[] array = product;
			foreach (ItemAmountRandom itemAmountRandom in array)
			{
				int num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);
				if (num5 > 0)
				{
					Item item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);
					player.GiveItem(item2);
				}
			}
		}
		if (string.IsNullOrEmpty(eatGesture))
		{
			player.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);
		}
		Facepunch.Rust.Analytics.Server.Consume(base.gameObject.name);
		if (consumable.conditionFractionToLose > 0f)
		{
			item.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);
		}
		else
		{
			item.UseItem((int)num2);
		}
	}

```

## OnStructureUpgraded(BuildingBlock,BasePlayer,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a new building grade.
/// </summary>
/// <param name="block">The building block that is being upgraded.</param>
/// <param name="player">The player who is performing the upgrade.</param>
/// <param name="newGrade">The new building grade being applied to the structure.</param>
/// <param name="skinId">The skin ID associated with the new grade.</param>
/// <returns>No return behavior.</returns>
void OnStructureUpgraded(BuildingBlock block, BasePlayer player, BuildingGrade.Enum newGrade, ulong skinId)
{
    Puts($"Structure upgraded by {player.displayName} to grade {newGrade} with skin ID {skinId}.");
    
    if (newGrade == BuildingGrade.Enum.Stone)
    {
        Puts($"Player {player.displayName} upgraded a structure to Stone grade.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void DoUpgradeToGrade(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		ConstructionGrade constructionGrade = blockDefinition.GetGrade((BuildingGrade.Enum)msg.read.Int32(), msg.read.UInt64());
		if (constructionGrade == null)
		{
			return;
		}
		if (!CanChangeToGrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
		{
			if (!(DeployVolume.LastDeployHit != null))
			{
				return;
			}
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(DeployVolume.LastDeployHit);
			if (baseEntity != null && baseEntity is BasePlayer basePlayer)
			{
				ulong currentTeam = msg.player.currentTeam;
				if (currentTeam != 0L && currentTeam == basePlayer.currentTeam)
				{
					string playerNameStreamSafe = NameHelper.GetPlayerNameStreamSafe(msg.player, basePlayer);
					msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, false, playerNameStreamSafe);
				}
			}
		}
		else
		{
			if (Interface.CallHook("OnStructureUpgrade", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin) != null || !CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))
			{
				return;
			}
			if (base.SecondsSinceAttacked < 30f)
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantUpgradeRecentlyDamaged, false, (30f - base.SecondsSinceAttacked).ToString("N0"));
				return;
			}
			if (!constructionGrade.gradeBase.alwaysUnlock && constructionGrade.gradeBase.skin != 0L && !msg.player.blueprints.steamInventory.HasItem((int)constructionGrade.gradeBase.skin))
			{
				msg.player.ShowToast(GameTip.Styles.Error, ConstructionErrors.SkinNotOwned, false);
				return;
			}
			PayForUpgrade(constructionGrade, msg.player);
			if (msg.player != null)
			{
				playerCustomColourToApply = GetShippingContainerBlockColourForPlayer(msg.player);
			}
			ClientRPC(RpcTarget.NetworkGroup("DoUpgradeEffect"), (int)constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			BuildingGrade.Enum @enum = grade;
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, constructionGrade.gradeBase.type, playerCustomColourToApply, constructionGrade.gradeBase.skin);
			OnSkinChanged(skinID, constructionGrade.gradeBase.skin);
			ChangeGrade(constructionGrade.gradeBase.type, playEffect: true);
			if (msg.player != null && @enum != constructionGrade.gradeBase.type)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE, new BaseMission.MissionEventPayload
				{
					NetworkIdentifier = net.ID,
					IntIdentifier = (int)constructionGrade.gradeBase.type
				}, 1f);
			}
			Interface.CallHook("OnStructureUpgraded", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
		}
	}

```

## CanSeeStash(BasePlayer,StashContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can see a stash container.
/// </summary>
/// <param name="player">The player attempting to see the stash.</param>
/// <param name="stash">The stash container being checked for visibility.</param>
/// <returns>
/// Returns `true` if the player can see the stash, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the stash is visible to the player.
/// </returns>
bool? CanSeeStash(BasePlayer player, StashContainer stash)
{
    Puts($"Checking visibility for stash {stash.net.ID} for player {player.displayName} (ID: {player.UserIDString}).");

    if (stash.IsHidden())
    {
        Puts($"Stash {stash.net.ID} is currently hidden from player {player.displayName}.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void CheckStashRevealInvoke()
	{
		for (int i = 0; i < nearbyStashes.Count; i++)
		{
			NearbyStash nearbyStash = nearbyStashes[i];
			if (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)
			{
				nearbyStashes.RemoveAt(i);
			}
			else if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))
			{
				nearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;
				if (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)
				{
					if (Interface.CallHook("CanSeeStash", this, nearbyStash.Entity) != null)
					{
						break;
					}
					nearbyStash.Entity.SetHidden(isHidden: false);
					Facepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);
					Interface.CallHook("OnStashExposed", nearbyStash.Entity, this);
				}
			}
			else
			{
				nearbyStash.LookingAtTime = 0f;
			}
		}
	}

```

## OnDeleteVendingOffer(VendingMachine,int)

```csharp
```csharp
/// <summary>
/// Called when a vending machine's sell order is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the offer is being deleted.</param>
/// <param name="orderIndex">The index of the sell order being deleted.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, int orderIndex)
{
    Puts($"Vending machine {vendingMachine.net.ID} is deleting sell order at index {orderIndex}.");
    
    if (orderIndex < 0)
    {
        Puts("Attempted to delete a sell order with a negative index.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", this, num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[num];
				Facepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, added: false);
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## OnIORefCleared(IOEntity.IORef,IOEntity)

```csharp
```csharp
/// <summary>
/// Called when an IO reference is cleared from an IO entity.
/// </summary>
/// <param name="ioRef">The IO reference that was cleared.</param>
/// <param name="entity">The IO entity from which the reference was cleared.</param>
/// <returns>No return behavior.</returns>
void OnIORefCleared(IOEntity.IORef ioRef, IOEntity entity)
{
    Puts($"IO reference cleared from entity: {entity?.name ?? "Unknown Entity"} with reference: {ioRef?.name ?? "Unknown Reference"}.");
}
```
```

### Source Code from the Library

```csharp

		public void Clear()
		{
			IOEntity obj = ioEnt;
			ioEnt = null;
			entityRef.Set(null);
			Interface.CallHook("OnIORefCleared", this, obj);
		}

```

## OnPlayerRespawn(BasePlayer,BasePlayer.SpawnPoint)

```csharp
```csharp
/// <summary>
/// Called when a player respawns in the game.
/// </summary>
/// <param name="player">The player who is respawning.</param>
/// <param name="spawnPoint">The spawn point where the player will respawn.</param>
/// <returns>
/// Returns a modified spawn point if the hook alters the respawn location; otherwise, returns the original spawn point.
/// </returns>
SpawnPoint OnPlayerRespawn(BasePlayer player, SpawnPoint spawnPoint)
{
    Puts($"Player {player.displayName} is respawning at position: {spawnPoint.pos}.");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and will respawn at a safe location.");
        spawnPoint.pos += new Vector3(0, 5, 0); // Adjust spawn position slightly above the original
    }

    return spawnPoint; // Return the potentially modified spawn point
}
```
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this);
		if (ConVar.Server.respawnAtDeathPosition && ServerCurrentDeathNote != null)
		{
			spawnPoint.pos = ServerCurrentDeathNote.worldPosition;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", this, spawnPoint);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnWeaponReload(BaseProjectile,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a weapon is reloaded by a player.
/// </summary>
/// <param name="weapon">The weapon being reloaded.</param>
/// <param name="player">The player who is reloading the weapon.</param>
/// <returns>
/// Returns `null` to allow the reload to proceed, or any non-null value to prevent the reload action.
/// </returns>
object OnWeaponReload(BaseProjectile weapon, BasePlayer player)
{
    Puts($"Player {player.displayName} is reloading weapon: {weapon.info.displayName.english} (ID: {weapon.net.ID})");

    if (player.inventory.GetAmount(weapon.ammoType) <= 0)
    {
        Puts($"Player {player.displayName} cannot reload because they have no ammo.");
        return "No ammo available for reload.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnWeaponReload", this, player) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			fractionalInsertCounter = 0;
			if (CanRefundAmmo)
			{
				SwitchAmmoTypesIfNeeded(player.inventory);
			}
			OnReloadStarted();
			StartReloadCooldown(GetReloadDuration());
		}
	}

```

## OnCrateHackEnd(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when the hacking of a locked crate has completed.
/// </summary>
/// <param name="crate">The hackable locked crate that was hacked.</param>
/// <returns>No return behavior.</returns>
void OnCrateHackEnd(HackableLockedCrate crate)
{
    Puts($"Hacking completed for crate ID: {crate.net.ID}. Original hacker ID: {crate.originalHackerPlayerId}");
    
    if (crate.originalHackerPlayer != null)
    {
        Puts($"Player {crate.originalHackerPlayer.displayName} successfully hacked the crate.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", this);
			Facepunch.Rust.Analytics.Azure.OnLockedCrateFinished(originalHackerPlayerId, this);
			if (originalHackerPlayer != null && originalHackerPlayer.serverClan != null)
			{
				originalHackerPlayer.AddClanScore(ClanScoreEventType.HackedCrate);
			}
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			CancelInvoke(HackProgress);
		}
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), (int)hackSeconds, (int)requiredHackSeconds);
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a melee item is thrown by a player.
/// </summary>
/// <param name="player">The player who threw the melee item.</param>
/// <param name="item">The item that was thrown.</param>
/// <returns>No return behavior.</returns>
void OnMeleeThrown(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} has thrown a melee item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.shortname == "rock")
    {
        Puts("Warning: Player threw a rock, which may indicate a low resource situation.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.IsActiveItem]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (player == null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsProjectile)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "item_missing");
				return;
			}
			ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
			if (component == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "mod_missing");
				return;
			}
			ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
			if (projectileShoot.projectiles.Count != 1)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "count_mismatch");
				return;
			}
			player.CleanupExpiredProjectiles();
			Guid projectileGroupId = Guid.NewGuid();
			foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.LogInvalid(player, this, "duplicate_id");
					continue;
				}
				Vector3 positionOffset = Vector3.zero;
				if (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))
				{
					if (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))
					{
						continue;
					}
					Vector3 position = player.eyes.position;
					positionOffset = position - projectile.startPos;
					projectile.startPos = position;
				}
				else if (!ValidateEyePos(player, projectile.startPos))
				{
					continue;
				}
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, projectileGroupId, positionOffset, item);
				Effect effect = new Effect();
				effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
				effect.scale = 1f;
				effect.pooledString = component.projectileObject.resourcePath;
				effect.number = projectile.seed;
				EffectNetwork.Send(effect);
			}
			projectileShoot?.Dispose();
			item.SetParent(null);
			Interface.CallHook("OnMeleeThrown", player, item);
			if (!canAiHearIt)
			{
				return;
			}
			float num = 0f;
			if (component.projectileObject == null)
			{
				return;
			}
			GameObject gameObject = component.projectileObject.Get();
			if (!(gameObject != null))
			{
				return;
			}
			Projectile component2 = gameObject.GetComponent<Projectile>();
			if (!(component2 != null))
			{
				return;
			}
			foreach (DamageTypeEntry damageType in component2.damageTypes)
			{
				num += damageType.amount;
			}
		}
	}

```

## OnEntityDistanceCheck(BaseEntity,BasePlayer,uint,string,float,bool)

```csharp
```csharp
/// <summary>
/// Called to check if a player is within a specified distance of an entity.
/// </summary>
/// <param name="entityId">The unique identifier of the entity being checked.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <param name="entity">The entity to check the distance against.</param>
/// <param name="player">The player whose distance from the entity is being checked.</param>
/// <param name="maximumDistance">The maximum distance allowed for the check.</param>
/// <param name="checkParent">Indicates whether to check the parent entity's distance if the initial check fails.</param>
/// <returns>
/// Returns `true` if the player is within the specified distance of the entity, or `false` otherwise.
/// If the method returns `null`, the default distance check logic will be used.
/// </returns>
bool? OnEntityDistanceCheck(uint entityId, string debugName, BaseEntity entity, BasePlayer player, float maximumDistance, bool checkParent = false)
{
    Puts($"Checking distance for Player {player.displayName} (ID: {player.UserIDString}) to Entity {debugName} (ID: {entityId}).");

    if (entity is null)
    {
        Puts("Entity is null, returning false.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance, bool checkParent = false)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityDistanceCheck", ent, player, id, debugName, maximumDistance, checkParent);
				if (obj is bool)
				{
					return (bool)obj;
				}
				bool flag = ent.Distance(player.eyes.position) <= maximumDistance;
				if (checkParent && !flag)
				{
					BaseEntity parentEntity = ent.GetParentEntity();
					flag = parentEntity != null && parentEntity.Distance(player.eyes.position) <= maximumDistance;
				}
				return flag;
			}

```

## OnMapMarkerAdded(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a player adds a new marker to the map.
/// </summary>
/// <param name="player">The player who added the map marker.</param>
/// <param name="mapNote">The details of the map marker that was added.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.displayName} added a map marker at position: {mapNote.position} with color index: {mapNote.colourIndex}.");
    
    if (mapNote.title == "Danger Zone")
    {
        Puts($"Warning: Player {player.displayName} marked a danger zone on the map!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 13L;
			if (State.pointsOfInterest == null)
			{
				State.pointsOfInterest = Facepunch.Pool.Get<List<MapNote>>();
			}
			if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
			{
				msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, false, ConVar.Server.maximumMapMarkers.ToString());
				return;
			}
			MapNote mapNote = MapNote.Deserialize(msg.read);
			ValidateMapNote(mapNote);
			mapNote.colourIndex = FindUnusedPointOfInterestColour();
			State.pointsOfInterest.Add(mapNote);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, mapNote);
		}
	}

```

## OnDemoRecordingStop(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is stopped.
/// </summary>
/// <param name="filename">The name of the recording file that was stopped.</param>
/// <param name="player">The player who stopped the recording.</param>
/// <returns>
/// Returns `null` to allow the recording to stop normally, or any non-null value to prevent the stop action.
/// </returns>
object OnDemoRecordingStop(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped for player {player.displayName}. Filename: {filename}");
    if (filename.Contains("restricted"))
    {
        Puts($"Recording {filename} is restricted and cannot be stopped.");
        return "Recording cannot be stopped due to restrictions.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnDefaultItemsReceive(PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when default items are given to a player.
/// </summary>
/// <param name="inventory">The player's inventory receiving the default items.</param>
/// <returns>No return behavior.</returns>
void OnDefaultItemsReceive(PlayerInventory inventory)
{
    Puts($"Default items are being given to player with inventory ID: {inventory.ID}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);
			}
		}
	}

```

## OnCupboardDeauthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is deauthorized from a building privilege cupboard.
/// </summary>
/// <param name="cupboard">The building privilege cupboard from which the player is being deauthorized.</param>
/// <param name="player">The player being deauthorized.</param>
/// <returns>No return behavior.</returns>
void OnCupboardDeauthorize(BuildingPrivlidge cupboard, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has been deauthorized from cupboard {cupboard.net.ID}.");
    
    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} has been removed from cupboard authorization.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && CanAdministrate(rpc2.player) && Interface.CallHook("OnCupboardDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Determines whether a player can be wounded based on various conditions.
/// </summary>
/// <param name="player">The player being checked for wounding eligibility.</param>
/// <param name="hitInfo">Information about the hit that may cause wounding.</param>
/// <returns>
/// Returns `true` if the player can be wounded, `false` if they cannot, 
/// or `null` if the default game logic should be used to determine eligibility.
/// </returns>
bool? CanBeWounded(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Checking if player {player.displayName} (ID: {player.UserIDString}) can be wounded.");

    if (player.IsSleeping())
    {
        Puts($"Player {player.displayName} is sleeping and cannot be wounded.");
        return false;
    }

    if (hitInfo == null)
    {
        Puts("HitInfo is null, cannot determine wounding eligibility.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsWounded())
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (!IsWounded() && UnityEngine.Time.realtimeSinceStartup - lastWoundedStartTime < ConVar.Server.rewounddelay)
		{
			return false;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((bool)activeGameMode && !activeGameMode.allowWounding)
		{
			return false;
		}
		if (triggers != null)
		{
			for (int i = 0; i < triggers.Count; i++)
			{
				if (triggers[i] is IHurtTrigger)
				{
					return false;
				}
			}
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnItemRecycleAmount(Item,int,Recycler)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled to determine the amount of resources produced.
/// </summary>
/// <param name="item">The item being recycled.</param>
/// <param name="amount">The amount of the item being recycled.</param>
/// <param name="recycler">The recycler that is processing the item.</param>
/// <returns>
/// Returns the amount of resources produced from recycling the item. 
/// If a non-null value is returned, it overrides the default recycling behavior.
/// </returns>
int OnItemRecycleAmount(Item item, int amount, Recycler recycler)
{
    Puts($"Recycling {amount} of {item.info.displayName.english} (Shortname: {item.info.shortname}) in {recycler.gameObject.name}.");

    if (item.info.shortname == "wood")
    {
        Puts("Wood recycling is limited to 50% of the amount.");
        return Mathf.FloorToInt(amount * 0.5f);
    }

    return amount; // Default behavior, return the original amount.
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", slot, this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", slot, num3, this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					float num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 *= slot.conditionNormalized;
					}
					float num5 = num / 0.5f;
					num4 *= num5;
					int num6 = Mathf.FloorToInt(num4);
					float num7 = num4 - (float)num6;
					scrapRemainder += num7;
					if (scrapRemainder >= 1f)
					{
						int num8 = Mathf.FloorToInt(scrapRemainder);
						scrapRemainder -= num8;
						num6 += num8;
					}
					if (num6 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num6, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj2 = Facepunch.Pool.Get<List<BasePlayer>>();
					Vis.Entities(base.transform.position, 3f, obj2, 131072);
					foreach (BasePlayer item3 in obj2)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Facepunch.Pool.FreeUnmanaged(ref obj2);
				}
				Facepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;
					int num10 = Mathf.FloorToInt(num9);
					float num11 = num9 - (float)num10;
					if (num11 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num11)
					{
						num10++;
					}
					if (num10 <= 0)
					{
						continue;
					}
					int num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);
					for (int i = 0; i < num12; i++)
					{
						int num13 = ((num10 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);
						Item item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
						if (!MoveItemToOutput(item2))
						{
							flag = true;
						}
						num10 -= num13;
						if (num10 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

```

## OnQueueMessage(Network.Connection,int)

```csharp
```csharp
/// <summary>
/// Called when a message about the player's queue position is sent.
/// </summary>
/// <param name="connection">The network connection of the player receiving the message.</param>
/// <param name="position">The player's position in the queue.</param>
/// <returns>
/// Returns `null` to allow the default message to be sent. 
/// Any non-null value will prevent the message from being sent.
/// </returns>
object OnQueueMessage(Network.Connection connection, int position)
{
    Puts($"Sending queue message to connection {connection.userid} at position {position}.");
    
    if (position < 0)
    {
        Puts($"Invalid queue position: {position}. Message will not be sent.");
        return "Invalid position.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendMessage(Connection c, int position)
	{
		if (Interface.CallHook("OnQueueMessage", c, position) == null)
		{
			string empty = string.Empty;
			empty = ((position <= 0) ? string.Format("YOU'RE NEXT - {1:N0} PLAYERS BEHIND YOU", position, queue.Count - position - 1) : $"{position:N0} PLAYERS AHEAD OF YOU, {queue.Count - position - 1:N0} PLAYERS BEHIND");
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.Message);
			netWrite.String("QUEUE");
			netWrite.String(empty);
			netWrite.Send(new SendInfo(c));
		}
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing ground support and needs to be handled accordingly.
/// </summary>
/// <param name="entity">The entity that is missing ground support.</param>
/// <returns>No return behavior.</returns>
void OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity.net.ID} is missing ground support and will be processed.");
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (baseEntity != null && Interface.CallHook("OnEntityGroundMissing", baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}

```

## OnWindmillUpdated(ElectricWindmill)

```csharp
```csharp
/// <summary>
/// Called when the windmill's state is updated, typically to adjust power generation based on wind speed.
/// </summary>
/// <param name="windmill">The electric windmill that is being updated.</param>
/// <returns>No return behavior.</returns>
void OnWindmillUpdated(ElectricWindmill windmill)
{
    Puts($"Windmill {windmill.net.ID} updated. Current energy generation: {windmill.currentEnergy}.");
    
    if (windmill.serverWindSpeed <= 0)
    {
        Puts("Windmill is not generating power due to insufficient wind.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", this);
		}
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an entity is successfully built in the game world.
/// </summary>
/// <param name="planner">The planner that initiated the build process.</param>
/// <param name="gameObject">The GameObject that was created as a result of the build.</param>
/// <returns>No return behavior.</returns>
void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
{
    Puts($"Entity built by {planner.GetOwnerPlayer()?.displayName ?? "unknown player"}: {gameObject.name}");

    if (gameObject.CompareTag("Deployable"))
    {
        Puts($"Deployable entity {gameObject.name} has been placed.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		if (RayEx.IsNaNOrInfinity(target.ray))
		{
			return null;
		}
		if (target.position.IsNaNOrInfinity())
		{
			return null;
		}
		if (target.normal.IsNaNOrInfinity())
		{
			return null;
		}
		Construction.lastPlacementError = "";
		Construction.lastPlacementErrorDebug = "";
		Construction.lastBuildingBlockError = null;
		Construction.lastPlacementErrorIsDetailed = false;
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketNotFemale, false);
				Construction.lastPlacementErrorDebug = target.socket.socketName;
				return null;
			}
			if (target.entity != null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.SocketOccupied, false);
				Construction.lastPlacementErrorDebug = target.socket.socketName;
				return null;
			}
			if (target.onTerrain)
			{
				Construction.lastPlacementErrorDebug = "Target on terrain is not allowed when attaching to socket (" + target.socket.socketName + ")";
				return null;
			}
		}
		Vector3 deployPos = ((target.entity != null && target.socket != null) ? target.GetWorldPosition() : target.position);
		if (AntiHack.TestIsBuildingInsideSomething(target, deployPos))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.InsideObjects, false);
			return null;
		}
		if (ConVar.AntiHack.eye_protection >= 2 && !HasLineOfSight(ownerPlayer, deployPos, target, component))
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.LineOfSightBlocked, false);
			return null;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanBuildResult? result = SleepingBag.CanBuildBed(ownerPlayer, component);
			if (HandleCanBuild(result, ownerPlayer))
			{
				return null;
			}
		}
		if (ConVar.Server.max_shelters > 0)
		{
			CanBuildResult? result2 = LegacyShelter.CanBuildShelter(ownerPlayer, component);
			if (HandleCanBuild(result2, ownerPlayer))
			{
				return null;
			}
		}
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, Construction.lastPlacementError, false);
			ConstructionErrors.Log(ownerPlayer, Construction.lastPlacementErrorDebug);
		}
		if (gameObject != null)
		{
			Interface.CallHook("OnEntityBuilt", this, gameObject);
			Deployable deployable = GetDeployable();
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
			if (baseEntity != null && deployable != null)
			{
				if (ShouldParent(target.entity, deployable))
				{
					if (target.socket is Socket_Specific_Female socket_Specific_Female)
					{
						if (socket_Specific_Female.parentToBone)
						{
							baseEntity.SetParent(target.entity, socket_Specific_Female.boneName, worldPositionStays: true);
						}
						else
						{
							baseEntity.SetParent(target.entity, worldPositionStays: true);
						}
					}
					else
					{
						baseEntity.SetParent(target.entity, worldPositionStays: true);
					}
				}
				if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
				{
					(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
				}
				if (deployable.copyInventoryFromItem)
				{
					StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
					if ((bool)component2)
					{
						component2.ReceiveInventoryFromItem(GetOwnerItem());
					}
				}
				ItemModDeployable modDeployable = GetModDeployable();
				if (modDeployable != null)
				{
					modDeployable.OnDeployed(baseEntity, ownerPlayer);
				}
				baseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer, GetOwnerItem());
				if (deployable.placeEffect.isValid)
				{
					if ((bool)target.entity && target.socket != null)
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up);
					}
					else
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, target.position, target.normal);
					}
				}
			}
			if (baseEntity != null)
			{
				Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
				if (GetOwnerItemDefinition() != null)
				{
					ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
					{
						WorldPosition = baseEntity.transform.position,
						UintIdentifier = baseEntity.prefabID,
						IntIdentifier = GetOwnerItemDefinition().itemid
					}, 1f);
				}
			}
			PayForPlacement(ownerPlayer, component);
			return baseEntity;
		}
		return null;
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player receives a bonus from a resource dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser providing the bonus.</param>
/// <param name="player">The player receiving the bonus.</param>
/// <param name="item">The item being given as a bonus.</param>
/// <returns>
/// Returns an <c>Item</c> if the item is modified or replaced; otherwise, returns <c>null</c> to use the original item.
/// </returns>
object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} received a bonus item: {item.info.displayName.english} from dispenser {dispenser.net.ID}.");
    
    // Example modification: double the amount of the item given
    item.amount *= 2;
    Puts($"Bonus item amount modified to: {item.amount}");
    
    return item; // Return the modified item
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", this, player, item);
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnBookmarksSendControl(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when control bookmarks are sent to a player from a computer station.
/// </summary>
/// <param name="station">The computer station sending the bookmarks.</param>
/// <param name="player">The player receiving the bookmarks.</param>
/// <param name="bookmarks">The string containing the control bookmarks.</param>
/// <returns>
/// Returns a non-null value to prevent the bookmarks from being sent. 
/// If `null` is returned, the bookmarks will be sent to the player.
/// </returns>
object OnBookmarksSendControl(ComputerStation station, BasePlayer player, string bookmarks)
{
    Puts($"Sending control bookmarks to player {player.displayName} from station {station.name}.");
    
    if (player.IsBanned)
    {
        Puts($"Player {player.displayName} is banned and cannot receive bookmarks.");
        return "Player is banned from receiving bookmarks.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendControlBookmarks(BasePlayer player)
	{
		if (!(player == null))
		{
			string text = GenerateControlBookmarkString();
			if (Interface.CallHook("OnBookmarksSendControl", this, player, text) == null)
			{
				ClientRPC(RpcTarget.Player("ReceiveBookmarks", player), text);
			}
		}
	}

```

## OnEntityFlagsNetworkUpdate(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when the network update for entity flags is sent.
/// </summary>
/// <param name="entity">The entity whose flags are being updated.</param>
/// <returns>No return behavior.</returns>
void OnEntityFlagsNetworkUpdate(BaseEntity entity)
{
    Puts($"Network flags updated for entity ID: {entity.net.ID}, Flags: {entity.flags}");
}
```
```

### Source Code from the Library

```csharp

	public void SendNetworkUpdate_Flags()
	{
		if (Rust.Application.isLoading || Rust.Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		using (TimeWarning.New("SendNetworkUpdate_Flags"))
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate_Flags");
			if (Interface.CallHook("OnEntityFlagsNetworkUpdate", this) == null)
			{
				List<Connection> subscribers = GetSubscribers();
				if (subscribers != null && subscribers.Count > 0)
				{
					NetWrite netWrite = Network.Net.sv.StartWrite();
					netWrite.PacketID(Message.Type.EntityFlags);
					netWrite.EntityID(net.ID);
					netWrite.Int32((int)flags);
					SendInfo info = new SendInfo(subscribers);
					netWrite.Send(info);
				}
				base.gameObject.SendOnSendNetworkUpdate(this);
			}
		}
	}

```

## OnWireClear(BasePlayer,IOEntity,int,IOEntity,bool)

```csharp
```csharp
/// <summary>
/// Called when a wire connection is cleared from an IOEntity.
/// </summary>
/// <param name="player">The player attempting to clear the wire connection.</param>
/// <param name="entity">The IOEntity from which the wire connection is being cleared.</param>
/// <param name="index">The index of the input or output being cleared.</param>
/// <param name="connectedEntity">The entity that was connected to the wire.</param>
/// <param name="isInput">Indicates whether the connection is an input (true) or output (false).</param>
/// <returns>
/// Returns `true` if the wire connection was successfully cleared; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine the outcome.
/// </returns>
bool? OnWireClear(BasePlayer player, IOEntity entity, int index, IOEntity connectedEntity, bool isInput)
{
    Puts($"Player {player.displayName} is attempting to clear wire connection on {entity.name} at index {index}.");

    if (connectedEntity == null)
    {
        Puts("No connected entity found to clear.");
        return false;
    }

    if (!CanModifyEntity(player, entity))
    {
        Puts($"Player {player.displayName} does not have permission to modify {entity.name}.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)
	{
		IOEntity iOEntity = ((clearEnt != null) ? clearEnt.GetComponent<IOEntity>() : null);
		IOEntity iOEntity2 = (IOEntity)(object)(isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);
		if (((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get() == null)
		{
			return false;
		}
		iOEntity2 = ((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get();
		object obj = Interface.CallHook("OnWireClear", ply, iOEntity, clearIndex, iOEntity2, isInput);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (iOEntity == null)
		{
			return false;
		}
		if (ply != null && !CanModifyEntity(ply, iOEntity))
		{
			return false;
		}
		return iOEntity.Disconnect(clearIndex, isInput);
	}

```

## OnEntityControl(PoweredRemoteControlEntity,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can control the powered remote control entity.
/// </summary>
/// <param name="entity">The powered remote control entity being controlled.</param>
/// <param name="playerId">The ID of the player attempting to control the entity.</param>
/// <returns>
/// Returns `true` if the player can control the entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can control the entity.
/// </returns>
bool? OnEntityControl(PoweredRemoteControlEntity entity, ulong playerId)
{
    Puts($"Player with ID {playerId} is attempting to control the entity: {entity.net.ID}.");

    if (!entity.IsPowered())
    {
        Puts($"Entity {entity.net.ID} is not powered, control denied.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", this, playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsPowered())
		{
			return IsStatic();
		}
		return true;
	}

```

## OnLockRemove(ModularCar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a lock is removed from a modular car.
/// </summary>
/// <param name="car">The modular car from which the lock is being removed.</param>
/// <param name="player">The player requesting the lock removal.</param>
/// <returns>
/// Returns `null` to allow the lock removal, or any non-null value to prevent it.
/// </returns>
object OnLockRemove(ModularCar car, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to remove the lock from car ID: {car.net.ID}.");

    if (player.IsAdmin)
    {
        Puts($"Admin {player.displayName} is allowed to remove the lock.");
        return null; // Allow lock removal for admins
    }

    Puts($"Player {player.displayName} is not authorized to remove the lock.");
    return "You are not authorized to remove this lock."; // Prevent lock removal
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_RequestRemoveLock(RPCMessage msg)
	{
		if (HasOccupant && carOccupant.CarLock.HasALock && Interface.CallHook("OnLockRemove", carOccupant, msg.player) == null)
		{
			carOccupant.CarLock.RemoveLock();
			Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

```

## OnBroadcastCommand(string,object[])

```csharp
```csharp
/// <summary>
/// Called when a broadcast command is issued to all clients.
/// </summary>
/// <param name="command">The command string to be broadcasted.</param>
/// <param name="args">An array of arguments associated with the command.</param>
/// <returns>
/// Returns `null` to allow the command to be broadcasted, or any non-null value to prevent the broadcast.
/// </returns>
object OnBroadcastCommand(string command, object[] args)
{
    Puts($"Broadcast command received: {command} with arguments: {string.Join(", ", args)}");
    
    if (command == "restricted.command")
    {
        Puts("Broadcast of restricted command is blocked.");
        return "You are not allowed to use this command.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void BroadcastToAllClients(string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnBroadcastCommand", strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			netWrite.String(ConsoleSystem.BuildCommand(strCommand, args));
			netWrite.Send(new SendInfo(Network.Net.sv.connections));
		}
	}

```

## CanUnlock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a code lock.
/// </summary>
/// <param name="player">The player attempting to unlock the code lock.</param>
/// <param name="codeLock">The code lock being unlocked.</param>
/// <returns>
/// Returns `true` if the player can unlock the code lock, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can unlock the code lock.
/// </returns>
bool? CanUnlock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to unlock a code lock.");

    if (player.IsBannedFromUnlocking)
    {
        Puts($"Player {player.displayName} is banned from unlocking code locks.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && !IsCodeEntryBlocked() && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnComposterUpdate(Composter)

```csharp
```csharp
/// <summary>
/// Called to update the composting process in the composter.
/// </summary>
/// <param name="composter">The composter that is being updated.</param>
/// <returns>No return behavior.</returns>
void OnComposterUpdate(Composter composter)
{
    Puts($"Updating composting process for composter ID: {composter.net.ID}.");
}
```
```

### Source Code from the Library

```csharp

	public void UpdateComposting()
	{
		if (Interface.CallHook("OnComposterUpdate", this) != null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				CompostItem(slot);
			}
		}
	}

```

## OnTakeCurrencyItem(VendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called when a currency item is taken from the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine from which the currency item is taken.</param>
/// <param name="takenCurrencyItem">The currency item that is being taken.</param>
/// <returns>No return behavior.</returns>
void OnTakeCurrencyItem(VendingMachine vendingMachine, Item takenCurrencyItem)
{
    Puts($"Currency item {takenCurrencyItem.info.displayName.english} taken from vending machine ID: {vendingMachine.net.ID}.");
    
    if (takenCurrencyItem.amount <= 0)
    {
        Puts("Attempted to take an empty currency item.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null && !takenCurrencyItem.MoveToContainer(base.inventory))
		{
			takenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);
		}
	}

```

## OnXmasGiftsDistribute(XMasRefill,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when distributing Christmas gifts to a player.
/// </summary>
/// <param name="xmasRefill">The reference to the Christmas gift distribution system.</param>
/// <param name="player">The player receiving the gifts.</param>
/// <returns>
/// Returns `true` if the gifts were successfully distributed, or `false` if the distribution was canceled by a hook.
/// </returns>
bool OnXmasGiftsDistribute(XMasRefill xmasRefill, BasePlayer player)
{
    Puts($"Distributing Christmas gifts to player: {player.displayName} (ID: {player.UserIDString})");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool DistributeGiftsForPlayer(BasePlayer player)
	{
		if (Interface.CallHook("OnXmasGiftsDistribute", this, player) != null)
		{
			return false;
		}
		int num = GiftsPerPlayer();
		int num2 = GiftSpawnAttempts();
		for (int i = 0; i < num2; i++)
		{
			if (num <= 0)
			{
				break;
			}
			Vector2 vector = UnityEngine.Random.insideUnitCircle * GiftRadius();
			Vector3 pos = player.transform.position + new Vector3(vector.x, 10f, vector.y);
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			if (DropToGround(ref pos))
			{
				string resourcePath = giftPrefabs[UnityEngine.Random.Range(0, giftPrefabs.Length)].resourcePath;
				BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);
				if ((bool)baseEntity)
				{
					baseEntity.Spawn();
					num--;
				}
			}
		}
		return true;
	}

```

## OnFuelItemCheck(EntityFuelSystem,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to check which fuel item is available in the fuel system's container.
/// </summary>
/// <param name="fuelSystem">The entity fuel system that is checking for fuel.</param>
/// <param name="container">The storage container where fuel items are stored.</param>
/// <returns>
/// Returns the fuel item if available; otherwise, returns `null` if no fuel item is found.
/// If a non-null value is returned from the hook, that value will be used as the fuel item.
/// </returns>
Item OnFuelItemCheck(EntityFuelSystem fuelSystem, StorageContainer container)
{
    Puts($"Checking fuel item for {fuelSystem.gameObject.name} in container {container?.gameObject.name ?? "none"}.");

    // Example condition to block a specific fuel item
    if (container != null && container.inventory.GetSlot(0)?.info.shortname == "low_quality.metal")
    {
        Puts("Low quality metal is not allowed as fuel.");
        return null;
    }

    return null; // Default behavior will be to check the first slot in the container
}
```
```

### Source Code from the Library

```csharp

	public Item GetFuelItem()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("OnFuelItemCheck", this, fuelContainer);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (fuelContainer == null)
		{
			return null;
		}
		return fuelContainer.inventory.GetSlot(0);
	}

```

## OnItemRefill(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is refilled by a player.
/// </summary>
/// <param name="item">The item that is being refilled.</param>
/// <param name="player">The player who is refilling the item.</param>
/// <returns>
/// Returns `null` to allow the refill to proceed, or any non-null value to prevent the refill action.
/// </returns>
object OnItemRefill(Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to refill item: {item.info.displayName.english} (ID: {item.info.itemid}).");

    if (item.info.itemid == 12345) // Example item ID for a restricted item
    {
        Puts($"Player {player.displayName} is not allowed to refill this item.");
        return "You cannot refill this item.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", item, player) == null)
		{
			float conditionNormalized = item.conditionNormalized;
			float maxConditionNormalized = item.maxConditionNormalized;
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
			Facepunch.Rust.Analytics.Azure.OnItemRepaired(player, player.GetCachedCraftLevelWorkbench(), item, conditionNormalized, maxConditionNormalized);
		}
	}

```

## OnRackedWeaponUnloaded(Item,BasePlayer,WeaponRack)

```csharp
```csharp
/// <summary>
/// Called when a weapon is unloaded from a weapon rack.
/// </summary>
/// <param name="item">The item representing the weapon that was unloaded.</param>
/// <param name="player">The player who unloaded the weapon.</param>
/// <param name="weaponRack">The weapon rack from which the weapon was unloaded.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponUnloaded(Item item, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Weapon {item.info.displayName.english} has been unloaded by {player.displayName} from the weapon rack.");
    
    if (item.info.shortname == "rifle.semiauto")
    {
        Puts($"Warning: {player.displayName} unloaded a semi-automatic rifle!");
    }
}
```
```

### Source Code from the Library

```csharp

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", slot, player, this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity == null))
		{
			BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
			if (!(component == null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", slot, player, this);
			}
		}
	}

```

## OnMlrsTarget(MLRS,UnityEngine.Vector3,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a target position is set for the Multiple Launch Rocket System (MLRS).
/// </summary>
/// <param name="mlrs">The MLRS instance that is targeting.</param>
/// <param name="targetPosition">The world position being targeted.</param>
/// <param name="player">The player who set the target position.</param>
/// <returns>
/// Returns `null` to allow the target position to be set, or any non-null value to prevent it.
/// </returns>
object OnMlrsTarget(MLRS mlrs, Vector3 targetPosition, BasePlayer player)
{
    Puts($"Player {player.displayName} set MLRS target position to {targetPosition}.");
    
    if (targetPosition.y < 0)
    {
        Puts("Target position is below ground level, adjusting to ground level.");
        targetPosition.y = 0; // Adjust to ground level if below
    }

    return null; // Allow the target to be set
}
```
```

### Source Code from the Library

```csharp

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 vector = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", this, worldPos, _mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Vector3 center = allSafeZone.triggerCollider.bounds.center;
				center.y = 0f;
				float num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 vector2 = trueTargetHitPos - center;
					trueTargetHitPos = center + vector2.normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", this, trueTargetHitPos, _mounted);
	}

```

## OnHelicopterOutOfCrates(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if the helicopter has run out of crates to drop.
/// </summary>
/// <param name="helicopter">The helicopter AI controller checking for crate availability.</param>
/// <returns>
/// Returns `true` if the helicopter is out of crates, or `false` if it still has crates available.
/// If the method returns `null`, the default logic will be used to determine crate availability.
/// </returns>
bool? OnHelicopterOutOfCrates(CH47HelicopterAIController helicopter)
{
    Puts($"Checking crate availability for helicopter ID: {helicopter.net.ID}.");
    
    if (helicopter.numCrates <= 0)
    {
        Puts($"Helicopter ID: {helicopter.net.ID} is out of crates.");
        return true;
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

```

## OnNpcAlert(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when a Scientist NPC is alerted.
/// </summary>
/// <param name="npc">The Scientist NPC that is being alerted.</param>
/// <returns>No return behavior.</returns>
void OnNpcAlert(ScientistNPC npc)
{
    Puts($"NPC {npc.name} has been alerted at time {Time.time}.");
    // Additional alert handling logic can be added here.
}
```
```

### Source Code from the Library

```csharp

	public void Alert()
	{
		if (Interface.CallHook("OnNpcAlert", this) == null)
		{
			lastAlertedTime = Time.time;
			SetChatterType(RadioChatterType.Alert);
		}
	}

```

## OnCupboardClearList(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the list of authorized players in a cupboard is cleared.
/// </summary>
/// <param name="cupboard">The building privilege cupboard being cleared.</param>
/// <param name="player">The player who initiated the clear action.</param>
/// <returns>No return behavior.</returns>
void OnCupboardClearList(BuildingPrivlidge cupboard, BasePlayer player)
{
    Puts($"Cupboard belonging to {cupboard.OwnerID} has had its authorized player list cleared by {player.displayName} (ID: {player.UserIDString}).");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player) && Interface.CallHook("OnCupboardClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnInterferenceUpdate(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to update the interference status of the auto turret.
/// </summary>
/// <param name="turret">The auto turret that is being updated for interference.</param>
/// <returns>No return behavior.</returns>
void OnInterferenceUpdate(AutoTurret turret)
{
    Puts($"Updating interference for turret ID: {turret.net.ID}, Status: {(turret.IsOn() ? "Active" : "Inactive")}");
    
    if (turret.HasInterference())
    {
        Puts($"Turret ID: {turret.net.ID} is currently experiencing interference.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateInterference()
	{
		if (!IsOn() || Interface.CallHook("OnInterferenceUpdate", this) != null)
		{
			return;
		}
		float num = 0f;
		foreach (AutoTurret nearbyTurret in nearbyTurrets)
		{
			if (!nearbyTurret.isClient && nearbyTurret.IsValid() && nearbyTurret.gameObject.activeSelf && !nearbyTurret.EqualNetID(net.ID) && nearbyTurret.IsOn() && !nearbyTurret.HasInterference())
			{
				num += 1f;
			}
		}
		SetFlag(Flags.OnFire, num >= (float)Sentry.maxinterference);
	}

```

## OnIngredientsCollect(ItemCrafter,ItemBlueprint,ItemCraftTask,int,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when ingredients are collected for crafting an item.
/// </summary>
/// <param name="crafter">The item crafter collecting the ingredients.</param>
/// <param name="blueprint">The blueprint of the item being crafted.</param>
/// <param name="task">The crafting task associated with the item.</param>
/// <param name="amount">The amount of items to craft.</param>
/// <param name="player">The player who is crafting the item.</param>
/// <returns>No return behavior.</returns>
void OnIngredientsCollect(ItemCrafter crafter, ItemBlueprint blueprint, ItemCraftTask task, int amount, BasePlayer player)
{
    Puts($"Collecting ingredients for crafting {blueprint.targetItem.shortname} (Amount: {amount}) by player {player?.displayName ?? "N/A"}.");
    
    if (blueprint.targetItem.shortname == "special.item")
    {
        Puts("Special item crafting requires additional checks.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null)
	{
		if (Interface.CallHook("OnIngredientsCollect", this, bp, task, amount, player) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			CollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list);
		}
		foreach (Item item in list)
		{
			item.CollectedForCrafting(player);
		}
		task.takenItems = list;
	}

```

## OnEngineStatsRefresh(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called to refresh the performance statistics of the vehicle engine.
/// </summary>
/// <param name="engine">The vehicle engine module whose stats are being refreshed.</param>
/// <param name="engineStorage">The storage containing the engine's performance data.</param>
/// <returns>No return behavior.</returns>
void OnEngineStatsRefresh(VehicleModuleEngine engine, Rust.Modular.EngineStorage engineStorage)
{
    Puts($"Refreshing engine stats for {engine.GetType().Name} with storage ID: {engineStorage?.GetHashCode()}");

    if (engineStorage == null)
    {
        Puts("Engine storage is null, setting performance stats to zero.");
    }
    else
    {
        Puts($"Engine is usable: {engineStorage.isUsable}, Acceleration Boost: {engineStorage.accelerationBoostPercent}, " +
             $"Top Speed Boost: {engineStorage.topSpeedBoostPercent}, Fuel Economy Boost: {engineStorage.fuelEconomyBoostPercent}");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## CanSwapToSeat(BasePlayer,ModularCarSeat)

```csharp
```csharp
/// <summary>
/// Determines whether a player can swap to a specific seat in a modular car.
/// </summary>
/// <param name="player">The player attempting to swap seats.</param>
/// <param name="seat">The seat the player wants to swap to.</param>
/// <returns>
/// Returns `true` if the player can swap to the seat, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can swap seats.
/// </returns>
bool? CanSwapToSeat(BasePlayer player, ModularCarSeat seat)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to swap to a seat in the modular car.");

    if (player.IsSleeping)
    {
        Puts($"Player {player.displayName} cannot swap seats while sleeping.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (associatedSeatingModule.DoorsAreLockable)
		{
			ModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;
			if (modularCar != null)
			{
				return modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
			}
		}
		return true;
	}

```

## OnHuntEventStart(EggHuntEvent)

```csharp
```csharp
/// <summary>
/// Called when the egg hunt event starts.
/// </summary>
/// <param name="event">The egg hunt event that is starting.</param>
/// <returns>No return behavior.</returns>
void OnHuntEventStart(EggHuntEvent event)
{
    Puts($"Egg Hunt Event has started! Event ID: {event.EventID}, Active Players: {BasePlayer.activePlayerList.Count}");
}
```
```

### Source Code from the Library

```csharp

	private void StartEvent()
	{
		if (Interface.CallHook("OnHuntEventStart", this) == null)
		{
			if (initialSpawnIndex <= BasePlayer.activePlayerList.Count)
			{
				eggSpawningFrameBudget = float.PositiveInfinity;
			}
			EnableEggs();
		}
	}

```

## OnVehicleModuleSelected(Item,ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player selects a module for a vehicle.
/// </summary>
/// <param name="item">The item representing the vehicle module selected.</param>
/// <param name="garage">The modular car garage that contains the vehicle.</param>
/// <param name="player">The player who selected the vehicle module.</param>
/// <returns>
/// Returns a non-null value to prevent the selection action, or `null` to allow it.
/// </returns>
object OnVehicleModuleSelected(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.displayName} selected module: {item.info.displayName.english} for vehicle in garage.");

    if (item.info.shortname == "vehicle.module.restricted")
    {
        Puts($"Player {player.displayName} attempted to select a restricted module.");
        return "You cannot select this module.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!ObjectEx.IsUnityNull(container))
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!ObjectEx.IsUnityNull(container2))
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## OnPlayerReported(BasePlayer,string,string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player reports another player.
/// </summary>
/// <param name="reporter">The player who is making the report.</param>
/// <param name="reportMessage">The message detailing the report.</param>
/// <param name="targetId">The ID of the player being reported.</param>
/// <param name="targetName">The name of the player being reported.</param>
/// <param name="reportType">The type of report being made.</param>
/// <param name="additionalInfo">Any additional information regarding the report.</param>
/// <returns>No return behavior.</returns>
void OnPlayerReported(BasePlayer reporter, string reportMessage, string targetId, string targetName, string reportType, string additionalInfo)
{
    Puts($"Player {reporter.displayName} reported {targetName} (ID: {targetId}) with message: \"{reportMessage}\" of type: {reportType}.");

    if (reportType == "cheating")
    {
        Puts($"Report from {reporter.displayName} indicates potential cheating by {targetName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnPlayerReported(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		string text3 = msg.read.String();
		string text4 = msg.read.String();
		string text5 = msg.read.String();
		DebugEx.Log($"[PlayerReport] {this} reported {text5}[{text4}] - \"{text}\"");
		RCon.Broadcast(RCon.LogType.Report, new
		{
			PlayerId = UserIDString,
			PlayerName = displayName,
			TargetId = text4,
			TargetName = text5,
			Subject = text,
			Message = text2,
			Type = text3
		});
		Interface.CallHook("OnPlayerReported", this, text5, text4, text, text2, text3);
	}

```

## OnPhotoCapture(PhotoEntity,Item,BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a photo is captured by a player.
/// </summary>
/// <param name="photoEntity">The photo entity that holds the captured image.</param>
/// <param name="item">The item used to capture the photo.</param>
/// <param name="player">The player who captured the photo.</param>
/// <param name="imageData">The byte array containing the image data.</param>
/// <returns>No return behavior.</returns>
void OnPhotoCapture(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] imageData)
{
    Puts($"Player {player.displayName} captured a photo using item {item.info.displayName.english}.");

    if (imageData.Length > 102400)
    {
        Puts("Photo data exceeds the maximum allowed size.");
    }
    else
    {
        Puts("Photo captured successfully and is ready for processing.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(3uL)]
	private void TakePhoto(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Item item = GetItem();
		if (player == null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError("Failed to create photo item");
			return;
		}
		if (!item2.instanceData.subEntity.IsValid)
		{
			item2.Remove();
			Debug.LogError("Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if (baseNetworkable == null)
		{
			item2.Remove();
			Debug.LogError("Sub-entity was not found");
			return;
		}
		if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError("Sub-entity is not a photo");
			return;
		}
		photoEntity.SetImageData(player.userID, array);
		if (Interface.CallHook("OnPhotoCapture", photoEntity, item, player, array) != null)
		{
			return;
		}
		if (!player.inventory.GiveItem(item2))
		{
			item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
		}
		EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));
		if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
		{
			Vector3 position = GetOwnerPlayer().eyes.position;
			Vector3 vector = GetOwnerPlayer().eyes.HeadForward();
			List<BasePlayer> obj = Facepunch.Pool.Get<List<BasePlayer>>();
			Vis.Entities(position + vector * 5f, 5f, obj, 131072);
			foreach (BasePlayer item3 in obj)
			{
				if (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
				{
					hasSentAchievement = true;
					GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
					break;
				}
			}
			Facepunch.Pool.FreeUnmanaged(ref obj);
		}
		item.LoseCondition(1f);
		Interface.CallHook("OnPhotoCaptured", photoEntity, item, player, array);
	}

```

## CanExplosiveStick(TimedExplosive,BaseEntity)

```csharp
```csharp
/// <summary>
/// Determines whether a timed explosive can stick to a specified entity.
/// </summary>
/// <param name="explosive">The timed explosive attempting to stick.</param>
/// <param name="entity">The entity to which the explosive is trying to attach.</param>
/// <returns>
/// Returns `true` if the explosive can stick to the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the explosive can stick.
/// </returns>
bool? CanExplosiveStick(TimedExplosive explosive, BaseEntity entity)
{
    Puts($"Checking if {explosive.info.displayName.english} can stick to {entity?.name ?? "unknown entity"}.");

    if (entity is BuildingBlock)
    {
        Puts("Explosive can stick to building blocks.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanStickTo(BaseEntity entity)
	{
		object obj = Interface.CallHook("CanExplosiveStick", this, entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (entity.TryGetComponent<DecorDeployable>(out var _))
		{
			return false;
		}
		if (entity is Drone)
		{
			return false;
		}
		if (entity is TravellingVendor)
		{
			return false;
		}
		return true;
	}

```

## OnVehicleLockableCheck(ModularCarCodeLock)

```csharp
```csharp
/// <summary>
/// Called to check if a vehicle can have a lock attached to it.
/// </summary>
/// <param name="vehicle">The vehicle being checked for lockability.</param>
/// <returns>
/// Returns `true` if the vehicle can have a lock, `false` if it cannot, 
/// or `null` to allow the default game logic to determine lockability.
/// </returns>
bool? OnVehicleLockableCheck(ModularCarCodeLock vehicle)
{
    Puts($"Checking if vehicle {vehicle.net.ID} can have a lock.");

    if (vehicle.owner.IsDead())
    {
        Puts($"Vehicle owner is dead; cannot attach a lock.");
        return false;
    }

    if (!vehicle.owner.HasDriverMountPoints())
    {
        Puts($"Vehicle owner does not have driver mount points; cannot attach a lock.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanHaveALock()
	{
		object obj = Interface.CallHook("OnVehicleLockableCheck", this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		if (!owner.IsDead())
		{
			return owner.HasDriverMountPoints();
		}
		return false;
	}

```

## CanAdministerVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Determines whether a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine in question.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine the player's permissions.
/// </returns>
bool? CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Checking administration rights for player {player.displayName} on vending machine {vendingMachine.net.ID}.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can administer the vending machine.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

```

## OnItemResearched(ResearchTable,int)

```csharp
```csharp
/// <summary>
/// Called when an item has been successfully researched at a research table.
/// </summary>
/// <param name="researchTable">The research table where the item was researched.</param>
/// <param name="scrapAmount">The amount of scrap used for the research.</param>
/// <returns>No return behavior.</returns>
void OnItemResearched(ResearchTable researchTable, int scrapAmount)
{
    Puts($"Item researched at {researchTable.name} using {scrapAmount} scrap.");
    
    if (scrapAmount > 100)
    {
        Puts("Researching this item is too expensive!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", this, num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount == num)
				{
					base.inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				base.inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
				item.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);
				if (!item.MoveToContainer(base.inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## OnPhotoCaptured(PhotoEntity,Item,BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a photo is captured by a player.
/// </summary>
/// <param name="photoEntity">The photo entity that holds the captured image data.</param>
/// <param name="item">The item used to capture the photo.</param>
/// <param name="player">The player who captured the photo.</param>
/// <param name="imageData">The byte array containing the image data of the captured photo.</param>
/// <returns>No return behavior.</returns>
void OnPhotoCaptured(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] imageData)
{
    Puts($"Player {player.displayName} captured a photo using item {item.info.displayName.english}.");

    if (imageData.Length > 102400)
    {
        Puts("Captured photo exceeds size limit.");
    }
    else
    {
        Puts("Photo captured successfully and is ready for processing.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(3uL)]
	private void TakePhoto(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Item item = GetItem();
		if (player == null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError("Failed to create photo item");
			return;
		}
		if (!item2.instanceData.subEntity.IsValid)
		{
			item2.Remove();
			Debug.LogError("Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if (baseNetworkable == null)
		{
			item2.Remove();
			Debug.LogError("Sub-entity was not found");
			return;
		}
		if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError("Sub-entity is not a photo");
			return;
		}
		photoEntity.SetImageData(player.userID, array);
		if (Interface.CallHook("OnPhotoCapture", photoEntity, item, player, array) != null)
		{
			return;
		}
		if (!player.inventory.GiveItem(item2))
		{
			item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
		}
		EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));
		if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
		{
			Vector3 position = GetOwnerPlayer().eyes.position;
			Vector3 vector = GetOwnerPlayer().eyes.HeadForward();
			List<BasePlayer> obj = Facepunch.Pool.Get<List<BasePlayer>>();
			Vis.Entities(position + vector * 5f, 5f, obj, 131072);
			foreach (BasePlayer item3 in obj)
			{
				if (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
				{
					hasSentAchievement = true;
					GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
					break;
				}
			}
			Facepunch.Pool.FreeUnmanaged(ref obj);
		}
		item.LoseCondition(1f);
		Interface.CallHook("OnPhotoCaptured", photoEntity, item, player, array);
	}

```

## OnRemoveDying(GrowableEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a dying growable entity is removed.
/// </summary>
/// <param name="receiver">The player who is receiving the item from the dying entity.</param>
/// <returns>No return behavior.</returns>
void OnRemoveDying(GrowableEntity entity, BasePlayer receiver)
{
    Puts($"Removing dying entity: {entity.name} for player: {receiver?.displayName ?? "world"}.");

    if (receiver != null)
    {
        Puts($"Player {receiver.displayName} will receive the item from the dying entity.");
    }
    else
    {
        Puts("No player to receive the item; it will be dropped in the world.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RemoveDying(BasePlayer receiver)
	{
		if (State == PlantProperties.State.Dying && !(Properties.removeDyingItem == null) && Interface.CallHook("OnRemoveDying", this, receiver) == null)
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, Vector3.up);
			}
			Item item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);
			if (receiver != null)
			{
				receiver.GiveItem(item, GiveItemReason.PickedUp);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
			}
			TellPlanter();
			Die();
		}
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player performs an attack.
/// </summary>
/// <param name="player">The player who is attacking.</param>
/// <param name="hitInfo">Information about the attack, including the target and damage details.</param>
/// <returns>
/// Returns a non-null value to prevent the default attack behavior. 
/// If `null` is returned, the attack proceeds as normal.
/// </returns>
object OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attacking with weapon: {hitInfo.Weapon?.info.shortname ?? "unknown"}.");

    if (hitInfo.HitEntity is BasePlayer targetPlayer)
    {
        Puts($"Player {player.displayName} is attacking {targetPlayer.displayName}.");
    }

    // Example condition to block the attack
    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot attack while in a safe zone.");
        return true; // Prevent the attack
    }

    return null; // Allow the attack to proceed
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", GetOwnerPlayer(), info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (info.DoHitEffects)
		{
			if (base.isServer)
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.server.ImpactEffect(info);
				}
			}
			else
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.client.ImpactEffect(info);
				}
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay);
		}
	}

```

## OnMlrsFired(MLRS,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a Multiple Launch Rocket System (MLRS) has fired.
/// </summary>
/// <param name="mlrs">The MLRS instance that fired.</param>
/// <param name="owner">The player who owns and fired the MLRS.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFired(MLRS mlrs, BasePlayer owner)
{
    Puts($"MLRS fired by player {owner.displayName} (ID: {owner.UserIDString}).");
    
    // Additional logic can be added here, such as logging or triggering events.
}
```
```

### Source Code from the Library

```csharp

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !(_mounted == null) && Interface.CallHook("OnMlrsFire", this, owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			InvokeRepeating(FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", this, owner);
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to access the locked entity.</param>
/// <param name="codeLock">The code lock associated with the entity.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine access permissions.
/// </returns>
bool? CanUseLockedEntity(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is trying to access a locked entity with CodeLock ID: {codeLock.net.ID}.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can access all locked entities.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player finishes looting.
/// </summary>
/// <param name="loot">The loot object associated with the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot loot)
{
    Puts($"Player {loot.baseEntity.displayName} has finished looting.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		base.baseEntity.HasClosedLoot();
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		ClearContainers();
		entitySource = null;
		itemSource = null;
	}

```

## CanBeHomingTargeted(AttackHeliPilotFlare)

```csharp
```csharp
/// <summary>
/// Determines whether the specified attack helicopter pilot can be targeted by homing missiles.
/// </summary>
/// <param name="heliPilot">The attack helicopter pilot to check.</param>
/// <returns>
/// Returns `true` if the helicopter pilot can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the pilot can be targeted.
/// </returns>
bool? CanBeHomingTargeted(AttackHeliPilotFlare heliPilot)
{
    Puts($"Checking if Attack Helicopter Pilot ID: {heliPilot.net.ID} can be targeted by homing missiles.");
    return null; // Default behavior will be used
}
```
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnRemoteIdentifierUpdate(PoweredRemoteControlEntity,string)

```csharp
```csharp
/// <summary>
/// Called when the remote identifier of a powered remote control entity is updated.
/// </summary>
/// <param name="remoteControl">The powered remote control entity whose identifier is being updated.</param>
/// <param name="newIdentifier">The new identifier being set for the remote control entity.</param>
/// <returns>
/// Returns a non-null value to prevent the identifier update, or `null` to allow the update to proceed.
/// </returns>
object OnRemoteIdentifierUpdate(PoweredRemoteControlEntity remoteControl, string newIdentifier)
{
    Puts($"Remote Control ID is being updated to: {newIdentifier} for entity ID: {remoteControl.net.ID}");
    
    if (newIdentifier == "forbiddenID")
    {
        Puts("Update rejected: forbidden identifier.");
        return "This identifier is not allowed.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		if (Interface.CallHook("OnRemoteIdentifierUpdate", this, newID) != null)
		{
			return;
		}
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!RemoteControlEntity.IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			if (!Rust.Application.isLoadingSave)
			{
				SendNetworkUpdate();
			}
		}
	}

```

## OnEntitySnapshot(BaseNetworkable,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when an entity snapshot is sent to a network connection.
/// </summary>
/// <param name="entity">The entity being sent in the snapshot.</param>
/// <param name="connection">The network connection to which the snapshot is being sent.</param>
/// <returns>
/// Returns a non-null value to prevent the entity snapshot from being sent. 
/// If `null` is returned, the snapshot will be sent as normal.
/// </returns>
object OnEntitySnapshot(BaseNetworkable entity, Network.Connection connection)
{
    Puts($"Sending snapshot for entity {entity.net.ID} to connection {connection.userid}.");
    
    if (entity is BasePlayer player && player.IsInvisible)
    {
        Puts($"Entity {entity.net.ID} is invisible and will not be sent.");
        return true; // Prevent sending the snapshot
    }
    
    return null; // Allow sending the snapshot
}
```
```

### Source Code from the Library

```csharp

	public void SendEntitySnapshot(BaseNetworkable ent)
	{
		if (Interface.CallHook("OnEntitySnapshot", ent, net.connection) != null)
		{
			return;
		}
		using (TimeWarning.New("SendEntitySnapshot"))
		{
			if (!(ent == null) && ent.net != null && ent.ShouldNetworkTo(this))
			{
				NetWrite netWrite = Network.Net.sv.StartWrite();
				net.connection.validate.entityUpdates++;
				SaveInfo saveInfo = default(SaveInfo);
				saveInfo.forConnection = net.connection;
				saveInfo.forDisk = false;
				SaveInfo saveInfo2 = saveInfo;
				netWrite.PacketID(Message.Type.Entities);
				netWrite.UInt32(net.connection.validate.entityUpdates);
				ent.ToStreamForNetwork(netWrite, saveInfo2);
				netWrite.Send(new SendInfo(net.connection));
			}
		}
	}

```

## OnTurretIdentifierSet(AutoTurret,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a turret's identifier is set by a player.
/// </summary>
/// <param name="turret">The turret whose identifier is being set.</param>
/// <param name="player">The player setting the turret's identifier.</param>
/// <param name="newIdentifier">The new identifier being set for the turret.</param>
/// <returns>
/// Returns `null` to allow the identifier change, or any non-null value to prevent the change.
/// </returns>
object OnTurretIdentifierSet(AutoTurret turret, BasePlayer player, string newIdentifier)
{
    Puts($"Player {player.displayName} is attempting to set turret ID to: {newIdentifier}.");
    
    if (newIdentifier == "restrictedID")
    {
        Puts($"Player {player.displayName} is not allowed to set the turret ID to a restricted value.");
        return "This identifier is not allowed.";
    }
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Server_SetID(RPCMessage msg)
	{
		if (msg.player == null || !CanChangeID(msg.player))
		{
			return;
		}
		string text = msg.read.String();
		if (string.IsNullOrEmpty(text) || ComputerStation.IsValidIdentifier(text))
		{
			string text2 = msg.read.String();
			if (ComputerStation.IsValidIdentifier(text2) && text == GetIdentifier() && Interface.CallHook("OnTurretIdentifierSet", this, msg.player, text2) == null)
			{
				Debug.Log("SetID success!");
				UpdateIdentifier(text2);
			}
		}
	}

```

## OnPlayerKeepAlive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a keep-alive message while wounded.
/// </summary>
/// <param name="woundedPlayer">The player who is currently wounded.</param>
/// <param name="interactingPlayer">The player sending the keep-alive message.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKeepAlive(BasePlayer woundedPlayer, BasePlayer interactingPlayer)
{
    Puts($"Player {interactingPlayer.displayName} sent a keep-alive for wounded player {woundedPlayer.displayName}.");
    
    if (woundedPlayer.IsWounded())
    {
        Puts($"Wounded player {woundedPlayer.displayName} is being kept alive by {interactingPlayer.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_KeepAlive(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerKeepAlive", this, msg.player) == null)
		{
			ProlongWounding(10f);
		}
	}

```

## OnCargoPlaneSignaled(BaseEntity,SupplySignal)

```csharp
```csharp
/// <summary>
/// Called when a cargo plane is signaled to drop supplies.
/// </summary>
/// <param name="entity">The entity representing the cargo plane.</param>
/// <param name="supplySignal">The supply signal that triggered the drop.</param>
/// <returns>No return behavior.</returns>
void OnCargoPlaneSignaled(BaseEntity entity, SupplySignal supplySignal)
{
    Puts($"Cargo plane signaled: {entity?.name} with signal type: {supplySignal?.signalType}");
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		BaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);
		if ((bool)baseEntity)
		{
			Vector3 vector = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));
			baseEntity.SendMessage("InitDropPosition", base.transform.position + vector, SendMessageOptions.DontRequireReceiver);
			baseEntity.Spawn();
			Interface.CallHook("OnCargoPlaneSignaled", baseEntity, this);
		}
		Invoke(FinishUp, 210f);
		SetFlag(Flags.On, b: true);
		SendNetworkUpdateImmediate();
	}

```

## OnBigWheelWin(BigWheelGame,Item,BigWheelBettingTerminal,int)

```csharp
```csharp
/// <summary>
/// Called when a player wins at the Big Wheel game.
/// </summary>
/// <param name="game">The Big Wheel game instance.</param>
/// <param name="winningItem">The item that the player has won.</param>
/// <param name="terminal">The betting terminal where the game was played.</param>
/// <param name="multiplier">The multiplier applied to the winnings.</param>
/// <returns>No return behavior.</returns>
void OnBigWheelWin(BigWheelGame game, Item winningItem, BigWheelBettingTerminal terminal, int multiplier)
{
    Puts($"Player has won at the Big Wheel! Item: {winningItem.info.displayName.english}, " +
         $"Terminal: {terminal.net.ID}, Multiplier: {multiplier}.");
    
    if (multiplier > 5)
    {
        Puts("Jackpot! High multiplier awarded!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) == null)
				{
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanEntityBeHostile(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether the specified player entity can be considered hostile.
/// </summary>
/// <param name="player">The player entity to check for hostility.</param>
/// <returns>
/// Returns `true` if the entity can be hostile; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine hostility.
/// </returns>
bool? CanEntityBeHostile(BasePlayer player)
{
    Puts($"Checking hostility for player {player.displayName} (ID: {player.UserIDString}).");

    if (player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} is in a safe zone and cannot be hostile.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return State.unHostileTimestamp > TimeEx.currentTimestamp;
	}

```

## OnSamSiteModeToggle(SamSite,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when the SAM site mode is toggled between defender and normal mode.
/// </summary>
/// <param name="samSite">The SAM site that is being toggled.</param>
/// <param name="player">The player who is toggling the mode.</param>
/// <param name="isDefenderMode">Indicates whether the SAM site is being set to defender mode.</param>
/// <returns>No return behavior.</returns>
void OnSamSiteModeToggle(SamSite samSite, BasePlayer player, bool isDefenderMode)
{
    Puts($"SAM Site {samSite.net.ID} mode toggled by {player.displayName} to {(isDefenderMode ? "Defender" : "Normal")} mode.");
    
    if (isDefenderMode)
    {
        Puts($"SAM Site {samSite.net.ID} is now in Defender Mode, ready to engage targets.");
    }
    else
    {
        Puts($"SAM Site {samSite.net.ID} is now in Normal Mode, disengaged from targets.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	private void ToggleDefenderMode(RPCMessage msg)
	{
		if (staticRespawn)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!(player == null) && player.CanBuild())
		{
			bool flag = msg.read.Bit();
			if (flag != IsInDefenderMode() && Interface.CallHook("OnSamSiteModeToggle", this, player, flag) == null)
			{
				SetFlag(Flag_ManuallySetMode, flag);
				SetFlag(Flag_TargetMode, flag);
			}
		}
	}

```

## OnHelicopterAttack(CH47HelicopterAIController,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when the helicopter is attacked.
/// </summary>
/// <param name="helicopter">The helicopter that is being attacked.</param>
/// <param name="hitInfo">Information about the hit, including damage and source.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterAttack(CH47HelicopterAIController helicopter, HitInfo hitInfo)
{
    Puts($"Helicopter {helicopter.net.ID} is under attack! Damage: {hitInfo.damage} from {hitInfo.Initiator?.displayName ?? "unknown source"}.");
    
    if (hitInfo.damage > 50)
    {
        Puts("Heavy damage detected! Initiating evasive maneuvers.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttack", this, info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved9, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

```

## OnSleepingBagDestroyed(SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The sleeping bag that is being destroyed.</param>
/// <param name="userId">The ID of the user who owns the sleeping bag.</param>
/// <returns>No return behavior.</returns>
void OnSleepingBagDestroyed(SleepingBag sleepingBag, ulong userId)
{
    Puts($"Sleeping bag with ID {sleepingBag.net.ID} owned by user {userId} has been destroyed.");
    
    if (sleepingBag.deployerUserID == userId)
    {
        Puts($"User {userId} has successfully destroyed their own sleeping bag.");
    }
    else
    {
        Puts($"Sleeping bag destroyed by user {userId}, but it was not their own.");
    }
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) => x.net.ID == sleepingBag);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, userID) != null)
		{
			return false;
		}
		RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
		sleepingBag2.deployerUserID = 0uL;
		sleepingBag2.SendNetworkUpdate();
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if (basePlayer != null)
		{
			basePlayer.SendRespawnOptions();
			Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, userID);
			Facepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
		}
		return true;
	}

```

## CanAdministerVending(BasePlayer,NPCVendingMachine)

```csharp
```csharp
/// <summary>
/// Determines whether a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine in question.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine the player's permissions.
/// </returns>
bool? CanAdministerVending(BasePlayer player, NPCVendingMachine vendingMachine)
{
    Puts($"Checking administration rights for player {player.displayName} on vending machine {vendingMachine.net.ID}.");
    
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can administer the vending machine.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret acquires a new target.
/// </summary>
/// <param name="turret">The helicopter turret that is acquiring the target.</param>
/// <param name="target">The new target that the turret is aiming at.</param>
/// <returns>
/// Returns `null` to allow the turret to set the new target, or any non-null value to prevent the target change.
/// </returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts($"Helicopter Turret {turret.net.ID} is attempting to target {target?.net.ID}.");
    
    if (target is Player player && player.IsInSafeZone())
    {
        Puts($"Targeting player {player.displayName} is not allowed as they are in a safe zone.");
        return true; // Prevent targeting
    }

    return null; // Allow targeting
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## OnFishCaught(ItemDefinition,BaseFishingRod,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a fish is caught by a player using a fishing rod.
/// </summary>
/// <param name="fish">The definition of the fish that was caught.</param>
/// <param name="fishingRod">The fishing rod used to catch the fish.</param>
/// <param name="player">The player who caught the fish.</param>
/// <returns>No return behavior.</returns>
void OnFishCaught(ItemDefinition fish, BaseFishingRod fishingRod, BasePlayer player)
{
    Puts($"Player {player.displayName} caught a fish: {fish.displayName.english} using {fishingRod.GetType().Name}.");
    
    if (fish.shortname == "shark")
    {
        Puts($"Warning: Player {player.displayName} caught a shark!");
    }
}
```
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine if a world projectile can be created based on the hit information and item definition.
/// </summary>
/// <param name="info">The hit information related to the projectile creation.</param>
/// <param name="itemDef">The item definition of the projectile being created.</param>
/// <returns>
/// Returns `null` to allow the projectile creation, or any non-null value to prevent it.
/// </returns>
object CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
{
    Puts($"Attempting to create a world projectile with item: {itemDef.displayName.english} at position: {info.HitPositionWorld}.");

    if (itemDef.shortname == "rocket.launcher")
    {
        Puts("Rocket launchers cannot create world projectiles.");
        return true; // Prevent creation
    }

    return null; // Allow creation
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if (droppedItem != null)
			{
				droppedItem.StickIn();
			}
			else
			{
				baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			Rigidbody component = baseEntity.GetComponent<Rigidbody>();
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## OnInventoryItemsCount(PlayerInventory,int)

```csharp
```csharp
/// <summary>
/// Called to get the count of a specific item in the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory being checked.</param>
/// <param name="itemId">The ID of the item to count.</param>
/// <returns>
/// Returns the number of items in the inventory with the specified item ID. 
/// If the method returns a non-integer value, the default inventory count logic will be used.
/// </returns>
int OnInventoryItemsCount(PlayerInventory inventory, int itemId)
{
    Puts($"Counting items in inventory for item ID: {itemId}.");
    
    if (itemId == 12345) // Example item ID for a special case
    {
        Puts("Special item detected, returning a fixed count of 10.");
        return 10; // Fixed count for a special item
    }

    return -1; // Indicate that the default logic should be used
}
```
```

### Source Code from the Library

```csharp

	public int GetAmount(int itemid)
	{
		if (itemid == 0)
		{
			return 0;
		}
		object obj = Interface.CallHook("OnInventoryItemsCount", this, itemid);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerWear != null)
		{
			num += containerWear.GetAmount(itemid, onlyUsableAmounts: true);
		}
		return num;
	}

```

## OnMlrsRocketFired(MLRS,ServerProjectile)

```csharp
```csharp
/// <summary>
/// Called when a rocket is fired from the MLRS (Multiple Launch Rocket System).
/// </summary>
/// <param name="mlrs">The MLRS instance that fired the rocket.</param>
/// <param name="projectile">The projectile that was fired.</param>
/// <returns>No return behavior.</returns>
void OnMlrsRocketFired(MLRS mlrs, ServerProjectile projectile)
{
    Puts($"Rocket fired from MLRS ID: {mlrs.net.ID}, Projectile ID: {projectile.net.ID}, " +
         $"Position: {projectile.transform.position}, Owner: {projectile.owner?.displayName ?? "Unknown"}");
}
```
```

### Source Code from the Library

```csharp

	public void FireNextRocket()
	{
		RocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount(AmmoTypes.MLRS_ROCKET);
		if (nextRocketIndex < 0 || nextRocketIndex >= RocketAmmoCount || IsBroken())
		{
			EndFiring();
			return;
		}
		StorageContainer rocketContainer = GetRocketContainer();
		Vector3 firingPos = firingPoint.position + firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;
		float num = 1f;
		if (radiusModIndex < radiusMods.Length)
		{
			num = radiusMods[radiusModIndex];
		}
		radiusModIndex++;
		Vector2 vector = UnityEngine.Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;
		Vector3 target = TrueHitPos + new Vector3(vector.x, 0f, vector.y);
		float requiredGravity;
		Vector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, target, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out requiredGravity);
		if (TryFireProjectile(rocketContainer, AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))
		{
			projectile.gravityModifier = requiredGravity / (0f - UnityEngine.Physics.gravity.y);
			Interface.CallHook("OnMlrsRocketFired", this, projectile);
			nextRocketIndex--;
		}
		else
		{
			EndFiring();
		}
	}

```

## OnBackpackDrop(Item,PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to drop their backpack.
/// </summary>
/// <param name="backpack">The backpack item being dropped.</param>
/// <param name="inventory">The player's inventory from which the backpack is being dropped.</param>
/// <returns>No return behavior.</returns>
void OnBackpackDrop(Item backpack, PlayerInventory inventory)
{
    Puts($"Player {inventory.Owner.displayName} is dropping their backpack: {backpack.info.displayName.english}.");
    
    if (backpack.amount > 1)
    {
        Puts($"Player {inventory.Owner.displayName} has multiple backpacks. Dropping one.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void TryDropBackpack()
	{
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack != null && base.baseEntity.isServer && Interface.CallHook("OnBackpackDrop", anyBackpack, this) == null)
		{
			anyBackpack.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
		}
	}

```

## CanDemolish(BasePlayer,StabilityEntity)

```csharp
```csharp
/// <summary>
/// Determines whether a player can demolish a specified stability entity.
/// </summary>
/// <param name="player">The player attempting to demolish the entity.</param>
/// <param name="entity">The stability entity that is being targeted for demolition.</param>
/// <returns>
/// Returns `true` if the player can demolish the entity; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will determine if the player can demolish the entity.
/// </returns>
bool? CanDemolish(BasePlayer player, StabilityEntity entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to demolish {entity.name}.");

    if (!entity.CanBeDemolished)
    {
        Puts($"Entity {entity.name} cannot be demolished.");
        return false;
    }

    if (!player.HasDemolishPrivilege(entity))
    {
        Puts($"Player {player.displayName} does not have the privilege to demolish {entity.name}.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CanBeDemolished && IsDemolishable())
		{
			return HasDemolishPrivilege(player);
		}
		return false;
	}

```

## OnEntityVisibilityCheck(BaseEntity,BasePlayer,uint,string,float)

```csharp
```csharp
/// <summary>
/// Called to check if a player can see a specific entity within a given distance.
/// </summary>
/// <param name="entityId">The unique identifier of the entity being checked.</param>
/// <param name="debugName">A debug name for logging purposes.</param>
/// <param name="entity">The entity to check visibility for.</param>
/// <param name="player">The player attempting to see the entity.</param>
/// <param name="maximumDistance">The maximum distance within which visibility is checked.</param>
/// <returns>
/// Returns `true` if the player can see the entity, `false` if they cannot, 
/// or `null` to allow the default visibility logic to determine the result.
/// </returns>
bool? OnEntityVisibilityCheck(uint entityId, string debugName, BaseEntity entity, BasePlayer player, float maximumDistance)
{
    Puts($"Checking visibility for Entity ID: {entityId}, Debug Name: {debugName}, Player: {player.displayName}");

    if (entity.IsInvisible())
    {
        Puts($"Entity {entityId} is invisible to player {player.displayName}.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityVisibilityCheck", ent, player, id, debugName, maximumDistance);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 1218519041))
				{
					if (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))
					{
						return ent.IsVisible(player.eyes.position, maximumDistance);
					}
					return true;
				}
				return false;
			}

```

## OnScientistRecalled(BradleyAPC,ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when a scientist NPC is recalled from a vehicle or position.
/// </summary>
/// <param name="apc">The APC vehicle from which the scientist is being recalled.</param>
/// <param name="scientist">The scientist NPC that is being recalled.</param>
/// <returns>No return behavior.</returns>
void OnScientistRecalled(BradleyAPC apc, ScientistNPC scientist)
{
    Puts($"Scientist {scientist.displayName} has been recalled from APC ID: {apc.net.ID}.");
    if (scientist.IsActive)
    {
        Puts($"Recalled scientist {scientist.displayName} was active.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void OnScientistMounted(ScientistNPC scientist)
	{
		if (!(scientist == null))
		{
			if (scientistPrefabLookUp.TryGetValue(scientist.prefabID, out var value))
			{
				mountedScientistPrefabs.Add(value);
			}
			activeScientists.Remove(scientist);
			numberOfScientistsToSpawn++;
			Interface.CallHook("OnScientistRecalled", this, scientist);
		}
	}

```

## CanUpdateSign(BasePlayer,CarvablePumpkin)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update the sign on a Carvable Pumpkin.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="pumpkin">The Carvable Pumpkin being updated.</param>
/// <returns>
/// Returns `true` if the player can update the sign, or `false` if they cannot.
/// If the method returns `null`, the default game logic will determine if the player can update the sign.
/// </returns>
bool? CanUpdateSign(BasePlayer player, CarvablePumpkin pumpkin)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to update the sign on a Carvable Pumpkin.");

    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and can update the sign.");
        return true;
    }

    if (pumpkin.IsLocked() && (ulong)player.userID != pumpkin.OwnerID)
    {
        Puts($"Player {player.displayName} is not the owner and cannot update the locked sign.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

```

## OnExperimentStart(Workbench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an experiment starts at a workbench.
/// </summary>
/// <param name="workbench">The workbench where the experiment is being conducted.</param>
/// <param name="player">The player initiating the experiment.</param>
/// <returns>
/// Returns a non-null value to prevent the experiment from starting. 
/// If `null` is returned, the experiment proceeds as normal.
/// </returns>
object OnExperimentStart(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment started at workbench by player {player.displayName} (ID: {player.UserIDString}).");

    if (player.inventory.GetAmount("experiment_item") < 1)
    {
        Puts($"Player {player.displayName} does not have the required experiment item.");
        return "You need an experiment item to start this experiment.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## CanSetRelationship(BasePlayer,BasePlayer,RelationshipManager.RelationshipType,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can set a relationship with another player.
/// </summary>
/// <param name="player">The player attempting to set the relationship.</param>
/// <param name="otherPlayer">The player with whom the relationship is being set.</param>
/// <param name="type">The type of relationship being set.</param>
/// <param name="weight">The weight of the relationship, default is 1.</param>
/// <returns>
/// Returns `true` if the relationship can be set, or `false` if it cannot.
/// If the method returns `null`, the default game logic will determine if the relationship can be set.
/// </returns>
bool? CanSetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipManager.RelationshipType type, int weight = 1)
{
    Puts($"Player {player.displayName} is attempting to set relationship with {otherPlayer.displayName} as {type} with weight {weight}.");

    if (type == RelationshipManager.RelationshipType.Enemy && player.IsInSafeZone())
    {
        Puts($"Player {player.displayName} cannot set an enemy relationship while in a safe zone.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight = 1, bool sendImmediate = false)
	{
		if (!contacts)
		{
			return;
		}
		ulong num = player.userID.Get();
		ulong num2 = otherPlayer.userID.Get();
		if (player == null || player == otherPlayer || player.IsNpc || (otherPlayer != null && otherPlayer.IsNpc) || Interface.CallHook("CanSetRelationship", player, otherPlayer, type, weight) != null)
		{
			return;
		}
		PlayerRelationships playerRelationships = GetRelationships(num);
		if (!CleanupOldContacts(playerRelationships, num))
		{
			CleanupOldContacts(playerRelationships, num, RelationshipType.Enemy);
		}
		PlayerRelationshipInfo relations = playerRelationships.GetRelations(num2);
		bool flag = false;
		if (relations.type != type)
		{
			flag = true;
			relations.weight = 0;
		}
		relations.type = type;
		relations.weight += weight;
		float num3 = UnityEngine.Time.realtimeSinceStartup - relations.lastMugshotTime;
		if (flag || relations.mugshotCrc == 0 || num3 >= mugshotUpdateInterval)
		{
			bool flag2 = otherPlayer.IsAlive();
			bool num4 = player.SecondsSinceAttacked > 10f && !player.IsAiming;
			float num5 = 100f;
			if (num4)
			{
				Vector3 normalized = (otherPlayer.eyes.position - player.eyes.position).normalized;
				bool flag3 = Vector3.Dot(player.eyes.HeadForward(), normalized) >= 0.6f;
				float num6 = Vector3Ex.Distance2D(player.transform.position, otherPlayer.transform.position);
				if (flag2 && num6 < num5 && flag3)
				{
					ClientRPC(RpcTarget.Player("CLIENT_DoMugshot", player), num2);
					relations.lastMugshotTime = UnityEngine.Time.realtimeSinceStartup;
				}
			}
		}
		if (sendImmediate)
		{
			SendRelationshipsFor(player);
		}
		else
		{
			MarkRelationshipsDirtyFor(player);
		}
	}

```

## OnPlayerSleepEnd(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player finishes sleeping.
/// </summary>
/// <param name="player">The player who has ended their sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnd(BasePlayer player)
{
    Puts($"Player {player.displayName} has woken up from sleep.");
    
    if (player.IsRestrained)
    {
        Puts($"Player {player.displayName} is restrained and cannot move immediately.");
    }
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", this) == null)
		{
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: true);
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if ((ulong)userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			CancelInvoke(ScheduledDeath);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
			}
			InvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				RemoveFromTriggers();
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", this);
			EACServer.LogPlayerSpawn(this);
			if (TotalPingCount > 0)
			{
				SendPingsToClient();
			}
			if (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))
			{
				ClientRPC(RpcTarget.Player("PromptToStartTutorial", this));
			}
		}
	}

```

## OnMissionStart(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission starts for a player.
/// </summary>
/// <param name="mission">The mission that is starting.</param>
/// <param name="instance">The instance of the mission being started.</param>
/// <param name="assignee">The player assigned to the mission.</param>
/// <returns>No return behavior.</returns>
void OnMissionStart(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts($"Mission {mission.missionName} has started for player {assignee.displayName} (ID: {assignee.UserIDString}).");

    if (assignee.IsInCreativeMode)
    {
        Puts($"Player {assignee.displayName} is in creative mode and will not receive mission penalties.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", this, instance, assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", this, instance, assignee);
	}

```

## CanBuild(Planner,Construction,Construction.Target)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can build a specific construction at a target location.
/// </summary>
/// <param name="planner">The planner used for the building process.</param>
/// <param name="construction">The construction that the player is attempting to build.</param>
/// <param name="target">The target location and context for the construction.</param>
/// <returns>
/// Returns `true` if the player can build the construction at the target location; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the player can build.
/// </returns>
bool? CanBuild(Planner planner, Construction construction, Construction.Target target)
{
    Puts($"Player {target.player.displayName} is attempting to build {construction.fullName} at position {target.position}.");

    if (construction.fullName == "foundation.stone")
    {
        Puts($"Player {target.player.displayName} is not allowed to build a stone foundation.");
        return false;
    }

    if (target.onTerrain)
    {
        Puts($"Building on terrain is allowed for {construction.fullName}.");
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.Antihack, false);
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindConstruction, false);
			ConstructionErrors.Log(ownerPlayer, msg.blockID.ToString());
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			using (ItemAmountList itemAmountList = Facepunch.Pool.Get<ItemAmountList>())
			{
				itemAmountList.amount = Facepunch.Pool.Get<List<float>>();
				itemAmountList.itemID = Facepunch.Pool.Get<List<int>>();
				GetConstructionCost(itemAmountList, construction);
				ownerPlayer.ClientRPC(RpcTarget.Player("Client_OnRepairFailedResources", ownerPlayer), itemAmountList);
				return;
			}
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.NoPermission, false);
			return;
		}
		Deployable deployable = GetDeployable(msg.entity);
		if (construction.deployable != deployable)
		{
			ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.DeployableMismatch, false);
			return;
		}
		Construction.Target target = default(Construction.Target);
		if (msg.entity.IsValid)
		{
			target.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if (target.entity == null)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindEntity, false);
				ConstructionErrors.Log(ownerPlayer, msg.entity.ToString());
				return;
			}
			msg.ray = new Ray(target.entity.transform.TransformPoint(msg.ray.origin), target.entity.transform.TransformDirection(msg.ray.direction));
			msg.position = target.entity.transform.TransformPoint(msg.position);
			msg.normal = target.entity.transform.TransformDirection(msg.normal);
			msg.rotation = target.entity.transform.rotation * msg.rotation;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != "")
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				if (target.socket == null)
				{
					ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CouldntFindSocket, false);
					ConstructionErrors.Log(ownerPlayer, msg.socket.ToString());
					return;
				}
			}
			else if (target.entity is Door)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.CantDeployOnDoor, false);
				return;
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.isHoldingShift = msg.isHoldingShift;
		target.valid = true;
		if (Interface.CallHook("CanBuild", this, construction, target) != null)
		{
			return;
		}
		if (ShouldParent(target.entity, deployable))
		{
			Vector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);
			float num = target.entity.Distance(position);
			if (num > 1f)
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.ParentTooFar, false);
				ConstructionErrors.Log(ownerPlayer, num.ToString());
				return;
			}
		}
		BaseEntity baseEntity = DoBuild(target, construction);
		if (baseEntity != null && ownerPlayer.IsInCreativeMode && Creative.freeBuild && baseEntity is BuildingBlock buildingBlock)
		{
			ConstructionGrade constructionGrade = construction.grades[msg.setToGrade];
			if (buildingBlock.currentGrade != constructionGrade)
			{
				buildingBlock.ChangeGradeAndSkin(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			}
		}
	}

```

## OnInventoryNetworkUpdate(PlayerInventory,ItemContainer,ProtoBuf.UpdateItemContainer,PlayerInventory.Type,PlayerInventory.NetworkInventoryMode)

```csharp
```csharp
/// <summary>
/// Called when the inventory of a player is updated over the network.
/// </summary>
/// <param name="playerInventory">The player's inventory that is being updated.</param>
/// <param name="container">The item container associated with the inventory update.</param>
/// <param name="updateData">The data representing the updated item container.</param>
/// <param name="type">The type of inventory being updated.</param>
/// <param name="mode">The network mode for the inventory update.</param>
/// <returns>No return behavior.</returns>
void OnInventoryNetworkUpdate(PlayerInventory playerInventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateData, PlayerInventory.Type type, PlayerInventory.NetworkInventoryMode mode)
{
    Puts($"Inventory update for player {playerInventory.Owner.displayName} of type {type} in mode {mode}.");

    if (container == null)
    {
        Puts("No item container found for the inventory update.");
        return;
    }

    Puts($"Updated container ID: {container.uid}, Item Count: {container.itemList.Count}");
}
```
```

### Source Code from the Library

```csharp

	public void SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode)
	{
		using UpdateItemContainer updateItemContainer = Facepunch.Pool.Get<UpdateItemContainer>();
		updateItemContainer.type = (int)type;
		if (container != null)
		{
			container.dirty = false;
			updateItemContainer.container = Facepunch.Pool.Get<List<ProtoBuf.ItemContainer>>();
			bool bIncludeContainer = type != Type.Wear || mode == NetworkInventoryMode.LocalPlayer;
			updateItemContainer.container.Add(container.Save(bIncludeContainer));
		}
		if (Interface.CallHook("OnInventoryNetworkUpdate", this, container, updateItemContainer, type, mode) != null)
		{
			return;
		}
		switch (mode)
		{
		case NetworkInventoryMode.Everyone:
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("UpdatedItemContainer"), updateItemContainer);
			break;
		case NetworkInventoryMode.LocalPlayer:
			base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", base.baseEntity), updateItemContainer);
			break;
		case NetworkInventoryMode.EveryoneButLocal:
			if (base.baseEntity.net?.group?.subscribers == null)
			{
				break;
			}
			{
				foreach (Connection subscriber in base.baseEntity.net.group.subscribers)
				{
					if (subscriber.player is BasePlayer basePlayer && basePlayer != base.baseEntity)
					{
						base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", basePlayer), updateItemContainer);
					}
				}
				break;
			}
		}
	}

```

## OnTeamDisband(RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team is disbanded.
/// </summary>
/// <param name="team">The team that is being disbanded.</param>
/// <returns>
/// Returns `null` to allow the team to be disbanded, or any non-null value to prevent the disbanding.
/// </returns>
object OnTeamDisband(RelationshipManager.PlayerTeam team)
{
    Puts($"Team with ID {team.teamID} is being disbanded. Members: {string.Join(", ", team.members)}");

    if (team.members.Count < 2)
    {
        Puts("Team disbanding prevented: Not enough members.");
        return "Cannot disband a team with less than 2 members.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Facepunch.Pool.Free(ref teamToDisband);
		}
	}

```

## CanCheckFuel(EntityFuelSystem,StorageContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines if a player can check the fuel of a storage container within interaction range.
/// </summary>
/// <param name="fuelSystem">The fuel system associated with the entity.</param>
/// <param name="fuelContainer">The storage container holding the fuel.</param>
/// <param name="player">The player attempting to check the fuel.</param>
/// <returns>
/// Returns `true` if the player can check the fuel, `false` if they cannot, 
/// or `null` if the default game logic should be used to determine the outcome.
/// </returns>
bool? CanCheckFuel(EntityFuelSystem fuelSystem, StorageContainer fuelContainer, BasePlayer player)
{
    Puts($"Player {player.displayName} is attempting to check fuel in container: {fuelContainer?.name ?? "Unknown"}.");

    if (fuelContainer == null)
    {
        Puts("No fuel container found.");
        return false;
    }

    if (player.IsInCreativeMode)
    {
        Puts($"Player {player.displayName} is in creative mode and can check fuel without restrictions.");
        return true;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool IsInFuelInteractionRange(BasePlayer player)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanCheckFuel", this, fuelContainer, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (fuelContainer != null)
		{
			float num = 0f;
			if (isServer)
			{
				num = 3f;
			}
			return fuelContainer.Distance(player.eyes.position) <= num;
		}
		return false;
	}

```

## CanBeHomingTargeted(CH47Helicopter)

```csharp
```csharp
/// <summary>
/// Determines whether the specified CH47 helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The CH47 helicopter to check.</param>
/// <returns>
/// Returns `true` if the helicopter can be targeted by homing missiles; otherwise, returns `false`.
/// If the method returns `null`, the default game logic will be used to determine if the helicopter can be targeted.
/// </returns>
bool? CanBeHomingTargeted(CH47Helicopter helicopter)
{
    Puts($"Checking if CH47 Helicopter ID: {helicopter.net.ID} can be targeted by homing missiles.");
    return false; // Default behavior, can be overridden by hooks.
}
```
```

### Source Code from the Library

```csharp

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnEntityDismounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player dismounts from an entity.
/// </summary>
/// <param name="entity">The entity from which the player is dismounting.</param>
/// <param name="player">The player who is dismounting.</param>
/// <returns>No return behavior.</returns>
void OnEntityDismounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.displayName} has dismounted from {entity.gameObject.name}.");
    
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.transform.rotation = Quaternion.identity;
			_mounted.ClientRPC(RpcTarget.Player("ForcePositionTo", _mounted), res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID.Get() + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
		}
		else
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.SendModelState(force: true);
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), res);
			}
			Facepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnActiveItemChanged(BasePlayer,Item,Item)

```csharp
```csharp
/// <summary>
/// Called when the active item of a player changes.
/// </summary>
/// <param name="player">The player whose active item has changed.</param>
/// <param name="previousItem">The item that was previously active.</param>
/// <param name="newItem">The item that is now active.</param>
/// <returns>No return behavior.</returns>
void OnActiveItemChanged(BasePlayer player, Item previousItem, Item newItem)
{
    Puts($"Player {player.displayName} changed active item from {previousItem?.info.displayName.english ?? "None"} " +
         $"to {newItem?.info.displayName.english ?? "None"}.");
    
    if (newItem != null && newItem.info.shortname == "rifle.ak")
    {
        Puts($"Player {player.displayName} has equipped an AK-47!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(ItemId itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnSendCommand(System.Collections.Generic.List<Network.Connection>,string,object[])

```csharp
```csharp
/// <summary>
/// Called when a command is sent to a list of connections.
/// </summary>
/// <param name="connections">The list of connections to which the command is being sent.</param>
/// <param name="command">The command string to be sent.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>No return behavior.</returns>
void OnSendCommand(List<Network.Connection> connections, string command, object[] args)
{
    Puts($"Sending command '{command}' to {connections.Count} connections.");
    foreach (var connection in connections)
    {
        Puts($"Command sent to connection ID: {connection.userid}");
    }
}
```
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(List<Connection> cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnSendCommand", cn, strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			netWrite.String(ConsoleSystem.BuildCommand(strCommand, args));
			netWrite.Send(new SendInfo(cn));
		}
	}

```

## IOnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnServerShutdown()
{
    Puts("Server is shutting down. Cleaning up resources and notifying players.");
}
```
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("IOnServerShutdown");
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## OnDecayHeal(DecayEntity)

```csharp
```csharp
/// <summary>
/// Called when a decay event occurs to potentially heal the entity.
/// </summary>
/// <param name="decayEntity">The entity that is undergoing decay.</param>
/// <returns>
/// Returns `null` to allow the default healing behavior, or any non-null value to prevent healing.
/// </returns>
object OnDecayHeal(DecayEntity decayEntity)
{
    Puts($"Decay healing check for entity ID: {decayEntity.net.ID}, Current Health: {decayEntity.healthFraction * decayEntity.MaxHealth()}");

    if (decayEntity.healthFraction < 0.5f)
    {
        Puts($"Entity ID: {decayEntity.net.ID} is critically decayed and will be healed.");
        return null; // Allow healing
    }

    Puts($"Entity ID: {decayEntity.net.ID} is stable and does not require healing.");
    return true; // Prevent healing
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnDecay(Decay decay, float decayDeltaTime)
	{
		lastDecayTick = UnityEngine.Time.time;
		if (HasParent() || !decay.ShouldDecay(this))
		{
			return;
		}
		float num = decayDeltaTime * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if (buildingPrivilege != null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", this) == null)
				{
					float num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();
					Heal(MaxHealth() * num2);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num;
		if (decayTimer < GetEntityDecayDelay())
		{
			return;
		}
		using (TimeWarning.New("DecayTick"))
		{
			float num3 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num3 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num3 -= decayPoint.protection;
					}
				}
			}
			if (Interface.CallHook("OnDecayDamage", this) == null && num3 > 0f)
			{
				float num4 = num / GetEntityDecayDuration() * MaxHealth();
				Hurt(num4 * num3 * decayVariance, DamageType.Decay);
			}
		}
	}

```

## OnItemCraftCancelled(ItemCraftTask,ItemCrafter)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is cancelled.
/// </summary>
/// <param name="task">The item crafting task that was cancelled.</param>
/// <param name="craftingStation">The entity or station that was performing the crafting.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task, ItemCrafter craftingStation)
{
    Puts($"Crafting task {task.taskUID} has been cancelled for item: {task.blueprint.targetItem.shortname}.");

    if (task.takenItems != null && task.takenItems.Count > 0)
    {
        foreach (Item takenItem in task.takenItems)
        {
            if (takenItem != null && takenItem.amount > 0)
            {
                Puts($"Returning {takenItem.amount} of {takenItem.info.displayName.english} to the player's inventory.");
            }
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask, this);
		owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(owner.inventory.containerMain))
					{
						takenItem.Drop(owner.inventory.containerMain.dropPosition + UnityEngine.Random.value * Vector3.down + UnityEngine.Random.insideUnitSphere, owner.inventory.containerMain.dropVelocity);
						owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
			itemCraftTask.takenItems.Clear();
		}
		return true;
	}

```

## OnPhoneDialTimedOut(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing attempt times out.
/// </summary>
/// <param name="caller">The phone controller that initiated the call.</param>
/// <param name="receiver">The phone controller that was being called.</param>
/// <param name="player">The player associated with the receiver's phone controller.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialTimedOut(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone call from {player.displayName} to {receiver?.currentPlayer?.displayName} has timed out.");
    if (receiver != null)
    {
        Puts($"Notifying {receiver.currentPlayer.displayName} of the timeout.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", activeCallTo, this, activeCallTo.currentPlayer) == null)
		{
			if (activeCallTo != null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", activeCallTo, this, activeCallTo.currentPlayer);
		}
	}

```

## OnBookmarkControlEnded(ComputerStation,BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player's control over a bookmark ends.
/// </summary>
/// <param name="station">The computer station that was being controlled.</param>
/// <param name="player">The player who was controlling the bookmark.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnded(ComputerStation station, BasePlayer player, BaseEntity entity)
{
    Puts($"Control ended for player {player.displayName} on entity {entity?.name ?? "unknown"} at station {station?.name ?? "unknown"}.");
    
    if (entity != null)
    {
        Puts($"Entity {entity.name} has been released from control.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if ((bool)ply)
		{
			ply.net.SwitchSecondaryGroup(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
		CancelInvoke(CheckCCTVAchievement);
		Interface.CallHook("OnBookmarkControlEnded", this, ply, baseEntity);
	}

```

## IOnCupboardAuthorize(ulong,BasePlayer,BuildingPrivlidge)

```csharp
```csharp
/// <summary>
/// Called when a player is authorized to use a cupboard.
/// </summary>
/// <param name="userId">The unique identifier of the user being authorized.</param>
/// <param name="player">The player who is authorizing the user.</param>
/// <param name="cupboard">The building privilege associated with the cupboard.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent it.
/// </returns>
object IOnCupboardAuthorize(ulong userId, BasePlayer player, BuildingPrivlidge cupboard)
{
    Puts($"Player {player.displayName} is attempting to authorize user with ID: {userId} to cupboard.");

    if (userId == player.userID)
    {
        Puts($"Player {player.displayName} cannot authorize themselves.");
        return "You cannot authorize yourself.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void AddAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player))
		{
			ulong num = rpc.read.UInt64();
			if (Interface.CallHook("IOnCupboardAuthorize", num, rpc.player, this) == null)
			{
				AddPlayer(rpc.player, num);
				SendNetworkUpdate();
			}
		}
	}

```

## OnFishingRodCast(BaseFishingRod,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a fishing rod is cast by a player.
/// </summary>
/// <param name="fishingRod">The fishing rod being used to cast.</param>
/// <param name="player">The player who is casting the fishing rod.</param>
/// <param name="lure">The lure item being used for the cast.</param>
/// <returns>No return behavior.</returns>
void OnFishingRodCast(BaseFishingRod fishingRod, BasePlayer player, Item lure)
{
    Puts($"Player {player.displayName} has cast the fishing rod with lure: {lure.info.displayName.english}.");
    
    if (lure.info.shortname == "lure.basic")
    {
        Puts("A basic lure has been used. Good luck!");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_RequestCast(RPCMessage msg)
	{
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		ItemModCompostable component = (ItemModCompostable)Interface.CallHook("CanCastFishingRod", ownerPlayer, this, currentLure, pos);
		if (!(component is bool) || (bool)(object)component)
		{
			FishingBobber component2 = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();
			component2.transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component2.Spawn();
			component2.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);
			int usedLureAmount = 0;
			if (FishLookup.Instance != null)
			{
				currentFishTarget = FishLookup.Instance.GetFish(component2.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);
			}
			lureUsed = currentLure.info;
			currentLure.UseItem(usedLureAmount);
			lastFish = fishableModifier;
			currentBobber.Set(component2);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReceiveCastPoint"), component2.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));
			catchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;
			float val = (lureUsed.TryGetComponent<ItemModCompostable>(out component) ? component.BaitValue : 0f);
			val = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);
			catchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);
			playerStartPosition = ownerPlayer.transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			InvokeRepeating(CatchProcess, 0f, 0f);
			inQueue = false;
			Interface.CallHook("OnFishingRodCast", this, ownerPlayer, currentLure);
		}
	}

```

## IOnRunCommandLine()

```csharp
```csharp
/// <summary>
/// Called when the command line is executed to update values based on provided switches.
/// </summary>
/// <returns>
/// Returns a non-null value to prevent further processing of command line switches. 
/// If `null` is returned, the command line switches will be processed as normal.
/// </returns>
object IOnRunCommandLine()
{
    Puts("Command line execution initiated. Processing switches...");
    // Example: Prevent processing if a specific condition is met
    if (SomeConditionToPreventProcessing())
    {
        Puts("Command line processing has been halted.");
        return "Processing halted due to conditions.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed from the console.
/// </summary>
/// <param name="arg">The arguments associated with the console command.</param>
/// <returns>
/// Returns `true` if the command was successfully executed; otherwise, returns `false`.
/// If the method returns a non-null value, it overrides the default command execution behavior.
/// </returns>
bool IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Executing server command: {arg.cmd.FullName} with arguments: {string.Join(", ", arg.Args)}");
    
    if (arg.cmd.FullName == "admin.ban")
    {
        Puts("Admin ban command is restricted.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null && string.IsNullOrWhiteSpace(arg.Reply))
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## OnClientDisconnected(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The connection of the client that has disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnected(Network.Connection connection, string reason)
{
    Puts($"Client {connection.userid} has disconnected: {reason}");
    if (reason == "timeout")
    {
        Puts($"Client {connection.userid} disconnected due to timeout.");
    }
}
```
```

### Source Code from the Library

```csharp

	protected void OnDisconnected(string strReason, Connection cn)
	{
		if (cn != null)
		{
			RecordDisconnection(cn);
			cn.connected = false;
			cn.active = false;
			if (callbackHandler != null)
			{
				callbackHandler.OnDisconnected(strReason, cn);
			}
			Interface.CallHook("OnClientDisconnected", cn, strReason);
			RemoveConnection(cn);
		}
	}

```

## OnNetworkSubscriptionsUpdate(Network.Networkable,System.Collections.Generic.List<Network.Visibility.Group>,unknown)

```csharp
```csharp
/// <summary>
/// Called when the network subscriptions for a networkable entity are updated.
/// </summary>
/// <param name="networkable">The networkable entity whose subscriptions are being updated.</param>
/// <param name="visibleGroups">The list of visibility groups that are currently visible to the entity.</param>
/// <param name="unknown">An unknown parameter that may be used for additional context.</param>
/// <returns>
/// Returns `null` to allow the default subscription behavior, or any non-null value to override it.
/// </returns>
object OnNetworkSubscriptionsUpdate(Network.Networkable networkable, List<Network.Visibility.Group> visibleGroups, object unknown)
{
    Puts($"Network subscriptions updated for {networkable.GetType().Name} with ID: {networkable.net.ID}.");
    
    if (visibleGroups.Count == 0)
    {
        Puts("No visible groups found for subscription.");
        return "No groups to subscribe.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool UpdateHighPrioritySubscriptions()
	{
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateHighPrioritySubscriptions"))
		{
			List<Group> obj = Pool.Get<List<Group>>();
			List<Group> obj2 = Pool.Get<List<Group>>();
			sv.visibility.GetVisibleFromNear(this.group, obj2);
			AddVisibleFromNear(secondaryGroup, obj2);
			subscriber.subscribed.Compare(obj2, obj, null, null);
			if (Interface.CallHook("OnNetworkSubscriptionsUpdate", this, obj, null) == null)
			{
				for (int i = 0; i < obj.Count; i++)
				{
					Group group = obj[i];
					subscriber.Subscribe(group);
					if (handler != null)
					{
						handler.OnNetworkGroupEnter(group);
					}
				}
			}
			Pool.FreeUnmanaged(ref obj);
			Pool.FreeUnmanaged(ref obj2);
		}
		return true;
	}

```

## OnNetworkSubscriptionsUpdate(Network.Networkable,System.Collections.Generic.List<Network.Visibility.Group>,System.Collections.Generic.List<Network.Visibility.Group>)

```csharp
```csharp
/// <summary>
/// Called when the network subscriptions for a networkable entity are updated.
/// </summary>
/// <param name="networkable">The networkable entity whose subscriptions are being updated.</param>
/// <param name="removedGroups">The list of visibility groups that have been removed from subscriptions.</param>
/// <param name="addedGroups">The list of visibility groups that have been added to subscriptions.</param>
/// <returns>No return behavior.</returns>
void OnNetworkSubscriptionsUpdate(Network.Networkable networkable, List<Network.Visibility.Group> removedGroups, List<Network.Visibility.Group> addedGroups)
{
    Puts($"Network subscriptions updated for {networkable.GetInstanceID()}. " +
         $"Removed Groups: {removedGroups.Count}, Added Groups: {addedGroups.Count}");

    foreach (var group in removedGroups)
    {
        Puts($"Group {group.id} has been removed from subscriptions.");
    }

    foreach (var group in addedGroups)
    {
        Puts($"Group {group.id} has been added to subscriptions.");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool UpdateSubscriptions(int removeLimit, int addLimit)
	{
		if (!updateSubscriptions)
		{
			return false;
		}
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateSubscriptions"))
		{
			updateSubscriptions = false;
			List<Group> obj = Pool.Get<List<Group>>();
			List<Group> obj2 = Pool.Get<List<Group>>();
			List<Group> obj3 = Pool.Get<List<Group>>();
			sv.visibility.GetVisibleFromFar(this.group, obj3);
			AddVisibleFromNear(secondaryGroup, obj3);
			subscriber.subscribed.Compare(obj3, obj, obj2, null);
			if (Interface.CallHook("OnNetworkSubscriptionsUpdate", this, obj, obj2) == null)
			{
				for (int i = 0; i < obj2.Count; i++)
				{
					Group group = obj2[i];
					if (removeLimit > 0)
					{
						subscriber.Unsubscribe(group);
						if (handler != null)
						{
							handler.OnNetworkGroupLeave(group);
						}
						removeLimit -= group.networkables.Count;
					}
					else
					{
						updateSubscriptions = true;
					}
				}
				for (int j = 0; j < obj.Count; j++)
				{
					Group group2 = obj[j];
					if (addLimit > 0)
					{
						subscriber.Subscribe(group2);
						if (handler != null)
						{
							handler.OnNetworkGroupEnter(group2);
						}
						addLimit -= group2.networkables.Count;
					}
					else
					{
						updateSubscriptions = true;
					}
				}
			}
			Pool.FreeUnmanaged(ref obj);
			Pool.FreeUnmanaged(ref obj2);
			Pool.FreeUnmanaged(ref obj3);
		}
		return true;
	}

```

## OnGroupCreated(string,string,int)

```csharp
```csharp
/// <summary>
/// Called when a new group is created.
/// </summary>
/// <param name="groupName">The name of the group that was created.</param>
/// <param name="groupTitle">The title of the group that was created.</param>
/// <param name="groupRank">The rank assigned to the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupCreated(string groupName, string groupTitle, int groupRank)
{
    Puts($"Group created: Name = {groupName}, Title = {groupTitle}, Rank = {groupRank}");
    
    if (groupRank < 0)
    {
        Puts($"Warning: Group {groupName} has a negative rank, which may cause issues.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string groupName, string groupTitle, int groupRank)
	{
		if (GroupExists(groupName) || string.IsNullOrEmpty(groupName))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = groupTitle,
			Rank = groupRank
		};
		groupsData.Add(groupName, value);
		Interface.CallHook("OnGroupCreated", groupName, groupTitle, groupRank);
		return true;
	}

```

## OnUserNameUpdated(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's nickname is updated.
/// </summary>
/// <param name="playerId">The ID of the player whose nickname is being updated.</param>
/// <param name="oldName">The player's previous nickname.</param>
/// <param name="newName">The player's new nickname.</param>
/// <returns>No return behavior.</returns>
void OnUserNameUpdated(string playerId, string oldName, string newName)
{
    Puts($"Player {playerId} changed their nickname from {oldName} to {newName}.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string playerId, string playerName)
	{
		if (UserExists(playerId))
		{
			UserData userData = GetUserData(playerId);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = playerName.Sanitize();
			userData.LastSeenNickname = playerName.Sanitize();
			Interface.CallHook("OnUserNameUpdated", playerId, lastSeenNickname, obj);
		}
	}

```

## OnGroupRankSet(string,int)

```csharp
```csharp
/// <summary>
/// Called when a group's rank is set or updated.
/// </summary>
/// <param name="groupName">The name of the group whose rank is being set.</param>
/// <param name="groupRank">The new rank to assign to the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupRankSet(string groupName, int groupRank)
{
    Puts($"Group rank updated: {groupName} is now ranked {groupRank}.");
    
    if (groupRank < 0)
    {
        Puts($"Warning: Group {groupName} has been assigned a negative rank.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string groupName, int groupRank)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Rank == groupRank)
		{
			return true;
		}
		value.Rank = groupRank;
		Interface.CallHook("OnGroupRankSet", groupName, groupRank);
		return true;
	}

```

## OnGroupTitleSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's title is set or updated.
/// </summary>
/// <param name="groupName">The name of the group whose title is being set.</param>
/// <param name="groupTitle">The new title for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupTitleSet(string groupName, string groupTitle)
{
    Puts($"The title for group '{groupName}' has been set to '{groupTitle}'.");
    
    if (groupTitle == "Admin")
    {
        Puts($"Group '{groupName}' is now an Admin group.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string groupName, string groupTitle)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Title == groupTitle)
		{
			return true;
		}
		value.Title = groupTitle;
		Interface.CallHook("OnGroupTitleSet", groupName, groupTitle);
		return true;
	}

```

## OnPermissionRegistered(string,Oxide.Core.Plugins.Plugin)

```csharp
```csharp
/// <summary>
/// Called when a new permission is registered by a plugin.
/// </summary>
/// <param name="permission">The name of the permission being registered.</param>
/// <param name="owner">The plugin that is registering the permission.</param>
/// <returns>No return behavior.</returns>
void OnPermissionRegistered(string permission, Oxide.Core.Plugins.Plugin owner)
{
    Puts($"Permission '{permission}' has been registered by plugin '{owner.Title}'.");

    if (permission.Contains("admin"))
    {
        Puts($"Warning: The permission '{permission}' is an admin permission and should be handled with care.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string permission, Plugin owner)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return;
		}
		if (PermissionExists(permission))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", permission, owner.Title);
			return;
		}
		if (!registeredPermissions.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			registeredPermissions.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(permission);
		Interface.CallHook("OnPermissionRegistered", permission, owner);
		if (!permission.StartsWith(owner.Name + ".", StringComparison.OrdinalIgnoreCase) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", owner.Name.ToLower(), permission, owner.Title);
		}
	}

```

## OnGroupParentSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's parent is set or changed.
/// </summary>
/// <param name="groupName">The name of the group whose parent is being set.</param>
/// <param name="parentGroupName">The name of the new parent group.</param>
/// <returns>No return behavior.</returns>
void OnGroupParentSet(string groupName, string parentGroupName)
{
    Puts($"Group '{groupName}' parent set to '{parentGroupName}'.");

    if (string.IsNullOrEmpty(parentGroupName))
    {
        Puts($"Group '{groupName}' is now a top-level group with no parent.");
    }
    else
    {
        Puts($"Group '{groupName}' is now a child of '{parentGroupName}'.");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string groupName, string parentGroupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parentGroupName))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))
		{
			return false;
		}
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parentGroupName))
		{
			return true;
		}
		if (HasCircularParent(groupName, parentGroupName))
		{
			return false;
		}
		value.ParentGroup = parentGroupName;
		Interface.CallHook("OnGroupParentSet", groupName, parentGroupName);
		return true;
	}

```

## OnGroupDeleted(string)

```csharp
```csharp
/// <summary>
/// Called when a group is deleted from the system.
/// </summary>
/// <param name="groupName">The name of the group that has been deleted.</param>
/// <returns>No return behavior.</returns>
void OnGroupDeleted(string groupName)
{
    Puts($"Group '{groupName}' has been successfully deleted.");
    
    // Additional logic can be added here if needed, such as notifying users or logging.
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		bool flag = groupsData.Remove(groupName);
		if (flag)
		{
			foreach (GroupData item in groupsData.Values.Where((GroupData g) => g.ParentGroup == groupName))
			{
				item.ParentGroup = string.Empty;
			}
		}
		if (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(groupName)))
		{
			SaveUsers();
		}
		if (flag)
		{
			Interface.CallHook("OnGroupDeleted", groupName);
		}
		return true;
	}

```

## OnDestroyUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a UI element is destroyed for a player.
/// </summary>
/// <param name="player">The player for whom the UI element is being destroyed.</param>
/// <param name="element">The identifier of the UI element being destroyed.</param>
/// <returns>
/// Returns `true` if the UI element was successfully destroyed; otherwise, returns `false`.
/// </returns>
bool OnDestroyUI(BasePlayer player, string element)
{
    Puts($"Destroying UI element '{element}' for player {player.displayName} (ID: {player.UserIDString}).");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		if (player?.net != null)
		{
			Interface.CallHook("OnDestroyUI", player, elem);
			CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("DestroyUI", player.net.connection), elem);
			return true;
		}
		return false;
	}

```

## OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a user executes a command.
/// </summary>
/// <param name="player">The player who executed the command.</param>
/// <param name="command">The command that was executed.</param>
/// <param name="args">The arguments passed with the command.</param>
/// <returns>
/// Returns a non-null value to indicate that the command was handled, or `null` to allow further processing.
/// </returns>
object OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer player, string command, string[] args)
{
    Puts($"User command received from {player.Name}: /{command} with arguments: {string.Join(", ", args)}");

    if (command.Equals("ban", StringComparison.OrdinalIgnoreCase) && args.Length > 0)
    {
        Puts($"User {player.Name} attempted to ban player: {args[0]}");
        return "You do not have permission to ban players.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnApplicationCommand(BasePlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player executes an application command.
/// </summary>
/// <param name="player">The player who executed the command.</param>
/// <param name="command">The command that was executed.</param>
/// <param name="args">The arguments passed with the command.</param>
/// <returns>No return behavior.</returns>
void OnApplicationCommand(BasePlayer player, string command, string[] args)
{
    Puts($"Player {player.displayName} executed command: {command} with arguments: {string.Join(", ", args)}");
    
    if (command == "admin")
    {
        Puts($"Admin command executed by {player.displayName}.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player changes their language setting.
/// </summary>
/// <param name="player">The player whose language has changed.</param>
/// <param name="newLanguage">The new language setting for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer player, string newLanguage)
{
    Puts($"Player {player.Name} has changed their language to {newLanguage}.");
    
    // Additional logic can be added here to handle language-specific settings or notifications.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnPlayerLanguageChanged(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player changes their language setting.
/// </summary>
/// <param name="player">The player whose language has changed.</param>
/// <param name="newLanguage">The new language setting for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(BasePlayer player, string newLanguage)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has changed their language to: {newLanguage}.");
    
    // Additional logic can be added here to handle language-specific settings or notifications.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>
/// Returns a non-null value to override the default respawn behavior. 
/// If a string is returned, it will be used as a message or reason for the respawn action. 
/// If `null` is returned, the default respawn logic will proceed.
/// </returns>
object OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
    
    if (player.IsBanned)
    {
        Puts($"Player {player.Name} is banned and cannot respawn.");
        return "You are banned from this server.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.CallHook("OnUserRespawn", iPlayer);
	}

```

## OnApplicationCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player issues a command in the application.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The command that was issued.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>
/// Returns a non-null value to prevent further processing of the command. 
/// If `null` is returned, the command will be processed normally.
/// </returns>
object OnApplicationCommand(Oxide.Core.Libraries.Covalence.IPlayer player, string command, string[] args)
{
    Puts($"Player {player.Name} issued command: {command} with arguments: {string.Join(", ", args)}");

    if (command.Equals("ban", StringComparison.OrdinalIgnoreCase) && args.Length > 0)
    {
        Puts($"Player {player.Name} attempted to ban: {args[0]}");
        return "You do not have permission to ban players.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnRconCommand(System.Net.IPAddress,string,string[])

```csharp
```csharp
/// <summary>
/// Called when an RCON command is received.
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the command.</param>
/// <param name="command">The command string sent via RCON.</param>
/// <param name="args">An array of arguments parsed from the command string.</param>
/// <returns>
/// Returns a non-null value to indicate that the command was handled, or `null` to allow default processing.
/// </returns>
object OnRconCommand(System.Net.IPAddress ipAddress, string command, string[] args)
{
    Puts($"RCON command received from {ipAddress}: {command}");

    if (command.Equals("shutdown", StringComparison.OrdinalIgnoreCase))
    {
        Puts("Shutdown command received. Initiating server shutdown.");
        return "Server is shutting down.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", ipAddress, message) != null)
			{
				return true;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnEntityTakeDamage(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit, including damage amount and source.</param>
/// <returns>
/// Returns a non-null value to override the default damage behavior. 
/// If a string is returned, it can be used as a message or reason for the damage being modified or blocked.
/// If `null` is returned, the default damage processing will occur.
/// </returns>
object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.net.ID} is taking damage: {hitInfo.damageTypes.Total()} from {hitInfo.Initiator?.net.ID ?? 0}.");

    if (entity is BasePlayer player && player.IsInvulnerable)
    {
        Puts($"Player {player.displayName} is invulnerable and will not take damage.");
        return "Player is invulnerable.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.CallHook("OnEntityTakeDamage", entity, hitInfo);
		}
		return null;
	}

```

## OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns in the game.
/// </summary>
/// <param name="player">The player who has respawned.</param>
/// <returns>No return behavior.</returns>
void OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
    // Additional logic can be added here if needed.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", iPlayer);
		}
	}

```

## OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user disconnects from the server.
/// </summary>
/// <param name="player">The player who has disconnected.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer player, string reason)
{
    Puts($"User {player.Name} has disconnected from the server. Reason: {reason}");
    
    if (reason == "timeout")
    {
        Puts($"User {player.Name} disconnected due to timeout.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer basePlayer, string reason)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(basePlayer);
	}

```

## OnServerInitialized(bool)

```csharp
```csharp
/// <summary>
/// Called when the server has been fully initialized.
/// </summary>
/// <param name="isInitialized">Indicates whether the server is initialized.</param>
/// <returns>No return behavior.</returns>
void OnServerInitialized(bool isInitialized)
{
    Puts($"Server initialization status: {isInitialized}");
    if (isInitialized)
    {
        Puts("Server has been successfully initialized.");
    }
    else
    {
        Puts("Server initialization failed.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			Analytics.Collect();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", serverInitialized);
		}
	}

```

## OnCupboardAssign(BuildingPrivlidge,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is assigned to a cupboard's authorization list.
/// </summary>
/// <param name="privilege">The building privilege associated with the cupboard.</param>
/// <param name="userId">The user ID of the player being assigned.</param>
/// <param name="player">The player being assigned to the cupboard.</param>
/// <returns>
/// Returns a non-null value to prevent the assignment, or `null` to allow it.
/// </returns>
object OnCupboardAssign(BuildingPrivlidge privilege, ulong userId, BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {userId}) is being assigned to cupboard privileges.");

    if (userId == 123456789) // Example user ID check
    {
        Puts($"Player {player.displayName} is not allowed to be assigned to this cupboard.");
        return "You cannot be assigned to this cupboard.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnCupboardAuthorize")]
	private object IOnCupboardAuthorize(ulong userID, BasePlayer player, BuildingPrivlidge privlidge)
	{
		if (userID == (ulong)player.userID)
		{
			if (Interface.CallHook("OnCupboardAuthorize", privlidge, player) != null)
			{
				return true;
			}
		}
		else if (Interface.CallHook("OnCupboardAssign", privlidge, userID, player) != null)
		{
			return true;
		}
		return null;
	}

```

## CanUserLogin(string,string,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a user can log in to the server.
/// </summary>
/// <param name="username">The username of the user attempting to log in.</param>
/// <param name="steamId">The Steam ID of the user attempting to log in.</param>
/// <param name="ipAddress">The IP address of the user attempting to log in.</param>
/// <returns>
/// Returns a non-null value to reject the login attempt, or `null` to allow the user to log in.
/// If a string is returned, it will be used as the rejection message.
/// </returns>
object CanUserLogin(string username, string steamId, string ipAddress)
{
    Puts($"Checking login for user: {username}, SteamID: {steamId}, IP: {ipAddress}");

    if (username == "bannedUser")
    {
        Puts($"User {username} is banned from logging in.");
        return "You are banned from this server.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnPlayerChat(BasePlayer,string,ConVar.Chat.ChatChannel)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="player">The player who sent the message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <param name="channel">The chat channel used for sending the message.</param>
/// <returns>
/// Returns a non-null value to prevent the message from being processed further. 
/// If `null` is returned, the message will be processed normally.
/// </returns>
object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) sent a message: {message} in channel: {channel}");

    if (message.StartsWith("/admin"))
    {
        Puts($"Admin command detected from {player.displayName}. Processing command...");
        return "Admin commands are not allowed in public chat.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, string steamId, string ipAddress)
{
    Puts($"User {username} (SteamID: {steamId}) has been unbanned. IP: {ipAddress}");
    
    if (ipAddress == "192.168.1.100")
    {
        Puts($"Warning: User {username} has been unbanned from a restricted IP address.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## CanClientLogin(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a client can log in to the server.
/// </summary>
/// <param name="connection">The network connection of the client attempting to log in.</param>
/// <returns>
/// Returns a non-null value to reject the login attempt, or `null` to allow the login to proceed.
/// If a string is returned, it will be used as the rejection message.
/// </returns>
object CanClientLogin(Network.Connection connection)
{
    Puts($"Client with username {connection.username} and ID {connection.userid} is attempting to log in.");

    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"Client {connection.username} is blocked from logging in due to IP restrictions.");
        return "Access denied: Your IP is not allowed.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnRconMessage(System.Net.IPAddress,Oxide.Core.RemoteConsole.RemoteMessage)

```csharp
```csharp
/// <summary>
/// Called when a message is received via RCON (Remote Console).
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the RCON message.</param>
/// <param name="message">The remote message containing the command.</param>
/// <returns>
/// Returns a non-null value to indicate that the message was handled, or `null` to allow default processing.
/// </returns>
object OnRconMessage(IPAddress ipAddress, Oxide.Core.RemoteConsole.RemoteMessage message)
{
    Puts($"Received RCON message from {ipAddress}: {message?.Message}");

    if (message?.Message == "shutdown")
    {
        Puts("Shutdown command received via RCON.");
        return "Server is shutting down.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", ipAddress, message) != null)
			{
				return true;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnPlayerBanned(string,ulong,string,string,long)

```csharp
```csharp
/// <summary>
/// Called when a player is banned from the server.
/// </summary>
/// <param name="playerName">The name of the player being banned.</param>
/// <param name="steamId">The Steam ID of the player being banned.</param>
/// <param name="ipAddress">The IP address of the player being banned.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The expiry time of the ban in Unix timestamp format.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string playerName, ulong steamId, string ipAddress, string reason, long expiry)
{
    Puts($"Player {playerName} (SteamID: {steamId}) has been banned. Reason: {reason}. Expiry: {expiry}");
    
    if (expiry > 0)
    {
        Puts($"This ban will expire on {DateTimeOffset.FromUnixTimeSeconds(expiry).DateTime}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnPlayerOfflineChat(ulong,string,string,ConVar.Chat.ChatChannel)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message while offline.
/// </summary>
/// <param name="playerId">The unique identifier of the player sending the message.</param>
/// <param name="playerName">The name of the player sending the message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <param name="channel">The chat channel in which the message was sent.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. 
/// If `null` is returned, the message will be processed normally.
/// </returns>
object OnPlayerOfflineChat(ulong playerId, string playerName, string message, ConVar.Chat.ChatChannel channel)
{
    Puts($"Offline chat from {playerName} (ID: {playerId}): {message}");

    if (message.Contains("spam"))
    {
        Puts($"Message from {playerName} flagged as spam.");
        return "Your message was flagged as spam.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player or another entity.
/// </summary>
/// <param name="npc">The NPC that is targeting.</param>
/// <param name="target">The entity that is being targeted.</param>
/// <returns>
/// Returns a non-null value to override the default targeting behavior. 
/// If `null` is returned, the NPC will proceed with its normal targeting logic.
/// </returns>
object OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.displayName} is targeting {target?.ShortPrefabName ?? "unknown entity"}.");

    if (target is BasePlayer player && player.IsInvisible())
    {
        Puts($"NPC {npc.displayName} cannot target invisible player {player.displayName}.");
        return true; // Prevent targeting
    }

    return null; // Allow normal targeting behavior
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcTarget", npc, target) != null)
		{
			npc.SetFact(BaseNpc.Facts.HasEnemy, 0);
			npc.SetFact(BaseNpc.Facts.EnemyRange, 3);
			npc.SetFact(BaseNpc.Facts.AfraidRange, 1);
			npc.playerTargetDecisionStartTime = 0f;
			return 0f;
		}
		return null;
	}

```

## OnPlayerBanned(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned from the server.
/// </summary>
/// <param name="connection">The network connection of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(Network.Connection connection, string reason)
{
    Puts($"Player with connection ID {connection.userid} has been banned. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerBanned")]
	private void IOnPlayerBanned(Connection connection, AuthResponse status)
	{
		Interface.CallHook("OnPlayerBanned", connection, status.ToString());
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The player who has been kicked.</param>
/// <param name="reason">The reason for the kick.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer player, string reason)
{
    Puts($"User {player.Name} has been kicked from the server. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer basePlayer, string reason)
	{
		if (basePlayer.IPlayer != null)
		{
			Interface.CallHook("OnUserKicked", basePlayer.IPlayer, reason);
		}
	}

```

## OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user connects to the server.
/// </summary>
/// <param name="player">The player who has connected.</param>
/// <returns>No return behavior.</returns>
void OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer player)
{
    Puts($"Player {player.Name} (ID: {player.Id}) has connected to the server.");
    
    // Additional logic can be added here, such as welcome messages or player initialization.
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnServerCommand(string,string[])

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="command">The name of the command being executed.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns a non-null value to prevent the command from executing further. 
/// If `null` is returned, the command will proceed with its default behavior.
/// </returns>
object OnServerCommand(string command, string[] args)
{
    Puts($"Server command executed: {command} with arguments: {string.Join(", ", args)}");

    if (command == "kick")
    {
        Puts("Kick command detected. Additional checks can be implemented here.");
        return "Kick command is not allowed.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnLoseCondition(object[])

```csharp
```csharp
/// <summary>
/// Called when an item loses condition.
/// </summary>
/// <param name="parameters">An array containing the item and the amount of condition lost.</param>
/// <returns>
/// Returns `true` if the condition loss is processed successfully; otherwise, returns `false`.
/// If the method returns a non-null value, it overrides the default behavior for condition loss.
/// </returns>
object OnLoseCondition(object[] parameters)
{
    Item item = (Item)parameters[0];
    float amount = (float)parameters[1];

    Puts($"Item {item.info.displayName.english} is losing condition: {amount}.");

    if (item.info.shortname == "wooden.spear")
    {
        Puts("Wooden spear condition loss is being overridden.");
        return false; // Prevent condition loss for wooden spear
    }

    return null; // Allow default behavior to proceed
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

```

## OnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The arguments associated with the server command.</param>
/// <returns>
/// Returns a non-null value to prevent the command from executing further. 
/// If `null` is returned, the command will proceed with its default behavior.
/// </returns>
object OnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Server command received: {arg.cmd.FullName} from player: {arg.Player()?.displayName ?? "Console"}");

    if (arg.cmd.FullName == "server.shutdown")
    {
        Puts("Shutdown command received. Preparing to shut down the server.");
        return "Server is shutting down.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerShutdown()
{
    Puts("Server is shutting down. Saving all player data and cleaning up resources.");
    // Additional cleanup logic can be added here if necessary
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerShutdown")]
	private void IOnServerShutdown()
	{
		Interface.Oxide.CallHook("OnServerShutdown");
		Interface.Oxide.OnShutdown();
		Covalence.PlayerManager.SavePlayerData();
	}

```

## OnUserBanned(string,string,string,string,long)

```csharp
```csharp
/// <summary>
/// Called when a user is banned from the server.
/// </summary>
/// <param name="username">The name of the user being banned.</param>
/// <param name="steamId">The Steam ID of the user being banned.</param>
/// <param name="ipAddress">The IP address of the user being banned.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The expiry time of the ban in Unix timestamp format.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string username, string steamId, string ipAddress, string reason, long expiry)
{
    Puts($"User {username} (SteamID: {steamId}, IP: {ipAddress}) has been banned. Reason: {reason}. Expiry: {expiry}");
    
    if (expiry > 0)
    {
        Puts($"This ban will expire on {DateTimeOffset.FromUnixTimeSeconds(expiry).DateTime}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnEntityTakeDamage(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player entity takes damage.
/// </summary>
/// <param name="player">The player entity that is taking damage.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns a non-null value to prevent the default damage handling, or `null` to allow it.
/// </returns>
object OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Player {player.displayName} is taking damage from {hitInfo.Initiator?.ToString() ?? "unknown source"}.");

    if (hitInfo.damageTypes.GetTotal() > 50)
    {
        Puts($"Damage from {hitInfo.Initiator?.ToString()} is too high, preventing further damage.");
        return true; // Prevent further damage handling
    }

    return null; // Allow default damage handling
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)
	{
		if (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", basePlayer, hitInfo) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			basePlayer.OnAttacked(hitInfo);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

```

## OnUserApproved(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="username">The username of the approved user.</param>
/// <param name="steamId">The Steam ID of the approved user.</param>
/// <param name="ipAddress">The IP address of the approved user.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object OnUserApproved(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been approved to join the server.");
    
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    
    // Additional checks can be added here
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The chat message sent by the player.</param>
/// <returns>
/// Returns a non-null value to prevent the message from being processed further. 
/// If `null` is returned, the message will be processed normally.
/// </returns>
object OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer player, string message)
{
    Puts($"Player {player.Name} (ID: {player.Id}) sent a message: {message}");

    if (message.Contains("badword"))
    {
        Puts($"Player {player.Name} used a prohibited word.");
        return "Your message contains prohibited content.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player successfully connects to the server.
/// </summary>
/// <param name="player">The player who has connected.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) has connected to the server.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved to the server.
/// </summary>
/// <param name="entity">The entity that is being saved.</param>
/// <param name="saveInfo">Information about the save operation.</param>
/// <returns>No return behavior.</returns>
void OnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity.net.ID} has been saved with save info for connection: {saveInfo.forConnection?.userid ?? 0}.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnEntitySaved")]
	private void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)
	{
		if (serverInitialized && saveInfo.forConnection != null)
		{
			Interface.CallHook("OnEntitySaved", baseNetworkable, saveInfo);
		}
	}

```

## OnPlayerCommand(BasePlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player issues a command.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The command that was issued.</param>
/// <param name="args">The arguments associated with the command.</param>
/// <returns>
/// Returns a non-null value to override the default command handling. 
/// If `null` is returned, the command will be processed normally.
/// </returns>
object OnPlayerCommand(BasePlayer player, string command, string[] args)
{
    Puts($"Player {player.displayName} issued command: {command} with arguments: {string.Join(", ", args)}");

    if (command.Equals("ban", StringComparison.OrdinalIgnoreCase) && args.Length > 0)
    {
        Puts($"Player {player.displayName} attempted to ban: {args[0]}");
        return "You cannot ban players using this command.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## CanUseUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Determines whether a player can use the UI with the specified JSON data.
/// </summary>
/// <param name="player">The player attempting to use the UI.</param>
/// <param name="json">The JSON data for the UI to be displayed.</param>
/// <returns>
/// Returns `true` if the player can use the UI; otherwise, returns `false`. 
/// If the method returns `null`, the default game logic will determine if the UI can be used.
/// </returns>
bool? CanUseUI(BasePlayer player, string json)
{
    Puts($"Checking UI usage for player {player.displayName} with JSON: {json}");
    
    if (player.IsBannedFromUI)
    {
        Puts($"Player {player.displayName} is banned from using the UI.");
        return false;
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AddUi(BasePlayer player, string json)
	{
		if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
		{
			CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", player.net.connection), json);
			return true;
		}
		return false;
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned player.</param>
/// <param name="steamId">The Steam ID of the unbanned player.</param>
/// <param name="ipAddress">The IP address of the unbanned player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} (SteamID: {steamId}) has been unbanned. IP Address: {ipAddress}");
    
    if (ipAddress == "192.168.1.100")
    {
        Puts($"Warning: Player {username} has a potentially restricted IP address.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## OnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to connect to the server.
/// </summary>
/// <param name="connection">The network connection of the user being approved.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object OnUserApprove(Network.Connection connection)
{
    Puts($"User {connection.username} (ID: {connection.userid}) is being approved for connection.");
    
    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"User {connection.username} is blocked from connecting due to IP restrictions.");
        return "Connection rejected: Unauthorized IP address.";
    }

    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## CanPickupEntity(BasePlayer,DoorCloser)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pick up a specified entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity that is being picked up.</param>
/// <returns>
/// Returns `null` to allow the pickup, or `true` to prevent the pickup.
/// If a non-null value is returned, the default pickup logic will be overridden.
/// </returns>
object CanPickupEntity(BasePlayer player, DoorCloser entity)
{
    Puts($"Player {player.displayName} (ID: {player.UserIDString}) is attempting to pick up entity: {entity.name}.");

    if (entity.IsLocked())
    {
        Puts($"Entity {entity.name} is locked and cannot be picked up.");
        return true; // Prevent pickup
    }

    return null; // Allow pickup
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)
	{
		object obj = Interface.CallHook("CanPickupEntity", basePlayer, entity);
		if (!(obj is bool) || (bool)obj)
		{
			return null;
		}
		return true;
	}

```

## OnClanMemberAdded(long,ulong)

```csharp
```csharp
/// <summary>
/// Called when a player is added to a clan as a member.
/// </summary>
/// <param name="clanId">The ID of the clan to which the member is being added.</param>
/// <param name="steamId">The Steam ID of the player being added to the clan.</param>
/// <returns>No return behavior.</returns>
void OnClanMemberAdded(long clanId, ulong steamId)
{
    Puts($"Player with SteamID {steamId} has been added to clan with ID {clanId}.");
}
```
```

### Source Code from the Library

```csharp

	public bool AcceptInvite(long clanId, ulong steamId)
	{
		BeginTransaction();
		try
		{
			if (DeleteInvite(clanId, steamId) && CreateMember(clanId, steamId))
			{
				Commit();
				Interface.CallHook("OnClanMemberAdded", clanId, steamId);
				return true;
			}
			Rollback();
			return false;
		}
		catch
		{
			Rollback();
			throw;
		}
	}

```

