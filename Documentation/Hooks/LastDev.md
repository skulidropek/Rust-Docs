# Hooks Definitions

## OnPlayerSpectate(BasePlayer,string)

```csharp
/// <summary>
/// Called when a player starts spectating.
/// </summary>
/// <param name="player">The player starting to spectate.</param>
/// <param name="filter">The filter used for spectating.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} started spectating with filter: {filter}");
}
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnFuelConsumed(BaseOven,Item,ItemModBurnable)

```csharp
/// <summary>
/// Called when fuel is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The fuel being consumed.</param>
/// <param name="burnable">The item being smelted.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnFuelConsumed(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts("OnFuelConsumed hook called!");
    // If you want to override the default behavior, return a non-null value
    return null;
}
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Facepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## OnNpcConversationStart(NPCTalking,BasePlayer,ConversationData)

```csharp
/// <summary>
/// Called when an NPC conversation starts with a player.
/// </summary>
/// <param name="npc">The NPC initiating the conversation.</param>
/// <param name="player">The player participating in the conversation.</param>
/// <param name="conversationData">Data related to the conversation.</param>
/// <returns>No return behavior.</returns>
void OnNpcConversationStart(NPCTalking npc, BasePlayer player, ConversationData conversationData)
{
    Puts($"NPC {npc.name} started a conversation with player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	public void Server_BeginTalking(BasePlayer ply)
	{
		if (!CanTalkTo(ply))
		{
			return;
		}
		CleanupConversingPlayers();
		OnConversationStarted(ply);
		ConversationData conversationFor = GetConversationFor(ply);
		if (conversationFor != null)
		{
			if (conversingPlayers.Contains(ply))
			{
				OnConversationEnded(ply);
			}
			if (Interface.CallHook("OnNpcConversationStart", this, ply, conversationFor) == null)
			{
				conversingPlayers.Add(ply);
				UpdateFlags();
				ClientRPC(RpcTarget.Player("Client_StartConversation", ply), GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech(ply));
			}
		}
	}

```

## OnCrateHack(HackableLockedCrate)

```csharp
/// <summary>
/// Called when a player attempts to hack a locked crate.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>Returns the result of the hacking attempt.</returns>
object OnCrateHack(HackableLockedCrate crate)
{
    Puts("OnCrateHack is working!");
    // Return the result of the hacking attempt
    return null;
}
```

### Source Code from the Library

```csharp

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", this);
		BroadcastEntityMessage("HackingStarted", 20f, 256);
		SetFlag(Flags.Reserved1, b: true);
		InvokeRepeating(HackProgress, 1f, 1f);
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

```

## CanAffordToPlace(BasePlayer,Planner,Construction)

```csharp
/// <summary>
/// Called to determine if a player can afford to place a construction.
/// </summary>
/// <param name="player">The player attempting to place the construction.</param>
/// <param name="planner">The planner used for placement.</param>
/// <param name="construction">The construction being placed.</param>
/// <returns>Returns true if the player can afford to place the construction, false otherwise.</returns>
bool CanAffordToPlace(BasePlayer player, Planner planner, Construction construction)
{
    Puts("CanAffordToPlace is working!");
    
    // If the hook returns a boolean value, return it
    object obj = Interface.CallHook("CanAffordToPlace", player, this, construction);
    if (obj is bool)
    {
        return (bool)obj;
    }
    
    // If the player is in creative mode and free build is enabled, return true
    if (player.IsInCreativeMode && Creative.freeBuild)
    {
        return true;
    }
    
    // Check if the player has enough resources to build the construction
    foreach (ItemAmount item in construction.defaultGrade.CostToBuild())
    {
        if ((float)player.inventory.GetAmount(item.itemDef.itemid) < item.amount)
        {
            return false;
        }
    }
    
    return true;
}
```

### Source Code from the Library

```csharp

	public bool CanAffordToPlace(Construction component)
	{
		if (isTypeDeployable)
		{
			return true;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return false;
		}
		object obj = Interface.CallHook("CanAffordToPlace", ownerPlayer, this, component);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ownerPlayer.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			if ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnDoorKnocked(DoorKnocker,BasePlayer)

```csharp
/// <summary>
/// Called when a door is knocked by a player.
/// </summary>
/// <param name="door">The door that was knocked.</param>
/// <param name="player">The player who knocked the door.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnDoorKnocked(BaseDoor door, BasePlayer player)
{
    Puts("OnDoorKnocked is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void Knock(BasePlayer player)
	{
		ClientRPC(RpcTarget.NetworkGroup("ClientKnock"), player.transform.position);
		Interface.CallHook("OnDoorKnocked", this, player);
	}

```

## CanLock(BasePlayer,ModularCar,ModularCarCodeLock)

```csharp
/// <summary>
/// Called to determine if a player can lock the Modular Car.
/// </summary>
/// <param name="player">The player attempting to lock the car.</param>
/// <param name="car">The Modular Car being locked.</param>
/// <param name="lockCode">The code required to lock the car.</param>
/// <returns>Returns true if the player has permission to lock the car, false otherwise.</returns>
bool CanLock(BasePlayer player, ModularCar car, ModularCarCodeLock lockCode)
{
    Puts("CanLock is working!");
    // Add logic here to determine if the player can lock the car
    return true; // Replace with actual logic
}
```

### Source Code from the Library

```csharp

	public bool HasLockPermission(BasePlayer player)
	{
		if (!HasALock)
		{
			return true;
		}
		if (!player.IsValid() || player.IsDead())
		{
			return false;
		}
		object obj = Interface.CallHook("CanLock", player, owner, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return whitelistPlayers.Contains(player.userID);
	}

```

## OnGrowableGather(GrowableEntity,BasePlayer,bool)

```csharp
/// <summary>
/// Called when a player attempts to gather a growable entity.
/// </summary>
/// <param name="entity">The growable entity being gathered.</param>
/// <param name="player">The player attempting to gather the entity.</param>
/// <param name="eat">Whether the player wants to eat the gathered item.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnGrowableGather(GrowableEntity entity, BasePlayer player, bool eat)
{
    Puts("OnGrowableGather hook called!");
    // Add custom logic here if needed
    return null;
}
```

### Source Code from the Library

```csharp

	public void PickFruit(BasePlayer player, bool eat = false)
	{
		if (!CanPick() || Interface.CallHook("OnGrowableGather", this, player, eat) != null)
		{
			return;
		}
		harvests++;
		GiveFruit(player, CurrentPickAmount, eat);
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(player, base.transform.position);
		}
		ResetSeason();
		if (Properties.pickEffect.isValid)
		{
			Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
		}
		if (harvests >= Properties.maxHarvests)
		{
			if (Properties.disappearAfterHarvest)
			{
				Die();
			}
			else
			{
				ChangeState(PlantProperties.State.Dying, resetAge: true);
			}
		}
		else
		{
			ChangeState(PlantProperties.State.Mature, resetAge: true);
		}
	}

```

## CanBeHomingTargeted(PlayerHelicopter)

```csharp
/// <summary>
/// Called to determine if the player helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The player's helicopter.</param>
/// <returns>Returns true if the helicopter can be targeted, and false otherwise.</returns>
bool CanBeHomingTargeted(PlayerHelicopter helicopter)
{
    Puts("CanBeHomingTargeted is working!");
    return true; // Or another value depending on the method’s functionality
}
```

### Source Code from the Library

```csharp

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsOn();
	}

```

## OnItemUnlock(Item)

```csharp
/// <summary>
/// Called when an item is unlocked.
/// </summary>
/// <param name="item">The item that was unlocked.</param>
/// <returns>No return behavior.</returns>
void OnItemUnlock(Item item)
{
    Puts($"Item {item} has been unlocked.");
}
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## CanUseHelicopter(BasePlayer,CH47HelicopterAIController)

```csharp
/// <summary>
/// Called to determine if a player can use the helicopter.
/// </summary>
/// <param name="player">The player attempting to use the helicopter.</param>
/// <param name="helicopterController">The AI controller of the helicopter.</param>
/// <returns>Returns true if the player can use the helicopter, and false otherwise.</returns>
bool CanUseHelicopter(BasePlayer player, CH47HelicopterAIController helicopterController)
{
    Puts("CanUseHelicopter is working!");
    // Add logic to determine if the player can use the helicopter
    return true; // Replace with actual logic
}
```

### Source Code from the Library

```csharp

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", player, this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject,UnityEngine.Collider)

```csharp
/// <summary>
/// Called when a trap trigger is snapped to an object.
/// </summary>
/// <param name="trapTrigger">The trap trigger that was snapped.</param>
/// <param name="obj">The object that the trap trigger was snapped to.</param>
/// <param name="col">The collider of the object that the trap trigger was snapped to.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trapTrigger, GameObject obj, Collider col)
{
    Puts($"Trap trigger snapped to {obj} at position: {obj.transform.position}");
}
```

### Source Code from the Library

```csharp

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		Interface.CallHook("OnTrapSnapped", this, obj, col);
		base.OnObjectAdded(obj, col);
		_trap.ObjectEntered(obj);
	}

```

## OnBoomboxToggle(BoomBox,BasePlayer,bool)

```csharp
/// <summary>
/// Called when the boombox is toggled on or off.
/// </summary>
/// <param name="boombox">The boombox entity.</param>
/// <param name="player">The player who triggered the toggle.</param>
/// <param name="isPlaying">Whether the boombox is playing music.</param>
/// <returns>No return behavior.</returns>
void OnBoomboxToggle(BoomBox boombox, BasePlayer player, bool isPlaying)
{
    Puts($"Boombox toggled {(isPlaying ? "on" : "off")} for player {player.UserID}");
}
```

### Source Code from the Library

```csharp

	public void ServerTogglePlay(BaseEntity.RPCMessage msg)
	{
		if (IsPowered())
		{
			bool flag = msg.read.ReadByte() == 1;
			if (Interface.CallHook("OnBoomboxToggle", this, msg.player, flag) == null)
			{
				ServerTogglePlay(flag);
			}
		}
	}

```

## OnDemoRecordingStopped(string,BasePlayer)

```csharp
/// <summary>
/// Called when a demo recording is stopped.
/// </summary>
/// <param name="filename">The filename of the recorded demo.</param>
/// <param name="player">The player who initiated the stop action.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStopped(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped: {filename} by player {player.UserIDString}");
}
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
/// <summary>
/// Called when a code is entered into the lock.
/// </summary>
/// <param name="lock">The CodeLock instance.</param>
/// <param name="player">The BasePlayer who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnCodeEntered(CodeLock lock, BasePlayer player, string code)
{
    // Minimal code to demonstrate functionality
    Puts("OnCodeEntered hook called!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked() || IsCodeEntryBlocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, blockwarning);
			}
			if ((float)wrongCodes >= maxFailedAttempts)
			{
				SetFlag(Flags.Reserved11, b: true);
				Invoke(ClearCodeEntryBlocked, lockoutCooldown);
			}
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
				wrongCodes = 0;
			}
			Facepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: false);
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
			Facepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: true);
		}
	}

```

## OnCodeChanged(BasePlayer,CodeLock,string,bool)

```csharp
/// <summary>
/// Called when the code of a CodeLock is changed.
/// </summary>
/// <param name="player">The player who changed the code.</param>
/// <param name="codeLock">The CodeLock whose code was changed.</param>
/// <param name="newCode">The new code entered by the player.</param>
/// <param name="isGuest">Whether the player is a guest or not.</param>
/// <returns>No return behavior.</returns>
void OnCodeChanged(BasePlayer player, CodeLock codeLock, string newCode, bool isGuest)
{
    Puts($"Code changed to {newCode} for CodeLock {codeLock}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (!IsLocked() && text.Length == 4 && text.IsNumeric() && !(!hasCode && flag) && Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!hasCode && !flag)
			{
				SetFlag(Flags.Locked, b: true);
			}
			Facepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			Interface.CallHook("OnCodeChanged", rpc.player, this, text, flag);
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item,ItemCrafter)

```csharp
/// <summary>
/// Called when an item crafting task is finished.
/// </summary>
/// <param name="task">The item crafting task.</param>
/// <param name="item">The crafted item.</param>
/// <param name="crafter">The entity that performed the crafting.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftFinished(ItemCraftTask task, Item item, BaseEntity crafter)
{
    Puts($"Item crafting finished: {task.blueprint.targetItem.shortname} crafted by {crafter.Name}");
}
```

### Source Code from the Library

```csharp

	public void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item.amount = task.blueprint.amountToCreate;
		int amount = item.amount;
		_ = owner.currentCraftLevel;
		bool inSafezone = owner.InSafeZone();
		if (item.hasCondition && task.conditionScale != 1f)
		{
			item.maxCondition *= task.conditionScale;
			item.condition = item.maxCondition;
		}
		item.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					Facepunch.Rust.Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item.info.shortname);
					takenItem.UseItem(num);
					num -= num2;
				}
				_ = 0;
			}
		}
		Facepunch.Rust.Analytics.Server.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		Facepunch.Rust.Analytics.Azure.OnCraftItem(item.info.shortname, item.amount, base.baseEntity, task.workbenchEntity, inSafezone);
		owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item, this);
		if (task.instanceData != null)
		{
			item.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		owner.ProcessMissionEvent(BaseMission.MissionEventType.CRAFT_ITEM, item.info.itemid, amount);
		if (owner.inventory.GiveItem(item))
		{
			owner.Command("note.inv", item.info.itemid, amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		owner.Command("note.inv", item.info.itemid, amount);
		owner.Command("note.inv", item.info.itemid, -item.amount);
		item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnItemFilter(Item,StorageContainer,int)

```csharp
/// <summary>
/// Called when an item is being filtered for placement in a storage container.
/// </summary>
/// <param name="item">The item being filtered.</param>
/// <param name="container">The storage container where the item will be placed.</param>
/// <param name="targetSlot">The slot number where the item will be placed.</param>
/// <returns>Returns a non-null value if the default behavior is overridden. If true, the item should be allowed to be placed in the container; otherwise, it should not be allowed.</returns>
object OnItemFilter(Item item, StorageContainer container, int targetSlot)
{
    Puts("OnItemFilter hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual bool ItemFilter(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("OnItemFilter", item, this, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (onlyAcceptCategory == ItemCategory.All)
		{
			return true;
		}
		return item.info.category == onlyAcceptCategory;
	}

```

## CanUnlock(BasePlayer,ModularCarCodeLock,string)

```csharp
/// <summary>
/// Called to determine if a player can unlock the Modular Car Code Lock.
/// </summary>
/// <param name="player">The player attempting to unlock the lock.</param>
/// <param name="lock">The Modular Car Code Lock being unlocked.</param>
/// <param name="codeEntered">The code entered by the player.</param>
/// <returns>Returns true if the player can unlock the lock, and false otherwise.</returns>
bool CanUnlock(BasePlayer player, ModularCarCodeLock lock, string codeEntered)
{
    Puts("CanUnlock is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public bool TryOpenWithCode(BasePlayer player, string codeEntered)
	{
		object obj = Interface.CallHook("CanUnlock", player, this, codeEntered);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CodeEntryBlocked(player))
		{
			return false;
		}
		if (!(codeEntered == Code))
		{
			if (Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				player.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning);
			}
			if ((float)wrongCodes >= CodeLock.maxFailedAttempts)
			{
				owner.SetFlag(BaseEntity.Flags.Reserved10, b: true);
				owner.Invoke(ClearCodeEntryBlocked, CodeLock.lockoutCooldown);
			}
			lastWrongTime = Time.realtimeSinceStartup;
			return false;
		}
		if (TryAddPlayer(player.userID))
		{
			wrongCodes = 0;
		}
		owner.SendNetworkUpdate();
		return true;
	}

```

## OnSignalBroadcast(BaseEntity)

```csharp
/// <summary>
/// Called when a signal is broadcasted to the network group.
/// </summary>
/// <param name="entity">The entity that triggered the signal broadcast.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnSignalBroadcast(BaseEntity entity)
{
    Puts("OnSignalBroadcast is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void SignalBroadcast(Signal signal, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", this) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("SignalFromServer", this, SendMethod.Unreliable, Priority.Immediate), (int)signal, sourceConnection?.userid ?? 0);
		}
	}

```

## OnAdventGiftAward(AdventCalendar,BasePlayer)

```csharp
/// <summary>
/// Called when a gift is awarded to a player.
/// </summary>
/// <param name="calendar">The advent calendar instance.</param>
/// <param name="player">The player receiving the gift.</param>
/// <returns>No return behavior.</returns>
void OnAdventGiftAward(AdventCalendar calendar, BasePlayer player)
{
    Puts("OnAdventGiftAward is working!");
}
```

### Source Code from the Library

```csharp

	public void AwardGift(BasePlayer player)
	{
		if (Interface.CallHook("OnAdventGiftAward", this, player) != null)
		{
			return;
		}
		DateTime now = DateTime.Now;
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) == startMonth && num >= 0 && num < days.Length)
		{
			if (!playerRewardHistory.ContainsKey(player.userID))
			{
				playerRewardHistory.Add(player.userID, new List<int>());
			}
			playerRewardHistory[player.userID].Add(num);
			Effect.server.Run(giftEffect.resourcePath, player.transform.position);
			if (num >= 0 && num < crosses.Length)
			{
				Effect.server.Run(boxCloseEffect.resourcePath, base.transform.position + Vector3.up * 1.5f);
			}
			DayReward dayReward = days[num];
			for (int i = 0; i < dayReward.rewards.Length; i++)
			{
				ItemAmount itemAmount = dayReward.rewards[i];
				player.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);
			}
			Interface.CallHook("OnAdventGiftAwarded", this, player);
		}
	}

```

## CanUnlock(BasePlayer,KeyLock)

```csharp
/// <summary>
/// Called when a player attempts to unlock an entity.
/// </summary>
/// <param name="player">The player attempting to unlock the entity.</param>
/// <param name="lock">The lock being unlocked.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
bool CanUnlock(BasePlayer player, KeyLock lock)
{
    Puts("CanUnlock is working!");
    return true;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnNearbyTurretsScan(AutoTurret,System.Collections.Generic.List<AutoTurret>,bool)

```csharp
/// <summary>
/// Called when the nearby turrets are scanned.
/// </summary>
/// <param name="turret">The turret that is scanning for nearby turrets.</param>
/// <param name="nearbyTurrets">A list of nearby turrets.</param>
/// <param name="created">Whether a new turret was created or not.</param>
/// <returns>No return behavior.</returns>
void OnNearbyTurretsScan(AutoTurret turret, List<AutoTurret> nearbyTurrets, bool created)
{
    Puts($"Nearby turrets scanned for {turret.name}");
}
```

### Source Code from the Library

```csharp

	public void UpdateNearbyTurrets(bool created)
	{
		List<AutoTurret> obj = Facepunch.Pool.GetList<AutoTurret>();
		if (Interface.CallHook("OnNearbyTurretsScan", this, obj, created) == null)
		{
			Vis.Entities(base.transform.position, Sentry.interferenceradius, obj, 256, QueryTriggerInteraction.Ignore);
		}
		foreach (AutoTurret item in obj)
		{
			if (!(item == this))
			{
				if (created)
				{
					nearbyTurrets.Add(item);
					item.nearbyTurrets.Add(this);
				}
				else
				{
					item.nearbyTurrets.Remove(this);
				}
			}
		}
		if (!created)
		{
			nearbyTurrets.Clear();
		}
		Facepunch.Pool.FreeList(ref obj);
	}

```

## OnEntityDestroy(CH47HelicopterAIController)

```csharp
/// <summary>
/// Called when a helicopter AI controller is destroyed.
/// </summary>
/// <param name="controller">The destroyed helicopter AI controller.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityDestroy(CH47HelicopterAIController controller)
{
    Puts("OnEntityDestroy is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

```

## OnExperimentEnded(Workbench)

```csharp
/// <summary>
/// Called when an experiment has ended.
/// </summary>
/// <param name="workbench">The workbench where the experiment was conducted.</param>
/// <returns>No return behavior.</returns>
void OnExperimentEnded(Workbench workbench)
{
    Puts("OnExperimentEnded is working!");
}
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnFishCatch(Item,BaseFishingRod,BasePlayer)

```csharp
Документация для OnFishCatch(Item, BaseFishingRod, BasePlayer)

**Описание**

Этот хук вызывается при улове рыбы. Он позволяет модулю изменить поведение игрока и предметов в зависимости от типа пойманной рыбы.

**Параметры**

* `Item`: Пойманная рыба.
* `BaseFishingRod`: Базовый рыболовный удочка, используемый для улова.
* `BasePlayer`: Игрок, который поймал рыбу.

**Возвращаемые значения**

Нет возвращаемых значений. Хук изменяет поведение игрока и предметов напрямую.

**Пример использования**

```csharp
public class MyFishModule : MonoBehaviour
{
    public void OnFishCatch(Item item, BaseFishingRod rod, BasePlayer player)
    {
        // Если пойманная рыба - карп, то изменяем поведение игрока и предметов
        if (item.shortname == "fish.carps")
        {
            player.SignalBroadcast(Signal.Alt_Attack);
            rod.Kill();
        }
    }
}
```

**Примечания**

Этот хук вызывается только один раз, когда игрок поймает рыбу. Если вы хотите изменить поведение игрока и предметов каждый раз, когда игрок использует рыболовный удочку, то вам нужно вызывать этот хук в другом месте кода.
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## OnWildlifeTrap(WildlifeTrap,TrappableWildlife)

```csharp
/// <summary>
/// Called when a wildlife trap is triggered.
/// </summary>
/// <param name="trap">The wildlife trap that was triggered.</param>
/// <param name="wildlife">The trappable wildlife caught by the trap.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns an object representing the result of the hook.</returns>
object OnWildlifeTrap(WildlifeTrap trap, TrappableWildlife wildlife)
{
    Puts("OnWildlifeTrap called!");
    // Minimal code to demonstrate functionality
}
```

### Source Code from the Library

```csharp

	public void TrapWildlife(TrappableWildlife trapped)
	{
		if (Interface.CallHook("OnWildlifeTrap", this, trapped) == null)
		{
			Item item = ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Remove();
				OnTrappedWildlife(setFlag: false);
			}
			else
			{
				OnTrappedWildlife(setFlag: true);
			}
		}
	}

```

## OnNpcEquipWeapon(ScientistNPC,Item)

```csharp
/// <summary>
/// Called when an NPC equips a weapon.
/// </summary>
/// <param name="npc">The NPC equipping the weapon.</param>
/// <param name="item">The item being equipped.</param>
/// <returns>No return behavior.</returns>
void OnNpcEquipWeapon(ScientistNPC npc, Item item)
{
    Puts($"NPC {npc} equipped item: {item}");
}
```

### Source Code from the Library

```csharp

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
		HeldEntity heldEntity = GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		Item item = heldEntity.GetItem();
		if (item == null || item.contents == null || Interface.CallHook("OnNpcEquipWeapon", this, item) != null)
		{
			return;
		}
		if (UnityEngine.Random.Range(0, 3) == 0)
		{
			Item item2 = ItemManager.CreateByName("weapon.mod.flashlight", 1, 0uL);
			if (!item2.MoveToContainer(item.contents))
			{
				item2.Remove();
				return;
			}
			lightsOn = false;
			InvokeRandomized(base.LightCheck, 0f, 30f, 5f);
			LightCheck();
		}
		else
		{
			Item item3 = ItemManager.CreateByName("weapon.mod.lasersight", 1, 0uL);
			if (!item3.MoveToContainer(item.contents))
			{
				item3.Remove();
			}
			LightToggle();
			lightsOn = true;
		}
	}

```

## CanBeRecycled(Item,Recycler)

```csharp
/// <summary>
/// Called to determine if an item can be recycled.
/// </summary>
/// <param name="item">The item being checked for recyclability.</param>
/// <param name="recycler">The recycler performing the check.</param>
/// <returns>Returns true if the item can be recycled, false otherwise.</returns>
object CanBeRecycled(Item item, Recycler recycler)
{
    Puts("CanBeRecycled is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	private bool CanBeRecycled(Item item)
	{
		object obj = Interface.CallHook("CanBeRecycled", item, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item != null)
		{
			return item.info.Blueprint != null;
		}
		return false;
	}

```

## OnQuarryConsumeFuel(MiningQuarry,Item)

```csharp
/// <summary>
/// Called when a quarry consumes fuel.
/// </summary>
/// <param name="quarry">The mining quarry consuming fuel.</param>
/// <param name="item">The item being consumed as fuel.</param>
/// <returns>Returns the consumed item if its amount is greater than or equal to 1, otherwise returns null.</returns>
object OnQuarryConsumeFuel(MiningQuarry quarry, Item item)
{
    Puts("OnQuarryConsumeFuel called!");
    return item;
}
```

### Source Code from the Library

```csharp

	public bool FuelCheck()
	{
		if (pendingWork > 0f)
		{
			return true;
		}
		Item item = fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemByItemName("diesel_barrel");
		object obj = Interface.CallHook("OnQuarryConsumeFuel", this, item);
		if (obj is Item)
		{
			item = (Item)obj;
		}
		if (item != null && item.amount >= 1)
		{
			pendingWork += workPerFuel;
			Facepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);
			item.UseItem();
			return true;
		}
		return false;
	}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when a vending machine admin interface is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <param name="player">The player opening the admin interface.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Admin interface opened for vending machine {vendingMachine} by player {player}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			OpenShop(player);
			ClientRPC(RpcTarget.Player("CLIENT_OpenAdminMenu", player));
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## CanReceiveCall(PhoneController)

```csharp
/// <summary>
/// Called to determine if a call can be received by the phone controller.
/// </summary>
/// <param name="controller">The phone controller.</param>
/// <returns>Returns <c>true</c> if the call can be received, and <c>false</c> otherwise.</returns>
bool CanReceiveCall(PhoneController controller)
{
    Puts("CanReceiveCall is working!");
    
    // If the return value from Interface.CallHook is a boolean, return it
    object obj = Interface.CallHook("CanReceiveCall", controller);
    if (obj is bool) 
    {
        return (bool)obj;
    }
    
    // Otherwise, check for power and parent requirements
    if (RequirePower && !controller.IsPowered())
    {
        return false;
    }
    if (RequireParent && !controller.baseEntity.HasParent())
    {
        return false;
    }
    
    // If all checks pass, return true
    return true;
}
```

### Source Code from the Library

```csharp

	private bool CanReceiveCall()
	{
		object obj = Interface.CallHook("CanReceiveCall", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequirePower && !IsPowered())
		{
			return false;
		}
		if (RequireParent && !base.baseEntity.HasParent())
		{
			return false;
		}
		return true;
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
/// <summary>
/// Called when a turret's target is set.
/// </summary>
/// <param name="turret">The turret that has a new target.</param>
/// <param name="targetEntity">The entity that the turret is now targeting.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnTurretTarget(AutoTurret turret, BaseCombatEntity targetEntity)
{
    Puts("OnTurretTarget hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);
				MarkDirtyForceUpdateOutputs();
				nextShotTime += 0.1f;
				authDirty = true;
			}
			target = targ;
		}
	}

```

## OnEntityActiveCheck(BaseEntity,BasePlayer,uint,string)

```csharp
/// <summary>
/// Called when the active check for an entity is performed.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <param name="player">The player performing the check.</param>
/// <param name="id">A unique identifier.</param>
/// <param name="debugName">A debug name for the entity.</param>
/// <returns>Returns true if the entity is active, false otherwise.</returns>
bool OnEntityActiveCheck(BaseEntity entity, BasePlayer player, uint id, string debugName)
{
    Puts("OnEntityActiveCheck called!");
    
    // If the entity or player is null, return false
    if (entity == null || player == null)
    {
        return false;
    }
    
    // If the entity's net and player's net are null, return false
    if (entity.net == null || player.net == null)
    {
        return false;
    }
    
    // Return the result of the hook call
    return true; // Or another value depending on the method’s functionality
}
```

### Source Code from the Library

```csharp
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityActiveCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				Item activeItem = player.GetActiveItem();
				if (activeItem == null)
				{
					return false;
				}
				if (activeItem.GetHeldEntity() != ent)
				{
					return false;
				}
				return true;
			}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
/// <summary>
/// Called to determine if a helicopter can use napalm.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <returns>Returns true if the helicopter can use napalm, and false otherwise.</returns>
bool CanHelicopterUseNapalm(PatrolHelicopterAI ai)
{
    Puts("CanHelicopterUseNapalm is working!");
    // Return value is used to determine if the helicopter can use napalm
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= UnityEngine.Random.Range(25f, 35f);
	}

```

## OnPhoneCallStarted(PhoneController,PhoneController,BasePlayer)

```csharp
/// <summary>
/// Called when a phone call is started.
/// </summary>
/// <param name="phoneController">The phone controller initiating the call.</param>
/// <param name="activeCallTo">The recipient of the call.</param>
/// <param name="currentPlayer">The player making the call.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPhoneCallStarted(PhoneController phoneController, PhoneController activeCallTo, BasePlayer currentPlayer)
{
    Puts("OnPhoneCallStarted hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", this, activeCallTo, currentPlayer) == null)
		{
			if (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)
			{
				_ = currentPlayer != null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			Invoke(TimeOutCall, TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", this, activeCallTo, currentPlayer);
		}
	}

```

## OnSignUpdated(CarvablePumpkin,BasePlayer)

```csharp
/// <summary>
/// Called when a sign is updated.
/// </summary>
/// <param name="pumpkin">The CarvablePumpkin instance.</param>
/// <param name="player">The player who updated the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(CarvablePumpkin pumpkin, BasePlayer player)
{
    Puts($"Sign updated by {player} on {pumpkin}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(5f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			UnityEngine.Debug.LogWarning($"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", this, msg.player);
	}

```

## OnVendingShopOpen(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player opening the vending shop.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnVendingShopOpen(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnVendingShopOpen is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", this, msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", this, msg.player);
		}
	}

```

## OnExcavatorMiningToggled(ExcavatorArm)

```csharp
/// <summary>
/// Called when the excavator's mining state is toggled.
/// </summary>
/// <param name="excavatorArm">The excavator arm that triggered the toggle.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnExcavatorMiningToggled(ExcavatorArm excavatorArm)
{
    Puts("OnExcavatorMiningToggled called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public void BeginMining()
	{
		if (!IsPowered())
		{
			return;
		}
		SetFlag(Flags.On, b: true);
		InvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);
		if (UnityEngine.Time.time > nextNotificationTime)
		{
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				if (!activePlayer.IsNpc && activePlayer.IsConnected && !activePlayer.IsInTutorial)
				{
					activePlayer.ShowToast(GameTip.Styles.Server_Event, excavatorPhrase);
				}
			}
			nextNotificationTime = UnityEngine.Time.time + 60f;
		}
		ExcavatorServerEffects.SetMining(isMining: true);
		Facepunch.Rust.Analytics.Server.ExcavatorStarted();
		excavatorStartTime = GetNetworkTime();
		Interface.CallHook("OnExcavatorMiningToggled", this);
	}

```

## OnClientProjectileEffectCreate(Network.Connection,BaseProjectile,string)

```csharp
/// <summary>
/// Called when a projectile effect is created on the client.
/// </summary>
/// <param name="connection">The connection of the client that created the effect.</param>
/// <param name="projectile">The projectile that triggered the effect creation.</param>
/// <param name="prefabName">The name of the prefab used to create the effect.</param>
/// <returns>No return behavior.</returns>
void OnClientProjectileEffectCreate(Network.Connection connection, BaseProjectile projectile, string prefabName)
{
    Puts("OnClientProjectileEffectCreate is working!");
}
```

### Source Code from the Library

```csharp

	public void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false, List<Connection> targets = null)
	{
		if (Interface.CallHook("OnClientProjectileEffectCreate", sourceConnection, this, prefabName) == null)
		{
			Effect effect = reusableInstance;
			effect.Clear();
			effect.Init(Effect.Type.Projectile, pos, velocity, sourceConnection);
			effect.scale = (silenced ? 0f : 1f);
			if (forceClientsideEffects)
			{
				effect.scale = 2f;
			}
			effect.pooledString = prefabName;
			effect.number = seed;
			effect.targets = targets;
			EffectNetwork.Send(effect);
		}
	}

```

## OnHorseLead(BaseRidableAnimal,BasePlayer)

```csharp
/// <summary>
/// Called when a player attempts to lead a ridable animal.
/// </summary>
/// <param name="animal">The ridable animal being led.</param>
/// <param name="player">The player attempting to lead the animal.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns an object representing the result of the hook.</returns>
object OnHorseLead(BaseRidableAnimal animal, BasePlayer player)
{
    Puts("OnHorseLead called!");
    // Minimal code to demonstrate functionality
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Lead(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && !AnyMounted() && !IsForSale())
		{
			bool num = IsLeading();
			bool flag = msg.read.Bit();
			if (num != flag && Interface.CallHook("OnHorseLead", this, player) == null)
			{
				SetLeading(flag ? player : null);
				LeadingChanged();
			}
		}
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
Документация для IOnBaseCombatEntityHurt(BaseCombatEntity, HitInfo)

/// <summary>
/// Called when a combat entity is hurt.
/// </summary>
/// <param name="entity">The combat entity being hurt.</param>
/// <param name="info">Information about the hit.</param>
/// <returns>No return behavior.</returns>
void IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo info)
{
    // Minimal code to demonstrate functionality
    Debug.Log("Entity " + entity.gameObject.name + " was hurt by " + info.Initiator.gameObject.name);
}
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead() || IsTransferProtected())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (!(this is BasePlayer))
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			float num2 = info.damageTypes.Total();
			health = num - num2;
			SendNetworkUpdate();
			if (ConVar.Global.developer > 1)
			{
				Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " hurt " + info.damageTypes.GetMajorityDamageType().ToString() + "/" + num2 + " - " + health.ToString("0") + " health left");
			}
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
					baseCombatEntity.lastDealtDamageTo = this;
				}
				if (this.IsValid() && lastAttacker is BasePlayer basePlayer)
				{
					basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.HURT_ENTITY, net.ID, num2);
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (markAttackerHostile && baseCombatEntity2 != null && baseCombatEntity2 != this)
			{
				baseCombatEntity2.MarkHostileFor();
			}
			if (lastDamage.IsConsideredAnAttack())
			{
				SetJustAttacked();
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;
				}
			}
			bool flag = Health() <= 0f;
			Facepunch.Rust.Analytics.Azure.OnEntityTakeDamage(info, flag);
			if (flag)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.LogAttack(info, "killed", num);
				}
				else
				{
					initiatorPlayer.stats.combat.LogAttack(info, "", num);
				}
			}
		}
	}

```

## OnAddVendingOffer(VendingMachine,ProtoBuf.VendingMachine.SellOrder)

```csharp
/// <summary>
/// Called when a new vending offer is added.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer is being added to.</param>
/// <param name="sellOrder">The sell order details of the offer.</param>
/// <returns>No return behavior.</returns>
void OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"New vending offer added to {vendingMachine} with sell order: {sellOrder}");
}
```

### Source Code from the Library

```csharp

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = itemToSellID;
			sellOrder.itemToSellAmount = itemToSellAmount;
			sellOrder.currencyID = currencyToUseID;
			sellOrder.currencyAmountPerItem = currencyAmount;
			sellOrder.currencyIsBP = bpState == 3 || bpState == 2;
			sellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", this, sellOrder);
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## OnHelicopterRetire(PatrolHelicopterAI)

```csharp
/// <summary>
/// Called when a patrol helicopter is retired.
/// </summary>
/// <param name="helicopter">The helicopter being retired.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterRetire(PatrolHelicopterAI helicopter)
{
    Puts("OnHelicopterRetire is working!");
}
```

### Source Code from the Library

```csharp

	public void Retire()
	{
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", this) == null)
		{
			Invoke(DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 newPos = Vector3Ex.Range(-1f, 1f);
			newPos.y = 0f;
			newPos.Normalize();
			newPos *= x * 20f;
			newPos.y = y;
			ExitCurrentState();
			isRetiring = true;
			State_Move_Enter(newPos);
		}
	}

```

## CanElevatorLiftMove(ElevatorLift)

```csharp
/// <summary>
/// Called to determine if the elevator lift can move.
/// </summary>
/// <param name="elevatorLift">The elevator lift in question.</param>
/// <returns>Returns <c>true</c> if the elevator lift can move, and <c>false</c> otherwise.</returns>
object CanElevatorLiftMove(ElevatorLift elevatorLift)
{
    Puts("CanElevatorLiftMove is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool CanMove()
	{
		object obj = Interface.CallHook("CanElevatorLiftMove", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (VehicleTrigger.HasContents && VehicleTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in VehicleTrigger.entityContents)
			{
				if (!vehiclePrefabWhitelist.Contains(entityContent.prefabID))
				{
					return false;
				}
			}
		}
		return true;
	}

```

## OnOvenStart(BaseOven)

```csharp
/// <summary>
/// Called when the oven starts cooking.
/// </summary>
/// <param name="oven">The oven that started cooking.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnOvenStart(BaseOven oven)
{
    Puts("OnOvenStart hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			InvokeRepeating(Cook, 0.5f, 0.5f);
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", this);
		}
	}

```

## OnMapImageUpdated()

```csharp
/// <summary>
/// Called when a map image is updated.
/// </summary>
/// <param name="imageId">The ID of the updated image.</param>
/// <param name="imageType">The type of the updated image (0 = fog, 1 = paint).</param>
/// <returns>No return behavior.</returns>
void OnMapImageUpdated(uint imageId, byte imageType)
{
    Puts($"Map image {imageType} updated with ID {imageId}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void ImageUpdate(RPCMessage msg)
	{
		if (msg.player == null)
		{
			return;
		}
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}

```

## IOnNpcTarget(BaseNpc,BaseEntity)

```csharp
/// <summary>
/// Called when an NPC targets a specific entity.
/// </summary>
/// <param name="npc">The NPC that has targeted the entity.</param>
/// <param name="target">The entity being targeted by the NPC.</param>
/// <returns>Returns a float value indicating the NPC's willingness to attack the target, or null if no default behavior is overridden.</returns>
float IOnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts("IOnNpcTarget hook called!");
    return 0.5f; // Default implementation returns a float value
}
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

```

## OnSignLocked(PhotoFrame,BasePlayer)

```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that was locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnSignLocked(PhotoFrame sign, BasePlayer player)
{
    Puts("OnSignLocked hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## OnCorpsePopulate(ScarecrowNPC,NPCPlayerCorpse)

```csharp
/// <summary>
/// Called when a corpse is populated with loot.
/// </summary>
/// <param name="scarecrowNPC">The Scarecrow NPC.</param>
/// <param name="npcPlayerCorpse">The player's corpse.</param>
/// <returns>Returns the populated corpse if overridden, otherwise null.</returns>
object OnCorpsePopulate(ScarecrowNPC scarecrowNPC, NPCPlayerCorpse npcPlayerCorpse)
{
    // Minimal code to demonstrate functionality
    Puts("OnCorpsePopulate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = "assets/prefabs/npc/murderer/murderer_corpse.prefab";
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse(strCorpsePrefab, flagsOnDeath, modelState) as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);
				nPCPlayerCorpse.playerName = "Scarecrow";
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
				if (LootSpawnSlots.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int i = 0; i < lootSpawnSlots.Length; i++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
						for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
				if (wasSoulReleased)
				{
					LootContainer.LootSpawnSlot[] lootSpawnSlots = bonusLootSlots;
					for (int i = 0; i < lootSpawnSlots.Length; i++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot2 = lootSpawnSlots[i];
						for (int k = 0; k < lootSpawnSlot2.numberToSpawn; k++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot2.probability)
							{
								lootSpawnSlot2.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
/// <summary>
/// Called to determine if a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>Returns true if the target player can be looted, false otherwise.</returns>
bool CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts("CanLootPlayer is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		if ((IsWounded() || IsSleeping() || CurrentGestureIsSurrendering || IsRestrainedOrSurrendering) && !IsLoadingAfterTransfer())
		{
			return !IsTransferring();
		}
		return false;
	}

```

## CanLootEntity(BasePlayer,BaseRidableAnimal)

```csharp
/// <summary>
/// Called when a player attempts to loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool CanLootEntity(BasePlayer player, BaseRidableAnimal entity)
{
    Puts("CanLootEntity is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (storageInventory == null)
		{
			return;
		}
		BasePlayer player = rpc.player;
		string text = rpc.read.String();
		if ((bool)player && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			ItemContainer container = equipmentInventory;
			string arg = lootPanelName;
			if (text == "storage")
			{
				arg = storagePanelName;
				container = storageInventory;
			}
			player.inventory.loot.AddContainer(container);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), arg);
			SendNetworkUpdate();
		}
	}

```

## OnWorldPrefabSpawned(UnityEngine.GameObject,string)

```csharp
/// <summary>
/// Called when a world prefab is spawned.
/// </summary>
/// <param name="gameObject">The spawned game object.</param>
/// <param name="category">The category of the spawned prefab.</param>
/// <returns>No return behavior.</returns>
void OnWorldPrefabSpawned(GameObject gameObject, string category)
{
    Puts($"World prefab {category} spawned at position: {gameObject.transform.position}");
}
```

### Source Code from the Library

```csharp

	private static void Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		if (prefab != null && (bool)prefab.Object)
		{
			spawnTimer.Restart();
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject gameObject = prefab.Spawn(position, rotation, scale);
			if ((bool)gameObject)
			{
				Interface.CallHook("OnWorldPrefabSpawned", gameObject, category);
				GameObjectEx.SetHierarchyGroup(gameObject, category);
			}
			spawnTimer.Stop();
			spawnTimings.Add(new SpawnTiming
			{
				category = category,
				prefab = prefab,
				position = position,
				rotation = rotation,
				scale = scale,
				time = spawnTimer.Elapsed
			});
		}
	}

```

## OnItemStacked(Item,Item,ItemContainer)

```csharp
Документация для OnItemStacked хука:

**Название:** `OnItemStacked`

**Описание:** Этот хук вызывается при стэкинге предмета в контейнер.

**Параметры:**

* `Item` **item1**: Предмет, который будет добавлен к существующему предмету.
* `Item` **item2**: Существующий предмет, в который будет добавлен новый предмет.
* `ItemContainer` **container**: Контейнер, в котором происходит стэкинг.
* `int` **amount**: Количество предметов, которые будут добавлены.

**Возвращаемые значения:**

Нет.

**Примечания:**

Этот хук вызывается после того, как предметы были проверены на возможность стэкинга и количество предметов было обновлено. Он позволяет модулю или плагину реагировать на событие стэкинга предмета в контейнер.

**Пример использования:**
```csharp
public void OnItemStacked(Item item1, Item item2, ItemContainer container, int amount)
{
    // Реакция на событие стэкинга предмета в контейнер
}
```
В этом примере мы создали метод `OnItemStacked`, который будет вызван при стэкинге предмета в контейнер. В методе можно реализовать любую логику, связанную с этим событием.
```

### Source Code from the Library

```csharp

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		using (TimeWarning.New("MoveToContainer"))
		{
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					foreach (Item item3 in from x in newcontainer.FindItemsByItemID(info.itemid)
						orderby x.position
						select x)
					{
						if (item3.CanStack(this) && (ignoreStackLimit || item3.amount < item3.MaxStackable()))
						{
							iTargetPos = item3.position;
						}
					}
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.availableSlots != null && newcontainer.availableSlots.Count > 0 && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", slot2, this, newcontainer, num2);
						MarkDirty();
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", item2, this, newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
	}

```

## OnInputUpdate(IOEntity,int,int)

```csharp
/// <summary>
/// Called when the input of an IO entity is updated.
/// </summary>
/// <param name="entity">The IO entity whose input has been updated.</param>
/// <param name="inputAmount">The amount of input received by the entity.</param>
/// <param name="inputSlot">The slot number of the input that was updated.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnInputUpdate(IOEntity entity, int inputAmount, int inputSlot)
{
    Puts("OnInputUpdate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (Interface.CallHook("OnInputUpdate", this, inputAmount, inputSlot) != null)
		{
			return;
		}
		if (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)
		{
			IOStateChanged(inputAmount, inputSlot);
			return;
		}
		UpdateHasPower(inputAmount, inputSlot);
		lastEnergy = currentEnergy;
		currentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);
		int passthroughAmount = GetPassthroughAmount();
		bool flag = lastPassthroughEnergy != passthroughAmount;
		lastPassthroughEnergy = passthroughAmount;
		if (currentEnergy != lastEnergy || flag)
		{
			IOStateChanged(inputAmount, inputSlot);
			ensureOutputsUpdated = true;
		}
		_processQueues[GetQueueType()].Enqueue(this);
	}

```

## OnWireConnect(BasePlayer,IOEntity,int,IOEntity,int,System.Collections.Generic.List<UnityEngine.Vector3>,System.Collections.Generic.List<float>)

```csharp
/// <summary>
/// Called when a player attempts to connect two entities with wires.
/// </summary>
/// <param name="player">The player attempting the connection.</param>
/// <param name="inputEntity">The entity being connected from.</param>
/// <param name="inputIndex">The index of the input on the input entity.</param>
/// <param name="outputEntity">The entity being connected to.</param>
/// <param name="outputIndex">The index of the output on the output entity.</param>
/// <param name="linePoints">A list of points defining the wire's path.</param>
/// <param name="slackLevels">A list of slack levels for the wire.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnWireConnect(BasePlayer player, IOEntity inputEntity, int inputIndex, IOEntity outputEntity, int outputIndex, List<UnityEngine.Vector3> linePoints, List<float> slackLevels)
{
    // Minimal code to demonstrate functionality
    Puts("OnWireConnect called!");
    
    // Return a non-null value if the default behavior is overridden
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(5uL)]
	public void RPC_MakeConnection(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		WireConnectionMessage wireConnectionMessage = WireConnectionMessage.Deserialize(rpc.read);
		List<Vector3> linePoints = wireConnectionMessage.linePoints;
		int inputIndex = wireConnectionMessage.inputIndex;
		int outputIndex = wireConnectionMessage.outputIndex;
		IOEntity iOEntity = new EntityRef<IOEntity>(wireConnectionMessage.inputID).Get(serverside: true);
		IOEntity iOEntity2 = new EntityRef<IOEntity>(wireConnectionMessage.outputID).Get(serverside: true);
		if (iOEntity == null || iOEntity2 == null || !ValidateLine(linePoints, iOEntity, iOEntity2, player, outputIndex) || inputIndex >= iOEntity.inputs.Length || outputIndex >= iOEntity2.outputs.Length || iOEntity.inputs[inputIndex].connectedTo.Get() != null || iOEntity2.outputs[outputIndex].connectedTo.Get() != null || (iOEntity.inputs[inputIndex].rootConnectionsOnly && !iOEntity2.IsRootEntity()) || !CanModifyEntity(player, iOEntity) || !CanModifyEntity(player, iOEntity2))
		{
			return;
		}
		List<float> slackLevels = wireConnectionMessage.slackLevels;
		IOEntity.LineAnchor[] array = new IOEntity.LineAnchor[wireConnectionMessage.lineAnchors.Count];
		for (int i = 0; i < wireConnectionMessage.lineAnchors.Count; i++)
		{
			WireLineAnchorInfo wireLineAnchorInfo = wireConnectionMessage.lineAnchors[i];
			array[i].entityRef = new EntityRef<Door>(wireLineAnchorInfo.parentID);
			array[i].boneName = wireLineAnchorInfo.boneName;
			array[i].index = (int)wireLineAnchorInfo.index;
			array[i].position = wireLineAnchorInfo.position;
		}
		WireColour wireColour = IntToColour(wireConnectionMessage.wireColor);
		if (Interface.CallHook("OnWireConnect", player, iOEntity, inputIndex, iOEntity2, outputIndex, wireConnectionMessage.linePoints, slackLevels) == null)
		{
			if (wireColour == WireColour.Invisible && !player.IsInCreativeMode)
			{
				wireColour = DefaultColor;
			}
			iOEntity2.ConnectTo(iOEntity, outputIndex, inputIndex, linePoints, slackLevels, array, wireColour);
			if (wireType == IOEntity.IOType.Industrial)
			{
				iOEntity.NotifyIndustrialNetworkChanged();
				iOEntity2.NotifyIndustrialNetworkChanged();
			}
		}
	}

```

## OnScientistInitialized(BradleyAPC,ScientistNPC,UnityEngine.Vector3)

```csharp
/// <summary>
/// Called when a Scientist NPC is initialized.
/// </summary>
/// <param name="scientist">The Scientist NPC instance.</param>
/// <param name="spawnPos">The position where the Scientist NPC was spawned.</param>
/// <returns>No return behavior.</returns>
void OnScientistInitialized(ScientistNPC scientist, Vector3 spawnPos)
{
    Puts($"Scientist initialized at {spawnPos} with ID {scientist.GetId()}");
}
```

### Source Code from the Library

```csharp

	private void InitScientist(ScientistNPC scientist, Vector3 spawnPos, BasePlayer triggerPlayer, bool roadSpawned, bool startChasing)
	{
		if (scientist == null)
		{
			return;
		}
		scientist.transform.position = spawnPos;
		if (!scientist.Brain.Navigator.PlaceOnNavMesh(0.2f))
		{
			activeScientists.Remove(scientist);
			scientist.Kill();
			return;
		}
		if (triggerPlayer != null)
		{
			scientist.Brain.Events.Memory.Entity.Set(triggerPlayer, 0);
			scientist.Brain.Senses.Memory.SetKnown(triggerPlayer, scientist, null);
			scientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 7);
			scientist.Brain.Events.Memory.Position.Set(scientist.Brain.Navigator.transform.position, 4);
			scientist.Brain.Events.Memory.Entity.Set(this, 7);
			AttackEntity attackEntity = scientist.GetAttackEntity();
			if (SetScientistChaseBasedOnWeapon && attackEntity != null && !attackEntity.CanUseAtLongRange)
			{
				startChasing = true;
			}
			scientist.Brain.Navigator.CanPathFindToChaseTargetIfNoMovePoint = startChasing;
			scientist.Brain.Navigator.CanUseRandomMovePointIfNonFound = !startChasing;
			if (startChasing)
			{
				scientist.Brain.SwitchToState(AIState.Chase, 6);
			}
			else
			{
				scientist.Brain.SwitchToState(AIState.TakeCover, 4);
			}
			scientist.Brain.Think(0f);
		}
		Interface.CallHook("OnScientistInitialized", this, scientist, spawnPos);
	}

```

## OnPayForUpgrade(BasePlayer,BuildingBlock,ConstructionGrade)

```csharp
/// <summary>
/// Called when a player pays for an upgrade.
/// </summary>
/// <param name="player">The player paying for the upgrade.</param>
/// <param name="block">The building block being upgraded.</param>
/// <param name="grade">The construction grade of the upgrade.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade grade)
{
    Puts("OnPayForUpgrade called!");
    // If you want to override the default behavior, return a non-null value
    return null;
}
```

### Source Code from the Library

```csharp

	public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
	{
		if (Interface.CallHook("OnPayForUpgrade", player, this, g) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in g.CostToBuild(grade))
		{
			player.inventory.Take(list, item.itemid, (int)item.amount);
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemid);
			Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "upgrade_block", itemDefinition.shortname, (int)item.amount, this, null, safezone: false, null, player.userID);
			player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## OnServerRestart(string,int)

```csharp
/// <summary>
/// Called when the server is about to restart.
/// </summary>
/// <param name="notice">A notice message to be displayed to clients.</param>
/// <param name="seconds">The number of seconds until the server restarts.</param>
/// <returns>No return behavior. The method will interrupt the server restart if it returns a non-null value.</returns>
void OnServerRestart(string notice, int seconds)
{
    Puts($"Server is restarting in {seconds} seconds with notice: {notice}");
}
```

### Source Code from the Library

```csharp

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (SingletonComponent<ServerMgr>.Instance == null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
			SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", strNotice, iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

```

## OnPhoneAnswer(PhoneController,PhoneController)

```csharp
/// <summary>
/// Called when a phone call is answered.
/// </summary>
/// <param name="caller">The PhoneController of the caller.</param>
/// <param name="callee">The PhoneController of the callee.</param>
/// <returns>No return behavior.</returns>
void OnPhoneAnswer(PhoneController caller, PhoneController callee)
{
    Puts("OnPhoneAnswer is working!");
}
```

### Source Code from the Library

```csharp

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (IsInvoking(TimeOutDialing))
		{
			CancelInvoke(TimeOutDialing);
		}
		if (!(activeCallTo == null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", this, activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", this, activeCallTo);
			}
		}
	}

```

## OnOvenTemperature(BaseOven,int)

```csharp
/// <summary>
/// Called when the oven temperature is requested.
/// </summary>
/// <param name="oven">The oven instance.</param>
/// <param name="slot">The slot number of the oven.</param>
/// <returns>Returns a float value representing the oven temperature, or null if not overridden.</returns>
float OnOvenTemperature(BaseOven oven, int slot)
{
    // Minimal code to demonstrate functionality
    return 0f;
}
```

### Source Code from the Library

```csharp

	public float GetTemperature(int slot)
	{
		object obj = Interface.CallHook("OnOvenTemperature", this, slot);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!HasFlag(Flags.On))
		{
			return 15f;
		}
		return cookingTemperature;
	}

```

## OnCoalingTowerStart(CoalingTower,BasePlayer)

```csharp
/// <summary>
/// Called when a coaling tower starts.
/// </summary>
/// <param name="coalingTower">The coaling tower that started.</param>
/// <param name="player">The player who triggered the start.</param>
/// <returns>No return behavior.</returns>
void OnCoalingTowerStart(CoalingTower coalingTower, BasePlayer player)
{
    Puts($"Coaling tower {coalingTower} started by player {player}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Unload(RPCMessage msg)
	{
		if (Interface.CallHook("OnCoalingTowerStart", this, msg.player) == null && !TryUnloadActiveWagon(out var attemptStatus) && msg.player != null)
		{
			ClientRPC(RpcTarget.Player("ActionFailed", msg.player), (byte)attemptStatus, arg2: true);
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
/// <summary>
/// Determines whether a helicopter can target a player.
/// </summary>
/// <param name="helicopterAI">The PatrolHelicopterAI instance.</param>
/// <param name="player">The BasePlayer instance to check.</param>
/// <returns>Returns true if the helicopter can target the player, false otherwise.</returns>
bool CanHelicopterTarget(PatrolHelicopterAI helicopterAI, BasePlayer player)
{
    // Minimal code to demonstrate functionality
    return true; // Replace with actual logic based on the context
}
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (ply.eyes.position.y < WaterSystem.OceanLevel && Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) > oceanDepthTargetCutoff)
		{
			return false;
		}
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## CanDestroyLock(BasePlayer,ModularCar,BaseVehicleModule)

```csharp
/// <summary>
/// Called when a player attempts to destroy the lock of a vehicle.
/// </summary>
/// <param name="player">The player attempting to destroy the lock.</param>
/// <param name="car">The vehicle with the lock being destroyed.</param>
/// <param name="module">The module containing the lock being destroyed.</param>
/// <returns>Returns true if the player can destroy the lock, and false otherwise.</returns>
bool CanDestroyLock(BasePlayer player, ModularCar car, BaseVehicleModule module)
{
    Puts("CanDestroyLock is working!");
    return true; // Default behavior: allow destruction
}
```

### Source Code from the Library

```csharp

	public bool PlayerCanDestroyLock(BasePlayer player, BaseVehicleModule viaModule)
	{
		object obj = Interface.CallHook("CanDestroyLock", player, this, viaModule);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CarLock.PlayerCanDestroyLock(viaModule);
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldHealth">The player's old health value.</param>
/// <param name="newHealth">The player's new health value.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Player {player.UserID} health changed from {oldHealth} to {newHealth}");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) != null)
		{
			return;
		}
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer)
		{
			if (oldvalue > newvalue)
			{
				LifeStoryHurt(oldvalue - newvalue);
			}
			else
			{
				LifeStoryHeal(newvalue - oldvalue);
			}
			metabolism.isDirty = true;
		}
	}

```

## OnDemoRecordingStart(string,BasePlayer)

```csharp
/// <summary>
/// Called when a demo recording is started.
/// </summary>
/// <param name="filePath">The path to the demo file.</param>
/// <param name="player">The player who initiated the recording.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStart(string filePath, BasePlayer player)
{
    Puts($"Demo recording started at {filePath} by player {player.UserIDString}");
}
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnItemSubmit(Item,Mailbox,BasePlayer)

```csharp
/// <summary>
/// Called when an item is submitted to the mailbox.
/// </summary>
/// <param name="item">The item being submitted.</param>
/// <param name="mailbox">The mailbox that received the item.</param>
/// <param name="player">The player who submitted the item.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemSubmit(Item item, Mailbox mailbox, BasePlayer player)
{
    Puts("OnItemSubmit hook called!");
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp

	public void SubmitInputItems(BasePlayer fromPlayer)
	{
		Item slot = base.inventory.GetSlot(mailInputSlot);
		if (IsFull() || slot == null || Interface.CallHook("OnItemSubmit", slot, this, fromPlayer) != null)
		{
			return;
		}
		if (MoveItemToStorage(slot))
		{
			if (slot.position != mailInputSlot)
			{
				Effect.server.Run(mailDropSound.resourcePath, GetDropPosition());
				if (fromPlayer != null && !PlayerIsOwner(fromPlayer))
				{
					SetFlag(Flags.On, b: true);
				}
			}
		}
		else
		{
			slot.Drop(GetDropPosition(), GetDropVelocity());
		}
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
/// <summary>
/// Called when a structure is being repaired.
/// </summary>
/// <param name="entity">The entity being repaired.</param>
/// <param name="player">The player performing the repair.</param>
/// <returns>No return behavior.</returns>
void OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
{
    Puts($"Structure {entity.ShortName} is being repaired by player {player.Name}");
}
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		float num = 30f;
		if (player2.IsInCreativeMode && Creative.freeRepair)
		{
			num = 0f;
		}
		if (SecondsSinceAttacked <= num)
		{
			OnRepairFailed(player2, $"Unable to repair: Recently damaged. Repairable in: {num - SecondsSinceAttacked:N0}s.");
			return;
		}
		float num2 = MaxHealth() - Health();
		float num3 = num2 / MaxHealth();
		if (num2 <= 0f || num3 <= 0f)
		{
			OnRepairFailed(player2, "Unable to repair: Not damaged.");
			return;
		}
		List<ItemAmount> list = RepairCost(num3);
		if (list == null)
		{
			return;
		}
		float num4 = list.Sum((ItemAmount x) => x.amount);
		float healthBefore = health;
		if (player2.IsInCreativeMode && Creative.freeRepair)
		{
			num4 = 0f;
		}
		if (num4 > 0f)
		{
			float num5 = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			if (float.IsNaN(num5))
			{
				num5 = 0f;
			}
			num5 = Mathf.Min(num5, 50f / num2);
			if (num5 <= 0f)
			{
				OnRepairFailedResources(player2, list);
				return;
			}
			int num6 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(num5 * item.amount);
				int num7 = player2.inventory.Take(null, item.itemid, amount);
				Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "repair_entity", item.itemDef.shortname, num7, this, null, safezone: false, null, player2.userID);
				if (num7 > 0)
				{
					num6 += num7;
					player2.Command("note.inv", item.itemid, num7 * -1);
				}
			}
			float num8 = (float)num6 / num4;
			health += num2 * num8;
			SendNetworkUpdate();
		}
		else
		{
			health += num2;
			SendNetworkUpdate();
		}
		Facepunch.Rust.Analytics.Azure.OnEntityRepaired(player2, this, healthBefore, health);
		if (Health() >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
/// <summary>
/// Determines whether a helicopter can strafe a target player.
/// </summary>
/// <param name="helicopterAI">The AI controlling the helicopter.</param>
/// <param name="targetPlayer">The player to be targeted by the helicopter.</param>
/// <returns>Returns true if the helicopter can strafe the target player, and false otherwise.</returns>
bool CanHelicopterStrafeTarget(PatrolHelicopterAI helicopterAI, BasePlayer targetPlayer)
{
    Puts("CanHelicopterStrafeTarget is working!");
    return true; // Replace with actual logic to determine whether the helicopter can strafe the target player
}
```

### Source Code from the Library

```csharp

	public bool ValidRocketTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ply == null)
		{
			return false;
		}
		return !ply.IsNearEnemyBase();
	}

```

## OnStashExposed(StashContainer,BasePlayer)

```csharp
/// <summary>
/// Called when a stash container is exposed to a player.
/// </summary>
/// <param name="stash">The stash container that was exposed.</param>
/// <param name="player">The player who exposed the stash.</param>
/// <returns>No return behavior.</returns>
void OnStashExposed(StashContainer stash, BasePlayer player)
{
    Puts($"Stash {stash} exposed to player {player}");
}
```

### Source Code from the Library

```csharp

	private void CheckStashRevealInvoke()
	{
		for (int i = 0; i < nearbyStashes.Count; i++)
		{
			NearbyStash nearbyStash = nearbyStashes[i];
			if (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)
			{
				nearbyStashes.RemoveAt(i);
			}
			else if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))
			{
				nearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;
				if (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)
				{
					if (Interface.CallHook("CanSeeStash", this, nearbyStash.Entity) != null)
					{
						break;
					}
					nearbyStash.Entity.SetHidden(isHidden: false);
					Facepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);
					Interface.CallHook("OnStashExposed", nearbyStash.Entity, this);
				}
			}
			else
			{
				nearbyStash.LookingAtTime = 0f;
			}
		}
	}

```

## CanLootEntity(BasePlayer,StorageContainer)

```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="container">The storage container of the entity.</param>
/// <returns>Returns true if the player can loot the entity, and false otherwise.</returns>
bool CanLootEntity(BasePlayer player, StorageContainer container)
{
    Puts("CanLootEntity is working!");
    // Minimal code to demonstrate functionality
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (IsLocked() || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, LockedMessage);
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, InUseMessage);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = panelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			AddContainers(player.inventory.loot);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnPhoneDialTimeout(PhoneController,PhoneController,BasePlayer)

```csharp
/// <summary>
/// Called when a phone dialing timeout occurs.
/// </summary>
/// <param name="phoneController">The phone controller that initiated the dialing.</param>
/// <param name="otherPhoneController">The other phone controller involved in the call.</param>
/// <param name="player">The player who initiated the dialing.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialTimeout(PhoneController phoneController, PhoneController otherPhoneController, BasePlayer player)
{
    Puts("OnPhoneDialTimeout is working!");
}
```

### Source Code from the Library

```csharp

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", activeCallTo, this, activeCallTo.currentPlayer) == null)
		{
			if (activeCallTo != null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", activeCallTo, this, activeCallTo.currentPlayer);
		}
	}

```

## OnVendingShopOpen(NPCVendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine that was opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior if the default behavior is not overridden.</returns>
void OnVendingShopOpen(NPCVendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnVendingShopOpen is working!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if (vendingMachine == null)
		{
			vendingMachine = GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", vendingMachine, msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", vendingMachine, msg.player);
		}
	}

```

## CanRecycle(Recycler,Item)

```csharp
/// <summary>
/// Called to determine if an item can be recycled.
/// </summary>
/// <param name="recycler">The recycler attempting to recycle the item.</param>
/// <param name="item">The item being recycled.</param>
/// <returns>Returns true if the item can be recycled, and false otherwise.</returns>
bool CanRecycle(Recycler recycler, Item item)
{
    Puts("CanRecycle is working!");
    return true; // Replace with actual logic to determine recyclability
}
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## OnCCTVDirectionChange(CCTV_RC,BasePlayer)

```csharp
/// <summary>
/// Called when the direction of a CCTV camera is changed.
/// </summary>
/// <param name="cctv">The CCTV camera whose direction was changed.</param>
/// <param name="player">The player who initiated the change.</param>
/// <returns>No return behavior.</returns>
void OnCCTVDirectionChange(BaseCCTV cctv, BasePlayer player)
{
    Puts($"CCTV direction changed by {player.displayName} for camera {cctv.ShortName}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void Server_SetDir(RPCMessage msg)
	{
		if (!IsStatic())
		{
			BasePlayer player = msg.player;
			if (player.CanBuild() && player.IsBuildingAuthed() && Interface.CallHook("OnCCTVDirectionChange", this, player) == null)
			{
				Vector3 direction = Vector3Ex.Direction(player.eyes.position, yaw.transform.position);
				direction = base.transform.InverseTransformDirection(direction);
				Vector3 vector = BaseMountable.ConvertVector(Quaternion.LookRotation(direction).eulerAngles);
				pitchAmount = Mathf.Clamp(vector.x, pitchClamp.x, pitchClamp.y);
				yawAmount = Mathf.Clamp(vector.y, yawClamp.x, yawClamp.y);
				SendNetworkUpdate();
			}
		}
	}

```

## OnWaterCollect(WaterCatcher)

```csharp
/// <summary>
/// Called when water is collected by a WaterCatcher.
/// </summary>
/// <param name="waterCatcher">The WaterCatcher that collected the water.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnWaterCollect(WaterCatcher waterCatcher)
{
    Puts("OnWaterCollect is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void CollectWater()
	{
		if (!IsFull() && Interface.CallHook("OnWaterCollect", this) == null)
		{
			float baseRate = collectionRates.baseRate;
			baseRate += Climate.GetFog(base.transform.position) * collectionRates.fogRate;
			if (TestIsOutside())
			{
				baseRate += Climate.GetRain(base.transform.position) * collectionRates.rainRate;
				baseRate += Climate.GetSnow(base.transform.position) * collectionRates.snowRate;
			}
			AddResource(Mathf.CeilToInt(maxItemToCreate * baseRate));
		}
	}

```

## OnTeamPromote(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
/// <summary>
/// Called when a team leader promotes another player to the same team.
/// </summary>
/// <param name="team">The team being promoted.</param>
/// <param name="player">The player being promoted.</param>
/// <returns>No return behavior.</returns>
void OnTeamPromote(PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.UserID} promoted to team leader of team {team.TeamName}");
}
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void promote(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);
		if (!(lookingAtPlayer == null) && !lookingAtPlayer.IsDead() && !(lookingAtPlayer == basePlayer) && lookingAtPlayer.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == (ulong)basePlayer.userID && Interface.CallHook("OnTeamPromote", playerTeam, lookingAtPlayer) == null)
			{
				playerTeam.SetTeamLeader(lookingAtPlayer.userID);
			}
		}
	}

```

## OnMapMarkersClear(BasePlayer,System.Collections.Generic.List<ProtoBuf.MapNote>)

```csharp
/// <summary>
/// Called when all map markers are cleared.
/// </summary>
/// <param name="player">The player who initiated the clear.</param>
/// <param name="markers">A list of map notes being cleared.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkersClear(BasePlayer player, System.Collections.Generic.List<ProtoBuf.MapNote> markers)
{
    Puts("OnMapMarkersClear is working!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.FromOwner]
	[RPC_Server]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, State.pointsOfInterest) != null)
		{
			return;
		}
		ServerCurrentDeathNote?.Dispose();
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				item?.Dispose();
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", this);
	}

```

## OnFuelCheck(EntityFuelSystem)

```csharp
/// <summary>
/// Called when the fuel level of an entity's fuel system is checked.
/// </summary>
/// <param name="fuelSystem">The entity's fuel system.</param>
/// <returns>Returns a boolean value indicating whether the fuel system has fuel, or null if the default behavior is overridden.</returns>
object OnFuelCheck(EntityFuelSystem fuelSystem)
{
    Puts("OnFuelCheck is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool HasFuel(bool forceCheck = false)
	{
		if (Time.time > nextFuelCheckTime || forceCheck)
		{
			object obj = Interface.CallHook("OnFuelCheck", this);
			if (obj is bool)
			{
				return (bool)obj;
			}
			cachedHasFuel = (float)GetFuelAmount() > 0f;
			nextFuelCheckTime = Time.time + UnityEngine.Random.Range(1f, 2f);
		}
		return cachedHasFuel;
	}

```

## OnSamSiteTargetScan(SamSite,System.Collections.Generic.List<SamSite.ISamSiteTarget>)

```csharp
/// <summary>
/// Called when the SamSite target is scanned.
/// </summary>
/// <param name="samSite">The SamSite instance.</param>
/// <param name="targets">A list of potential targets.</param>
/// <returns>No return behavior.</returns>
void OnSamSiteTargetScan(SamSite samSite, List<SamSite.ISamSiteTarget> targets)
{
    Puts("OnSamSiteTargetScan is working!");
}
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (UnityEngine.Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> obj = Facepunch.Pool.GetList<ISamSiteTarget>();
		if (Interface.CallHook("OnSamSiteTargetScan", this, obj) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(obj, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(obj, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in obj)
		{
			if (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!ObjectEx.IsUnityNull(samSiteTarget) && currentTarget != samSiteTarget)
		{
			lockOnTime = UnityEngine.Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!ObjectEx.IsUnityNull(currentTarget))
		{
			lastTargetVisibleTime = UnityEngine.Time.time;
		}
		Facepunch.Pool.FreeList(ref obj);
		if (ObjectEx.IsUnityNull(currentTarget))
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

```

## OnBookmarkInput(ComputerStation,BasePlayer,InputState)

```csharp
/// <summary>
/// Called when a player inputs data into the bookmark system.
/// </summary>
/// <param name="computerStation">The computer station where the input was made.</param>
/// <param name="player">The player who made the input.</param>
/// <param name="inputState">The state of the input.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnBookmarkInput(ComputerStation computerStation, BasePlayer player, InputState inputState)
{
    Puts("OnBookmarkInput called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (HasFlag(Flags.Reserved2) && currentlyControllingEnt.IsValid(serverside: true) && Interface.CallHook("OnBookmarkInput", this, player, inputState) == null)
		{
			currentlyControllingEnt.Get(serverside: true).GetComponent<IRemoteControllable>().UserInput(inputState, new CameraViewerId(player.userID, 0L));
		}
	}

```

## OnItemSkinChange(int,Item,RepairBench,BasePlayer)

```csharp
Документация для OnItemSkinChange(int, Item, RepairBench, BasePlayer)

**Описание**

Функция вызывается при смене кожи предмета в Ремонтной Башне. Она проверяет, может ли игрок применить данную кожу к предмету, и если да, то изменяет его.

**Параметры**

* `int`: номер кожи
* `Item`: предмет, на который будет применена кожа
* `RepairBench`: Ремонтная Башня, в которой происходит действие
* `BasePlayer`: игрок, который выполняет действие

**Возвращаемые значения**

Функция не возвращает никаких значений.

**Описание процесса**

1. Функция проверяет, может ли игрок применить данную кожу к предмету.
2. Если да, то функция изменяет кожу предмета и вызывает эффект смены кожи.
3. Если нет, то функция не выполняет никаких действий.

**Примечания**

* Функция вызывается в методе `ChangeSkin` класса `RepairBench`.
* Функция проверяет, может ли игрок применить данную кожу к предмету, используя метод `CheckSkinOwnership` класса `BasePlayer`.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ChangeSkin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		ItemId itemId = new ItemId(msg.read.UInt64());
		bool isValid = itemId.IsValid;
		bool flag = !isValid || UnityEngine.Time.realtimeSinceStartup > nextSkinChangeAudioTime;
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || Interface.CallHook("OnItemSkinChange", num, slot, this, player) != null || (isValid && slot.uid != itemId))
		{
			return;
		}
		bool flag2 = false;
		if (msg.player.UnlockAllSkins)
		{
			flag2 = true;
		}
		if (num != 0 && !flag2 && !player.blueprints.CheckSkinOwnership(num, player.userID))
		{
			debugprint("RepairBench.ChangeSkin player does not have item :" + num + ":");
			return;
		}
		ulong Skin = ItemDefinition.FindSkin(slot.info.itemid, num);
		if (Skin == slot.skin && slot.info.isRedirectOf == null)
		{
			debugprint("RepairBench.ChangeSkin cannot apply same skin twice : " + Skin + ": " + slot.skin);
			return;
		}
		if (flag)
		{
			nextSkinChangeAudioTime = UnityEngine.Time.realtimeSinceStartup + 0.75f;
		}
		ItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		if (slot.info.isRedirectOf != null)
		{
			Skin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, num);
			skin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		}
		ItemSkin itemSkin = ((skin.id == 0) ? null : (skin.invItem as ItemSkin));
		if (((bool)itemSkin && (itemSkin.Redirect != null || slot.info.isRedirectOf != null)) || (!itemSkin && slot.info.isRedirectOf != null))
		{
			ItemDefinition template = ((itemSkin != null) ? itemSkin.Redirect : slot.info.isRedirectOf);
			bool flag3 = false;
			if (itemSkin != null && itemSkin.Redirect == null && slot.info.isRedirectOf != null)
			{
				template = slot.info.isRedirectOf;
				flag3 = num != 0;
			}
			float condition = slot.condition;
			float maxCondition = slot.maxCondition;
			int amount = slot.amount;
			int ammoCount = 0;
			ItemDefinition ammoType = null;
			if (slot.GetHeldEntity() != null && slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
			{
				ammoCount = baseProjectile.primaryMagazine.contents;
				ammoType = baseProjectile.primaryMagazine.ammoType;
			}
			List<Item> obj = Facepunch.Pool.GetList<Item>();
			if (slot.contents != null && slot.contents.itemList != null && slot.contents.itemList.Count > 0)
			{
				foreach (Item item2 in slot.contents.itemList)
				{
					obj.Add(item2);
				}
				foreach (Item item3 in obj)
				{
					item3.RemoveFromContainer();
				}
			}
			slot.Remove();
			ItemManager.DoRemoves();
			Item item = ItemManager.Create(template, 1, 0uL);
			item.MoveToContainer(base.inventory, 0, allowStack: false);
			item.maxCondition = maxCondition;
			item.condition = condition;
			item.amount = amount;
			if (item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile baseProjectile2)
			{
				if (baseProjectile2.primaryMagazine != null)
				{
					baseProjectile2.SetAmmoCount(ammoCount);
					baseProjectile2.primaryMagazine.ammoType = ammoType;
				}
				baseProjectile2.ForceModsChanged();
			}
			if (obj.Count > 0 && item.contents != null)
			{
				foreach (Item item4 in obj)
				{
					item4.MoveToContainer(item.contents);
				}
			}
			Facepunch.Pool.FreeList(ref obj);
			if (flag3)
			{
				ApplySkinToItem(item, Skin);
			}
			Facepunch.Rust.Analytics.Server.SkinUsed(item.info.shortname, num);
			Facepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, item, Skin);
		}
		else
		{
			ApplySkinToItem(slot, Skin);
			Facepunch.Rust.Analytics.Server.SkinUsed(slot.info.shortname, num);
			Facepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, slot, Skin);
		}
		if (flag && skinchangeEffect.isValid)
		{
			Effect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);
		}
	}

```

## OnSupplyDropDropped(BaseEntity,CargoPlane)

```csharp
/// <summary>
/// Called when a supply drop is dropped from a cargo plane.
/// </summary>
/// <param name="baseEntity">The entity that was dropped.</param>
/// <param name="cargoPlane">The cargo plane that dropped the entity.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropDropped(BaseEntity baseEntity, CargoPlane cargoPlane)
{
    Puts($"Supply drop {baseEntity} dropped from cargo plane {cargoPlane}");
}
```

### Source Code from the Library

```csharp

	private void Update()
	{
		if (!base.isServer)
		{
			return;
		}
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);
			if ((bool)baseEntity)
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
				Interface.CallHook("OnSupplyDropDropped", baseEntity, this);
			}
		}
		base.transform.position = Vector3.Lerp(startPos, endPos, num);
		base.transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
	}

```

## CanUseFuel(EntityFuelSystem,StorageContainer,float,float)

```csharp
/// <summary>
/// Called to determine if the entity can use fuel from a storage container.
/// </summary>
/// <param name="entity">The entity attempting to use fuel.</param>
/// <param name="container">The storage container containing fuel.</param>
/// <param name="seconds">The number of seconds to use fuel for.</param>
/// <param name="fuelUsedPerSecond">The amount of fuel used per second.</param>
/// <returns>Returns the number of items used if the default behavior is overridden, otherwise returns 0.</returns>
object CanUseFuel(EntityFuelSystem entity, StorageContainer container, float seconds, float fuelUsedPerSecond)
{
    Puts("CanUseFuel hook called!");
    // If the return value is not an int, return 0
    return 0;
}
```

### Source Code from the Library

```csharp

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanUseFuel", this, fuelContainer, seconds, fuelUsedPerSecond);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelContainer == null)
		{
			return 0;
		}
		Item slot = fuelContainer.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		pendingFuel += seconds * fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Facepunch.Rust.Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, "fuel_system");
			pendingFuel -= num;
			return num;
		}
		return 0;
	}

```

## OnLootSpawn(LootContainer)

```csharp
/// <summary>
/// Called when loot is spawned.
/// </summary>
/// <param name="lootContainer">The container holding the loot.</param>
/// <returns>No return behavior.</returns>
void OnLootSpawn(LootContainer lootContainer)
{
    Puts("OnLootSpawn called!");
}
```

### Source Code from the Library

```csharp

	public virtual void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				Invoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

```

## OnPlayerAssist(BasePlayer,BasePlayer)

```csharp
/// <summary>
/// Called when a player assists another wounded player.
/// </summary>
/// <param name="assister">The player assisting the wounded player.</param>
/// <param name="victim">The wounded player being assisted.</param>
/// <returns>No return behavior.</returns>
void OnPlayerAssist(BasePlayer assister, BasePlayer victim)
{
    Puts($"Player {assister.UserIDString} assisted wounded player {victim.UserIDString}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Assist(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerAssist", this, msg.player) == null)
		{
			StopWounded(msg.player);
			msg.player.stats.Add("wounded_assisted", 1, (Stats)5);
			stats.Add("wounded_healed", 1);
		}
	}

```

## IOnServerInitialized()

```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
void IOnServerInitialized()
{
    Puts("Server initialized!");
}
```

### Source Code from the Library

```csharp

	public void OpenConnection()
	{
		if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
		{
			ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
		}
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		StartSteamServer();
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			CloseConnection();
			return;
		}
		Network.Net.sv.callbackHandler = this;
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		EACServer.DoStartup();
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
		if (ConVar.Server.autoUploadMap)
		{
			MapUploader.UploadMap();
		}
		Interface.CallHook("IOnServerInitialized");
	}

```

## OnDecayDamage(DecayEntity)

```csharp
/// <summary>
/// Called when a decay entity is damaged.
/// </summary>
/// <param name="entity">The decay entity being damaged.</param>
/// <returns>Returns the damage amount if overridden, otherwise returns null.</returns>
object OnDecayDamage(DecayEntity entity)
{
    Puts("OnDecayDamage called!");
    // If you want to override the default behavior and return a custom value, do so here
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void DecayTick()
	{
		if (decay == null)
		{
			return;
		}
		float num = decay.GetDecayTickOverride();
		if (num == 0f)
		{
			num = ConVar.Decay.tick;
		}
		float num2 = UnityEngine.Time.time - lastDecayTick;
		if (num2 < num)
		{
			return;
		}
		lastDecayTick = UnityEngine.Time.time;
		if (HasParent() || !decay.ShouldDecay(this))
		{
			return;
		}
		float num3 = num2 * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num3;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if (buildingPrivilege != null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", this) == null)
				{
					float num4 = num2 / GetEntityDecayDuration() * GetEntityHealScale();
					Heal(MaxHealth() * num4);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num3;
		if (decayTimer < GetEntityDecayDelay())
		{
			return;
		}
		using (TimeWarning.New("DecayTick"))
		{
			float num5 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num5 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num5 -= decayPoint.protection;
					}
				}
			}
			if (Interface.CallHook("OnDecayDamage", this) == null && num5 > 0f)
			{
				float num6 = num3 / GetEntityDecayDuration() * MaxHealth();
				Hurt(num6 * num5 * decayVariance, DamageType.Decay);
			}
		}
	}

```

## OnActiveItemChange(BasePlayer,Item,ItemId)

```csharp
/// <summary>
/// Called when the active item changes.
/// </summary>
/// <param name="player">The player whose active item is changing.</param>
/// <param name="oldItem">The old active item.</param>
/// <param name="newItemId">The ID of the new active item.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnActiveItemChange(BasePlayer player, Item oldItem, ItemId newItemId)
{
    Puts("OnActiveItemChange is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(ItemId itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnOvenStarted(BaseOven)

```csharp
/// <summary>
/// Called when the oven is started.
/// </summary>
/// <param name="oven">The oven that was started.</param>
/// <returns>No return behavior.</returns>
void OnOvenStarted(BaseOven oven)
{
    Puts("OnOvenStarted hook called!");
}
```

### Source Code from the Library

```csharp

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			InvokeRepeating(Cook, 0.5f, 0.5f);
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", this);
		}
	}

```

## OnSupplyDropLanded(SupplyDrop)

```csharp
/// <summary>
/// Called when a supply drop lands.
/// </summary>
/// <param name="supplyDrop">The supply drop that landed.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropLanded(SupplyDrop supplyDrop)
{
    Puts("OnSupplyDropLanded is working!");
}
```

### Source Code from the Library

```csharp

	private void OnCollisionEnter(Collision collision)
	{
		bool flag = ((1 << collision.collider.gameObject.layer) & 0x40A10111) > 0;
		if (((1 << collision.collider.gameObject.layer) & 0x8000000) > 0 && CollisionEx.GetEntity(collision) is Tugboat)
		{
			flag = true;
		}
		if (flag)
		{
			RemoveParachute();
			MakeLootable();
		}
		Interface.CallHook("OnSupplyDropLanded", this);
	}

```

## OnSignalBroadcast(BaseEntity,Network.Connection)

```csharp
/// <summary>
/// Called when a signal is broadcasted to the network.
/// </summary>
/// <param name="entity">The entity that triggered the signal.</param>
/// <param name="connection">The connection that received the signal.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnSignalBroadcast(BaseEntity entity, Network.Connection connection)
{
    Puts("OnSignalBroadcast is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", this, sourceConnection) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("SignalFromServerEx", this, SendMethod.Unreliable, Priority.Immediate), (int)signal, arg, sourceConnection?.userid ?? 0);
		}
	}

```

## OnOvenCooked(BaseOven,Item,BaseEntity)

```csharp
/// <summary>
/// Called when an oven is cooked.
/// </summary>
/// <param name="oven">The oven being cooked.</param>
/// <param name="item">The item being cooked.</param>
/// <param name="slot">The slot where the item is being cooked.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnOvenCooked(BaseOven oven, Item item, BaseEntity slot)
{
    Puts("OnOvenCooked is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		if (HasFlag(Flags.Reserved8))
		{
			return;
		}
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		if (item != null)
		{
			ItemModBurnable itemModBurnable = item.info.ItemModBurnable;
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, itemModBurnable);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnConstructionPlace(BaseEntity,Construction,Construction.Target,BasePlayer)

```csharp
/// <summary>
/// Called when a construction is placed.
/// </summary>
/// <param name="baseEntity">The entity being constructed.</param>
/// <param name="construction">The construction component.</param>
/// <param name="target">The target of the construction.</param>
/// <param name="ownerPlayer">The player who owns the construction.</param>
/// <returns>No return behavior.</returns>
void OnConstructionPlace(BaseEntity baseEntity, Construction construction, Construction.Target target, BasePlayer ownerPlayer)
{
    Puts($"Construction placed at {baseEntity.transform.position} by {ownerPlayer.displayName}");
}
```

### Source Code from the Library

```csharp

	public GameObject DoPlacement(Construction.Target placement, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		BaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);
		if (!baseEntity)
		{
			return null;
		}
		float num = 1f;
		float num2 = 0f;
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			baseEntity.skinID = ownerItem.skin;
			if (ownerItem.hasCondition)
			{
				num = ownerItem.conditionNormalized;
			}
		}
		PoolableEx.AwakeFromInstantiate(baseEntity.gameObject);
		BuildingBlock buildingBlock = baseEntity as BuildingBlock;
		if ((bool)buildingBlock)
		{
			buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
			if (!buildingBlock.blockDefinition)
			{
				Debug.LogError("Placing a building block that has no block definition!");
				return null;
			}
			buildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);
			num2 = buildingBlock.currentGrade.maxHealth;
		}
		BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
		if ((bool)baseCombatEntity)
		{
			num2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);
			baseCombatEntity.ResetLifeStateOnSpawn = false;
			baseCombatEntity.InitializeHealth(num2 * num, num2);
		}
		if (Interface.CallHook("OnConstructionPlace", baseEntity, component, placement, ownerPlayer) != null)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.KillMessage();
			}
			else
			{
				GameManager.Destroy(baseEntity);
			}
			return null;
		}
		baseEntity.OnPlaced(ownerPlayer);
		baseEntity.OwnerID = ownerPlayer.userID;
		baseEntity.Spawn();
		if ((bool)buildingBlock)
		{
			Effect.server.Run("assets/bundled/prefabs/fx/build/frame_place.prefab", baseEntity, 0u, Vector3.zero, Vector3.zero);
		}
		StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
		if ((bool)stabilityEntity)
		{
			stabilityEntity.UpdateSurroundingEntities();
		}
		return baseEntity.gameObject;
	}

```

## OnGrowableStateChange(GrowableEntity,PlantProperties.State)

```csharp
/// <summary>
/// Called when the state of a growable entity changes.
/// </summary>
/// <param name="entity">The growable entity whose state has changed.</param>
/// <param name="newState">The new state of the growable entity.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnGrowableStateChange(GrowableEntity entity, PlantProperties.State newState)
{
    Puts($"Growable entity's state changed to {newState} for ID {entity.Id}");
    return null;
}
```

### Source Code from the Library

```csharp

	public void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)
	{
		if (Interface.CallHook("OnGrowableStateChange", this, state) != null || (base.isServer && State == state))
		{
			return;
		}
		State = state;
		if (!base.isServer)
		{
			return;
		}
		if (!loading)
		{
			if (currentStage.resources > 0f)
			{
				yieldPool = currentStage.yield;
			}
			if (state == PlantProperties.State.Crossbreed)
			{
				if (Properties.CrossBreedEffect.isValid)
				{
					Effect.server.Run(Properties.CrossBreedEffect.resourcePath, base.transform.position, Vector3.up);
				}
				GrowableGenetics.CrossBreed(this);
			}
			SendNetworkUpdate();
		}
		if (resetAge)
		{
			stageAge = 0f;
		}
	}

```

## OnLootEntityEnd(BasePlayer,ContainerIOEntity)

```csharp
/// <summary>
/// Called when a player finishes looting an entity.
/// </summary>
/// <param name="player">The player who finished looting the entity.</param>
/// <param name="entity">The entity that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ContainerIOEntity entity)
{
    Puts($"Player {player.Name} finished looting {entity.DisplayName}");
}
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
/// <summary>
/// Called to determine if a target can be targeted by the helicopter turret.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <param name="turret">The helicopter turret performing the check.</param>
/// <returns>Returns true if the target can be targeted, and false otherwise.</returns>
bool CanBeTargeted(BaseCombatEntity entity, HelicopterTurret turret)
{
    Puts("CanBeTargeted is working!");
    return true; // Or another value depending on the method’s functionality
}
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## OnRackedWeaponLoad(Item,ItemDefinition,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a weapon is loaded on a rack.
/// </summary>
/// <param name="item">The item being loaded.</param>
/// <param name="itemDefinition">The definition of the item being loaded.</param>
/// <param name="player">The player loading the weapon.</param>
/// <param name="weaponRack">The weapon rack where the weapon is being loaded.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponLoad(Item item, ItemDefinition itemDefinition, BasePlayer player, WeaponRack weaponRack)
{
    Puts("OnRackedWeaponLoad called!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!player)
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (heldEntity == null)
		{
			return;
		}
		BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
		if (component == null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null || Interface.CallHook("OnRackedWeaponLoad", slot, itemDefinition, player, this) != null)
		{
			return;
		}
		if (itemDefinition == SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!(itemDefinition != null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component2 = itemDefinition.GetComponent<ItemModProjectile>();
		if (!(component2 == null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", slot, itemDefinition, player, this);
		}
	}

```

## OnTeamUpdated(ulong,ProtoBuf.PlayerTeam,BasePlayer)

```csharp
Документация для хука `OnTeamUpdated`:

**Название:** OnTeamUpdated

**Описание:** Этот хук вызывается при обновлении информации о команде, в которой находится игрок.

**Параметры:**

* `ulong`: Идентификатор команды.
* `ProtoBuf.PlayerTeam`: Объект с информацией о команде.
* `BasePlayer`: Объект игрока, который находится в этой команде.

**Когда вызывается:** Этот хук вызывается в методе `TeamUpdate` класса `RelationshipManager`.

**Функция:**

Этот хук обновляет информацию о команде и передает ее клиенту. Он также вызывает метод `ClientRPC` для отправки информации о команде на клиент.

**Примечания:**

* Этот хук не возвращает никаких значений.
* Он вызывается только при обновлении информации о команде, а не при создании новой команды или удалении существующей.
```

### Source Code from the Library

```csharp

	public void TeamUpdate(bool fullTeamUpdate)
	{
		if (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)
		{
			return;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(currentTeam);
		if (playerTeam == null)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		using PlayerTeam playerTeam2 = Facepunch.Pool.Get<PlayerTeam>();
		playerTeam2.teamLeader = playerTeam.teamLeader;
		playerTeam2.teamID = playerTeam.teamID;
		playerTeam2.teamName = playerTeam.teamName;
		playerTeam2.members = Facepunch.Pool.GetList<PlayerTeam.TeamMember>();
		playerTeam2.teamLifetime = playerTeam.teamLifetime;
		playerTeam2.teamPings = Facepunch.Pool.GetList<MapNote>();
		foreach (ulong member in playerTeam.members)
		{
			BasePlayer basePlayer = RelationshipManager.FindByID(member);
			if ((bool)basePlayer && basePlayer.IsInTutorial)
			{
				continue;
			}
			PlayerTeam.TeamMember teamMember = Facepunch.Pool.Get<PlayerTeam.TeamMember>();
			teamMember.displayName = ((basePlayer != null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
			teamMember.healthFraction = ((basePlayer != null && basePlayer.IsAlive()) ? basePlayer.healthFraction : 0f);
			teamMember.position = ((basePlayer != null) ? basePlayer.transform.position : Vector3.zero);
			teamMember.online = basePlayer != null && !basePlayer.IsSleeping();
			teamMember.wounded = basePlayer != null && basePlayer.IsWounded();
			if ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) && basePlayer != null)
			{
				if ((bool)basePlayer.GetHeldEntity() && basePlayer.GetHeldEntity().IsInstrument())
				{
					num++;
				}
				if (basePlayer.isMounted)
				{
					if (basePlayer.GetMounted().IsInstrument())
					{
						num++;
					}
					if (basePlayer.GetMounted().IsSummerDlcVehicle)
					{
						num2++;
					}
				}
				if (num >= 4 && !sentInstrumentTeamAchievement)
				{
					GiveAchievement("TEAM_INSTRUMENTS");
					sentInstrumentTeamAchievement = true;
				}
				if (num2 >= 4)
				{
					GiveAchievement("SUMMER_INFLATABLE");
					sentSummerTeamAchievement = true;
				}
			}
			teamMember.userID = member;
			playerTeam2.members.Add(teamMember);
			if (basePlayer != null)
			{
				if (basePlayer.State.pings != null && basePlayer.State.pings.Count > 0 && basePlayer != this)
				{
					playerTeam2.teamPings.AddRange(basePlayer.State.pings);
				}
				if (fullTeamUpdate && basePlayer != this)
				{
					basePlayer.TeamUpdate(fullTeamUpdate: false);
				}
			}
		}
		playerTeam2.leaderMapNotes = Facepunch.Pool.GetList<MapNote>();
		PlayerState playerState = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(playerTeam.teamLeader);
		if (playerState?.pointsOfInterest != null)
		{
			foreach (MapNote item in playerState.pointsOfInterest)
			{
				playerTeam2.leaderMapNotes.Add(item);
			}
		}
		if (Interface.CallHook("OnTeamUpdated", currentTeam, playerTeam2, this) == null)
		{
			ClientRPC(RpcTarget.PlayerAndSpectators("CLIENT_ReceiveTeamInfo", this), playerTeam2);
			if (playerTeam2.leaderMapNotes != null)
			{
				playerTeam2.leaderMapNotes.Clear();
			}
			if (playerTeam2.teamPings != null)
			{
				playerTeam2.teamPings.Clear();
			}
			BasePlayer basePlayer2 = FindByID(playerTeam.teamLeader);
			if (fullTeamUpdate && basePlayer2 != null && basePlayer2 != this)
			{
				basePlayer2.TeamUpdate(fullTeamUpdate: false);
			}
		}
	}

```

## OnRconConnection(System.Net.IPAddress)

```csharp
/// <summary>
/// Called when a new Rcon connection is established.
/// </summary>
/// <param name="address">The IP address of the client attempting to connect.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool OnRconConnection(System.Net.IPAddress address)
{
    Puts($"RCON connection from {address}");
    return false;
}
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", iPEndPoint.Address) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					UnityEngine.Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnEntityTakeDamage(ResourceEntity,HitInfo)

```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that took the damage.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityTakeDamage(ResourceEntity entity, HitInfo hitInfo)
{
    Puts("OnEntityTakeDamage is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", this, info) != null)
		{
			return;
		}
		if (resourceDispenser != null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if ((bool)baseProtection)
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnKilled(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

```

## OnOutputUpdate(IOEntity)

```csharp
/// <summary>
/// Called when an output is updated.
/// </summary>
/// <param name="ioEntity">The IO entity associated with the output.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnOutputUpdate(IOEntity ioEntity)
{
    Puts("OnOutputUpdate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void UpdateOutputs()
	{
		if (Interface.CallHook("OnOutputUpdate", this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		ensureOutputsUpdated = false;
		using (TimeWarning.New("ProcessIOOutputs"))
		{
			for (int i = 0; i < outputs.Length; i++)
			{
				IOSlot iOSlot = outputs[i];
				bool flag = true;
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if (!(iOEntity != null))
				{
					continue;
				}
				if (ioType == IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)
				{
					using (TimeWarning.New("FluidOutputProcessing"))
					{
						if (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))
						{
							flag = false;
						}
					}
				}
				int passthroughAmount = GetPassthroughAmount(i);
				iOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);
			}
		}
	}

```

## OnExcavatorResourceSet(ExcavatorArm,string,BasePlayer)

```csharp
/// <summary>
/// Called when the excavator's resource target is set.
/// </summary>
/// <param name="excavatorArm">The excavator arm.</param>
/// <param name="resourceType">The type of resource to mine.</param>
/// <param name="player">The player who set the resource target.</param>
/// <returns>No return behavior.</returns>
void OnExcavatorResourceSet(ExcavatorArm excavatorArm, string resourceType, BasePlayer player)
{
    Puts($"Resource target set to {resourceType} by player {player.UserID}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_SetResourceTarget(RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnExcavatorResourceSet", this, text, msg.player) == null)
		{
			switch (text)
			{
			case "HQM":
				resourceMiningIndex = 0;
				break;
			case "Sulfur":
				resourceMiningIndex = 1;
				break;
			case "Stone":
				resourceMiningIndex = 2;
				break;
			case "Metal":
				resourceMiningIndex = 3;
				break;
			}
			if (!IsOn())
			{
				BeginMining();
			}
		}
	}

```

## OnPlayerPveDamage(BaseEntity,HitInfo,BuildingBlock)

```csharp
/// <summary>
/// Called when a player deals damage to another entity in PVE mode.
/// </summary>
/// <param name="entity">The entity that was damaged.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <param name="block">The building block that was used to deal the damage.</param>
/// <returns>No return behavior. If this hook is not handled, the default behavior will be executed.</returns>
void OnPlayerPveDamage(BaseEntity entity, HitInfo hitInfo, BuildingBlock block)
{
    Puts("OnPlayerPveDamage is working!");
}
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer)
		{
			if (Interface.CallHook("OnPlayerPveDamage", info.Initiator, info, this) == null)
			{
				(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			}
		}
		else if (!info.Initiator || !(info.Initiator is BasePlayer { IsInTutorial: not false }))
		{
			base.Hurt(info);
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The container from which the items were dropped.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnContainerDropItems(ItemContainer container)
{
    Puts("OnContainerDropItems called!");
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			float num2 = UnityEngine.Random.Range(0f, 2f);
			item.RemoveFromContainer();
			BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
			if (baseEntity == null)
			{
				item.Remove();
				continue;
			}
			if (baseEntity is DroppedItem droppedItem && container.entityOwner is LootContainer)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;
			}
			if (num2 > 0f)
			{
				baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
				baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
			}
		}
	}

```

## OnGrowableGathered(GrowableEntity,Item,BasePlayer)

```csharp
/// <summary>
/// Called when a growable entity is gathered.
/// </summary>
/// <param name="entity">The growable entity being gathered.</param>
/// <param name="item">The item gathered from the entity.</param>
/// <param name="player">The player who gathered the item.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnGrowableGathered(GrowableEntity entity, Item item, BasePlayer player)
{
    Puts("OnGrowableGathered hook called!");
    // Add custom logic here
    return null;
}
```

### Source Code from the Library

```csharp

	public void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)
	{
		Item item = ItemManager.Create(Properties.pickupItem, amount, 0uL);
		if (applyCondition)
		{
			item.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);
		}
		if (eat && player != null && IsFood())
		{
			ItemModConsume component = item.info.GetComponent<ItemModConsume>();
			if (component != null)
			{
				component.DoAction(item, player);
				return;
			}
		}
		if (player != null)
		{
			Interface.CallHook("OnGrowableGathered", this, item, player);
			Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
		}
		else
		{
			item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
		}
	}

```

## OnItemDeployed(Deployer,BaseEntity,BaseEntity)

```csharp
/// <summary>
/// Called when an item is deployed.
/// </summary>
/// <param name="deployer">The entity that deployed the item.</param>
/// <param name="baseEntity">The base entity on which the item was deployed.</param>
/// <param name="deployedItem">The item that was deployed.</param>
/// <returns>No return behavior.</returns>
void OnItemDeployed(BaseEntity deployer, BaseEntity baseEntity, BaseEntity deployedItem)
{
    Puts($"Item deployed on {baseEntity} by {deployer}");
}
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ChatMessage("Building is blocked at player position!");
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		if (ownerPlayer.Distance(baseEntity) > 3f)
		{
			ownerPlayer.ChatMessage("Too far away!");
			return;
		}
		if (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))
		{
			ownerPlayer.ChatMessage("Building is blocked at placement position!");
			return;
		}
		if (ownerPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = ownerPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null && !currentTutorialIsland.CheckPlacement(ownerPlayer, deployable, baseEntity.transform.position, baseEntity.transform.rotation))
			{
				return;
			}
		}
		Item ownerItem = GetOwnerItem();
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			baseEntity2.skinID = ownerItem.skin;
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity, ownerPlayer, ownerItem);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
			if (ownerPlayer.IsInTutorial)
			{
				TutorialIsland currentTutorialIsland2 = ownerPlayer.GetCurrentTutorialIsland();
				if (currentTutorialIsland2 != null)
				{
					currentTutorialIsland2.OnPlayerBuiltConstruction(ownerPlayer);
				}
			}
			if (GetOwnerItemDefinition() != null)
			{
				ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
				{
					WorldPosition = baseEntity2.transform.position,
					UintIdentifier = baseEntity2.prefabID,
					IntIdentifier = GetOwnerItemDefinition().itemid
				}, 1f);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity, baseEntity2);
		Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);
		if (!ownerPlayer.IsInCreativeMode || !Creative.freeBuild)
		{
			UseItemAmount(1);
		}
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum,ulong)

```csharp
/// <summary>
/// Called when a structure is upgraded to a new grade.
/// </summary>
/// <param name="block">The building block being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="grade">The new grade of the building block.</param>
/// <param name="upgradeId">The ID of the upgrade being applied.</param>
/// <returns>No return behavior.</returns>
void OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade, ulong upgradeId)
{
    Puts($"Building {block.name} upgraded to grade {grade} by player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoUpgradeToGrade_Delayed(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
		ulong num = msg.read.UInt64();
		ConstructionGrade constructionGrade = blockDefinition.GetGrade(@enum, num);
		if (!(constructionGrade == null) && CanChangeToGrade(@enum, num, msg.player) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum, num) == null && CanAffordUpgrade(@enum, num, msg.player) && !(base.SecondsSinceAttacked < 30f) && (num == 0L || msg.player.blueprints.steamInventory.HasItem((int)num)))
		{
			PayForUpgrade(constructionGrade, msg.player);
			if (msg.player != null)
			{
				playerCustomColourToApply = msg.player.LastBlockColourChangeId;
			}
			ClientRPC(RpcTarget.NetworkGroup("DoUpgradeEffect"), (int)@enum, num);
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, @enum, playerCustomColourToApply, num);
			OnSkinChanged(skinID, num);
			ChangeGrade(@enum, playEffect: true);
			Interface.CallHook("OnStructureUpgraded", this, msg.player, @enum, num);
		}
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
/// <summary>
/// Called to determine if a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being used.</param>
/// <returns>Returns true if the player has permission, false otherwise.</returns>
bool CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts("CanUseMailbox is working!");
    return true; // Replace with actual logic to determine if player can use mailbox
}
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when a player attempts to rotate the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="player">The player attempting to rotate the vending machine.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnRotateVendingMachine is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_RotateVM(RPCMessage msg)
	{
		if (Interface.CallHook("OnRotateVendingMachine", this, msg.player) == null && CanRotate())
		{
			UpdateEmptyFlag();
			if (msg.player.CanBuild() && IsInventoryEmpty())
			{
				base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
				SendNetworkUpdate();
			}
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
/// <summary>
/// Called when a player finishes looting an entity.
/// </summary>
/// <param name="player">The player who finished looting the entity.</param>
/// <param name="lootableCorpse">The lootable corpse that was being looted.</param>
object OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts("OnLootEntityEnd is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
/// <summary>
/// Called when a player attempts to disarm a landmine.
/// </summary>
/// <param name="landmine">The landmine being disarmed.</param>
/// <param name="player">The player attempting to disarm the landmine.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts("OnTrapDisarm hook called!");
    // Minimal code to demonstrate functionality
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if ((ulong)rpc.player.userID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			if (UnityEngine.Random.Range(0, 100) < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## OnTurretRotate(AutoTurret,BasePlayer)

```csharp
/// <summary>
/// Called when a turret is rotated.
/// </summary>
/// <param name="turret">The AutoTurret instance that was rotated.</param>
/// <param name="player">The BasePlayer who initiated the rotation.</param>
/// <returns>No return behavior.</returns>
void OnTurretRotate(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret} rotated by player {player}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void FlipAim(RPCMessage rpc)
	{
		if (!IsOnline() && IsAuthed(rpc.player) && !booting && Interface.CallHook("OnTurretRotate", this, rpc.player) == null)
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnBookmarkControlEnded(ComputerStation,BasePlayer,IRemoteControllable)

```csharp
/// <summary>
/// Called when a bookmark control is ended.
/// </summary>
/// <param name="computerStation">The computer station that initiated the control.</param>
/// <param name="player">The player who was controlling the entity.</param>
/// <param name="remoteControllable">The remote controllable entity being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer player, IRemoteControllable remoteControllable)
{
    Puts($"Bookmark control ended for {player.UserIDString} on {computerStation.Name}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## CanUseGesture(BasePlayer,GestureConfig)

```csharp
/// <summary>
/// Called to determine if a player can use a gesture.
/// </summary>
/// <param name="player">The player attempting to use the gesture.</param>
/// <param name="gestureConfig">Configuration for the gesture being used.</param>
/// <returns>Returns true if the player can use the gesture, and false otherwise.</returns>
bool CanUseGesture(BasePlayer player, GestureConfig gestureConfig)
{
    Puts("CanUseGesture is working!");
    return true; // Default to allowing the gesture
}
```

### Source Code from the Library

```csharp

	public bool IsOwnedBy(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseGesture", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (gestureType == GestureType.NPC)
		{
			return player.IsNpc;
		}
		if (gestureType == GestureType.Cinematic)
		{
			return player.IsAdmin;
		}
		if (dlcItem != null && dlcItem.CanUse(player))
		{
			return true;
		}
		if (inventoryItem != null && player.blueprints.steamInventory.HasItem(inventoryItem.id))
		{
			return true;
		}
		return false;
	}

```

## OnClientDisconnect(Network.Connection,string)

```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The connection that was used by the client.</param>
/// <param name="reason">The reason for the disconnection, if provided.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnect(Network.Connection connection, string reason)
{
    Puts($"Client {connection} disconnected: {reason}");
}
```

### Source Code from the Library

```csharp

	public void ReadDisconnectReason(Message packet)
	{
		string text = packet.read.String(4096);
		string text2 = packet.connection.ToString();
		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
		{
			Interface.CallHook("OnClientDisconnect", packet.connection, text);
			DebugEx.Log(text2 + " disconnecting: " + text);
		}
	}

```

## OnEntityMarkHostile(BaseCombatEntity,float)

```csharp
/// <summary>
/// Called when an entity is marked as hostile.
/// </summary>
/// <param name="entity">The entity being marked as hostile.</param>
/// <param name="duration">The duration for which the entity will be marked as hostile.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityMarkHostile(BaseCombatEntity entity, float duration)
{
    Puts("OnEntityMarkHostile is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			float b = UnityEngine.Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, b);
		}
	}

```

## OnSprayRemove(SprayCanSpray,BasePlayer)

```csharp
/// <summary>
/// Called when a spray can is removed from the game.
/// </summary>
/// <param name="spray">The spray can being removed.</param>
/// <param name="player">The player who removed the spray can.</param>
/// <returns>No return behavior.</returns>
void OnSprayRemove(SprayCanSpray spray, BasePlayer player)
{
    Puts($"Spray can removed by {player.Name}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void Server_RequestWaterClear(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && Menu_WaterClear_ShowIf(player) && Interface.CallHook("OnSprayRemove", this, player) == null)
		{
			Kill();
		}
	}

```

## OnServerRestartInterrupt()

```csharp
/// <summary>
/// Called when the server restart is interrupted.
/// </summary>
/// <returns>No return behavior.</returns>
void OnServerRestartInterrupt()
{
    Puts("Server restart interrupted!");
}
```

### Source Code from the Library

```csharp

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (SingletonComponent<ServerMgr>.Instance == null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
			SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", strNotice, iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

```

## OnPlayerRevive(BasePlayer,BasePlayer)

```csharp
/// <summary>
/// Called when a player is revived by another player.
/// </summary>
/// <param name="reviver">The player who performed the revive.</param>
/// <param name="revivedPlayer">The player being revived.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerRevive(BasePlayer reviver, BasePlayer revivedPlayer)
{
    Puts("OnPlayerRevive called!");
    
    // If the revived player is wounded and can be revived, stop their wounded state
    if (revivedPlayer.IsWounded() && canRevive)
    {
        revivedPlayer.StopWounded(reviver);
    }
    
    return null;
}
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Facepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if (player != ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
					player.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}

```

## OnNpcRadioChatter(ScientistNPC)

```csharp
/// <summary>
/// Called when a scientist NPC plays radio chatter.
/// </summary>
/// <param name="npc">The scientist NPC playing the radio chatter.</param>
/// <returns>No return behavior.</returns>
void OnNpcRadioChatter(ScientistNPC npc)
{
    Puts($"Scientist NPC '{npc.name}' played radio chatter.");
}
```

### Source Code from the Library

```csharp

	public void PlayRadioChatter()
	{
		if (RadioChatterEffects.Length != 0)
		{
			if (base.IsDestroyed || base.transform == null)
			{
				CancelInvoke(PlayRadioChatter);
			}
			else if (Interface.CallHook("OnNpcRadioChatter", this) == null)
			{
				Effect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				QueueRadioChatter();
			}
		}
	}

```

## OnTechTreeNodeUnlocked(Workbench,TechTreeData.NodeInstance,BasePlayer)

```csharp
/// <summary>
/// Called when a tech tree node is unlocked.
/// </summary>
/// <param name="workbench">The workbench where the unlock occurred.</param>
/// <param name="node">The unlocked tech tree node.</param>
/// <param name="player">The player who unlocked the node.</param>
/// <returns>Returns null if the default behavior is not overridden.</returns>
object OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
{
    Puts("OnTechTreeNodeUnlocked called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if (techTreeForLevel == null)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log("Node for unlock not found :" + id);
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && byID2.itemDef != null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log("Player unlocked group :" + byID.groupName);
			}
			else if (byID.itemDef != null && Interface.CallHook("OnTechTreeNodeUnlock", this, byID, player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", this, byID, player);
					Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

```

## OnAmmoUnload(BaseProjectile,Item,BasePlayer)

```csharp
/// <summary>
/// Called when ammo is unloaded from a projectile.
/// </summary>
/// <param name="projectile">The projectile being unloaded.</param>
/// <param name="item">The item associated with the projectile.</param>
/// <param name="player">The player performing the action.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnAmmoUnload(BaseProjectile projectile, Item item, BasePlayer player)
{
    Puts("OnAmmoUnload hook called!");
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp

	public void UnloadAmmo(Item item, BasePlayer player)
	{
		BaseProjectile component = item.GetHeldEntity().GetComponent<BaseProjectile>();
		if (!component.canUnloadAmmo || Interface.CallHook("OnAmmoUnload", component, item, player) != null || !component)
		{
			return;
		}
		int num = component.primaryMagazine.contents;
		if (num <= 0)
		{
			return;
		}
		component.SetAmmoCount(0);
		item.MarkDirty();
		SendNetworkUpdateImmediate();
		int stackable = component.primaryMagazine.ammoType.stackable;
		if (num > stackable)
		{
			int num2 = Mathf.FloorToInt(num / component.primaryMagazine.ammoType.stackable);
			num %= stackable;
			for (int i = 0; i < num2; i++)
			{
				Item item2 = ItemManager.Create(component.primaryMagazine.ammoType, stackable, 0uL);
				player.GiveItem(item2);
			}
		}
		if (num > 0)
		{
			Item item3 = ItemManager.Create(component.primaryMagazine.ammoType, num, 0uL);
			player.GiveItem(item3);
		}
	}

```

## OnPlayerRecovered(BasePlayer)

```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecovered(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered.");
}
```

### Source Code from the Library

```csharp

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			if (IsCrawling())
			{
				base.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if ((bool)BaseGameMode.GetActiveGameMode(base.isServer))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", this);
		}
	}

```

## OnLiquidWeaponFired(LiquidWeapon,BasePlayer)

```csharp
/// <summary>
/// Called when a liquid weapon is fired.
/// </summary>
/// <param name="liquidWeapon">The liquid weapon being fired.</param>
/// <param name="player">The player firing the liquid weapon.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnLiquidWeaponFired(LiquidWeapon liquidWeapon, BasePlayer player)
{
    Puts("OnLiquidWeaponFired is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void StartFiring(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (OnCooldown())
		{
			return;
		}
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		if (CanFire(player))
		{
			CancelInvoke(FireTick);
			InvokeRepeating(FireTick, 0f, FireRate);
			SetFlag(Flags.On, b: true);
			StartCooldown(FireRate);
			if (base.isServer)
			{
				SendNetworkUpdateImmediate();
			}
			Interface.CallHook("OnLiquidWeaponFired", this, player);
		}
	}

```

## OnNetworkGroupEntered(BaseNetworkable,Network.Visibility.Group)

```csharp
/// <summary>
/// Called when a network entity enters a network group.
/// </summary>
/// <param name="entity">The entity that entered the group.</param>
/// <param name="group">The group that was entered.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnNetworkGroupEntered(BaseNetworkable entity, Network.Visibility.Group group)
{
    Puts($"Entity {entity} entered network group: {group}");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", this, group);
	}

```

## CanStackItem(Item,Item)

```csharp
/// <summary>
/// Called when checking if an item can be stacked with another item.
/// </summary>
/// <param name="item">The item to check.</param>
/// <param name="otherItem">The other item to stack with.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise returns true if the items can be stacked and false otherwise.</returns>
object CanStackItem(Item item, Item otherItem)
{
    Puts("CanStackItem is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (MaxStackable() <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != item.info.condition.max)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.info.condition.max)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		if (item.skin != skin)
		{
			return false;
		}
		if (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			int num2 = ((instanceData != null) ? instanceData.dataInt : (-1));
			if (num != num2)
			{
				return false;
			}
		}
		if (item.instanceData != null && instanceData != null && (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt && item.info.Blueprint != null && item.info.Blueprint.workbenchLevelRequired == 3)))
		{
			return false;
		}
		if (instanceData != null && instanceData.subEntity.IsValid && (bool)info.GetComponent<ItemModSign>())
		{
			return false;
		}
		if (item.instanceData != null && item.instanceData.subEntity.IsValid && (bool)item.info.GetComponent<ItemModSign>())
		{
			return false;
		}
		return true;
	}

```

## OnCorpsePopulate(GingerbreadNPC,NPCPlayerCorpse)

```csharp
/// <summary>
/// Called when a corpse is populated with loot.
/// </summary>
/// <param name="corpse">The corpse being populated.</param>
/// <param name="lootContainer">The container holding the loot to be spawned.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnCorpsePopulate(GingerbreadNPC corpse, NPCPlayerCorpse lootContainer)
{
    // Minimal code to demonstrate functionality
    Puts("OnCorpsePopulate hook called!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		using (TimeWarning.New("Create corpse"))
		{
			string corpseResourcePath = CorpseResourcePath;
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse(corpseResourcePath, flagsOnDeath, modelState) as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain);
				nPCPlayerCorpse.playerName = "Gingerbread";
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
				if (LootSpawnSlots.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int i = 0; i < lootSpawnSlots.Length; i++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
						for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnDieselEngineToggled(DieselEngine)

```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off.
/// </summary>
/// <param name="engine">The diesel engine that was toggled.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnDieselEngineToggled(DieselEngine engine)
{
    Puts("OnDieselEngineToggled is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void EngineOff()
	{
		SetFlag(Flags.On, b: false);
		BroadcastEntityMessage("DieselEngineOff");
		Interface.CallHook("OnDieselEngineToggled", this);
	}

```

## OnPhoneDial(PhoneController,PhoneController,BasePlayer)

```csharp
/// <summary>
/// Called when a player attempts to dial a phone number.
/// </summary>
/// <param name="caller">The player making the call.</param>
/// <param name="callee">The phone controller being called.</param>
/// <param name="player">The BasePlayer instance.</param>
/// <returns>Returns null if the default behavior is overridden, otherwise returns a non-null value.</returns>
object OnPhoneDial(PhoneController caller, PhoneController callee, BasePlayer player)
{
    Puts("OnPhoneDial hook called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public void CallPhone(int number)
	{
		if (number == PhoneNumber)
		{
			OnDialFailed(Telephone.DialFailReason.CallSelf);
			return;
		}
		if (TelephoneManager.GetCurrentActiveCalls() + 1 > TelephoneManager.MaxConcurrentCalls)
		{
			OnDialFailed(Telephone.DialFailReason.NetworkBusy);
			return;
		}
		PhoneController telephone = TelephoneManager.GetTelephone(number);
		if (telephone != null)
		{
			if (Interface.CallHook("OnPhoneDial", this, telephone, currentPlayer) == null)
			{
				if (telephone.serverState == Telephone.CallState.Idle && telephone.CanReceiveCall())
				{
					SetPhoneState(Telephone.CallState.Dialing);
					lastDialedNumber = number;
					activeCallTo = telephone;
					activeCallTo.ReceiveCallFrom(this);
				}
				else
				{
					OnDialFailed(Telephone.DialFailReason.Engaged);
					telephone.OnIncomingCallWhileBusy();
				}
			}
		}
		else
		{
			OnDialFailed(Telephone.DialFailReason.WrongNumber);
		}
	}

```

## OnLootEntityEnd(BasePlayer,DroppedItemContainer)

```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="droppedItemContainer">The container holding the dropped items.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, DroppedItemContainer droppedItemContainer)
{
    Puts("OnLootEntityEnd is working!");
}
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		if (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)
		{
			Kill();
		}
		else
		{
			ResetRemovalTime();
			SetFlag(Flags.Open, b: false);
			SendNetworkUpdate();
		}
		EvaluateBagConditions();
	}

```

## OnInventoryItemsTake(PlayerInventory,System.Collections.Generic.List<Item>,int,int)

```csharp
/// <summary>
/// Called when a player attempts to take items from their inventory.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="items">A list of items to be taken.</param>
/// <param name="itemid">The ID of the item being taken.</param>
/// <param name="amount">The amount of the item being taken.</param>
/// <returns>Returns a non-negative integer representing the total number of items taken, or null if the default behavior is overridden.</returns>
object OnInventoryItemsTake(PlayerInventory inventory, List<Item> items, int itemid, int amount)
{
    Puts("OnInventoryItemsTake hook called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public int Take(List<Item> collect, int itemid, int amount)
	{
		object obj = Interface.CallHook("OnInventoryItemsTake", this, collect, itemid, amount);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			int num2 = containerMain.Take(collect, itemid, amount);
			num += num2;
			amount -= num2;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerBelt != null)
		{
			int num3 = containerBelt.Take(collect, itemid, amount);
			num += num3;
			amount -= num3;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerWear != null)
		{
			int num4 = containerWear.Take(collect, itemid, amount);
			num += num4;
			amount -= num4;
		}
		return num;
	}

```

## OnCargoShipHarborApproach(CargoShip,CargoNotifier)

```csharp
/// <summary>
/// Called when a cargo ship approaches the harbor.
/// </summary>
/// <param name="ship">The cargo ship approaching the harbor.</param>
/// <param name="notifier">The notifier for cargo-related events.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipHarborApproach(CargoShip ship, CargoNotifier notifier)
{
    Puts("OnCargoShipHarborApproach is working!");
}
```

### Source Code from the Library

```csharp

	public void StartHarborApproach(CargoNotifier cn)
	{
		if (Interface.CallHook("OnCargoShipHarborApproach", this, cn) != null)
		{
			return;
		}
		PlayHorn();
		isDoingHarborApproach = true;
		dockCount++;
		shouldLookAhead = false;
		if (proxManager != null)
		{
			proxManager.StartMovement();
		}
		ClearAllHarborEntitiesOnShip();
		foreach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)
		{
			if (!(allCrane == null) && !allCrane.isClient && !(allCrane.Distance2D(harborApproachPath.nodes[harborApproachPath.nodes.Count / 2].Position) > 150f))
			{
				allCrane.ReplenishContainers();
			}
		}
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
/// <summary>
/// Called when two dropped items are combined.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>Returns true if the combination is allowed, false otherwise.</returns>
bool CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    // Minimal code to demonstrate functionality
    Puts("CanCombineDroppedItem called!");
    
    // If the items have different info or blueprint targets, do not combine
    if (item1.item.info != item2.item.info || (item1.item.IsBlueprint() && item1.item.blueprintTarget != item2.item.blueprintTarget))
    {
        return false;
    }
    
    // If either item has a condition that is not at max, do not combine
    if ((item1.item.hasCondition && item1.item.condition != item1.item.maxCondition) || (item2.item.hasCondition && item2.item.condition != item2.item.maxCondition))
    {
        return false;
    }
    
    // If the items have genetics and different instance data, do not combine
    if (item1.item.info.amountType == ItemDefinition.AmountType.Genetics)
    {
        int num = ((item1.item.instanceData != null) ? item1.item.instanceData.dataInt : (-1));
        int num2 = ((item2.item.instanceData != null) ? item2.item.instanceData.dataInt : (-1));
        if (num != num2)
        {
            return false;
        }
    }
    
    // If either item has an associated sign, do not combine
    if ((item1.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item1.item) != null) || (item2.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item2.item) != null))
    {
        return false;
    }
    
    // If the items can be combined, return true
    return true;
}
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.DestroyItem();
			di.Kill();
			Interface.CallHook("OnDroppedItemCombined", this);
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(base.transform.position, Vector3.zero, base.transform.rotation);
			}
		}
	}

```

## OnDefaultItemsReceived(PlayerInventory)

```csharp
/// <summary>
/// Called when default items are received by the player.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <returns>No return behavior.</returns>
void OnDefaultItemsReceived(PlayerInventory inventory)
{
    Puts("OnDefaultItemsReceived is working!");
}
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);
			}
		}
	}

```

## OnEntityLeave(TriggerComfort,BaseEntity)

```csharp
/// <summary>
/// Called when an entity leaves the trigger comfort zone.
/// </summary>
/// <param name="comfort">The trigger comfort zone.</param>
/// <param name="entity">The entity that left the comfort zone.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityLeave(TriggerComfort comfort, BaseEntity entity)
{
    Puts("OnEntityLeave is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void OnEntityLeave(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			_players.Remove(basePlayer);
		}
	}

```

## CanBeHomingTargeted(PatrolHelicopter)

```csharp
/// <summary>
/// Called to determine if a patrol helicopter can be targeted by homing.
/// </summary>
/// <param name="patrolHelicopter">The patrol helicopter in question.</param>
/// <returns>Returns <c>true</c> if the patrol helicopter can be targeted, and <c>false</c> otherwise.</returns>
bool CanBeHomingTargeted(PatrolHelicopter patrolHelicopter)
{
    Puts("CanBeHomingTargeted is working!");
    return true; // Or another value depending on the method’s functionality
}
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
/// <summary>
/// Called when the Bradley APC is patrolling.
/// </summary>
/// <param name="apc">The Bradley APC.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    // Minimal code to demonstrate functionality
    Puts("OnBradleyApcPatrol called!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		IAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		IAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);
		bool flag = false;
		List<IAIPathNode> nodes = Facepunch.Pool.GetList<IAIPathNode>();
		IAIPathNode iAIPathNode;
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			iAIPathNode = nodes[nodes.Count - 1];
		}
		else
		{
			iAIPathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.Position) > 2f))
		{
			return;
		}
		if (closestToPoint == iAIPathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.Position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
		else
		{
			if (!AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].Position);
				}
			}
			foreach (IAIPathNode item in path)
			{
				currentPath.Add(item.Position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
	}

```

## OnAdventGiftAwarded(AdventCalendar,BasePlayer)

```csharp
/// <summary>
/// Called when an Advent gift is awarded to a player.
/// </summary>
/// <param name="calendar">The Advent calendar instance.</param>
/// <param name="player">The player who received the gift.</param>
/// <returns>No return behavior.</returns>
void OnAdventGiftAwarded(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Advent gift awarded to {player.UserIDString} on {calendar.Name}");
}
```

### Source Code from the Library

```csharp

	public void AwardGift(BasePlayer player)
	{
		if (Interface.CallHook("OnAdventGiftAward", this, player) != null)
		{
			return;
		}
		DateTime now = DateTime.Now;
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) == startMonth && num >= 0 && num < days.Length)
		{
			if (!playerRewardHistory.ContainsKey(player.userID))
			{
				playerRewardHistory.Add(player.userID, new List<int>());
			}
			playerRewardHistory[player.userID].Add(num);
			Effect.server.Run(giftEffect.resourcePath, player.transform.position);
			if (num >= 0 && num < crosses.Length)
			{
				Effect.server.Run(boxCloseEffect.resourcePath, base.transform.position + Vector3.up * 1.5f);
			}
			DayReward dayReward = days[num];
			for (int i = 0; i < dayReward.rewards.Length; i++)
			{
				ItemAmount itemAmount = dayReward.rewards[i];
				player.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);
			}
			Interface.CallHook("OnAdventGiftAwarded", this, player);
		}
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
/// <summary>
/// Called when a player's sleep has ended.
/// </summary>
/// <param name="player">The player whose sleep has ended.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has woken up.");
}
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", this) == null)
		{
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: true);
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if ((ulong)userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			CancelInvoke(ScheduledDeath);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
			}
			InvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				RemoveFromTriggers();
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", this);
			EACServer.LogPlayerSpawn(this);
			if (TotalPingCount > 0)
			{
				SendPingsToClient();
			}
			if (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))
			{
				ClientRPC(RpcTarget.Player("PromptToStartTutorial", this));
			}
		}
	}

```

## OnAmmoSwitch(BaseProjectile,BasePlayer,ItemDefinition)

```csharp
/// <summary>
/// Called when the player switches to a different type of ammunition.
/// </summary>
/// <param name="projectile">The projectile being switched.</param>
/// <param name="player">The player performing the switch.</param>
/// <param name="itemDefinition">The definition of the new ammunition type.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnAmmoSwitch(BaseProjectile projectile, BasePlayer player, ItemDefinition itemDefinition)
{
    Puts("OnAmmoSwitch called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnAmmoSwitch", this, ownerPlayer, itemDefinition) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				SetAmmoCount(0);
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnInterferenceOthersUpdate(AutoTurret)

```csharp
/// <summary>
/// Called when interference on others is updated.
/// </summary>
/// <param name="autoTurret">The AutoTurret instance.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnInterferenceOthersUpdate(AutoTurret autoTurret)
{
    Puts("OnInterferenceOthersUpdate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdateInterferenceOnOthers()
	{
		if (Interface.CallHook("OnInterferenceOthersUpdate", this) != null)
		{
			return;
		}
		foreach (AutoTurret nearbyTurret in nearbyTurrets)
		{
			if (nearbyTurret != null)
			{
				nearbyTurret.TryRegisterForInterferenceUpdate();
			}
		}
	}

```

## OnEntityDeath(ResourceEntity,HitInfo)

```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity that was killed.</param>
/// <param name="hitInfo">Information about the hit that caused the death.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityDeath(ResourceEntity entity, HitInfo hitInfo)
{
    Puts("OnEntityDeath hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void OnKilled(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", this, info);
		Kill();
	}

```

## OnFireworkExhausted(BaseFirework)

```csharp
/// <summary>
/// Called when a firework is exhausted.
/// </summary>
/// <param name="firework">The firework that has been exhausted.</param>
/// <returns>No return behavior.</returns>
void OnFireworkExhausted(BaseFirework firework)
{
    Puts("OnFireworkExhausted is working!");
}
```

### Source Code from the Library

```csharp

	public virtual void OnExhausted()
	{
		SetFlag(Flags.Reserved8, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.OnFire, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		EnableGlobalBroadcast(wants: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkExhausted", this);
		Invoke(Cleanup, corpseDuration);
		_activeFireworks.Remove(this);
	}

```

## OnVehicleLockRequest(ModularCarGarage,BasePlayer,string)

```csharp
/// <summary>
/// Called when a player requests to add a lock to a vehicle.
/// </summary>
/// <param name="garage">The modular car garage.</param>
/// <param name="player">The player requesting the lock.</param>
/// <param name="lockType">The type of lock to be added.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnVehicleLockRequest(ModularCarGarage garage, BasePlayer player, string lockType)
{
    Puts("OnVehicleLockRequest called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void RPC_RequestAddLock(RPCMessage msg)
	{
		if (!HasOccupant || carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (player == null)
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("OnVehicleLockRequest", this, player, text) == null)
		{
			ItemAmount itemAmount = lockResourceCost;
			if ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && carOccupant.CarLock.TryAddALock(text, player.userID))
			{
				player.inventory.Take(null, itemAmount.itemDef.itemid, Mathf.CeilToInt(itemAmount.amount));
				Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnServerInformationUpdated()

```csharp
Документация для OnServerInformationUpdated()

**Описание**

Хук OnServerInformationUpdated() вызывается после обновления информации о сервере в методе UpdateServerInformation(). Этот хук позволяет плагинам и модификаторам получать доступ к обновленной информации о сервере.

**Параметры**

Нет параметров, передаваемых в этот хук.

**Возвращаемые значения**

Нет возвращаемых значений.

**Примечания**

Этот хук вызывается после того, как информация о сервере обновлена в методе UpdateServerInformation(). Это означает, что плагины и модификаторы могут получить доступ к обновленной информации о сервере, включая его название, максимальное количество игроков, карту и т. д.

**Пример использования**

Например, если вы хотите создать плагин, который отображает информацию о сервере в чате, вы можете использовать этот хук для получения обновленной информации о сервере и отобразить ее в чате.
```csharp
public class MyPlugin : MonoBehaviour
{
    public void OnServerInformationUpdated()
    {
        // Получаем обновленную информацию о сервере
        string serverName = SteamServer.ServerName;
        int maxPlayers = SteamServer.MaxPlayers;

        // Отображаем информацию в чате
        Debug.Log($"Сервер: {serverName}, Максимальное количество игроков: {maxPlayers}");
    }
}
```
**Использование**

Чтобы использовать этот хук, вам необходимо создать класс-плагин и переопределить метод OnServerInformationUpdated(). В этом методе вы можете получить доступ к обновленной информации о сервере и выполнить необходимые действия.
```

### Source Code from the Library

```csharp

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		using (TimeWarning.New("UpdateServerInformation"))
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.GetServerBrowserMapName();
			string value = "stok";
			if (Restarting)
			{
				value = "strst";
			}
			string text = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text2 = $"gm{GamemodeName()}";
			string text3 = (ConVar.Server.pve ? ",pve" : string.Empty);
			string text4 = ConVar.Server.tags?.Trim(',') ?? "";
			string text5 = ((!string.IsNullOrWhiteSpace(text4)) ? ("," + text4) : "");
			string text6 = BuildInfo.Current?.Scm?.ChangeId ?? "0";
			string text7 = PingEstimater.GetCachedClosestRegion().Code;
			if (!string.IsNullOrEmpty(ConVar.Server.ping_region_code_override))
			{
				text7 = ConVar.Server.ping_region_code_override;
			}
			SteamServer.GameTags = ServerTagCompressor.CompressTags($"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},$r{text7},v{2555}{text3}{text5},{text},{text2},cs{text6}");
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = ConVar.Server.description.SplitToChunks(100).ToArray();
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			SteamServer.SetKey("status", value);
			string value2 = World.Seed.ToString();
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			if (activeGameMode != null && !activeGameMode.ingameMap)
			{
				value2 = "0";
			}
			SteamServer.SetKey("world.seed", value2);
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("logoimage", ConVar.Server.logoimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			if (!string.IsNullOrWhiteSpace(ConVar.Server.favoritesEndpoint))
			{
				SteamServer.SetKey("favendpoint", ConVar.Server.favoritesEndpoint);
			}
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("uptime", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("ram_sys", (Performance.report.memoryUsageSystem / 1000000).ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
		Interface.CallHook("OnServerInformationUpdated");
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
/// <summary>
/// Called when a resource is gathered from a mining quarry.
/// </summary>
/// <param name="quarry">The mining quarry that gathered the resource.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>The gathered item, or null if it should be removed.</returns>
object OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts("OnQuarryGather is working!");
    return item;
}
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
		float num = Mathf.Min(workToAdd, pendingWork);
		pendingWork -= num;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			float workNeeded = resource.workNeeded;
			int num2 = Mathf.FloorToInt(resource.workDone / workNeeded);
			resource.workDone += num;
			int num3 = Mathf.FloorToInt(resource.workDone / workNeeded);
			if (resource.workDone > workNeeded)
			{
				resource.workDone %= workNeeded;
			}
			if (num2 != num3)
			{
				int iAmount = num3 - num2;
				Item item = ItemManager.Create(resource.type, iAmount, 0uL);
				Facepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);
				if (Interface.CallHook("OnQuarryGather", this, item) != null)
				{
					item.Remove();
				}
				else if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
	}

```

## OnVehicleModuleSelect(Item,ModularCarGarage,BasePlayer)

```csharp
/// <summary>
/// Called when a player selects a module for their vehicle.
/// </summary>
/// <param name="item">The item being selected.</param>
/// <param name="garage">The modular car garage.</param>
/// <param name="player">The player selecting the module.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnVehicleModuleSelect(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts("OnVehicleModuleSelect called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!ObjectEx.IsUnityNull(container))
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!ObjectEx.IsUnityNull(container2))
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## OnRackedWeaponTaken(Item,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a weapon is taken from a rack.
/// </summary>
/// <param name="item">The item being taken.</param>
/// <param name="player">The player taking the item.</param>
/// <param name="rack">The rack from which the item was taken.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnRackedWeaponTaken(Item item, BasePlayer player, WeaponRack rack)
{
    Puts("OnRackedWeaponTaken is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", slot, player, this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		if (slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex))
		{
			if ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1)
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", slot, player, this);
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum,ulong)

```csharp
/// <summary>
/// Called to determine if a player can afford an upgrade.
/// </summary>
/// <param name="player">The player attempting the upgrade.</param>
/// <param name="blockDefinition">The block definition being upgraded.</param>
/// <param name="grade">The grade of the upgrade.</param>
/// <param name="skin">The skin ID of the upgrade.</param>
/// <returns>Returns true if the player can afford the upgrade, false otherwise.</returns>
bool CanAffordUpgrade(BasePlayer player, BuildingBlock blockDefinition, BuildingGrade.Enum grade, ulong skin)
{
    Puts("CanAffordUpgrade is working!");
    // If the return value from Interface.CallHook is a boolean, return it
    if (/* check if obj is bool */ true) 
        return /* cast to bool */;
    
    // If the player is in creative mode and has free build enabled, they can afford any upgrade
    if (player != null && player.IsInCreativeMode && Creative.freeBuild)
        return true;
    
    // Check if the player has enough items to build the upgrade
    foreach (ItemAmount item in blockDefinition.GetGrade(grade, skin).CostToBuild(grade))
    {
        if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
            return false;
    }
    
    return true;
}
```

### Source Code from the Library

```csharp

	public bool CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade, iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player != null && player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		foreach (ItemAmount item in blockDefinition.GetGrade(iGrade, iSkin).CostToBuild(grade))
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## CanLootEntity(BasePlayer,ContainerIOEntity)

```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>Returns true if the player can loot the entity, false otherwise.</returns>
bool CanLootEntity(BasePlayer player, ContainerIOEntity entity)
{
    Puts("CanLootEntity is working!");
    return true; // Default to allowing looting
}
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (needsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if ((onlyOneUser && IsOpen()) || IsTransferring())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, StorageContainer.LockedMessage);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = lootPanelName;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnEntityFromOwnerCheck(BaseEntity,BasePlayer,uint,string)

```csharp
/// <summary>
/// Called when checking if an entity is from a specific owner.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <param name="owner">The owner of the entity.</param>
/// <param name="id">A unique identifier for the check.</param>
/// <param name="debugName">A debug name for the check.</param>
/// <returns>Returns true if the entity is from the specified owner, false otherwise.</returns>
bool OnEntityFromOwnerCheck(BaseEntity entity, BasePlayer owner, uint id, string debugName)
{
    Puts("OnEntityFromOwnerCheck called!");
    // Return true or false based on the check result
    return true; // Replace with actual logic
}
```

### Source Code from the Library

```csharp
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityFromOwnerCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				return true;
			}

```

## OnCupboardAuthorize(BuildingPrivlidge,BasePlayer)

```csharp
/// <summary>
/// Called when a player attempts to authorize access to a cupboard.
/// </summary>
/// <param name="privilege">The cupboard's privilege.</param>
/// <param name="player">The player attempting to authorize access.</param>
/// <returns>Returns null if the default behavior is not overridden, indicating that the player has been successfully authorized.</returns>
object OnCupboardAuthorize(BuildingPrivlidge privilege, BasePlayer player)
{
    Puts("OnCupboardAuthorize called!");
    // Add logic here to handle authorization
    return null;
}
```

### Source Code from the Library

```csharp

	internal void OnDeployed(BaseEntity ent, BasePlayer player)
	{
		if (player.IsValid() && !string.IsNullOrEmpty(UnlockAchievement))
		{
			player.GiveAchievement(UnlockAchievement);
		}
		if (ent is BuildingPrivlidge buildingPrivlidge && Interface.CallHook("OnCupboardAuthorize", buildingPrivlidge, player) == null)
		{
			buildingPrivlidge.AddPlayer(player, player.userID);
		}
	}

```

## OnEntityMarkHostile(BasePlayer,float)

```csharp
/// <summary>
/// Called when an entity is marked as hostile.
/// </summary>
/// <param name="player">The player who marked the entity as hostile.</param>
/// <param name="duration">The duration for which the entity will be considered hostile.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityMarkHostile(BasePlayer player, float duration)
{
    Puts("OnEntityMarkHostile is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			double currentTimestamp = TimeEx.currentTimestamp;
			double val = currentTimestamp + (double)duration;
			State.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);
			DirtyPlayerState();
			double num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);
			ClientRPC(RpcTarget.Player("SetHostileLength", this), (float)num);
		}
	}

```

## OnMagazineReload(BaseProjectile,IAmmoContainer,BasePlayer)

```csharp
/// <summary>
/// Called when a magazine is reloaded.
/// </summary>
/// <param name="projectile">The projectile being reloaded.</param>
/// <param name="ammoContainer">The ammo container providing the ammunition.</param>
/// <param name="player">The player reloading the magazine.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
object OnMagazineReload(BaseProjectile projectile, IAmmoContainer ammoContainer, BasePlayer player)
{
    Puts("OnMagazineReload called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual bool TryReloadMagazine(IAmmoContainer ammoSource, int desiredAmount = -1)
	{
		object obj = Interface.CallHook("OnMagazineReload", this, ammoSource, GetOwnerPlayer());
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!TryReload(ammoSource, desiredAmount))
		{
			return false;
		}
		SendNetworkUpdateImmediate();
		ItemManager.DoRemoves();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer != null)
		{
			ownerPlayer.inventory.ServerUpdate(0f);
		}
		return true;
	}

```

## OnSendModelState(BasePlayer)

```csharp
/// <summary>
/// Called when the client needs to send its current state to the server.
/// </summary>
/// <param name="player">The player whose state is being sent.</param>
/// <returns>No return behavior. The method's result is ignored by the caller.</returns>
void OnSendModelState(BasePlayer player)
{
    Puts("OnSendModelState called!");
}
```

### Source Code from the Library

```csharp

	public void SendModelState(bool force = false)
	{
		if (!force && (!wantsSendModelState || nextModelStateUpdate > UnityEngine.Time.time))
		{
			return;
		}
		wantsSendModelState = false;
		nextModelStateUpdate = UnityEngine.Time.time + 0.1f;
		if (!IsDead() && !IsSpectating())
		{
			modelState.sleeping = IsSleeping();
			modelState.mounted = isMounted;
			modelState.relaxed = IsRelaxed();
			modelState.onPhone = HasActiveTelephone && !activeTelephone.IsMobile;
			modelState.crawling = IsCrawling();
			if (!base.limitNetworking && Interface.CallHook("OnSendModelState", this) == null)
			{
				modelState.loading = IsLoadingAfterTransfer();
				ClientRPC(RpcTarget.NetworkGroup("OnModelState"), modelState);
			}
		}
	}

```

## OnFireworkDesignChange(PatternFirework,ProtoBuf.PatternFirework.Design,BasePlayer)

```csharp
/// <summary>
/// Called when a player's firework design is changed.
/// </summary>
/// <param name="design">The new firework design.</param>
/// <param name="player">The player who made the change.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns the result of the hook.</returns>
object OnFireworkDesignChange(ProtoBuf.PatternFirework design, BasePlayer player)
{
    Puts("OnFireworkDesignChange is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		ProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);
		if (Interface.CallHook("OnFireworkDesignChange", this, design, rpc.player) != null)
		{
			return;
		}
		if (design?.stars != null)
		{
			while (design.stars.Count > MaxStars)
			{
				int index = design.stars.Count - 1;
				design.stars[index].Dispose();
				design.stars.RemoveAt(index);
			}
			foreach (ProtoBuf.PatternFirework.Star star in design.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			design.editedBy = rpc.player.userID;
		}
		Design?.Dispose();
		Design = design;
		Interface.CallHook("OnFireworkDesignChanged", this, design, rpc.player);
		SendNetworkUpdateImmediate();
	}

```

## CanVendingAcceptItem(VendingMachine,Item,int)

```csharp
/// <summary>
/// Called to determine if a vending machine can accept an item.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being attempted to be accepted.</param>
/// <param name="targetSlot">The target slot on the vending machine where the item is being placed.</param>
/// <returns>Returns true if the vending machine can accept the item, false otherwise.</returns>
bool CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)
{
    Puts("CanVendingAcceptItem is working!");
    return true; // Default to allowing acceptance
}
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer basePlayer = item.GetRootContainer()?.GetOwnerPlayer();
		if (transactionActive || industrialItemIncoming)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (base.inventory.itemList.Contains(item))
		{
			return true;
		}
		if (basePlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(basePlayer);
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container that the item was added to.</param>
/// <param name="item">The item that was added.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item} added to container {container}");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## OnFeedbackReported(BasePlayer,string,string,Facepunch.Models.ReportType)

```csharp
/// <summary>
/// Called when a player reports feedback.
/// </summary>
/// <param name="player">The player who reported the feedback.</param>
/// <param name="subject">The subject of the feedback report.</param>
/// <param name="message">The message of the feedback report.</param>
/// <param name="reportType">The type of the feedback report.</param>
/// <returns>No return behavior.</returns>
void OnFeedbackReported(BasePlayer player, string subject, string message, ReportType reportType)
{
    Puts($"Player {player.UserIDString} reported {reportType} - \"{subject}\" \"{message}\"");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnFeedbackReport(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		ReportType reportType = (ReportType)Mathf.Clamp(msg.read.Int32(), 0, 5);
		if (ConVar.Server.printReportsToConsole)
		{
			DebugEx.Log($"[FeedbackReport] {this} reported {reportType} - \"{text}\" \"{text2}\"");
			RCon.Broadcast(RCon.LogType.Report, new
			{
				PlayerId = UserIDString,
				PlayerName = displayName,
				Subject = text,
				Message = text2,
				Type = reportType
			});
		}
		if (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))
		{
			string image = msg.read.StringMultiLine(60000);
			Facepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);
			feedback.Type = reportType;
			feedback.Message = text2;
			feedback.Subject = text;
			Facepunch.Models.Feedback feedback2 = feedback;
			feedback2.AppInfo.Image = image;
			Facepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2);
			Interface.CallHook("OnFeedbackReported", this, text, text2, reportType);
		}
	}

```

## OnQueueCycle(int)

```csharp
/// <summary>
/// Called when the queue cycle is triggered.
/// </summary>
/// <param name="availableSlots">The number of available slots in the game.</param>
/// <returns>No return behavior.</returns>
void OnQueueCycle(int availableSlots)
{
    Puts("OnQueueCycle is working!");
}
```

### Source Code from the Library

```csharp

	public void Cycle(int availableSlots)
	{
		if (Interface.CallHook("OnQueueCycle", availableSlots) != null)
		{
			return;
		}
		if (UnityEngine.Time.realtimeSinceStartup > nextCleanupReservedSlots)
		{
			nextCleanupReservedSlots = UnityEngine.Time.realtimeSinceStartup + 1f;
			CleanupExpiredReservedSlots();
		}
		if (queue.Count != 0)
		{
			if (availableSlots - Joining > 0)
			{
				JoinGame(queue[0]);
			}
			SendMessages();
		}
	}

```

## CanMoveItem(Item,PlayerInventory,ItemContainerId,int,int,ItemMoveModifier)

```csharp
Документация для `CanMoveItem(Item, PlayerInventory, ItemContainerId, int, int, ItemMoveModifier)`

**Описание**

Функция проверки возможности перемещения предмета из инвентаря игрока в контейнер.

**Параметры**

* `Item`: Объект предмета, который необходимо переместить.
* `PlayerInventory`: Инвентарь игрока, из которого будет перемещен предмет.
* `ItemContainerId`: Идентификатор контейнера, в который будет перемещен предмет.
* `int`: Количество предметов, которые будут перемещены.
* `int`: Максимальное количество предметов, которое может вместить контейнер.
* `ItemMoveModifier`: Флаги, определяющие, каким образом будет выполнено перемещение.

**Возвращаемое значение**

Функция возвращает `null`, если перемещение возможно. В противном случае функция не возвращает никаких значений и завершает работу.

**Примечания**

* Функция вызывается из метода `MoveItem` в классе `BaseEntity`.
* Функция проверяет, можно ли переместить предмет из инвентаря игрока в контейнер, учитывая ограничения на количество предметов и возможность использования флагов `ItemMoveModifier`.
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server.FromOwner]
	[BaseEntity.RPC_Server]
	public void MoveItem(BaseEntity.RPCMessage msg)
	{
		if (base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId itemId = msg.read.ItemID();
		ItemContainerId itemContainerId = msg.read.ItemContainerID();
		int num = msg.read.Int8();
		int num2 = (int)msg.read.UInt32();
		ItemMoveModifier itemMoveModifier = (ItemMoveModifier)msg.read.Int32();
		Item item = FindItemByUID(itemId);
		if (item == null)
		{
			BasePlayer player = msg.player;
			ItemId itemId2 = itemId;
			player.ChatMessage("Invalid item (" + itemId2.ToString() + ")");
		}
		else
		{
			if (Interface.CallHook("CanMoveItem", item, this, itemContainerId, num, num2, itemMoveModifier) != null)
			{
				return;
			}
			BaseEntity entityOwner = item.GetEntityOwner();
			if (entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering)
			{
				return;
			}
			if (!CanMoveItemsFrom(entityOwner, item))
			{
				msg.player.ChatMessage("Cannot move item!");
				return;
			}
			if (num2 <= 0)
			{
				num2 = item.amount;
			}
			num2 = Mathf.Clamp(num2, 1, item.MaxStackable());
			if (msg.player.GetActiveItem() == item)
			{
				msg.player.UpdateActiveItem(default(ItemId));
			}
			if (!itemContainerId.IsValid)
			{
				BaseEntity baseEntity = entityOwner;
				if (loot.containers.Count > 0)
				{
					if (entityOwner == base.baseEntity)
					{
						if (!itemMoveModifier.HasFlag(ItemMoveModifier.Alt))
						{
							baseEntity = loot.entitySource;
						}
					}
					else
					{
						baseEntity = base.baseEntity;
					}
				}
				if (baseEntity is IIdealSlotEntity idealSlotEntity)
				{
					itemContainerId = idealSlotEntity.GetIdealContainer(base.baseEntity, item, itemMoveModifier);
					if (itemContainerId == ItemContainerId.Invalid)
					{
						return;
					}
				}
				ItemContainer parent = item.parent;
				if (parent != null && parent.IsLocked())
				{
					msg.player.ChatMessage("Container is locked!");
					return;
				}
				if (!itemContainerId.IsValid)
				{
					if (baseEntity == loot.entitySource)
					{
						foreach (ItemContainer container in loot.containers)
						{
							if (!container.PlayerItemInputBlocked() && !container.IsLocked() && item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))
							{
								break;
							}
						}
						return;
					}
					if (!GiveItem(item, itemMoveModifier))
					{
						msg.player.ChatMessage("GiveItem failed!");
					}
					return;
				}
			}
			ItemContainer itemContainer = FindContainer(itemContainerId);
			if (itemContainer == null)
			{
				BasePlayer player2 = msg.player;
				ItemContainerId itemContainerId2 = itemContainerId;
				player2.ChatMessage("Invalid container (" + itemContainerId2.ToString() + ")");
				return;
			}
			if (itemContainer.IsLocked())
			{
				msg.player.ChatMessage("Container is locked!");
				return;
			}
			if (itemContainer.PlayerItemInputBlocked())
			{
				msg.player.ChatMessage("Container does not accept player items!");
				return;
			}
			if (itemContainer.maxStackSize > 0)
			{
				num2 = Mathf.Clamp(num2, 1, itemContainer.maxStackSize);
			}
			using (TimeWarning.New("Split"))
			{
				if (item.amount > num2)
				{
					int split_Amount = num2;
					Item item2 = item.SplitItem(split_Amount);
					Item slot = itemContainer.GetSlot(num);
					if (slot != null && !item.CanStack(slot) && item.parent != null && !item2.MoveToContainer(item.parent, -1, allowStack: false, ignoreStackLimit: false, base.baseEntity, allowSwap: false))
					{
						item.amount += item2.amount;
						item2.Remove();
						ItemManager.DoRemoves();
						ServerUpdate(0f);
						return;
					}
					if (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))
					{
						item.amount += item2.amount;
						item2.Remove();
					}
					else
					{
						item.parent.onItemRemovedFromStack?.Invoke(item, num2);
					}
					ItemManager.DoRemoves();
					ServerUpdate(0f);
					return;
				}
			}
			if (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))
			{
				ItemManager.DoRemoves();
				ServerUpdate(0f);
			}
		}
	}

```

## OnBuildingMerge(ServerBuildingManager,BuildingManager.Building,BuildingManager.Building)

```csharp
/// <summary>
/// Called when two buildings are merged.
/// </summary>
/// <param name="serverBuildingManager">The server building manager.</param>
/// <param name="building1">The first building being merged.</param>
/// <param name="building2">The second building being merged.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnBuildingMerge(ServerBuildingManager serverBuildingManager, Building building1, Building building2)
{
    Puts("OnBuildingMerge hook called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	private void Merge(Building building1, Building building2)
	{
		Interface.CallHook("OnBuildingMerge", this, building1, building2);
		while (building2.HasDecayEntities())
		{
			building2.decayEntities[0].AttachToBuilding(building1.ID);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building1.isNavMeshCarvingDirty = true;
			building2.isNavMeshCarvingDirty = true;
			int ticks = 3;
			UpdateNavMeshCarver(building1, ref ticks, 0);
			UpdateNavMeshCarver(building1, ref ticks, 0);
		}
	}

```

## CanLock(BasePlayer,CodeLock)

```csharp
/// <summary>
/// Called when a player attempts to lock the entity.
/// </summary>
/// <param name="player">The player attempting to lock the entity.</param>
/// <param name="lock">The code lock being used.</param>
/// <returns>Returns null if the default behavior is not overridden, indicating that the lock can be applied.</returns>
object CanLock(BasePlayer player, CodeLock lock)
{
    Puts("CanLock hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", rpc.player, this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnCrateDropped(HackableLockedCrate)

```csharp
/// <summary>
/// Called when a hackable locked crate is dropped.
/// </summary>
/// <param name="crate">The dropped crate.</param>
/// <returns>Returns the crate if it's used in the method's functionality, otherwise returns null.</returns>
object OnCrateDropped(HackableLockedCrate crate)
{
    Puts("OnCrateDropped is working!");
    return crate;
}
```

### Source Code from the Library

```csharp

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", this);
	}

```

## OnConnectionDequeue(Network.Connection)

```csharp
/// <summary>
/// Called when a network connection is dequeued.
/// </summary>
/// <param name="connection">The removed connection.</param>
/// <returns>No return behavior.</returns>
void OnConnectionDequeue(Network.Connection connection)
{
    Puts($"Connection {connection} dequeued.");
}
</prompt>
```

### Source Code from the Library

```csharp

	public void RemoveConnection(Connection connection)
	{
		if (Interface.CallHook("OnConnectionDequeue", connection) == null)
		{
			if (queue.Remove(connection))
			{
				nextMessageTime = 0f;
			}
			joining.Remove(connection);
		}
	}

```

## OnSendCommand(Network.Connection,string,object[])

```csharp
/// <summary>
/// Called when a client sends a command to the server.
/// </summary>
/// <param name="connection">The connection of the client sending the command.</param>
/// <param name="command">The command being sent.</param>
/// <param name="args">Arguments for the command.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnSendCommand(Network.Connection connection, string command, object[] args)
{
    Puts("OnSendCommand hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(Connection cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnSendCommand", cn, strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			string val = ConsoleSystem.BuildCommand(strCommand, args);
			netWrite.String(val);
			netWrite.Send(new SendInfo(cn));
		}
	}

```

## OnLootNetworkUpdate(PlayerLoot)

```csharp
/// <summary>
/// Called when the loot network is updated.
/// </summary>
/// <param name="loot">The updated loot data.</param>
/// <returns>No return behavior.</returns>
void OnLootNetworkUpdate(PlayerLoot loot)
{
    Puts($"Loot network updated: {loot}");
}
```

### Source Code from the Library

```csharp

	private void SendUpdate()
	{
		isInvokingSendUpdate = false;
		if (!base.baseEntity.IsValid() || Interface.CallHook("OnLootNetworkUpdate", this) != null)
		{
			return;
		}
		using PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		if ((bool)entitySource && entitySource.net != null)
		{
			playerUpdateLoot.entityID = entitySource.net.ID;
		}
		if (itemSource != null)
		{
			playerUpdateLoot.itemID = itemSource.uid;
		}
		if (containers.Count > 0)
		{
			playerUpdateLoot.containers = Pool.Get<List<ProtoBuf.ItemContainer>>();
			foreach (ItemContainer container in containers)
			{
				playerUpdateLoot.containers.Add(container.Save());
			}
		}
		base.baseEntity.ClientRPC(RpcTarget.Player("UpdateLoot", base.baseEntity), playerUpdateLoot);
	}

```

## CanUnlockTechTreeNode(BasePlayer,TechTreeData.NodeInstance,TechTreeData)

```csharp
/// <summary>
/// Called when a player attempts to unlock a tech tree node.
/// </summary>
/// <param name="player">The player attempting to unlock the node.</param>
/// <param name="node">The node instance being unlocked.</param>
/// <param name="techTreeData">The tech tree data associated with the node.</param>
/// <returns>Returns a boolean value indicating whether the node can be unlocked.</returns>
bool CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)
{
    Puts("CanUnlockTechTreeNode is working!");
    // Return true if the node can be unlocked, false otherwise
    return true; // Replace with actual logic to determine whether the node can be unlocked
}
```

### Source Code from the Library

```csharp

	public bool PlayerCanUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNode", player, node, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerHasPathForUnlock(player, node))
		{
			return !HasPlayerUnlocked(player, node);
		}
		return false;
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
/// <summary>
/// Called to determine if a target can be targeted by an auto turret.
/// </summary>
/// <param name="entity">The entity being targeted.</param>
/// <param name="autoTurret">The auto turret attempting to target the entity.</param>
/// <returns>Returns true if the entity can be targeted, false otherwise.</returns>
bool CanBeTargeted(BaseCombatEntity entity, AutoTurret autoTurret)
{
    // Minimal code to demonstrate functionality
    return (bool)Interface.CallHook("CanBeTargeted", entity, autoTurret);
}
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.GetList<RaycastHit>();
		Vector3 position = eyePos.transform.position;
		if (GamePhysics.CheckSphere(position, 0.1f, 2097152))
		{
			return false;
		}
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);
		for (int i = 0; (float)i < (CheckPeekers() ? 3f : 1f); i++)
		{
			Vector3 normalized = (vector + vector2 * visibilityOffsets[i] - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);
			for (int j = 0; j < obj3.Count; j++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);
				if ((!(entity != null) || !entity.isClient) && (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) && (!(entity != null) || !entity.EqualNetID(this)))
				{
					if (entity != null && (entity == obj || entity.EqualNetID(obj)))
					{
						Facepunch.Pool.FreeList(ref obj3);
						peekIndex = i;
						return true;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj3);
		return false;
	}

```

## OnCollectiblePickup(CollectibleEntity,BasePlayer,bool)

```csharp
/// <summary>
/// Called when a collectible item is picked up by a player.
/// </summary>
/// <param name="entity">The collectible entity being picked up.</param>
/// <param name="player">The player who picked up the collectible.</param>
/// <param name="eat">Whether the collectible was eaten or not.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnCollectiblePickup(CollectibleEntity entity, BasePlayer player, bool eat)
{
    Puts("OnCollectiblePickup is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void DoPickup(BasePlayer reciever, bool eat = false)
	{
		if (itemList == null || Interface.CallHook("OnCollectiblePickup", this, reciever, eat) != null)
		{
			return;
		}
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			if (reciever != null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)
			{
				continue;
			}
			Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
			if (item == null)
			{
				continue;
			}
			if (eat && item.info.category == ItemCategory.Food && reciever != null)
			{
				ItemModConsume component = item.info.GetComponent<ItemModConsume>();
				if (component != null)
				{
					component.DoAction(item, reciever);
					continue;
				}
			}
			if ((bool)reciever)
			{
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);
				Interface.CallHook("OnCollectiblePickedup", this, reciever, item);
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
		}
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(reciever, base.transform.position);
		}
		Kill();
	}

```

## OnBoomboxStationUpdate(BoomBox,string,BasePlayer)

```csharp
/// <summary>
/// Called when the boombox station is updated.
/// </summary>
/// <param name="boomBox">The boombox entity.</param>
/// <param name="stationIp">The new radio IP address.</param>
/// <param name="player">The player who updated the station.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnBoomboxStationUpdate(BoomBox boomBox, string stationIp, BasePlayer player)
{
    Puts("OnBoomboxStationUpdate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnBoomboxStationUpdate", this, text, msg.player) == null && IsStationValid(text))
		{
			if (msg.player != null)
			{
				ulong assignedRadioBy = msg.player.userID.Get();
				AssignedRadioBy = assignedRadioBy;
			}
			CurrentRadioIp = text;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnRadioIPChanged"), CurrentRadioIp);
			Interface.CallHook("OnBoomboxStationUpdated", this, text, msg.player);
			if (IsOn())
			{
				ServerTogglePlay(play: false);
			}
		}
	}

```

## OnDispenserBonusReceived(ResourceDispenser,BasePlayer,Item)

```csharp
/// <summary>
/// Called when a bonus item is received from a dispenser.
/// </summary>
/// <param name="dispenser">The dispenser that provided the bonus.</param>
/// <param name="player">The player who received the bonus.</param>
/// <param name="item">The bonus item received.</param>
/// <returns>No return behavior.</returns>
void OnDispenserBonusReceived(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} received bonus item: {item.info.shortname}");
}
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", this, player, item);
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
Документация для IOnBasePlayerAttacked(BasePlayer, HitInfo)

**Описание**

Этот хук вызывается при атаке игрока на сервере. Он позволяет модификаторам изменить поведение игрока в ответ на атаку.

**Параметры**

* `BasePlayer`: Игрок, который был атакован.
* `HitInfo`: Информация о нападении (например, тип оружия, точка удара и т. д.).

**Возвращаемые значения**

Нет возвращаемых значений.

**Примечания**

Этот хук вызывается после того, как игрок был атакован на сервере. Если модификатор вернет не null из этого хука, то стандартное поведение игрока при атаке будет отменено.

**Пример использования**

Например, вы можете использовать этот хук для изменения здоровья игрока в ответ на атаку:
```csharp
public class MyMod : MonoBehaviour
{
    public void IOnBasePlayerAttacked(BasePlayer player, HitInfo info)
    {
        // Изменить здоровье игрока в ответ на атаку
        player.health -= 10f;
    }
}
```
В этом примере модификатор уменьшает здоровье игрока на 10 единиц при каждой атаке.
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float oldHealth = base.health;
		if (InSafeZone() && !IsHostile() && info.Initiator != null && info.Initiator != this)
		{
			info.damageTypes.ScaleAll(0f);
		}
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.GetList<Item>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortalTo(info))
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			if (isMounted)
			{
				GetMounted().MounteeTookDamage(this, info);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				ClientRPC(RpcTarget.Player("TakeDamageHit", this));
			}
			string text = StringPool.Get(info.HitBone);
			bool flag = Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) > 0.4f;
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer && !info.damageTypes.IsMeleeType())
			{
				initiatorPlayer.LifeStoryShotHit(info.Weapon);
			}
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				if (!initiatorPlayer || !initiatorPlayer.limitNetworking)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new Vector3(0f, 2f, 0f), Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);
				}
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1, (Stats)5);
					if (initiatorPlayer.IsBeingSpectated)
					{
						foreach (BaseEntity child in initiatorPlayer.children)
						{
							if (child is BasePlayer basePlayer)
							{
								basePlayer.ClientRPC(RpcTarget.Player("SpectatedPlayerHeadshot", basePlayer));
							}
						}
					}
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.LogAttack(info, "wounded", oldHealth);
			}
			else if (IsDead())
			{
				stats.combat.LogAttack(info, "killed", oldHealth);
			}
			else
			{
				stats.combat.LogAttack(info, "", oldHealth);
			}
		}
		if (ConVar.Global.cinematicGingerbreadCorpses)
		{
			info.HitMaterial = ConVar.Global.GingerbreadMaterialID();
		}
	}

```

## OnMlrsFire(MLRS,BasePlayer)

```csharp
/// <summary>
/// Called when the MLRS fires a rocket.
/// </summary>
/// <param name="mlrs">The MLRS instance.</param>
/// <param name="owner">The player who fired the rocket.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFire(MLRS mlrs, BasePlayer owner)
{
    Puts("OnMlrsFire is working!");
}
```

### Source Code from the Library

```csharp

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !(_mounted == null) && Interface.CallHook("OnMlrsFire", this, owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			InvokeRepeating(FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", this, owner);
		}
	}

```

## OnFlameThrowerBurn(FlameThrower,BaseEntity)

```csharp
/// <summary>
/// Called when a flame thrower burns an entity.
/// </summary>
/// <param name="flameThrower">The flame thrower that caused the burn.</param>
/// <param name="entity">The entity that was burned.</param>
/// <returns>No return behavior.</returns>
void OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity entity)
{
    Puts($"Entity {entity} burned by flame thrower {flameThrower}");
}
```

### Source Code from the Library

```csharp

	public void FlameTick()
	{
		float num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;
		lastFlameTick = UnityEngine.Time.realtimeSinceStartup;
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		ReduceAmmo(num);
		SendNetworkUpdate();
		Ray ray = ownerPlayer.eyes.BodyRay();
		Vector3 origin = ray.origin;
		RaycastHit hitInfo;
		bool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);
		if (!num2)
		{
			hitInfo.point = origin + ray.direction * flameRange;
		}
		float num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);
		float amount = damagePerSec[0].amount;
		damagePerSec[0].amount = amount * num * num3;
		int num4 = 2146305;
		int layers = 133376;
		if (!ownerPlayer.IsNpc)
		{
			num4 |= 0x800;
		}
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, num4, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true);
		damagePerSec[0].amount = damagePerSec[0].amount * playerDamageMultiplier;
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, layers, useLineOfSight: true, ignoreAI: false, ignoreAttackingPlayer: true);
		damagePerSec[0].amount = amount;
		if (num2 && UnityEngine.Time.realtimeSinceStartup >= nextFlameTime && hitInfo.distance > 1.1f)
		{
			nextFlameTime = UnityEngine.Time.realtimeSinceStartup + (ownerPlayer.IsNpc ? 0.25f : 0.45f);
			Vector3 point = hitInfo.point;
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, point - ray.direction * 0.25f);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnFlameThrowerBurn", this, baseEntity);
				baseEntity.creatorEntity = ownerPlayer;
				FireBall fireBall = baseEntity as FireBall;
				if (fireBall != null && ownerPlayer.IsNpc)
				{
					fireBall.ignoreNPC = true;
				}
				baseEntity.Spawn();
			}
		}
		if (ammo == 0)
		{
			SetFlameState(wantsOn: false);
		}
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null && !base.UsingInfiniteAmmoCheat && !ownerPlayer.IsNpc)
		{
			ownerItem.LoseCondition(num);
		}
	}

```

## OnPlayerPingsSend(BasePlayer,ProtoBuf.MapNoteList)

```csharp
/// <summary>
/// Called when a player sends pings to the client.
/// </summary>
/// <param name="player">The player sending the pings.</param>
/// <param name="mapNoteList">A list of map notes sent by the player.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerPingsSend(BasePlayer player, ProtoBuf.MapNoteList mapNoteList)
{
    Puts("OnPlayerPingsSend called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public void SendPingsToClient()
	{
		using MapNoteList mapNoteList = Facepunch.Pool.Get<MapNoteList>();
		mapNoteList.notes = Facepunch.Pool.GetList<MapNote>();
		mapNoteList.notes.AddRange(State.pings);
		Interface.CallHook("OnPlayerPingsSend", this, mapNoteList);
		ClientRPC(RpcTarget.Player("Client_ReceivePings", this), mapNoteList);
		mapNoteList.notes.Clear();
	}

```

## OnTimedExplosiveExplode(TimedExplosive,UnityEngine.Vector3)

```csharp
Документация для OnTimedExplosiveExplode(TimedExplosive, Vector3)

**Описание**

Этот хук вызывается при взрыве взрывного устройства с задержкой. Он позволяет модулю или скрипту вмешаться в процесс взрыва и изменить его поведение.

**Сигнатура**

`public virtual void OnTimedExplosiveExplode(TimedExplosive timedExplosive, Vector3 explosionFxPos)`

* `timedExplosive`: Объект взрывного устройства с задержкой.
* `explosionFxPos`: Позиция взрыва в пространстве.

**Возвращаемое значение**

Нет. Хук не возвращает никаких значений.

**Описание поведения**

Когда хук вызывается, он позволяет модулю или скрипту изменить поведение взрыва. Например, можно изменить тип взрыва, его силу или расположение.

**Пример использования**

```csharp
public class MyModule : MonoBehaviour
{
    public void OnTimedExplosiveExplode(TimedExplosive timedExplosive, Vector3 explosionFxPos)
    {
        // Измените поведение взрыва здесь
        Debug.Log("Взрыв произошел!");
    }
}
```

**Примечания**

* Хук вызывается только один раз при взрыве.
* Объект `timedExplosive` содержит информацию о взрывном устройстве с задержкой, включая его позицию и силу.
* Позиция взрыва в пространстве указывается в переменной `explosionFxPos`.
```

### Source Code from the Library

```csharp

	public virtual void Explode(Vector3 explosionFxPos)
	{
		Facepunch.Rust.Analytics.Azure.OnExplosion(this);
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(explosionFxPos - new Vector3(0f, 0.25f, 0f), waves: true, volumes: false);
		if (underwaterExplosionEffect.isValid && waterInfo.isValid && waterInfo.currentDepth >= underwaterExplosionDepth)
		{
			Effect.server.Run(underwaterExplosionEffect.resourcePath, explosionFxPos, explosionUsesForward ? base.transform.forward : Vector3.up, null, broadcast: true);
		}
		else if (explosionEffect.isValid)
		{
			Effect.server.Run(explosionEffect.resourcePath, explosionFxPos, explosionUsesForward ? base.transform.forward : Vector3.up, null, broadcast: true);
		}
		if (watersurfaceExplosionEffect.isValid && waterInfo.isValid && waterInfo.overallDepth >= watersurfaceExplosionDepth.x && waterInfo.currentDepth <= watersurfaceExplosionDepth.y)
		{
			Effect.server.Run(watersurfaceExplosionEffect.resourcePath, explosionFxPos.WithY(waterInfo.surfaceLevel), explosionUsesForward ? base.transform.forward : Vector3.up, null, broadcast: true);
		}
		if (damageTypes.Count > 0)
		{
			if (Interface.CallHook("OnTimedExplosiveExplode", this, explosionFxPos) != null)
			{
				return;
			}
			Vector3 vector = ExplosionCenter();
			if (onlyDamageParent)
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), vector, minExplosionRadius, explosionRadius, damageTypes, 166144, useLineOfSight: true, IgnoreAI);
				BaseEntity baseEntity = GetParentEntity();
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				while (baseCombatEntity == null && baseEntity != null && baseEntity.HasParent())
				{
					baseEntity = baseEntity.GetParentEntity();
					baseCombatEntity = baseEntity as BaseCombatEntity;
				}
				if (baseEntity == null || !GameObjectEx.IsOnLayer(baseEntity.gameObject, Layer.Construction))
				{
					List<BuildingBlock> obj = Pool.GetList<BuildingBlock>();
					Vis.Entities(vector, explosionRadius, obj, 2097152, QueryTriggerInteraction.Ignore);
					BuildingBlock buildingBlock = null;
					float num = float.PositiveInfinity;
					foreach (BuildingBlock item in obj)
					{
						if (!item.isClient && !item.IsDestroyed && !(item.healthFraction <= 0f))
						{
							float num2 = Vector3.Distance(item.ClosestPoint(vector), vector);
							if (num2 < num && item.IsVisible(vector, explosionRadius))
							{
								buildingBlock = item;
								num = num2;
							}
						}
					}
					if ((bool)buildingBlock)
					{
						HitInfo hitInfo = new HitInfo();
						hitInfo.Initiator = creatorEntity;
						hitInfo.WeaponPrefab = LookupPrefab();
						hitInfo.damageTypes.Add(damageTypes);
						hitInfo.PointStart = vector;
						hitInfo.PointEnd = buildingBlock.transform.position;
						float amount = 1f - Mathf.Clamp01((num - minExplosionRadius) / (explosionRadius - minExplosionRadius));
						hitInfo.damageTypes.ScaleAll(amount);
						buildingBlock.Hurt(hitInfo);
					}
					Pool.FreeList(ref obj);
				}
				if ((bool)baseCombatEntity)
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.Initiator = creatorEntity;
					hitInfo2.WeaponPrefab = LookupPrefab();
					hitInfo2.damageTypes.Add(damageTypes);
					baseCombatEntity.Hurt(hitInfo2);
				}
				else if (baseEntity != null)
				{
					HitInfo hitInfo3 = new HitInfo();
					hitInfo3.Initiator = creatorEntity;
					hitInfo3.WeaponPrefab = LookupPrefab();
					hitInfo3.damageTypes.Add(damageTypes);
					hitInfo3.PointStart = vector;
					hitInfo3.PointEnd = baseEntity.transform.position;
					baseEntity.OnAttacked(hitInfo3);
				}
			}
			else
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), vector, minExplosionRadius, explosionRadius, damageTypes, 1210222849, useLineOfSight: true, IgnoreAI);
			}
			SeismicSensor.Notify(vector, vibrationLevel);
			BlindAnyAI();
		}
		if (!base.IsDestroyed && !HasFlag(Flags.Broken))
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
/// <summary>
/// Called when a player attempts to loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
bool CanLootEntity(BasePlayer player, LootableCorpse entity)
{
    Puts("CanLootEntity is working!");
    return false;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!player || !player.CanInteract() || !CanLoot() || containers == null || Interface.CallHook("CanLootEntity", player, this) != null || !player.inventory.loot.StartLootingEntity(this))
		{
			return;
		}
		SetFlag(Flags.Open, b: true);
		for (int i = 0; i < containers.Length; i++)
		{
			ItemContainer itemContainer = containers[i];
			if (CanLootContainer(itemContainer, i))
			{
				player.inventory.loot.AddContainer(itemContainer);
			}
		}
		player.inventory.loot.SendImmediate();
		ClientRPC(RpcTarget.Player("RPC_ClientLootCorpse", player));
		SendNetworkUpdate();
	}

```

## OnTeamUpdate(ulong,ulong,BasePlayer)

```csharp
/// <summary>
/// Called when a player's team is updated.
/// </summary>
/// <param name="oldTeam">The player's old team ID.</param>
/// <param name="newTeam">The player's new team ID.</param>
/// <param name="player">The player whose team was updated.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnTeamUpdate(ulong oldTeam, ulong newTeam, BasePlayer player)
{
    Puts($"Player {player.UserID} team updated from {oldTeam} to {newTeam}");
    // Additional logic can be implemented here
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdateTeam(ulong newTeam)
	{
		if (Interface.CallHook("OnTeamUpdate", currentTeam, newTeam, this) == null)
		{
			currentTeam = newTeam;
			SendNetworkUpdate();
			if (RelationshipManager.ServerInstance.FindTeam(newTeam) == null)
			{
				ClearTeam();
			}
			else
			{
				TeamUpdate();
			}
		}
	}

```

## IOnPlayerConnected(BasePlayer)

```csharp
Документация для IOnPlayerConnected(BasePlayer)

/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
/// <returns>No return behavior.</returns>
void IOnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.UserIDString} connected!");
}

Метод вызывается в PlayerInit(Network.Connection c) и является частью процесса подключения игрока к серверу.
```

### Source Code from the Library

```csharp

	public void PlayerInit(Network.Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			bots.Remove(this);
			userID = c.userid;
			UserIDString = userID.ToString();
			displayName = c.username;
			c.player = this;
			secondsConnected = 0;
			currentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;
			SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(userID, displayName);
			tickInterpolator.Reset(base.transform.position);
			tickHistory.Reset(base.transform.position);
			eyeHistory.Clear();
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			InvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			GlobalNetworkHandler.server.StartSendingSnapshot(this);
			ClientRPC(RpcTarget.Player("StartLoading", this));
			if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);
			}
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			Interface.CallHook("IOnPlayerConnected", this);
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
			}
			inventory.crafting.SendToOwner();
			if (TerrainMeta.Path != null && TerrainMeta.Path.OceanPatrolFar != null)
			{
				SendCargoPatrolPath();
			}
		}
	}

```

## OnMaxStackable(Item)

```csharp
/// <summary>
/// Called when the maximum stackable quantity of an item is being determined.
/// </summary>
/// <param name="item">The item whose max stackable quantity is being calculated.</param>
/// <returns>The maximum stackable quantity, or the default value if overridden by a hook.</returns>
int OnMaxStackable(Item item)
{
    Puts("OnMaxStackable called!");
    return 0; // Default value
}
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## OnFireworkDesignChanged(PatternFirework,ProtoBuf.PatternFirework.Design,BasePlayer)

```csharp
/// <summary>
/// Called when a firework's design is changed.
/// </summary>
/// <param name="design">The new firework design.</param>
/// <param name="player">The player who made the change.</param>
/// <returns>No return behavior.</returns>
void OnFireworkDesignChanged(ProtoBuf.PatternFirework.Design design, BasePlayer player)
{
    Puts($"Firework design changed by {player.UserIDString}.");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		ProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);
		if (Interface.CallHook("OnFireworkDesignChange", this, design, rpc.player) != null)
		{
			return;
		}
		if (design?.stars != null)
		{
			while (design.stars.Count > MaxStars)
			{
				int index = design.stars.Count - 1;
				design.stars[index].Dispose();
				design.stars.RemoveAt(index);
			}
			foreach (ProtoBuf.PatternFirework.Star star in design.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			design.editedBy = rpc.player.userID;
		}
		Design?.Dispose();
		Design = design;
		Interface.CallHook("OnFireworkDesignChanged", this, design, rpc.player);
		SendNetworkUpdateImmediate();
	}

```

## OnVendingShopOpen(InvisibleVendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when a vending shop is opened by a player.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player opening the vending shop.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnVendingShopOpen(InvisibleVendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnVendingShopOpen called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", vendingMachine, player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!(conversingPlayer == player) && !(conversingPlayer == null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			List<Item> list = player.inventory.FindItemsByItemID(itemDefinition.itemid);
			foreach (Item item in list)
			{
				num -= item.amount;
			}
			if (num > 0)
			{
				int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
				ForceSpeechNode(player, speechNodeIndex2);
				break;
			}
			Facepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
			num = nPCConversationResultAction.scrapCost;
			foreach (Item item2 in list)
			{
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			lastActionPlayer = player;
			BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
			lastActionPlayer = null;
			break;
		}
	}

```

## OnDemoRecordingStarted(string,BasePlayer)

```csharp
/// <summary>
/// Called when a demo recording is started.
/// </summary>
/// <param name="text">The path to the demo file.</param>
/// <param name="player">The player who initiated the recording.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStarted(string text, BasePlayer player)
{
    Puts($"Demo recording started for {player.UserIDString} at {text}");
}
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
/// <summary>
/// Called when a medical tool is used to heal a player.
/// </summary>
/// <param name="tool">The medical tool being used.</param>
/// <param name="player">The player being healed.</param>
/// <returns>Returns the result of the healing action, or null if no specific behavior is overridden.</returns>
object OnHealingItemUse(MedicalTool tool, BasePlayer player)
{
    // Minimal code to demonstrate functionality
    Puts("OnHealingItemUse called!");
    
    // If a custom implementation returns a non-null value, it will override the default healing behavior
    return null;
}
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Facepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if (player != ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
					player.ProcessMissionEvent(BaseMission.MissionEventType.HEAL, prefabID, effect.amount);
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}

```

## OnSleepingBagDestroy(SleepingBag,ulong)

```csharp
/// <summary>
/// Called when a player's sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The destroyed sleeping bag.</param>
/// <param name="userID">The ID of the player who owned the sleeping bag.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnSleepingBagDestroy(SleepingBag sleepingBag, ulong userID)
{
    Puts("OnSleepingBagDestroy called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) => x.net.ID == sleepingBag);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, userID) != null)
		{
			return false;
		}
		RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
		sleepingBag2.deployerUserID = 0uL;
		sleepingBag2.SendNetworkUpdate();
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if (basePlayer != null)
		{
			basePlayer.SendRespawnOptions();
			Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, userID);
			Facepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
		}
		return true;
	}

```

## OnBoatPathGenerate()

```csharp
/// <summary>
/// Called when generating a boat path.
/// </summary>
/// <returns>Returns the generated path as a List of Vector3.</returns>
List<Vector3> OnBoatPathGenerate()
{
    Puts("OnBoatPathGenerate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float y = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num5 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num5 * (MathF.PI / 180f)) * num4, y, Mathf.Cos(num5 * (MathF.PI / 180f)) * num4));
		}
		float num6 = 4f;
		float num7 = 200f;
		bool flag = true;
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 vector = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 b = list[index2];
				Vector3 b2 = list[index];
				Vector3 origin = vector;
				Vector3 normalized = (Vector3.zero - vector).normalized;
				Vector3 vector2 = vector + normalized * num6;
				if (Vector3.Distance(vector2, b) > num7 || Vector3.Distance(vector2, b2) > num7)
				{
					continue;
				}
				bool flag2 = true;
				int num8 = 16;
				for (int l = 0; l < num8; l++)
				{
					float num9 = (float)l / (float)num8 * 360f;
					Vector3 normalized2 = new Vector3(Mathf.Sin(num9 * (MathF.PI / 180f)), y, Mathf.Cos(num9 * (MathF.PI / 180f))).normalized;
					Vector3 vector3 = vector2 + normalized2 * 1f;
					Vector3 direction = normalized;
					if (vector3 != Vector3.zero)
					{
						direction = (vector3 - vector2).normalized;
					}
					if (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1084293377))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = vector2;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning("Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log("Generated ocean patrol path with node count: " + list.Count);
		return list;
	}

```

## CanUseWires(BasePlayer)

```csharp
/// <summary>
/// Called when a player attempts to use wires.
/// </summary>
/// <param name="player">The player attempting to use the wires.</param>
/// <returns>Returns true if the player can use the wires, false otherwise.</returns>
bool CanUseWires(BasePlayer player)
{
    Puts("CanUseWires is working!");
    // If obj is bool, return (bool)obj;
    // Otherwise, return null
    return null;
}
```

### Source Code from the Library

```csharp

	public static bool CanPlayerUseWires(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseWires", player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player != null && player.IsInCreativeMode && Creative.unlimitedIo)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		List<Collider> obj2 = Facepunch.Pool.GetList<Collider>();
		GamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);
		bool result = true;
		foreach (Collider item in obj2)
		{
			if (!item.gameObject.CompareTag("IgnoreWireCheck"))
			{
				result = false;
				break;
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		return result;
	}

```

## OnRackedWeaponUnload(Item,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a weapon is unloaded from a rack.
/// </summary>
/// <param name="item">The item being unloaded.</param>
/// <param name="player">The player unloading the weapon.</param>
/// <param name="weaponRack">The weapon rack from which the weapon was unloaded.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponUnload(Item item, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Weapon {item.info.name} unloaded by player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", slot, player, this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity == null))
		{
			BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
			if (!(component == null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", slot, player, this);
			}
		}
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
/// <summary>
/// Called when an entity enters the trigger area.
/// </summary>
/// <param name="trigger">The trigger that detected the entity's entry.</param>
/// <param name="entity">The entity that entered the trigger area.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts("OnEntityEnter is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			if (Interface.CallHook("OnEntityEnter", this, ent) == null)
			{
				entityContents.Add(ent);
				OnEntityEnterTrigger?.Invoke(ent);
			}
		}
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
/// <summary>
/// Called when a turret is authorized to be used by a player.
/// </summary>
/// <param name="turret">The AutoTurret being authorized.</param>
/// <param name="player">The BasePlayer authorizing the turret.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts("OnTurretAuthorize called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void AddSelfAuthorize(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!IsOnline() && player2.CanBuild() && !AtMaxAuthCapacity() && Interface.CallHook("OnTurretAuthorize", this, player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)player2.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = player2.userID;
			playerNameID.username = player2.displayName;
			authorizedPlayers.Add(playerNameID);
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, player2, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", player2.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity being killed.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityKill(BaseNetworkable entity)
{
    Puts("OnEntityKill is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
		}
		else if (Interface.CallHook("OnEntityKill", this) == null)
		{
			EntityProfiler.killed++;
			if (EntityProfiler.mode >= 2)
			{
				EntityProfiler.OnKilled(this);
			}
			OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

```

## OnClothingItemChanged(PlayerInventory,Item,bool)

```csharp
/// <summary>
/// Called when a clothing item is added or removed from the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The clothing item that was added or removed.</param>
/// <param name="added">True if the item was added, false if it was removed.</param>
/// <returns>No return behavior.</returns>
void OnClothingItemChanged(PlayerInventory inventory, Item item, bool added)
{
    Puts($"Clothing item {item.name} {(added ? "added" : "removed")} from player's inventory.");
}
```

### Source Code from the Library

```csharp

	public void OnClothingChanged(Item item, bool bAdded)
	{
		base.baseEntity.SV_ClothingChanged();
		ItemManager.DoRemoves();
		ServerUpdate(0f);
		if (item.position == ItemContainer.BackpackSlotIndex)
		{
			item.RecalulateParentEntity(children: true);
			Invoke(UpdatedVisibleHolsteredItems, 0.1f);
		}
		base.baseEntity.ProcessMissionEvent(BaseMission.MissionEventType.CLOTHINGCHANGED, 0, 0f);
		Interface.CallHook("OnClothingItemChanged", this, item, bAdded);
	}

```

## CanCatchFish(BasePlayer,BaseFishingRod,Item)

```csharp
Документация для CanCatchFish(BasePlayer, BaseFishingRod, Item)

**Описание**

Функция вызывается при улове рыбы и позволяет проверить, можно ли поймать эту рыбу.

**Параметры**

* `BasePlayer`: Игрок, который пытается поймать рыбу.
* `BaseFishingRod`: Рыболовная удочка игрока.
* `Item`: Пойманная рыба.

**Возвращаемые значения**

Функция возвращает `bool`, указывающий, можно ли поймать эту рыбу. Если функция вернула `true`, то рыба поймана и добавлена в инвентарь игрока.

**Примечания**

* Функция вызывается после того, как игроку удалось поймать рыбу.
* Функция проверяет, можно ли поймать эту рыбу, исходя из различных факторов, таких как тип рыбы, уровень игрока и т.п.
* Если функция вернула `true`, то рыба добавляется в инвентарь игрока и игрок получает соответствующую награду.

**Пример использования**

```csharp
object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
if (obj is bool && !(bool)obj)
{
    // Рыба не поймана
}
else
{
    // Рыба поймана и добавлена в инвентарь игрока
}
```
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## OnPhoneNameUpdate(PhoneController,string,BasePlayer)

```csharp
/// <summary>
/// Called when a player's phone name is updated.
/// </summary>
/// <param name="controller">The phone controller.</param>
/// <param name="newName">The new phone name.</param>
/// <param name="player">The player who updated the phone name.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnPhoneNameUpdate(PhoneController controller, string newName, BasePlayer player)
{
    Puts($"Phone name updated to {newName} for player {player}");
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!(msg.player != currentPlayer))
		{
			string text = msg.read.String();
			if (text.Length > 20)
			{
				text = text.Substring(0, 20);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", this, text, msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", this, PhoneName, msg.player);
			}
		}
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
/// <summary>
/// Called when a player attempts to loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="container">The dropped item container of the entity.</param>
/// <returns>Returns null if the default behavior is allowed, or a non-null value if the default behavior is overridden.</returns>
object CanLootEntity(BasePlayer player, DroppedItemContainer container)
{
    Puts("CanLootEntity is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## OnCargoShipHarborLeave(CargoShip)

```csharp
/// <summary>
/// Called when a cargo ship leaves the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship leaving the harbor.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipHarborLeave(CargoShip cargoShip)
{
    Puts("Cargo ship has left the harbor.");
}
```

### Source Code from the Library

```csharp

	private void LeaveHarbor()
	{
		if (docking_debug)
		{
			Debug.Log("Cargo is leaving harbor.");
		}
		PlayHorn();
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: true);
		currentHarborApproachNode++;
		Interface.CallHook("OnCargoShipHarborLeave", this);
	}

```

## OnXmasStockingFill(Stocking)

```csharp
/// <summary>
/// Called when a Christmas stocking is filled with loot.
/// </summary>
/// <param name="stocking">The stocking being filled.</param>
/// <returns>No return behavior.</returns>
void OnXmasStockingFill(Stocking stocking)
{
    Puts("OnXmasStockingFill called!");
}
```

### Source Code from the Library

```csharp

	public override void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! " + base.name);
		}
		else if (IsEmpty() && Interface.CallHook("OnXmasStockingFill", this) == null)
		{
			base.SpawnLoot();
			SetFlag(Flags.On, b: true);
			Hurt(MaxHealth() * 0.1f, DamageType.Generic, null, useProtection: false);
		}
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
/// <summary>
/// Called to determine whether the network should be enabled for a given player.
/// </summary>
/// <param name="entity">The entity that is being checked.</param>
/// <param name="player">The player who is attempting to connect.</param>
/// <returns>Returns true if the network should be enabled, and false otherwise.</returns>
bool CanNetworkTo(BaseNetworkable entity, BasePlayer player)
{
    Puts("CanNetworkTo called!");
    return true; // Default behavior
}
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (net.group == null)
		{
			return true;
		}
		return player.net.subscriber.IsSubscribed(net.group);
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
/// <summary>
/// Called when the recycler is toggled on or off.
/// </summary>
/// <param name="recycler">The recycler being toggled.</param>
/// <param name="player">The player who triggered the toggle.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts("OnRecyclerToggle called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || msg.player == null || Interface.CallHook("OnRecyclerToggle", this, msg.player) != null || (!flag && onlyOneUser && msg.player.inventory.loot.entitySource != this) || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

```

## OnThreatLevelUpdate(BasePlayer)

```csharp
/// <summary>
/// Called when the threat level of a player needs to be updated.
/// </summary>
/// <param name="player">The player whose threat level is being updated.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns an object representing the updated threat level.</returns>
object OnThreatLevelUpdate(BasePlayer player)
{
    // Minimal code to demonstrate functionality
    Puts("OnThreatLevelUpdate called!");
    
    // Return value and its usage: The return value represents the updated threat level of the player.
    // It is used in the context where this hook is called, which is in the EnsureUpdated method.
    // If the default behavior is not overridden, the return value will be null.
    return null;
}
```

### Source Code from the Library

```csharp

	public void EnsureUpdated()
	{
		if (UnityEngine.Time.realtimeSinceStartup - lastUpdateTime < 30f)
		{
			return;
		}
		lastUpdateTime = UnityEngine.Time.realtimeSinceStartup;
		cachedThreatLevel = 0f;
		if (IsSleeping() || Interface.CallHook("OnThreatLevelUpdate", this) != null)
		{
			return;
		}
		if (inventory.containerWear.itemList.Count > 2)
		{
			cachedThreatLevel += 1f;
		}
		foreach (Item item in inventory.containerBelt.itemList)
		{
			BaseEntity heldEntity = item.GetHeldEntity();
			if ((bool)heldEntity && heldEntity is BaseProjectile && !(heldEntity is BowWeapon))
			{
				cachedThreatLevel += 2f;
				break;
			}
		}
	}

```

## CanBeHomingTargeted(BaseHelicopter)

```csharp
/// <summary>
/// Called to determine if the helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The helicopter being evaluated.</param>
/// <returns>Returns <c>true</c> if the helicopter can be targeted, and <c>false</c> otherwise.</returns>
bool CanBeHomingTargeted(BaseHelicopter helicopter)
{
    Puts("CanBeHomingTargeted is working!");
    return true;
}
```

### Source Code from the Library

```csharp

	public virtual bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## CanEntityBeHostile(BaseCombatEntity)

```csharp
/// <summary>
/// Called to determine if an entity can be hostile.
/// </summary>
/// <param name="entity">The entity in question.</param>
/// <returns>Returns a boolean value indicating whether the entity can be hostile.</returns>
bool CanEntityBeHostile(BaseCombatEntity entity)
{
    Puts("CanEntityBeHostile is working!");
    return true; // Replace with actual logic to determine if the entity can be hostile
}
```

### Source Code from the Library

```csharp

	public virtual bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnPlayerStudyBlueprint(BasePlayer,Item)

```csharp
/// <summary>
/// Called when a player attempts to study a blueprint.
/// </summary>
/// <param name="player">The player attempting to study the blueprint.</param>
/// <param name="item">The blueprint being studied.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnPlayerStudyBlueprint(BasePlayer player, Item item)
{
    Puts("OnPlayerStudyBlueprint called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (item.GetOwnerPlayer() != player)
		{
			bool flag = false;
			foreach (ItemContainer container in player.inventory.loot.containers)
			{
				if (item.GetRootContainer() == container)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (!(command == "study") || !item.IsBlueprint() || IsBlueprintUnlocked(item, player, out var blueprintTargetDef, out var blueprint) || Interface.CallHook("OnPlayerStudyBlueprint", player, item) != null)
		{
			return;
		}
		Item item2 = item;
		if (item.amount > 1)
		{
			item2 = item.SplitItem(1);
		}
		item2.UseItem();
		player.blueprints.Unlock(blueprintTargetDef);
		Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, "blueprint", ResearchTable.ScrapForResearch(blueprintTargetDef), player);
		if (blueprint != null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				player.blueprints.Unlock(additionalUnlock);
				Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, additionalUnlock, "blueprint", 0, player);
			}
		}
		if (studyEffect.isValid)
		{
			Effect.server.Run(studyEffect.resourcePath, player, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
	}

```

## OnSensorDetect(HBHFSensor,BasePlayer)

```csharp
/// <summary>
/// Called when a sensor detects a player.
/// </summary>
/// <param name="sensor">The sensor that detected the player.</param>
/// <param name="player">The player that was detected.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnSensorDetect(HBHFSensor sensor, BasePlayer player)
{
    Puts("OnSensorDetect called!");
    // If you want to override the default behavior, return a non-null value
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdatePassthroughAmount()
	{
		if (base.isClient)
		{
			return;
		}
		int num = detectedPlayers;
		detectedPlayers = 0;
		if (myTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in myTrigger.entityContents)
			{
				if (entityContent == null || !entityContent.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f))
				{
					continue;
				}
				BasePlayer component = entityContent.GetComponent<BasePlayer>();
				if (Interface.CallHook("OnSensorDetect", this, component) == null)
				{
					bool flag = component.CanBuild();
					if ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && component != null && component.IsAlive() && !component.IsSleeping() && component.isServer)
					{
						detectedPlayers++;
					}
				}
			}
		}
		if (num != detectedPlayers && IsPowered())
		{
			MarkDirty();
			if (detectedPlayers > num)
			{
				Effect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);
			}
			else if (detectedPlayers < num)
			{
				Effect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnOvenCook(BaseOven,Item)

```csharp
/// <summary>
/// Called when an oven is cooking an item.
/// </summary>
/// <param name="oven">The oven performing the cooking.</param>
/// <param name="item">The item being cooked.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnOvenCook(BaseOven oven, Item item)
{
    Puts("OnOvenCook is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		if (HasFlag(Flags.Reserved8))
		{
			return;
		}
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		if (item != null)
		{
			ItemModBurnable itemModBurnable = item.info.ItemModBurnable;
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, itemModBurnable);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnVendingShopOpened(InvisibleVendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine that was opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnVendingShopOpened(InvisibleVendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnVendingShopOpened is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", vendingMachine, player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!(conversingPlayer == player) && !(conversingPlayer == null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			List<Item> list = player.inventory.FindItemsByItemID(itemDefinition.itemid);
			foreach (Item item in list)
			{
				num -= item.amount;
			}
			if (num > 0)
			{
				int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
				ForceSpeechNode(player, speechNodeIndex2);
				break;
			}
			Facepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
			num = nPCConversationResultAction.scrapCost;
			foreach (Item item2 in list)
			{
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			lastActionPlayer = player;
			BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
			lastActionPlayer = null;
			break;
		}
	}

```

## OnCodeChange(ModularCar,BasePlayer,string)

```csharp
/// <summary>
/// Called when a new code is requested for the modular car.
/// </summary>
/// <param name="car">The modular car.</param>
/// <param name="player">The player requesting the new code.</param>
/// <param name="newCode">The new code to be set.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnCodeChange(ModularCar car, BasePlayer player, string newCode)
{
    Puts("OnCodeChange hook called!");
    // If you want to override the default behavior, return a non-null value
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestNewCode(RPCMessage msg)
	{
		if (!HasOccupant || !carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!(player == null))
		{
			string text = msg.read.String();
			if (Interface.CallHook("OnCodeChange", carOccupant, player, text) == null && carOccupant.CarLock.TrySetNewCode(text, player.userID))
			{
				Effect.server.Run(changeLockCodeEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnPatrolHelicopterTakeDamage(PatrolHelicopter,HitInfo)

```csharp
/// <summary>
/// Called when a patrol helicopter takes damage.
/// </summary>
/// <param name="helicopter">The patrol helicopter that took the damage.</param>
/// <param name="info">Information about the hit that caused the damage.</param>
/// <returns>No return behavior.</returns>
void OnPatrolHelicopterTakeDamage(PatrolHelicopter helicopter, HitInfo info)
{
    Puts($"Patrol helicopter {helicopter} took damage from {info}");
}
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnPatrolHelicopterTakeDamage", this, info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			if (Interface.CallHook("OnPatrolHelicopterKill", this, info) != null)
			{
				return;
			}
			base.health = 10000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		myAI.OtherDamaged(info);
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
/// <summary>
/// Called to determine if the helicopter can strafe.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <returns>Returns true if the helicopter can strafe, and false otherwise.</returns>
bool CanHelicopterStrafe(PatrolHelicopterAI ai)
{
    Puts("CanHelicopterStrafe is working!");
    // Return true or false based on the implementation
    return true;
}
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= UnityEngine.Random.Range(15f, 25f))
		{
			return CanInterruptState();
		}
		return false;
	}

```

## OnWindmillUpdate(ElectricWindmill)

```csharp
/// <summary>
/// Called when the windmill's state is updated.
/// </summary>
/// <param name="windmill">The ElectricWindmill instance being updated.</param>
/// <returns>No return behavior.</returns>
void OnWindmillUpdate(ElectricWindmill windmill)
{
    Puts("OnWindmillUpdate is working!");
}
```

### Source Code from the Library

```csharp

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", this);
		}
	}

```

## OnHelicopterDropCrate(CH47HelicopterAIController)

```csharp
/// <summary>
/// Called when a helicopter drops a crate.
/// </summary>
/// <param name="helicopter">The helicopter that dropped the crate.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts("OnHelicopterDropCrate is working!");
}
```

### Source Code from the Library

```csharp

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

```

## OnItemResearch(ResearchTable,Item,BasePlayer)

```csharp
/// <summary>
/// Called when a player researches an item.
/// </summary>
/// <param name="researchTable">The research table being used.</param>
/// <param name="item">The item being researched.</param>
/// <param name="player">The player performing the research.</param>
/// <returns>No return behavior.</returns>
void OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player)
{
    Puts($"Item {item.info.shortname} researched by player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Facepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnCargoShipEgress(CargoShip)

```csharp
/// <summary>
/// Called when a cargo ship begins to exit the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship exiting the harbor.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnCargoShipEgress(CargoShip cargoShip)
{
    Puts("OnCargoShipEgress hook called!");
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp

	public void StartEgress()
	{
		if (!isDoingHarborApproach && !egressing)
		{
			egressing = true;
			if (Interface.CallHook("OnCargoShipEgress", this) == null)
			{
				CancelInvoke(PlayHorn);
				radiation.SetActive(value: true);
				SetFlag(Flags.Reserved8, b: true);
				InvokeRepeating(UpdateRadiation, 10f, 1f);
				Invoke(DelayedDestroy, 60f * egress_duration_minutes);
			}
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
/// <summary>
/// Called to determine if a player can be targeted by the gun trap.
/// </summary>
/// <param name="player">The player being checked.</param>
/// <param name="gunTrap">The gun trap performing the check.</param>
/// <returns>Returns true if the player can be targeted, false otherwise.</returns>
bool CanBeTargeted(BasePlayer player, GunTrap gunTrap)
{
    // Minimal code to demonstrate functionality
    return true; // Replace with actual logic to determine if the player can be targeted
}
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		if (entityContents == null || entityContents.Count == 0)
		{
			return false;
		}
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		BuildingPrivlidge cachedTc = GetCachedTc();
		bool flag = false;
		foreach (BaseEntity item in entityContents)
		{
			BasePlayer component = item.GetComponent<BasePlayer>();
			if (component.IsSleeping() || !component.IsAlive())
			{
				continue;
			}
			object obj2 = Interface.CallHook("CanBeTargeted", component, this);
			if (obj2 is bool)
			{
				Pool.FreeList(ref obj);
				return (bool)obj2;
			}
			if (!(cachedTc == null) && cachedTc.IsAuthed(component))
			{
				continue;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
			for (int i = 0; i < obj.Count; i++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeList(ref obj);
		return flag;
	}

```

## CanSamSiteShoot(SamSite)

```csharp
/// <summary>
/// Called to determine if the player can shoot at a SAM site.
/// </summary>
/// <param name="samSite">The SAM site being targeted.</param>
/// <returns>Returns true if the player can shoot, and false otherwise.</returns>
bool CanSamSiteShoot(SamSite samSite)
{
    Puts("CanSamSiteShoot is working!");
    // Minimal code to demonstrate functionality
    return true;
}
```

### Source Code from the Library

```csharp

	public void WeaponTick()
	{
		if (IsDead() || UnityEngine.Time.time < lockOnTime || UnityEngine.Time.time < nextBurstTime)
		{
			return;
		}
		if (!IsPowered())
		{
			firedCount = 0;
			return;
		}
		if (firedCount >= 6)
		{
			float timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;
			nextBurstTime = UnityEngine.Time.time + timeBetweenBursts;
			firedCount = 0;
			return;
		}
		EnsureReloaded();
		if (Interface.CallHook("CanSamSiteShoot", this) == null && HasAmmo())
		{
			bool num = ammoItem != null && ammoItem.amount == lowAmmoThreshold;
			if (!staticRespawn && ammoItem != null)
			{
				ammoItem.UseItem();
			}
			firedCount++;
			float speedMultiplier = 1f;
			if (!ObjectEx.IsUnityNull(currentTarget))
			{
				speedMultiplier = currentTarget.SAMTargetType.speedMultiplier;
			}
			FireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);
			Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
			currentTubeIndex++;
			if (currentTubeIndex >= tubes.Length)
			{
				currentTubeIndex = 0;
			}
			if (num)
			{
				MarkIODirty();
			}
		}
	}

```

## OnDispenserGathered(ResourceDispenser,BasePlayer,Item)

```csharp
/// <summary>
/// Called when a resource is gathered from a dispenser.
/// </summary>
/// <param name="dispenser">The dispenser that gathered the resource.</param>
/// <param name="player">The player who gathered the resource.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnDispenserGathered(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts("OnDispenserGathered called!");
    return null;
}
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		f = Mathf.Round(f);
		float num3 = f * destroyFraction * 2f;
		if (itemAmt.amount <= f + num3)
		{
			float num4 = (f + num3) / itemAmt.amount;
			f /= num4;
			num3 /= num4;
		}
		itemAmt.amount -= Mathf.Floor(f);
		itemAmt.amount -= Mathf.Floor(num3);
		if (f < 1f)
		{
			f = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (f >= 1f)
		{
			int num5 = CalculateGatherBonus(entity, itemAmt, f);
			int iAmount = Mathf.FloorToInt(f) + num5;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (Interface.CallHook("OnDispenserGather", this, entity, item) == null && item != null)
			{
				OverrideOwnership(item, attackWeapon);
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
				Interface.CallHook("OnDispenserGathered", this, entity, item);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
/// <summary>
/// Called to determine if a player can bypass the queue.
/// </summary>
/// <param name="connection">The player's connection.</param>
/// <returns>Returns <c>true</c> if the player can bypass the queue, and <c>false</c> otherwise.</returns>
object CanBypassQueue(Network.Connection connection)
{
    Puts("CanBypassQueue is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.SkipQueue)
		{
			return true;
		}
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			if (reservedSlots[i].UserId == connection.userid && reservedSlots[i].Expiry > UnityEngine.Time.realtimeSinceStartup)
			{
				return true;
			}
		}
		return false;
	}

```

## OnNpcConversationRespond(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
/// <summary>
/// Called when a player responds to an NPC's conversation.
/// </summary>
/// <param name="npc">The NPC initiating the conversation.</param>
/// <param name="player">The player responding to the conversation.</param>
/// <param name="conversationData">The data for the ongoing conversation.</param>
/// <param name="responseNode">The node representing the player's response.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnNpcConversationRespond(NPCTalking npc, BasePlayer player, ConversationData conversationData, ConversationData.ResponseNode responseNode)
{
    // Minimal code to demonstrate functionality
    Puts("OnNpcConversationRespond called!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode == null || Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) != null)
		{
			return;
		}
		if (responseNode.conditions.Length != 0)
		{
			UpdateFlags();
		}
		bool flag = responseNode.PassesConditions(player, this);
		if (flag)
		{
			string actionString = responseNode.GetActionString();
			if (!string.IsNullOrEmpty(actionString))
			{
				OnConversationAction(player, actionString);
			}
		}
		int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
		if (speechNodeIndex == -1)
		{
			ForceEndConversation(player);
			return;
		}
		ForceSpeechNode(player, speechNodeIndex);
		Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
	}

```

## OnCrateLaptopAttack(HackableLockedCrate,HitInfo)

```csharp
/// <summary>
/// Called when a hackable locked crate is attacked with a laptop.
/// </summary>
/// <param name="crate">The hackable locked crate being attacked.</param>
/// <param name="info">Information about the attack.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnCrateLaptopAttack(HackableLockedCrate crate, HitInfo info)
{
    Puts("OnCrateLaptopAttack is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (base.isServer)
		{
			if (StringPool.Get(info.HitBone) == "laptopcollision")
			{
				if (Interface.CallHook("OnCrateLaptopAttack", this, info) != null)
				{
					return;
				}
				Effect.server.Run(shockEffect.resourcePath, info.HitPositionWorld, Vector3.up);
				hackSeconds -= 8f * (info.damageTypes.Total() / 50f);
				if (hackSeconds < 0f)
				{
					hackSeconds = 0f;
				}
			}
			RefreshDecay();
		}
		base.OnAttacked(info);
	}

```

## OnFindSpawnPoint(BasePlayer)

```csharp
/// <summary>
/// Called when a player's spawn point is being determined.
/// </summary>
/// <param name="player">The player whose spawn point is being determined.</param>
/// <returns>Returns the player's spawn point, or null if not found.</returns>
BasePlayer.SpawnPoint OnFindSpawnPoint(BasePlayer player)
{
    Puts("OnFindSpawnPoint called!");
    
    // If a custom spawn point was provided by the game mode, return it
    BaseGameMode baseGameMode = Gamemode();
    if ((bool)baseGameMode && baseGameMode.useCustomSpawns)
    {
        return baseGameMode.GetPlayerSpawn(player);
    }
    
    // Check for a spawn point in the tutorial island
    TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
    if (currentTutorialIsland != null)
    {
        BasePlayer.SpawnPoint spawnPoint;
        if (player.CurrentTutorialAllowance > BasePlayer.TutorialItemAllowance.Level1_HatchetPickaxe)
        {
            spawnPoint.pos = currentTutorialIsland.MidMissionSpawnPoint.position;
            spawnPoint.rot = currentTutorialIsland.MidMissionSpawnPoint.rotation;
        }
        else
        {
            spawnPoint.pos = currentTutorialIsland.InitialSpawnPoint.position;
            spawnPoint.rot = currentTutorialIsland.InitialSpawnPoint.rotation;
        }
        return spawnPoint;
    }
    
    // Check for a spawn point provided by the SpawnHandler component
    BasePlayer.SpawnPoint spawnPoint2 = SpawnHandler.GetSpawnPoint();
    if (spawnPoint2 != null)
    {
        return spawnPoint2;
    }
    
    // If all else fails, find a random spawn point in the game world
    GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
    if (array.Length != 0)
    {
        GameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];
        BasePlayer.SpawnPoint spawnPoint3;
        spawnPoint3.pos = gameObject.transform.position;
        spawnPoint3.rot = gameObject.transform.rotation;
        return spawnPoint3;
    }
    
    // If no spawn point is found, spawn at the camera's position
    if (MainCamera.mainCamera != null)
    {
        BasePlayer.SpawnPoint spawnPoint4;
        spawnPoint4.pos = MainCamera.position;
        spawnPoint4.rot = MainCamera.rotation;
        return spawnPoint4;
    }
    
    // If all else fails, log an error and spawn at the camera's position
    UnityEngine.Debug.Log("Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
    if (MainCamera.mainCamera != null)
    {
        BasePlayer.SpawnPoint spawnPoint5;
        spawnPoint5.pos = MainCamera.position;
        spawnPoint5.rot = MainCamera.rotation;
        return spawnPoint5;
    }
    
    // If all else fails, spawn at the ground level
    BasePlayer.SpawnPoint spawnPoint6;
    if (UnityEngine.Physics.Raycast(new Ray(spawnPoint6.pos, Vector3.down), out var hitInfo, 32f, 1537286401))
    {
        spawnPoint6.pos = hitInfo.point;
    }
    return spawnPoint6;
}
```

### Source Code from the Library

```csharp

	public static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null)
	{
		object obj = Interface.CallHook("OnFindSpawnPoint", forPlayer);
		if (obj is BasePlayer.SpawnPoint)
		{
			return (BasePlayer.SpawnPoint)obj;
		}
		bool flag = false;
		if (forPlayer != null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null)
			{
				BasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();
				if (forPlayer.CurrentTutorialAllowance > BasePlayer.TutorialItemAllowance.Level1_HatchetPickaxe)
				{
					spawnPoint.pos = currentTutorialIsland.MidMissionSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.MidMissionSpawnPoint.rotation;
				}
				else
				{
					spawnPoint.pos = currentTutorialIsland.InitialSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.InitialSpawnPoint.rotation;
				}
				return spawnPoint;
			}
		}
		BaseGameMode baseGameMode = Gamemode();
		if ((bool)baseGameMode && baseGameMode.useCustomSpawns)
		{
			BasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);
			if (playerSpawn != null)
			{
				return playerSpawn;
			}
		}
		if (SingletonComponent<SpawnHandler>.Instance != null && !flag)
		{
			BasePlayer.SpawnPoint spawnPoint2 = SpawnHandler.GetSpawnPoint();
			if (spawnPoint2 != null)
			{
				return spawnPoint2;
			}
		}
		BasePlayer.SpawnPoint spawnPoint3 = new BasePlayer.SpawnPoint();
		if (forPlayer != null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland2 = forPlayer.GetCurrentTutorialIsland();
			if (currentTutorialIsland2 != null)
			{
				spawnPoint3.pos = currentTutorialIsland2.InitialSpawnPoint.position;
				spawnPoint3.rot = currentTutorialIsland2.InitialSpawnPoint.rotation;
				return spawnPoint3;
			}
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (array.Length != 0)
		{
			GameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];
			spawnPoint3.pos = gameObject.transform.position;
			spawnPoint3.rot = gameObject.transform.rotation;
		}
		else
		{
			UnityEngine.Debug.Log("Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
			if (MainCamera.mainCamera != null)
			{
				spawnPoint3.pos = MainCamera.position;
				spawnPoint3.rot = MainCamera.rotation;
			}
		}
		if (UnityEngine.Physics.Raycast(new Ray(spawnPoint3.pos, Vector3.down), out var hitInfo, 32f, 1537286401))
		{
			spawnPoint3.pos = hitInfo.point;
		}
		return spawnPoint3;
	}

```

## OnEventTrigger(TriggeredEventPrefab)

```csharp
/// <summary>
/// Called when an event trigger is activated.
/// </summary>
/// <param name="eventPrefab">The triggered event prefab.</param>
/// <returns>No return behavior.</returns>
void OnEventTrigger(TriggeredEventPrefab eventPrefab)
{
    Puts("OnEventTrigger called!");
}
```

### Source Code from the Library

```csharp

	public override void RunEvent()
	{
		if (Interface.CallHook("OnEventTrigger", this) != null)
		{
			return;
		}
		Debug.Log("[event] " + targetPrefab.resourcePath);
		BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
		if (!baseEntity)
		{
			return;
		}
		baseEntity.SendMessage("TriggeredEventSpawn", SendMessageOptions.DontRequireReceiver);
		baseEntity.Spawn();
		spawnedEntity = baseEntity;
		if (!shouldBroadcastSpawn)
		{
			return;
		}
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if ((bool)activePlayer && activePlayer.IsConnected && !activePlayer.IsInTutorial)
			{
				activePlayer.ShowToast(GameTip.Styles.Server_Event, spawnPhrase);
			}
		}
	}

```

## OnFuelConsume(BaseOven,Item,ItemModBurnable)

```csharp
/// <summary>
/// Called when a fuel item is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuelItem">The fuel item being consumed.</param>
/// <param name="burnableItem">The burnable item being processed.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnFuelConsume(BaseOven oven, Item fuelItem, ItemModBurnable burnableItem)
{
    Puts("OnFuelConsume hook called!");
    
    // If the fuel item's amount is less than or equal to the fuel rate, remove the fuel item
    if (fuelItem.amount <= GetFuelRate())
    {
        fuelItem.Remove();
        return null;
    }
    
    // Use the fuel item at the current fuel rate
    fuelItem.UseItem(GetFuelRate());
    
    // Add a pending item analytics event for the consumed fuel
    Facepunch.Rust.Analytics.Azure.AddPendingItems(oven, fuelItem.info.shortname, GetFuelRate(), "smelt");
    
    // Update the fuel item's properties with the burnable item's fuel amount and mark it dirty
    fuelItem.fuel = burnableItem.fuelAmount;
    fuelItem.MarkDirty();
    
    return null;
}
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Facepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## CanPickupEntity(BasePlayer,BaseCombatEntity)

```csharp
/// <summary>
/// Called when a player attempts to pick up an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
{
    Puts("CanPickupEntity is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (pickup.enabled && (!pickup.requireBuildingPrivilege || player.CanBuild()) && (!pickup.requireHammer || player.IsHoldingEntity<Hammer>()))
		{
			if (player != null)
			{
				return !player.IsInTutorial;
			}
			return false;
		}
		return false;
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
/// <summary>
/// Called when a player attempts to buy an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <param name="player">The player attempting to make the purchase.</param>
/// <param name="itemIndex">The index of the item being purchased.</param>
/// <param name="quantity">The quantity of the item being purchased.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer player, int itemIndex, int quantity)
{
    Puts("OnBuyVendingItem hook called!");
    // Add custom logic here to override the default behavior
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void BuyItem(RPCMessage rpc)
	{
		if (OccupiedCheck(rpc.player))
		{
			int num = rpc.read.Int32();
			int num2 = rpc.read.Int32();
			if (IsVending())
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage);
			}
			else if (Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2) == null)
			{
				SetPendingOrder(rpc.player, num, num2);
				Invoke(CompletePendingOrder, GetBuyDuration());
			}
		}
	}

```

## OnTurretAssign(AutoTurret,ulong,BasePlayer)

```csharp
/// <summary>
/// Called when a turret is assigned to a player.
/// </summary>
/// <param name="turret">The turret being assigned.</param>
/// <param name="playerId">The ID of the player being assigned the turret.</param>
/// <param name="player">The player being assigned the turret.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnTurretAssign(AutoTurret turret, ulong playerId, BasePlayer player)
{
    Puts("OnTurretAssign called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AssignToFriend(RPCMessage msg)
	{
		if (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", this, num, msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = num;
			playerNameID.username = username;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(playerNameID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", this, num, msg.player);
		}
	}

```

## CanCastFishingRod(BasePlayer,BaseFishingRod,Item,UnityEngine.Vector3)

```csharp
/// <summary>
/// Called when a player attempts to cast their fishing rod.
/// </summary>
/// <param name="owner">The player casting the rod.</param>
/// <param name="rod">The fishing rod being used.</param>
/// <param name="lure">The lure attached to the rod.</param>
/// <param name="position">The position where the rod is being cast.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise returns null.</returns>
object CanCastFishingRod(BasePlayer owner, BaseFishingRod rod, Item lure, UnityEngine.Vector3 position)
{
    // Minimal code to demonstrate functionality
    Puts("CanCastFishingRod called!");
    
    // Return a non-null value if the default behavior is overridden
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_RequestCast(RPCMessage msg)
	{
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		ItemModCompostable component = (ItemModCompostable)Interface.CallHook("CanCastFishingRod", ownerPlayer, this, currentLure, pos);
		if (!(component is bool) || (bool)(object)component)
		{
			FishingBobber component2 = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();
			component2.transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component2.Spawn();
			component2.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);
			int usedLureAmount = 0;
			if (FishLookup.Instance != null)
			{
				currentFishTarget = FishLookup.Instance.GetFish(component2.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);
			}
			lureUsed = currentLure.info;
			currentLure.UseItem(usedLureAmount);
			lastFish = fishableModifier;
			currentBobber.Set(component2);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReceiveCastPoint"), component2.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));
			catchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;
			float val = (lureUsed.TryGetComponent<ItemModCompostable>(out component) ? component.BaitValue : 0f);
			val = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);
			catchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);
			playerStartPosition = ownerPlayer.transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			InvokeRepeating(CatchProcess, 0f, 0f);
			inQueue = false;
			Interface.CallHook("OnFishingRodCast", this, ownerPlayer, currentLure);
		}
	}

```

## OnFindBurnable(BaseOven)

```csharp
/// <summary>
/// Called when a burnable item is being searched for.
/// </summary>
/// <param name="oven">The oven searching for the burnable item.</param>
/// <returns>Returns the found burnable item, or null if not found.</returns>
object OnFindBurnable(BaseOven oven)
{
    Puts("OnFindBurnable called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (base.inventory == null)
		{
			return null;
		}
		foreach (Item item in base.inventory.itemList)
		{
			if (IsBurnableItem(item))
			{
				return item;
			}
		}
		return null;
	}

```

## OnVehicleModuleDeselected(ModularCarGarage,BasePlayer)

```csharp
/// <summary>
/// Called when a vehicle module is deselected in the modular car garage.
/// </summary>
/// <param name="garage">The modular car garage instance.</param>
/// <param name="player">The player who deselected the vehicle module.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModuleDeselected(ModularCarGarage garage, BasePlayer player)
{
    Puts("OnVehicleModuleDeselected is working!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DeselectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.inventory.loot.IsLooting() && !(player.inventory.loot.entitySource != this))
		{
			if (player.inventory.loot.RemoveContainerAt(3))
			{
				player.inventory.loot.SendImmediate();
			}
			Interface.CallHook("OnVehicleModuleDeselected", this, player);
		}
	}

```

## OnMapMarkersCleared(BasePlayer)

```csharp
/// <summary>
/// Called when all map markers are cleared.
/// </summary>
/// <param name="player">The player who initiated the clearing.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkersCleared(BasePlayer player)
{
    Puts("All map markers have been cleared!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.FromOwner]
	[RPC_Server]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, State.pointsOfInterest) != null)
		{
			return;
		}
		ServerCurrentDeathNote?.Dispose();
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				item?.Dispose();
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", this);
	}

```

## OnTurretClearList(AutoTurret,BasePlayer)

```csharp
/// <summary>
/// Called when the list of authorized players is cleared.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <param name="player">The BasePlayer instance whose authorization was cleared.</param>
/// <returns>No return behavior.</returns>
void OnTurretClearList(AutoTurret turret, BasePlayer player)
{
    Puts($"Authorized players list cleared for {player.UserIDString} by {turret.EntityID}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			authDirty = true;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "clear", rpc.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnTeamCreated(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
/// <summary>
/// Called when a team is created.
/// </summary>
/// <param name="player">The player who created the team.</param>
/// <param name="team">The newly created team.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnTeamCreated(BasePlayer player, PlayerTeam team)
{
    Puts("OnTeamCreated hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Facepunch.Rust.Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
/// <summary>
/// Called when an item is being crafted.
/// </summary>
/// <param name="task">The crafting task.</param>
/// <param name="owner">The player who initiated the craft.</param>
/// <param name="item">The item being crafted (if it's a temporary blueprint).</param>
/// <returns>Returns true if the default behavior is allowed, and false otherwise.</returns>
object OnItemCraft(ItemCraftTask task, BasePlayer owner, Item item)
{
    // Minimal code to demonstrate functionality
    Puts("OnItemCraft hook called!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)
	{
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		if (!CanCraft(bp, amount, free))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		if (!free)
		{
			CollectIngredients(bp, itemCraftTask, amount, owner);
		}
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			if (fromTempBlueprint != null && itemCraftTask.instanceData != null)
			{
				fromTempBlueprint.instanceData = itemCraftTask.instanceData;
			}
			return (bool)obj;
		}
		queue.AddLast(itemCraftTask);
		if (owner != null)
		{
			owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## OnTerrainInitialized()

```csharp
/// <summary>
/// Called when the terrain is initialized.
/// </summary>
void OnTerrainInitialized()
{
    Puts("Terrain initialized!");
}
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

```

## CanPurchaseItem(BasePlayer,Item,System.Action<BasePlayer, Item>,VendingMachine,ItemContainer)

```csharp
Документация для CanPurchaseItem(BasePlayer, Item, System.Action<BasePlayer, Item>, VendingMachine, ItemContainer)

**Описание**

Хук `CanPurchaseItem` вызывается в методе `DoTransaction` при попытке совершить покупку предмета у автомата.

**Параметры**

* `BasePlayer buyer`: Игрок, который совершает покупку.
* `Item item`: Предмет, который необходимо купить.
* `System.Action<BasePlayer, Item> onItemPurchased`: Делегат, который вызывается после успешной покупки предмета.
* `VendingMachine vendingMachine`: Автомат, у которого происходит покупка.
* `ItemContainer targetContainer`: Контейнер, в который необходимо положить купленный предмет.

**Возвращаемое значение**

Хук возвращает `bool` значение, указывающее, может ли игрок совершить покупку предмета. Если значение равно `true`, то покупка возможна, иначе - нет.

**Примечания**

* Хук вызывается после того, как был проверен баланс игрока и доступность предмета у автомата.
* Если хук возвращает `false`, то покупка не будет совершена, и метод `DoTransaction` вернет `false`.
* Если хук возвращает `true`, то покупка будет совершена, и метод `DoTransaction` продолжит работу.
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions, targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> obj2 = Facepunch.Pool.GetList<Item>();
		GetItemsToSell(sellOrder, obj2);
		if (obj2 == null || obj2.Count == 0)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = obj2.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		List<Item> source = buyer.inventory.FindItemsByItemID(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = (from x in source
			where !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)
			where x.GetItemVolume() <= maxCurrencyVolume
			select x).ToList();
		if (source.Count == 0)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;
		if (num3 < num4)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			TakeCurrencyItem(item);
			onCurrencyRemoved?.Invoke(buyer, item);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		Facepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, num4, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);
		int num7 = 0;
		foreach (Item item4 in obj2)
		{
			int num8 = num - num7;
			Item item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);
			if (item2 == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item2.amount;
				object obj3 = Interface.CallHook("CanPurchaseItem", buyer, item2, onItemPurchased, this, targetContainer);
				if (obj3 != null)
				{
					if (!(obj3 is bool))
					{
						return false;
					}
					return (bool)obj3;
				}
				RecordSaleAnalytics(item2, sellOrderId);
				if (targetContainer == null)
				{
					GiveSoldItem(item2, buyer);
				}
				else if (!item2.MoveToContainer(targetContainer))
				{
					item2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
				}
				onItemPurchased?.Invoke(buyer, item2);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## CanDismountEntity(BasePlayer,BaseMountable)

```csharp
/// <summary>
/// Called when a player attempts to dismount an entity.
/// </summary>
/// <param name="player">The player attempting to dismount the entity.</param>
/// <param name="entity">The entity being dismounted.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
bool CanDismountEntity(BasePlayer player, BaseMountable entity)
{
    Puts("CanDismountEntity is working!");
    return false;
}
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.transform.rotation = Quaternion.identity;
			_mounted.ClientRPC(RpcTarget.Player("ForcePositionTo", _mounted), res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			string[] obj = new string[6] { "Killing player due to invalid dismount point :", player.displayName, " / ", null, null, null };
			BasePlayer.EncryptedValue<ulong> userID = player.userID;
			obj[3] = userID.ToString();
			obj[4] = " on obj : ";
			obj[5] = base.gameObject.name;
			Debug.LogWarning(string.Concat(obj));
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
		}
		else
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.SendModelState(force: true);
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), res);
			}
			Facepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnSprinklerSplashed(Sprinkler)

```csharp
/// <summary>
/// Called when a sprinkler splashes.
/// </summary>
/// <param name="sprinkler">The sprinkler that splashed.</param>
/// <returns>No return behavior.</returns>
void OnSprinklerSplashed(Sprinkler sprinkler)
{
    Puts("OnSprinklerSplashed is working!");
}
```

### Source Code from the Library

```csharp

	private void DoSplash()
	{
		using (TimeWarning.New("SprinklerSplash"))
		{
			int num = WaterPerSplash;
			if ((float)updateSplashableCache > SplashFrequency * 4f || forceUpdateSplashables)
			{
				cachedSplashables.Clear();
				forceUpdateSplashables = false;
				updateSplashableCache = 0f;
				Vector3 position = Eyes.position;
				Vector3 up = base.transform.up;
				float sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;
				float value = Vector3.Angle(up, Vector3.up) / 180f;
				value = Mathf.Clamp(value, 0.2f, 1f);
				sprinklerEyeHeightOffset *= value;
				Vector3 startPosition = position + up * (Server.sprinklerRadius * 0.5f);
				Vector3 endPosition = position + up * sprinklerEyeHeightOffset;
				List<BaseEntity> obj = Facepunch.Pool.GetList<BaseEntity>();
				Vis.Entities(startPosition, endPosition, Server.sprinklerRadius, obj, 1237003025);
				if (obj.Count > 0)
				{
					foreach (BaseEntity item in obj)
					{
						if (!item.isClient && item is ISplashable splashable && !cachedSplashables.Contains(splashable) && splashable.WantsSplash(currentFuelType, num) && item.IsVisible(position) && (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)))
						{
							cachedSplashables.Add(splashable);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
			}
			if (cachedSplashables.Count > 0)
			{
				int num2 = num / cachedSplashables.Count;
				float num3 = (float)(num % cachedSplashables.Count) / (float)cachedSplashables.Count;
				foreach (ISplashable cachedSplashable in cachedSplashables)
				{
					int amount = num2 + ((UnityEngine.Random.value < num3) ? 1 : 0);
					if (!ObjectEx.IsUnityNull(cachedSplashable) && cachedSplashable.WantsSplash(currentFuelType, amount))
					{
						int num4 = cachedSplashable.DoSplash(currentFuelType, amount);
						num -= num4;
						if (num <= 0)
						{
							break;
						}
					}
				}
			}
			if (DecayPerSplash > 0f)
			{
				Hurt(DecayPerSplash);
			}
		}
		Interface.CallHook("OnSprinklerSplashed", this);
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The Bradley APC instance.</param>
/// <returns>No return behavior.</returns>
void OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts("OnBradleyApcInitialize called!");
}
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## CanDeployItem(BasePlayer,Deployer,NetworkableId)

```csharp
/// <summary>
/// Called when a player attempts to deploy an item.
/// </summary>
/// <param name="player">The player attempting to deploy the item.</param>
/// <param name="deployer">The deployer object.</param>
/// <param name="networkableId">The ID of the networkable entity being deployed.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise null.</returns>
object CanDeployItem(BasePlayer player, Deployer deployer, NetworkableId networkableId)
{
    Puts("CanDeployItem hook called!");
    // Return a non-null value to override the default behavior
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void DoDeploy(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Deployable deployable = GetDeployable();
		if (deployable == null)
		{
			return;
		}
		Ray ray = msg.read.Ray();
		NetworkableId networkableId = msg.read.EntityID();
		if (Interface.CallHook("CanDeployItem", msg.player, this, networkableId) == null)
		{
			if (deployable.toSlot)
			{
				DoDeploy_Slot(deployable, ray, networkableId);
			}
			else
			{
				DoDeploy_Regular(deployable, ray);
			}
		}
	}

```

## OnMapMarkerAdd(BasePlayer,ProtoBuf.MapNote)

```csharp
/// <summary>
/// Called when a new map marker is added.
/// </summary>
/// <param name="player">The player who added the marker.</param>
/// <param name="mapNote">The details of the newly added marker.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkerAdd(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"New map marker added by {player.UserIDString} at position: {mapNote.position}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 13L;
			if (State.pointsOfInterest == null)
			{
				State.pointsOfInterest = Facepunch.Pool.GetList<MapNote>();
			}
			if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
			{
				msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, ConVar.Server.maximumMapMarkers.ToString());
				return;
			}
			MapNote mapNote = MapNote.Deserialize(msg.read);
			ValidateMapNote(mapNote);
			mapNote.colourIndex = FindUnusedPointOfInterestColour();
			State.pointsOfInterest.Add(mapNote);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, mapNote);
		}
	}

```

## CanMountEntity(BasePlayer,BaseMountable)

```csharp
/// <summary>
/// Called when a player attempts to mount an entity.
/// </summary>
/// <param name="player">The player attempting to mount the entity.</param>
/// <param name="entity">The entity being mounted.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object CanMountEntity(BasePlayer player, BaseMountable entity)
{
    Puts("CanMountEntity is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform transform = mountAnchor;
			player.MountObject(this);
			player.MovePosition(transform.position);
			player.transform.rotation = transform.rotation;
			player.ServerRotation = transform.rotation;
			player.OverrideViewAngles(transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(transform.rotation);
			player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), player.transform.position);
			Facepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
			if (this.IsValid() && player.IsValid())
			{
				player.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);
			}
		}
	}

```

## OnWaterCollect(WaterPump,ItemDefinition)

```csharp
/// <summary>
/// Called when water is collected from a pump.
/// </summary>
/// <param name="pump">The water pump collecting the water.</param>
/// <param name="itemDefinition">The item definition of the collected water.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnWaterCollect(WaterPump pump, ItemDefinition itemDefinition)
{
    Puts("OnWaterCollect is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void CreateWater()
	{
		if (!IsFull())
		{
			ItemDefinition atPoint = WaterResource.GetAtPoint(WaterResourceLocation.position);
			if (atPoint != null && Interface.CallHook("OnWaterCollect", this, atPoint) == null)
			{
				base.inventory.AddItem(atPoint, AmountPerPump, 0uL);
				UpdateOnFlag();
			}
		}
	}

```

## OnEngineStarted(MotorRowboat,BasePlayer)

```csharp
/// <summary>
/// Called when the engine of a motorized rowboat is started.
/// </summary>
/// <param name="rowboat">The motorized rowboat.</param>
/// <param name="driver">The driver of the rowboat.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEngineStarted(MotorRowboat rowboat, BasePlayer driver)
{
    Puts("OnEngineStarted hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.On, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
			if (wantsOn)
			{
				rigidBody.WakeUp();
				buoyancy.Wake();
			}
		}
	}

```

## CanWaterBallSplash(ItemDefinition,UnityEngine.Vector3,float,int)

```csharp
/// <summary>
/// Called when a water ball splash is attempted.
/// </summary>
/// <param name="liquidDef">The definition of the liquid being splashed.</param>
/// <param name="position">The position where the splash is occurring.</param>
/// <param name="radius">The radius of the splash.</param>
/// <param name="amount">The amount of liquid to be splashed.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool CanWaterBallSplash(ItemDefinition liquidDef, Vector3 position, float radius, int amount)
{
    // Minimal code to demonstrate functionality
    Puts("CanWaterBallSplash called!");
    
    // If the return value (obj) is used as a boolean in the calling context, return true if overridden, false otherwise
    return true;
}
```

### Source Code from the Library

```csharp

	public static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)
	{
		object obj = Interface.CallHook("CanWaterBallSplash", liquidDef, position, radius, amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		List<BaseEntity> obj2 = Pool.GetList<BaseEntity>();
		Vis.Entities(position, radius, obj2, 1220225811);
		int num = 0;
		int num2 = amount;
		while (amount > 0 && num < 3)
		{
			List<ISplashable> obj3 = Pool.GetList<ISplashable>();
			foreach (BaseEntity item in obj2)
			{
				if (!item.isClient && item is ISplashable splashable && !obj3.Contains(splashable) && splashable.WantsSplash(liquidDef, amount))
				{
					bool flag = true;
					if (item is PlanterBox && !GamePhysics.LineOfSight(item.transform.position + new Vector3(0f, 1f, 0f), position, 2097152))
					{
						flag = false;
					}
					if (flag)
					{
						obj3.Add(splashable);
					}
				}
			}
			if (obj3.Count == 0)
			{
				break;
			}
			int b = Mathf.CeilToInt(amount / obj3.Count);
			foreach (ISplashable item2 in obj3)
			{
				int num3 = item2.DoSplash(liquidDef, Mathf.Min(amount, b));
				amount -= num3;
				if (amount <= 0)
				{
					break;
				}
			}
			Pool.FreeList(ref obj3);
			num++;
		}
		Pool.FreeList(ref obj2);
		return amount < num2;
	}

```

## OnNpcGiveSoldItem(NPCVendingMachine,Item,BasePlayer)

```csharp
/// <summary>
/// Called when an NPC vending machine gives a sold item to a player.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that gave the item.</param>
/// <param name="item">The item that was given to the player.</param>
/// <param name="buyer">The player who bought the item.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnNpcGiveSoldItem(NPCVendingMachine vendingMachine, Item item, BasePlayer buyer)
{
    Puts("OnNpcGiveSoldItem hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnNpcGiveSoldItem", this, soldItem, buyer) == null)
		{
			base.GiveSoldItem(soldItem, buyer);
		}
	}

```

## OnItemLock(Item)

```csharp
/// <summary>
/// Called when an item is locked.
/// </summary>
/// <param name="item">The item being locked.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemLock(Item item)
{
    Puts("OnItemLock is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## OnTeamRejectInvite(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
/// <summary>
/// Called when a player rejects an invitation to join a team.
/// </summary>
/// <param name="player">The player rejecting the invite.</param>
/// <param name="team">The team being rejected from.</param>
/// <returns>No return behavior.</returns>
void OnTeamRejectInvite(BasePlayer player, PlayerTeam team)
{
    Puts($"Player {player.UserIDString} has rejected an invitation to join team: {team.Name}");
}
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void rejectinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamRejectInvite", basePlayer, playerTeam) == null)
			{
				playerTeam.RejectInvite(basePlayer);
			}
		}
	}

```

## OnLiquidWeaponFiringStopped(LiquidWeapon)

```csharp
/// <summary>
/// Called when the liquid weapon firing is stopped.
/// </summary>
/// <param name="liquidWeapon">The liquid weapon that was firing.</param>
/// <returns>No return behavior.</returns>
void OnLiquidWeaponFiringStopped(LiquidWeapon liquidWeapon)
{
    Puts("OnLiquidWeaponFiringStopped called!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StopFiring()
	{
		CancelInvoke(FireTick);
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		SetFlag(Flags.On, b: false);
		if (base.isServer)
		{
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnLiquidWeaponFiringStopped", this);
	}

```

## OnFireworkStarted(BaseFirework)

```csharp
/// <summary>
/// Called when a firework is started.
/// </summary>
/// <param name="firework">The firework that was started.</param>
/// <returns>Returns the result of the hook's execution.</returns>
object OnFireworkStarted(BaseFirework firework)
{
    Puts("OnFireworkStarted hook called!");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void Begin()
	{
		SetFlag(Flags.OnFire, b: false);
		SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkStarted", this);
		Invoke(OnExhausted, activityLength);
	}

```

## OnWildlifeTrap(SurvivalFishTrap,ItemDefinition)

```csharp
/// <summary>
/// Called when a wildlife trap is triggered.
/// </summary>
/// <param name="trap">The survival fish trap that was triggered.</param>
/// <param name="itemDefinition">The item definition of the caught fish.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns the result of the hook.</returns>
object OnWildlifeTrap(SurvivalFishTrap trap, ItemDefinition itemDefinition)
{
    Puts("OnWildlifeTrap called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void TrapThink()
	{
		ItemDefinition itemDefinition = null;
		Item item = null;
		int usedLureAmount = 0;
		using (List<Item>.Enumerator enumerator = base.inventory.itemList.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				if ((current.info.TryGetComponent<ItemModCompostable>(out var component) ? component.BaitValue : 0f) > 0f)
				{
					item = current;
					itemDefinition = FishLookup.Instance.GetFish(base.transform.position, cachedWaterBody, current, out var _, current.info.GetComponent<ItemModFishable>(), out usedLureAmount, 5f);
				}
			}
		}
		item?.UseItem(usedLureAmount);
		if (UnityEngine.Random.Range(0f, 1f) <= trapSuccessRate || !(itemDefinition != null))
		{
			return;
		}
		try
		{
			bypassItemFilter = true;
			if (Interface.CallHook("OnWildlifeTrap", this, itemDefinition) == null)
			{
				Item item2 = ItemManager.Create(itemDefinition, 1, 0uL);
				if (!item2.MoveToContainer(base.inventory))
				{
					item2.Drop(base.transform.position, Vector3.zero, Quaternion.identity);
				}
				OnTrappedWildlife(setFlag: true);
			}
		}
		finally
		{
			bypassItemFilter = false;
		}
	}

```

## OnMissionSucceeded(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
/// <summary>
/// Called when a mission is successfully completed.
/// </summary>
/// <param name="mission">The mission that was accomplished.</param>
/// <param name="instance">The mission instance that was completed.</param>
/// <param name="assignee">The player who was assigned to the mission.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnMissionSucceeded(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts("OnMissionSucceeded hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)
	{
		instance.status = MissionStatus.Accomplished;
		MissionEnded(instance, assignee);
		MissionComplete(instance, assignee);
		Interface.CallHook("OnMissionSucceeded", this, instance, assignee);
	}

```

## OnVehicleModuleMove(BaseVehicleModule,BaseModularVehicle,BasePlayer)

```csharp
/// <summary>
/// Called when a vehicle module attempts to move.
/// </summary>
/// <param name="module">The vehicle module attempting to move.</param>
/// <param name="vehicle">The modular vehicle the module is attached to.</param>
/// <param name="player">The player attempting to move the module.</param>
/// <returns>Returns true if the default behavior allows the module to be moved, and false otherwise. If a custom return value is provided, it should be of type bool.</returns>
object OnVehicleModuleMove(BaseVehicleModule module, BaseModularVehicle vehicle, BasePlayer player)
{
    // Minimal code to demonstrate functionality
    Puts("OnVehicleModuleMove called!");
    
    // Return true if the default behavior allows the module to be moved
    return true;
}
```

### Source Code from the Library

```csharp

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		BaseVehicleModule moduleForItem = GetModuleForItem(item);
		if (moduleForItem != null)
		{
			object obj = Interface.CallHook("OnVehicleModuleMove", moduleForItem, this, player);
			if (obj != null)
			{
				if (!(obj is bool))
				{
					return false;
				}
				return (bool)obj;
			}
			return moduleForItem.CanBeMovedNow();
		}
		return true;
	}

```

## CanNetworkTo(BasePlayer,BasePlayer)

```csharp
/// <summary>
/// Called to determine whether the current player can network to another player.
/// </summary>
/// <param name="targetPlayer">The player to check networking for.</param>
/// <returns>Returns true if the target player can be networked to, false otherwise.</returns>
bool CanNetworkTo(BasePlayer targetPlayer)
{
    Puts("CanNetworkTo is working!");
    return true; // Minimal code to demonstrate functionality
}
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return true;
		}
		if (IsSpectating() && player != this)
		{
			return false;
		}
		bool flag = base.ShouldNetworkTo(player);
		if (ServerOcclusion.OcclusionEnabled && flag)
		{
			flag = OcclusionLineOfSight(player);
		}
		return flag;
	}

```

## OnTerrainCreate(TerrainGenerator)

```csharp
/// <summary>
/// Called when a new terrain is created.
/// </summary>
/// <param name="generator">The terrain generator used to create the terrain.</param>
/// <returns>No return behavior.</returns>
void OnTerrainCreate(TerrainGenerator generator)
{
    Puts("OnTerrainCreate is working!");
}
```

### Source Code from the Library

```csharp

	public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
	{
		Interface.CallHook("OnTerrainCreate", this);
		Terrain component = Terrain.CreateTerrainGameObject(new TerrainData
		{
			baseMapResolution = GetBaseMapRes(),
			heightmapResolution = heightmapResolution,
			alphamapResolution = alphamapResolution,
			size = new Vector3(World.Size, 1000f, World.Size)
		}).GetComponent<Terrain>();
		component.transform.position = base.transform.position + new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);
		component.drawInstanced = false;
		component.castShadows = config.CastShadows;
		component.materialType = Terrain.MaterialType.Custom;
		component.materialTemplate = config.Material;
		component.gameObject.tag = base.gameObject.tag;
		component.gameObject.layer = base.gameObject.layer;
		component.gameObject.GetComponent<TerrainCollider>().sharedMaterial = config.GenericMaterial;
		TerrainMeta terrainMeta = component.gameObject.AddComponent<TerrainMeta>();
		component.gameObject.AddComponent<TerrainPhysics>();
		component.gameObject.AddComponent<TerrainColors>();
		component.gameObject.AddComponent<TerrainCollision>();
		component.gameObject.AddComponent<TerrainBiomeMap>();
		component.gameObject.AddComponent<TerrainAlphaMap>();
		component.gameObject.AddComponent<TerrainHeightMap>();
		component.gameObject.AddComponent<TerrainSplatMap>();
		component.gameObject.AddComponent<TerrainTopologyMap>();
		component.gameObject.AddComponent<TerrainWaterMap>();
		component.gameObject.AddComponent<TerrainPlacementMap>();
		component.gameObject.AddComponent<TerrainPath>();
		component.gameObject.AddComponent<TerrainTexturing>();
		terrainMeta.terrain = component;
		terrainMeta.config = config;
		Object.DestroyImmediate(base.gameObject);
		return component.gameObject;
	}

```

## OnCupboardProtectionCalculated(BuildingPrivlidge,float)

```csharp
/// <summary>
/// Called when the protection calculation for a cupboard is performed.
/// </summary>
/// <param name="privilege">The building privilege.</param>
/// <param name="minutes">The calculated protected minutes.</param>
/// <returns>No return behavior.</returns>
void OnCupboardProtectionCalculated(BuildingPrivlidge privilege, float minutes)
{
    Puts($"Cupboard protection calculation result: {minutes} minutes");
}
```

### Source Code from the Library

```csharp

	public float GetProtectedMinutes(bool force = false)
	{
		if (base.isServer)
		{
			if (!force && UnityEngine.Time.realtimeSinceStartup < nextProtectedCalcTime)
			{
				return cachedProtectedMinutes;
			}
			nextProtectedCalcTime = UnityEngine.Time.realtimeSinceStartup + 60f;
			List<ItemAmount> obj = Facepunch.Pool.GetList<ItemAmount>();
			CalculateUpkeepCostAmounts(obj);
			float num = CalculateUpkeepPeriodMinutes();
			float num2 = -1f;
			if (base.inventory != null)
			{
				foreach (ItemAmount item in obj)
				{
					int num3 = base.inventory.FindItemsByItemID(item.itemid).Sum((Item x) => x.amount);
					if (num3 > 0 && item.amount > 0f)
					{
						float num4 = (float)num3 / item.amount * num;
						if (num2 == -1f || num4 < num2)
						{
							num2 = num4;
						}
					}
					else
					{
						num2 = 0f;
					}
				}
				if (num2 == -1f)
				{
					num2 = 0f;
				}
			}
			Facepunch.Pool.FreeList(ref obj);
			cachedProtectedMinutes = num2;
			Interface.CallHook("OnCupboardProtectionCalculated", this, cachedProtectedMinutes);
			return cachedProtectedMinutes;
		}
		return 0f;
	}

```

## OnBonusItemDrop(Item,BasePlayer)

```csharp
/// <summary>
/// Called when a bonus item is dropped.
/// </summary>
/// <param name="item">The dropped item.</param>
/// <param name="player">The player who dropped the item.</param>
/// <returns>No return behavior.</returns>
void OnBonusItemDrop(Item item, BasePlayer player)
{
    Puts($"Bonus item {item.info.name} dropped by player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnFireBallDamage(FireBall,BaseCombatEntity,HitInfo)

```csharp
/// <summary>
/// Called when a fireball deals damage to an entity.
/// </summary>
/// <param name="fireBall">The fireball that dealt the damage.</param>
/// <param name="entity">The entity that was damaged.</param>
/// <param name="hitInfo">Information about the hit, including the damage type and amount.</param>
/// <returns>No return behavior.</returns>
void OnFireBallDamage(FireBall fireBall, BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Fireball dealt {hitInfo.damageTypes.Get(DamageType.Heat)} heat damage to {entity} at position {hitInfo.HitPositionWorld}");
}
```

### Source Code from the Library

```csharp

	public void DoRadialDamage()
	{
		List<BaseCombatEntity> obj = Pool.GetList<BaseCombatEntity>();
		Vector3 position = base.transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Entities(position, radius, obj, AttackLayers, QueryTriggerInteraction.Ignore);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = ((creatorEntity == null) ? GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);
		hitInfo.PointStart = base.transform.position;
		foreach (BaseCombatEntity item in obj)
		{
			if (!(item == null) && item.isServer && item.IsAlive() && (!ignoreNPC || !item.IsNpc) && item.IsVisible(position))
			{
				if (item is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", item, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = item.transform.position;
				hitInfo.HitPositionWorld = item.transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", this, item, hitInfo);
				item.OnAttacked(hitInfo);
			}
		}
		Pool.FreeList(ref obj);
	}

```

## OnPhoneNameUpdated(PhoneController,string,BasePlayer)

```csharp
/// <summary>
/// Called when a player's phone name is updated.
/// </summary>
/// <param name="controller">The phone controller.</param>
/// <param name="newName">The new phone name.</param>
/// <param name="player">The player who updated the phone name.</param>
/// <returns>No return behavior.</returns>
void OnPhoneNameUpdated(PhoneController controller, string newName, BasePlayer player)
{
    Puts($"Phone name of {controller} updated to '{newName}' by {player}");
}
```

### Source Code from the Library

```csharp

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!(msg.player != currentPlayer))
		{
			string text = msg.read.String();
			if (text.Length > 20)
			{
				text = text.Substring(0, 20);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", this, text, msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", this, PhoneName, msg.player);
			}
		}
	}

```

## OnLiquidVesselFill(BaseLiquidVessel,BasePlayer,LiquidContainer)

```csharp
/// <summary>
/// Called when a liquid vessel is being filled.
/// </summary>
/// <param name="vessel">The liquid vessel being filled.</param>
/// <param name="player">The player performing the fill operation.</param>
/// <param name="container">The liquid container being used for filling (if applicable).</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnLiquidVesselFill(BaseLiquidVessel vessel, BasePlayer player, LiquidContainer container)
{
    Puts("OnLiquidVesselFill hook called!");
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp

	public void FillCheck()
	{
		if (base.isClient)
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		float f = (UnityEngine.Time.realtimeSinceStartup - lastFillTime) * fillMlPerSec;
		Vector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);
		LiquidContainer facingLiquidContainer = GetFacingLiquidContainer();
		if (Interface.CallHook("OnLiquidVesselFill", this, ownerPlayer, facingLiquidContainer) != null)
		{
			return;
		}
		if (facingLiquidContainer == null && CanFillFromWorld())
		{
			AddLiquid(WaterResource.GetAtPoint(pos), Mathf.FloorToInt(f));
		}
		else if (facingLiquidContainer != null && facingLiquidContainer.HasLiquidItem())
		{
			int num = Mathf.CeilToInt((1f - HeldFraction()) * (float)MaxHoldable());
			if (num > 0)
			{
				Item liquidItem = facingLiquidContainer.GetLiquidItem();
				int num2 = Mathf.Min(Mathf.CeilToInt(f), Mathf.Min(liquidItem.amount, num));
				AddLiquid(liquidItem.info, num2);
				liquidItem.UseItem(num2);
				facingLiquidContainer.OpenTap(2f);
			}
		}
		lastFillTime = UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnTurretModeToggle(AutoTurret,BasePlayer)

```csharp
/// <summary>
/// Called when the mode of a turret is toggled.
/// </summary>
/// <param name="turret">The AutoTurret whose mode is being toggled.</param>
/// <param name="player">The player who triggered the toggle.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns an object representing the result of the hook.</returns>
object OnTurretModeToggle(AutoTurret turret, BasePlayer player)
{
    Puts("OnTurretModeToggle called!");
    // Minimal code to demonstrate functionality
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SERVER_Peacekeeper(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player) && Interface.CallHook("OnTurretModeToggle", this, rpc.player) == null)
		{
			SetPeacekeepermode(isOn: true);
		}
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
This is a C# code snippet that appears to be part of a game's physics and combat system. Here's a breakdown of the code:

**Purpose:**

The code checks if an attack (melee or ranged) hits its target, and if so, updates various statistics and flags accordingly.

**Key variables:**

* `player`: The player entity performing the attack.
* `hitInfo`: Information about the hit, including the position of the hit and the entity that was hit.
* `flag8`, `flag7`, and `flag`: Various flags used to track the status of the attack.
* `num5` and `melee_losforgiveness`: Constants used in the line-of-sight calculations.

**Main logic:**

1. The code first checks if the attack hits its target using a line-of-sight calculation (`GamePhysics.LineOfSight`). If it does, it sets various flags and statistics accordingly.
2. If the attack misses its target, it logs an invalid hit in the player's combat log and resets certain flags.

**Line-of-sight calculations:**

The code uses two different line-of-sight calculations:

* `GamePhysics.LineOfSight(hitPositionWorld, position2, num5)`: Checks if there is a direct line of sight from the hit position to the attacker's eyes.
* `GamePhysics.LineOfSight(position2, hitPositionWorld, num5, melee_losforgiveness, 0f)`: Checks if there is an indirect line of sight (i.e., through other entities or obstacles).

**Anti-hack checks:**

The code also includes anti-hack checks to prevent players from exploiting the system. If a player attempts to perform an invalid attack, it logs a violation and resets certain flags.

Overall, this code snippet appears to be part of a larger game engine that handles physics and combat mechanics.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo hitInfo = Facepunch.Pool.Get<HitInfo>();
			hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
			hitInfo.Initiator = player;
			hitInfo.Weapon = this;
			hitInfo.WeaponPrefab = this;
			hitInfo.Predicted = msg.connection;
			hitInfo.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, hitInfo) != null)
			{
				return;
			}
			if (hitInfo.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.LogInvalid(hitInfo, "melee_nan");
				return;
			}
			BaseEntity hitEntity = hitInfo.HitEntity;
			BasePlayer basePlayer = hitInfo.HitEntity as BasePlayer;
			bool flag = basePlayer != null;
			bool flag2 = flag && basePlayer.IsSleeping();
			bool flag3 = flag && basePlayer.IsWounded();
			bool flag4 = flag && basePlayer.isMounted;
			bool flag5 = flag && basePlayer.HasParent();
			bool flag6 = hitEntity != null;
			bool flag7 = flag6 && hitEntity.IsNpc;
			bool flag8;
			int num5;
			Vector3 center;
			Vector3 position;
			Vector3 pointStart;
			Vector3 hitPositionWorld;
			Vector3 vector;
			int num16;
			if (ConVar.AntiHack.melee_protection > 0)
			{
				flag8 = true;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTimeClamped + num2 + num3) * num;
				num5 = 1075904512;
				if (ConVar.AntiHack.melee_terraincheck)
				{
					num5 |= 0x800000;
				}
				if (ConVar.AntiHack.melee_vehiclecheck)
				{
					num5 |= 0x8000000;
				}
				if (flag && hitInfo.boneArea == (HitArea)(-1))
				{
					string shortPrefabName2 = base.ShortPrefabName;
					string shortPrefabName3 = basePlayer.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.MeleeHack, "Bone is invalid  (" + shortPrefabName2 + " on " + shortPrefabName3 + " bone " + hitInfo.HitBone + ")");
					player.stats.combat.LogInvalid(hitInfo, "melee_bone");
					flag8 = false;
				}
				if (ConVar.AntiHack.melee_protection >= 2)
				{
					if (flag6)
					{
						float num6 = hitEntity.MaxVelocity() + hitEntity.GetParentVelocity().magnitude;
						float num7 = hitEntity.BoundsPadding() + num4 * num6;
						float num8 = hitEntity.Distance(hitInfo.HitPositionWorld);
						if (num8 > num7)
						{
							string shortPrefabName4 = base.ShortPrefabName;
							string shortPrefabName5 = hitEntity.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num8 + "m > " + num7 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(hitInfo, "melee_target");
							flag8 = false;
						}
					}
					if (ConVar.AntiHack.melee_protection >= 4 && flag8 && flag && !flag7 && !flag2 && !flag3 && !flag4 && !flag5)
					{
						float magnitude = basePlayer.GetParentVelocity().magnitude;
						float num9 = basePlayer.BoundsPadding() + num4 * magnitude + ConVar.AntiHack.tickhistoryforgiveness;
						float num10 = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld);
						if (num10 > num9)
						{
							string shortPrefabName6 = base.ShortPrefabName;
							string shortPrefabName7 = basePlayer.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.MeleeHack, "Player too far away (" + shortPrefabName6 + " on " + shortPrefabName7 + " with " + num10 + "m > " + num9 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(hitInfo, "player_distance");
							flag8 = false;
						}
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					if (ConVar.AntiHack.melee_protection >= 4)
					{
						float magnitude2 = player.GetParentVelocity().magnitude;
						float num11 = player.BoundsPadding() + num4 * magnitude2 + num * maxDistance;
						float num12 = player.tickHistory.Distance(player, hitInfo.HitPositionWorld);
						if (num12 > num11)
						{
							string shortPrefabName8 = base.ShortPrefabName;
							string text = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName8 + " on " + text + " with " + num12 + "m > " + num11 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(hitInfo, "melee_initiator");
							flag8 = false;
						}
					}
					else
					{
						float num13 = player.MaxVelocity() + player.GetParentVelocity().magnitude;
						float num14 = player.BoundsPadding() + num4 * num13 + num * maxDistance;
						float num15 = player.Distance(hitInfo.HitPositionWorld);
						if (num15 > num14)
						{
							string shortPrefabName9 = base.ShortPrefabName;
							string text2 = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName9 + " on " + text2 + " with " + num15 + "m > " + num14 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(hitInfo, "melee_initiator");
							flag8 = false;
						}
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					if (flag6)
					{
						center = player.eyes.center;
						position = player.eyes.position;
						pointStart = hitInfo.PointStart;
						hitPositionWorld = hitInfo.HitPositionWorld;
						hitPositionWorld -= (hitPositionWorld - pointStart).normalized * 0.001f;
						vector = hitInfo.PositionOnRay(hitPositionWorld);
						Vector3 vector2 = Vector3.zero;
						Vector3 vector3 = Vector3.zero;
						Vector3 vector4 = Vector3.zero;
						if (ConVar.AntiHack.melee_backtracking > 0f)
						{
							vector2 = (position - center).normalized * ConVar.AntiHack.melee_backtracking;
							vector3 = (pointStart - position).normalized * ConVar.AntiHack.melee_backtracking;
							vector4 = (vector - pointStart).normalized * ConVar.AntiHack.melee_backtracking;
						}
						if (GamePhysics.LineOfSight(center - vector2, position + vector2, num5) && GamePhysics.LineOfSight(position - vector3, pointStart + vector3, num5) && GamePhysics.LineOfSight(pointStart - vector4, vector, num5))
						{
							num16 = (GamePhysics.LineOfSight(vector, hitPositionWorld, num5) ? 1 : 0);
							if (num16 != 0)
							{
								player.stats.Add("hit_" + hitEntity.Categorize() + "_direct_los", 1, Stats.Server);
								goto IL_07c7;
							}
						}
						else
						{
							num16 = 0;
						}
						player.stats.Add("hit_" + hitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
						goto IL_07c7;
					}
					goto IL_08b5;
				}
				goto IL_0a1c;
			}
			goto IL_0a2e;
			IL_07c7:
			if (num16 == 0)
			{
				string shortPrefabName10 = base.ShortPrefabName;
				string shortPrefabName11 = hitEntity.ShortPrefabName;
				string[] obj = new string[14]
				{
					"Line of sight (", shortPrefabName10, " on ", shortPrefabName11, ") ", null, null, null, null, null,
					null, null, null, null
				};
				Vector3 vector5 = center;
				obj[5] = vector5.ToString();
				obj[6] = " ";
				vector5 = position;
				obj[7] = vector5.ToString();
				obj[8] = " ";
				vector5 = pointStart;
				obj[9] = vector5.ToString();
				obj[10] = " ";
				vector5 = vector;
				obj[11] = vector5.ToString();
				obj[12] = " ";
				vector5 = hitPositionWorld;
				obj[13] = vector5.ToString();
				AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj));
				player.stats.combat.LogInvalid(hitInfo, "melee_los");
				flag8 = false;
			}
			goto IL_08b5;
			IL_0a2e:
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50))
			{
				DoAttackShared(hitInfo);
				return;
			}
			IL_0a1c:
			if (!flag8)
			{
				AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
				return;
			}
			goto IL_0a2e;
			IL_08b5:
			if (flag8 && flag && !flag7)
			{
				Vector3 hitPositionWorld2 = hitInfo.HitPositionWorld;
				Vector3 position2 = basePlayer.eyes.position;
				Vector3 vector6 = basePlayer.CenterPoint();
				float melee_losforgiveness = ConVar.AntiHack.melee_losforgiveness;
				bool flag9 = GamePhysics.LineOfSight(hitPositionWorld2, position2, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(position2, hitPositionWorld2, num5, melee_losforgiveness, 0f);
				if (!flag9)
				{
					flag9 = GamePhysics.LineOfSight(hitPositionWorld2, vector6, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(vector6, hitPositionWorld2, num5, melee_losforgiveness, 0f);
				}
				if (!flag9)
				{
					string shortPrefabName12 = base.ShortPrefabName;
					string shortPrefabName13 = basePlayer.ShortPrefabName;
					string[] obj2 = new string[12]
					{
						"Line of sight (", shortPrefabName12, " on ", shortPrefabName13, ") ", null, null, null, null, null,
						null, null
					};
					Vector3 vector5 = hitPositionWorld2;
					obj2[5] = vector5.ToString();
					obj2[6] = " ";
					vector5 = position2;
					obj2[7] = vector5.ToString();
					obj2[8] = " or ";
					vector5 = hitPositionWorld2;
					obj2[9] = vector5.ToString();
					obj2[10] = " ";
					vector5 = vector6;
					obj2[11] = vector5.ToString();
					AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj2));
					player.stats.combat.LogInvalid(hitInfo, "melee_los");
					flag8 = false;
				}
			}
			goto IL_0a1c;
		}
	}

```

## OnTeamLeave(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
/// <summary>
/// Called when a player leaves their team.
/// </summary>
/// <param name="team">The team the player is leaving.</param>
/// <param name="player">The player leaving the team.</param>
/// <returns>No return behavior.</returns>
void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.UserIDString} left team: {team.Name}");
}
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void leaveteam(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam != 0L)
		{
			PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
			if (playerTeam != null && Interface.CallHook("OnTeamLeave", playerTeam, basePlayer) == null)
			{
				playerTeam.RemovePlayer(basePlayer.userID);
				basePlayer.ClearTeam();
			}
		}
	}

```

## OnMapMarkerRemove(BasePlayer,System.Collections.Generic.List<ProtoBuf.MapNote>,int)

```csharp
/// <summary>
/// Called when a map marker is removed.
/// </summary>
/// <param name="player">The player who initiated the removal.</param>
/// <param name="markers">A list of markers to be removed.</param>
/// <param name="index">The index of the marker to remove.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnMapMarkerRemove(BasePlayer player, System.Collections.Generic.List<ProtoBuf.MapNote> markers, int index)
{
    // Minimal code to demonstrate functionality
    Puts($"Map marker removed at index {index} for player {player.UserID}");
    
    // Return null if the default behavior is not overridden
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server.FromOwner]
	[RPC_Server]
	public void Server_RemovePointOfInterest(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (State.pointsOfInterest != null && State.pointsOfInterest.Count > num && num >= 0 && Interface.CallHook("OnMapMarkerRemove", this, State.pointsOfInterest, num) == null)
		{
			State.pointsOfInterest[num].Dispose();
			State.pointsOfInterest.RemoveAt(num);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
		}
	}

```

## OnEntityControl(AutoTurret,ulong)

```csharp
/// <summary>
/// Called when a player attempts to control an entity.
/// </summary>
/// <param name="entity">The entity being controlled.</param>
/// <param name="playerID">The ID of the player attempting to control the entity.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
object OnEntityControl(AutoTurret entity, ulong playerID)
{
    Puts("OnEntityControl is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", this, playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (booting)
		{
			return false;
		}
		if (IsPowered())
		{
			return !PeacekeeperMode();
		}
		return false;
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
Документация для IOnBasePlayerHurt(BasePlayer, HitInfo)

**Описание**

Хук `IOnBasePlayerHurt` вызывается в методе `Hurt` класса `BasePlayer`, когда игрок получает повреждение. Этот хук позволяет модифицировать поведение игрока при получении повреждения.

**Параметры**

* `BasePlayer`: Объект игрока, который получил повреждение.
* `HitInfo`: Информация о повреждении, включая источник повреждения и тип повреждения.

**Возвращаемое значение**

Хук возвращает `null` или объект, если хук был вызван. Если хук не был вызван, метод `Hurt` продолжит выполняться как обычно.

**Примечания**

* Хук вызывается только при условии, что игрок не мертв, не защищен от повреждения и не является ботом.
* Хук может модифицировать поведение игрока при получении повреждения, например, изменяя тип повреждения или его величину.

**Пример использования**

Например, можно использовать хук для изменения типа повреждения, если игрок получает повреждение от определенного источника. Например:
```csharp
public class MyPlugin : MonoBehaviour
{
    public void OnEnable()
    {
        Interface.CallHook("IOnBasePlayerHurt", (player, hitInfo) =>
        {
            if (hitInfo.Initiator is MyCustomWeapon)
            {
                hitInfo.damageTypes.Scale(DamageType.Generic, 0f);
                return true;
            }
            return false;
        });
    }
}
```
В этом примере хук изменяет тип повреждения на `Generic`, если источник повреждения является экземпляром класса `MyCustomWeapon`.
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || IsTransferProtected() || (IsImmortalTo(info) && info.damageTypes.Total() >= 0f) || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && !IsNpc && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		if (info.damageTypes.Has(DamageType.Fun_Water))
		{
			bool flag = true;
			Item activeItem = GetActiveItem();
			if (activeItem != null && (activeItem.info.shortname == "gun.water" || activeItem.info.shortname == "pistol.water"))
			{
				float value = metabolism.wetness.value;
				metabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);
				bool flag2 = metabolism.wetness.value >= ConVar.Server.funWaterDamageThreshold;
				flag = !flag2;
				if (info.InitiatorPlayer != null)
				{
					if (flag2 && value < ConVar.Server.funWaterDamageThreshold)
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_SOAKED");
					}
					if (metabolism.radiation_level.Fraction() > 0.2f && !string.IsNullOrEmpty("SUMMER_RADICAL"))
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_RADICAL");
					}
				}
			}
			if (flag)
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
		}
		if (info.damageTypes.Get(DamageType.Drowned) > 5f && drownEffect.isValid)
		{
			Effect.server.Run(drownEffect.resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
		if (modifiers != null)
		{
			if (info.damageTypes.Has(DamageType.Radiation))
			{
				info.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));
			}
			if (info.damageTypes.Has(DamageType.RadiationExposure))
			{
				info.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));
			}
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((bool)initiatorPlayer && initiatorPlayer != this)
		{
			if (initiatorPlayer.InSafeZone() || InSafeZone())
			{
				initiatorPlayer.MarkHostileFor(300f);
			}
			if (initiatorPlayer.InSafeZone() && !initiatorPlayer.IsNpc)
			{
				info.damageTypes.ScaleAll(0f);
				return;
			}
			if (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(DamageType.Explosion) > 0f)
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);
			}
		}
		base.Hurt(info);
		if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
		{
			BasePlayer instigator = info?.InitiatorPlayer;
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerHurt(instigator, this, info);
		}
		if (IsRestrained && info.damageTypes.GetMajorityDamageType().InterruptsRestraintMinigame())
		{
			Handcuffs handcuffs = GetHeldEntity() as Handcuffs;
			if (handcuffs != null)
			{
				handcuffs.InterruptUnlockMiniGame(wasPushedOrDamaged: true);
			}
		}
		EACServer.LogPlayerTakeDamage(this, info);
		metabolism.SendChangesToClient();
		if (info.PointStart != Vector3.zero && (info.damageTypes.Total() >= 0f || IsGod()))
		{
			int arg = (int)info.damageTypes.GetMajorityDamageType();
			if (info.Weapon != null && info.damageTypes.Has(DamageType.Bullet))
			{
				BaseProjectile component = info.Weapon.GetComponent<BaseProjectile>();
				if (component != null && component.IsSilenced())
				{
					arg = 12;
				}
			}
			ClientRPC(RpcTarget.PlayerAndSpectators("DirectionalDamage", this), info.PointStart, arg, Mathf.CeilToInt(info.damageTypes.Total()));
		}
		cachedNonSuicideHitInfo = info;
	}

```

## OnResearchCostDetermine(Item)

```csharp
/// <summary>
/// Called to determine the research cost for a given item.
/// </summary>
/// <param name="item">The item for which the research cost is being determined.</param>
/// <returns>The research cost as an integer. If the default behavior is overridden, returns a non-null value.</returns>
object OnResearchCostDetermine(Item item)
{
    Puts("OnResearchCostDetermine is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public static int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", item);
		if (obj is int)
		{
			return (int)obj;
		}
		return ScrapForResearch(item.info);
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
/// <summary>
/// Called when an entity leaves the trigger area.
/// </summary>
/// <param name="trigger">The trigger that detected the entity's departure.</param>
/// <param name="entity">The entity that left the trigger area.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts("OnEntityLeave is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			entityContents.Remove(ent);
			OnEntityLeaveTrigger?.Invoke(ent);
		}
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum,ulong)

```csharp
/// <summary>
/// Called when a player attempts to change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="block">The building block being modified.</param>
/// <param name="grade">The new grade to apply.</param>
/// <param name="skinId">The ID of the skin being used.</param>
/// <returns>Returns true if the grade can be changed, false otherwise.</returns>
bool CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade, ulong skinId)
{
    Puts("CanChangeGrade is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public bool CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade, iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (HasUpgradePrivilege(iGrade, iSkin, player))
		{
			return !IsUpgradeBlocked();
		}
		return false;
	}

```

## OnVehicleModulesAssign(ModularCar,Rust.Modular.ItemModVehicleModule[])

```csharp
/// <summary>
/// Called when vehicle modules are assigned to a Modular Car.
/// </summary>
/// <param name="vehicle">The Modular Car.</param>
/// <param name="modules">A list of ItemModVehicleModule items to be assigned.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModulesAssign(ModularCar vehicle, Rust.Modular.ItemModVehicleModule[] modules)
{
    Puts("OnVehicleModulesAssign is working!");
}
```

### Source Code from the Library

```csharp

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", this, modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				Item item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);
				float num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", this, modularCarPresetConfig.socketItemDefs);
		Invoke(HandleAdminBonus, 0f);
	}

```

## CanBeHomingTargeted(RoadFlare)

```csharp
/// <summary>
/// Determines whether the current entity can be targeted by homing projectiles.
/// </summary>
/// <param name="flare">The road flare used for targeting.</param>
/// <returns>Returns <c>true</c> if the entity can be targeted, and <c>false</c> otherwise.</returns>
bool CanBeHomingTargeted(RoadFlare flare)
{
    Puts("CanBeHomingTargeted is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## IOnUserApprove(Network.Connection)

```csharp
/// <summary>
/// Called when a new user connects to the server.
/// </summary>
/// <param name="connection">The user's network connection.</param>
/// <returns>No return behavior.</returns>
void IOnUserApprove(Network.Connection connection)
{
    Puts($"New user connected: {connection}");
}
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0L)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2555)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)");
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			ServerUsers.User user = ServerUsers.Get(connection.userid);
			string text = user?.notes ?? "no reason given";
			string text2 = ((user != null && user.expiry > 0) ? (" for " + (user.expiry - Epoch.Current).FormatSecondsLong()) : "");
			Reject(connection, "You are banned from this server" + text2 + " (" + text + ")");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log(connection.ToString() + " has auth level 1");
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log(connection.ToString() + " has auth level 2");
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log(connection.ToString() + " is a developer");
			connection.authLevel = 3u;
		}
		if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnItemUse(Item,int)

```csharp
/// <summary>
/// Called when an item is used.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amount">The amount of the item to consume.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise returns the consumed amount.</returns>
object OnItemUse(Item item, int amount)
{
    Puts("OnItemUse hook called!");
    // If the return value is not null, it means the default behavior was overridden
    if (/* check if obj is not null */) {
        // Return the custom value
        return /* custom value */;
    }
    // Otherwise, return the consumed amount
    return amount;
}
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", this, amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## CanLootEntity(BasePlayer,IndustrialCrafter)

```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>Returns true if the player can loot the entity, false otherwise.</returns>
bool CanLootEntity(BasePlayer player, IndustrialCrafter entity)
{
    Puts("CanLootEntity is working!");
    return true; // Replace with actual logic to determine if the player can loot the entity
}
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (NeedsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if (OnlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), LootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnLootPlayer(BasePlayer,BasePlayer)

```csharp
/// <summary>
/// Called when a player is looted.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="target">The player being looted.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts("OnLootPlayer hook called!");
    // Add your custom logic here
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_LootPlayer(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))
		{
			player.inventory.loot.AddContainer(inventory.containerMain);
			player.inventory.loot.AddContainer(inventory.containerWear);
			player.inventory.loot.AddContainer(inventory.containerBelt);
			Interface.CallHook("OnLootPlayer", this, player);
			player.inventory.loot.SendImmediate();
			player.ClientRPC(RpcTarget.Player("RPC_OpenLootPanel", player), "player_corpse");
		}
	}

```

## OnTurretAssigned(AutoTurret,ulong,BasePlayer)

```csharp
/// <summary>
/// Called when a turret is assigned to a player.
/// </summary>
/// <param name="turret">The AutoTurret being assigned.</param>
/// <param name="id">The ID of the player being assigned the turret.</param>
/// <param name="player">The BasePlayer being assigned the turret.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnTurretAssigned(AutoTurret turret, ulong id, BasePlayer player)
{
    Puts("OnTurretAssigned is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AssignToFriend(RPCMessage msg)
	{
		if (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", this, num, msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = num;
			playerNameID.username = username;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(playerNameID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", this, num, msg.player);
		}
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
/// <summary>
/// Called when a turret is shutting down.
/// </summary>
/// <param name="turret">The AutoTurret instance being shut down.</param>
/// <returns>No return behavior.</returns>
void OnTurretShutdown(AutoTurret turret)
{
    Puts($"Turret {turret} is shutting down.");
}
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if ((!IsOffline() || booting) && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			CancelInvoke(SetOnline);
			booting = false;
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## OnSurveyGather(SurveyCharge,Item)

```csharp
/// <summary>
/// Called when a survey charge is gathered.
/// </summary>
/// <param name="surveyCharge">The survey charge being gathered.</param>
/// <param name="item">The item being dropped.</param>
/// <returns>No return behavior.</returns>
void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts("OnSurveyGather is working!");
}
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		base.Explode();
		if (WaterLevel.Test(base.transform.position, waves: true, volumes: true, this))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))
		{
			return;
		}
		Vector3 point = hitOut.point;
		_ = hitOut.normal;
		List<SurveyCrater> obj = Pool.GetList<SurveyCrater>();
		Vis.Entities(base.transform.position, 10f, obj, 1);
		bool num = obj.Count > 0;
		Pool.FreeList(ref obj);
		if (num)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag = true;
				if (resource.isLiquid)
				{
					flag2 = true;
				}
				for (int i = 0; i < num2; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", this, item);
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);
					item.Drop(base.transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
				}
			}
		}
		if (flag)
		{
			string strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);
			BaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if ((bool)baseEntity)
			{
				baseEntity.Spawn();
			}
		}
	}

```

## OnPlayerMarkersSend(BasePlayer,ProtoBuf.MapNoteList)

```csharp
/// <summary>
/// Called when the player's markers are sent to the client.
/// </summary>
/// <param name="player">The player whose markers are being sent.</param>
/// <param name="markers">A list of map notes representing the player's markers.</param>
/// <returns>No return behavior.</returns>
void OnPlayerMarkersSend(BasePlayer player, ProtoBuf.MapNoteList markers)
{
    Puts($"Sending {markers.notes.Count} markers to client for player {player.UserIDString}");
}
```

### Source Code from the Library

```csharp

	public void SendMarkersToClient()
	{
		using MapNoteList mapNoteList = Facepunch.Pool.Get<MapNoteList>();
		mapNoteList.notes = Facepunch.Pool.GetList<MapNote>();
		if (ServerCurrentDeathNote != null)
		{
			mapNoteList.notes.Add(ServerCurrentDeathNote);
		}
		if (State.pointsOfInterest != null)
		{
			mapNoteList.notes.AddRange(State.pointsOfInterest);
		}
		Interface.CallHook("OnPlayerMarkersSend", this, mapNoteList);
		ClientRPC(RpcTarget.Player("Client_ReceiveMarkers", this), mapNoteList);
		mapNoteList.notes.Clear();
	}

```

## OnInventoryAmmoFind(PlayerInventory,System.Collections.Generic.List<Item>,Rust.AmmoTypes)

```csharp
/// <summary>
/// Called when the game is searching for a specific type of ammunition in the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="items">A list of items to search through.</param>
/// <param name="ammoType">The type of ammunition being searched for.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise null.</returns>
object OnInventoryAmmoFind(PlayerInventory inventory, List<Item> items, Rust.AmmoTypes ammoType)
{
    Puts("OnInventoryAmmoFind hook called!");
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		if (Interface.CallHook("OnInventoryAmmoFind", this, list, ammoType) == null)
		{
			if (containerMain != null)
			{
				containerMain.FindAmmo(list, ammoType);
			}
			if (containerBelt != null)
			{
				containerBelt.FindAmmo(list, ammoType);
			}
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
/// <summary>
/// Called when a player disconnects from the game.
/// </summary>
/// <param name="player">The disconnected player.</param>
/// <param name="reason">The reason for disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} disconnected: {reason}");
}
```

### Source Code from the Library

```csharp

	public void OnDisconnected(string strReason, Network.Connection connection)
	{
		Facepunch.Rust.Analytics.Azure.OnPlayerDisconnected(connection, strReason);
		GlobalNetworkHandler.server.OnClientDisconnected(connection);
		connectionQueue.TryAddReservedSlot(connection);
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		if (connection.authStatusSteam == "ok")
		{
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
		if (connection.authStatusNexus == "ok")
		{
			NexusServer.Logout(connection.userid);
		}
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when the vending broadcast toggle is activated.
/// </summary>
/// <param name="vendingMachine">The vending machine that triggered the hook.</param>
/// <param name="player">The player who activated the hook.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnToggleVendingBroadcast is working!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## OnPhoneDialFail(PhoneController,Telephone.DialFailReason,BasePlayer)

```csharp
/// <summary>
/// Called when a phone dial attempt fails.
/// </summary>
/// <param name="phoneController">The phone controller that failed to dial.</param>
/// <param name="reason">The reason for the dial failure.</param>
/// <param name="player">The player who attempted to make the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialFail(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer player)
{
    Puts($"Phone dial failed with reason {reason} for player {player.UserID}");
}
```

### Source Code from the Library

```csharp

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", this, reason, currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientOnDialFailed"), (int)reason);
			activeCallTo = null;
			if (IsInvoking(TimeOutCall))
			{
				CancelInvoke(TimeOutCall);
			}
			if (IsInvoking(TriggerTimeOut))
			{
				CancelInvoke(TriggerTimeOut);
			}
			if (IsInvoking(TimeOutDialing))
			{
				CancelInvoke(TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", this, reason, currentPlayer);
		}
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player.displayName} has respawned.");
}
```

### Source Code from the Library

```csharp

	public void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity = null)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((bool)activeGameMode && !activeGameMode.CanPlayerRespawn(this))
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		respawnId = Guid.NewGuid().ToString("N");
		ServerPerformance.spawns++;
		SetParent(null, worldPositionStays: true);
		base.transform.SetPositionAndRotation(position, rotation);
		tickInterpolator.Reset(position);
		tickHistory.Reset(position);
		eyeHistory.Clear();
		estimatedVelocity = Vector3.zero;
		estimatedSpeed = 0f;
		estimatedSpeed2D = 0f;
		lastTickTime = 0f;
		StopWounded();
		ResetWoundingVars();
		StopSpectating();
		UpdateNetworkGroup();
		EnablePlayerCollider();
		RemovePlayerRigidbody();
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		if (modifiers != null)
		{
			modifiers.RemoveAll();
		}
		InitializeHealth(StartHealth(), StartMaxHealth());
		bool flag = false;
		if (ConVar.Server.respawnWithLoadout)
		{
			string infoString = GetInfoString("client.respawnloadout", string.Empty);
			if (!string.IsNullOrEmpty(infoString) && Inventory.LoadLoadout(infoString, out var so))
			{
				so.LoadItemsOnTo(this);
				flag = true;
			}
		}
		if (!flag)
		{
			inventory.GiveDefaultItems();
		}
		SendNetworkUpdateImmediate();
		ClientRPC(RpcTarget.Player("StartLoading", this));
		Facepunch.Rust.Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);
		if ((bool)activeGameMode)
		{
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);
		}
		if (IsConnected)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", this);
		ProcessMissionEvent(BaseMission.MissionEventType.RESPAWN, 0, 0f);
	}

```

## OnHelicopterStrafeEnter(PatrolHelicopterAI,UnityEngine.Vector3,BasePlayer)

```csharp
/// <summary>
/// Called when a helicopter enters strafing mode.
/// </summary>
/// <param name="helicopterAI">The AI instance of the helicopter.</param>
/// <param name="targetPosition">The position of the target to be strafed.</param>
/// <param name="strafeTarget">The player being targeted by the helicopter.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterStrafeEnter(PatrolHelicopterAI helicopterAI, UnityEngine.Vector3 targetPosition, BasePlayer strafeTarget)
{
    Puts("OnHelicopterStrafeEnter is working!");
}
```

### Source Code from the Library

```csharp

	private void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		if (Interface.CallHook("OnHelicopterStrafeEnter", this, strafeTarget.transform.position, strafeTarget) == null)
		{
			strafe_target = strafeTarget;
			get_out_of_strafe_distance = UnityEngine.Random.Range(13f, 17f);
			if (CanUseNapalm() && shouldUseNapalm)
			{
				passNapalm = shouldUseNapalm;
				useNapalm = true;
				lastNapalmTime = UnityEngine.Time.realtimeSinceStartup;
			}
			lastStrafeTime = UnityEngine.Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			RefreshTargetPosition();
			numRocketsLeft = 12 + UnityEngine.Random.Range(-1, 1);
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafe_target_position, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

```

## OnFireworkDamage(BaseFirework,HitInfo)

```csharp
/// <summary>
/// Called when a firework deals damage to an entity.
/// </summary>
/// <param name="firework">The firework that dealt the damage.</param>
/// <param name="info">Information about the hit event.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnFireworkDamage(BaseFirework firework, HitInfo info)
{
    Puts("OnFireworkDamage is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Interface.CallHook("OnFireworkDamage", this, info) == null && info.damageTypes.Has(DamageType.Heat))
		{
			StaggeredTryLightFuse();
		}
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
/// <summary>
/// Called when the Bradley APC is hunting.
/// </summary>
/// <param name="bradleyApc">The Bradley APC instance.</param>
/// <returns>No return behavior.</returns>
void OnBradleyApcHunt(BradleyAPC bradleyApc)
{
    Puts("OnBradleyApcHunt is working!");
}
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			IAIPathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<IAIPathNode> nodes = Facepunch.Pool.GetList<IAIPathNode>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			IAIPathNode iAIPathNode = null;
			List<IAIPathNode> nearNodes = Facepunch.Pool.GetList<IAIPathNode>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<IAIPathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (IAIPathNode item2 in nearNodes)
			{
				Stack<IAIPathNode> path = new Stack<IAIPathNode>();
				if (targetInfo.entity.IsVisible(item2.Position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					iAIPathNode = item2;
				}
			}
			if (stack == null && nearNodes.Count > 0)
			{
				Stack<IAIPathNode> path2 = new Stack<IAIPathNode>();
				IAIPathNode iAIPathNode2 = nearNodes[UnityEngine.Random.Range(0, nearNodes.Count)];
				if (AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) && pathCost2 < num)
				{
					stack = path2;
					iAIPathNode = iAIPathNode2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].Position);
					}
				}
				foreach (IAIPathNode item3 in stack)
				{
					currentPath.Add(item3.Position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = iAIPathNode.Position;
			}
			Facepunch.Pool.FreeList(ref nearNodes);
			Facepunch.Pool.FreeList(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## OnRackedWeaponMount(Item,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a weapon is mounted on a rack.
/// </summary>
/// <param name="item">The item being mounted.</param>
/// <param name="player">The player who performed the action.</param>
/// <param name="rack">The rack where the item was mounted.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
object OnRackedWeaponMount(Item item, BasePlayer player, WeaponRack rack)
{
    Puts("OnRackedWeaponMount called!");
    // If you want to override the default behavior, return a non-null value
    return null;
}
```

### Source Code from the Library

```csharp

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", item, player, this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			Debug.LogWarning("no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if (player != null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", item, player, this);
		return true;
	}

```

## OnPlayerWantsMount(BasePlayer,BaseMountable)

```csharp
/// <summary>
/// Called when a player wants to mount an entity.
/// </summary>
/// <param name="player">The player attempting to mount the entity.</param>
/// <param name="entity">The entity being mounted.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerWantsMount(BasePlayer player, BaseMountable entity)
{
    Puts("OnPlayerWantsMount is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void WantsMount(BasePlayer player)
	{
		if (!player.IsValid() || !player.CanInteract() || Interface.CallHook("OnPlayerWantsMount", player, this) != null)
		{
			return;
		}
		if (!DirectlyMountable())
		{
			BaseVehicle baseVehicle = VehicleParent();
			if (baseVehicle != null)
			{
				baseVehicle.WantsMount(player);
				return;
			}
		}
		AttemptMount(player);
	}

```

## OnEntityLoaded(BaseNetworkable,BaseNetworkable.LoadInfo)

```csharp
/// <summary>
/// Called when an entity is loaded.
/// </summary>
/// <param name="entity">The loaded entity.</param>
/// <param name="loadInfo">Information about the load operation.</param>
/// <returns>No return behavior.</returns>
void OnEntityLoaded(BaseNetworkable entity, LoadInfo loadInfo)
{
    Puts($"Entity {entity} loaded.");
}
 
Метод OnEntityLoaded вызывается при загрузке сущности и содержит информацию о сущности и операции загрузки.
```

### Source Code from the Library

```csharp

	public virtual void Load(LoadInfo info)
	{
		if (info.msg.baseNetworkable != null)
		{
			LoadInfo loadInfo = info;
			Interface.CallHook("OnEntityLoaded", this, info);
			ProtoBuf.BaseNetworkable baseNetworkable = loadInfo.msg.baseNetworkable;
			if (prefabID != baseNetworkable.prefabID)
			{
				Debug.LogError("Prefab IDs don't match! " + prefabID + "/" + baseNetworkable.prefabID + " -> " + base.gameObject, base.gameObject);
			}
		}
	}

```

## OnBuildingSplit(BuildingManager.Building,uint)

```csharp
/// <summary>
/// Called when a building is split into multiple parts.
/// </summary>
/// <param name="building">The original building being split.</param>
/// <param name="newID">The ID of the new building created by splitting the original building.</param>
/// <returns>No return behavior.</returns>
void OnBuildingSplit(BuildingManager.Building building, uint newID)
{
    Puts($"Building {building.buildingID} has been split into a new building with ID {newID}");
}
```

### Source Code from the Library

```csharp

	private void Split(Building building)
	{
		while (building.HasBuildingBlocks())
		{
			BuildingBlock buildingBlock = building.buildingBlocks[0];
			uint newID = BuildingManager.server.NewBuildingID();
			Interface.CallHook("OnBuildingSplit", building, newID);
			buildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)
			{
				b.AttachToBuilding(newID);
			});
		}
		while (building.HasBuildingPrivileges())
		{
			BuildingPrivlidge buildingPrivlidge = building.buildingPrivileges[0];
			BuildingBlock nearbyBuildingBlock = buildingPrivlidge.GetNearbyBuildingBlock();
			buildingPrivlidge.AttachToBuilding(nearbyBuildingBlock ? nearbyBuildingBlock.buildingID : 0u);
		}
		while (building.HasDecayEntities())
		{
			DecayEntity decayEntity = building.decayEntities[0];
			BuildingBlock nearbyBuildingBlock2 = decayEntity.GetNearbyBuildingBlock();
			decayEntity.AttachToBuilding(nearbyBuildingBlock2 ? nearbyBuildingBlock2.buildingID : 0u);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(building, ref ticks, 0);
		}
	}

```

## OnPortalUsed(BasePlayer,BasePortal)

```csharp
/// <summary>
/// Called when a player uses a portal.
/// </summary>
/// <param name="player">The player using the portal.</param>
/// <param name="portal">The portal being used.</param>
/// <returns>No return behavior.</returns>
void OnPortalUsed(BasePlayer player, BasePortal portal)
{
    Puts($"Player {player.UserIDString} used portal {portal.name}");
}
```

### Source Code from the Library

```csharp

	public virtual void UsePortal(BasePlayer player)
	{
		if (Interface.CallHook("OnPortalUse", player, this) != null)
		{
			return;
		}
		LinkPortal();
		if (targetPortal != null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			Vector3 position = player.transform.position;
			Vector3 vector = targetPortal.GetLocalEntryExitPosition();
			Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 vector3 = vector2;
			if (isMirrored)
			{
				Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);
				vector = targetPortal.relativeAnchor.transform.TransformPoint(position2);
				vector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);
			}
			else
			{
				vector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, vector, Vector3.up);
			}
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(vector);
			player.ForceUpdateTriggers();
			player.ClientRPC(RpcTarget.Player("ForceViewAnglesTo", player), vector3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			player.ClientRPC(RpcTarget.Player("StartLoading_Quick", player), arg1: true);
			Interface.CallHook("OnPortalUsed", player, this);
		}
		else
		{
			Debug.Log("No portal...");
		}
	}

```

## CanHackCrate(BasePlayer,HackableLockedCrate)

```csharp
/// <summary>
/// Called to determine if a player can hack a locked crate.
/// </summary>
/// <param name="player">The player attempting to hack the crate.</param>
/// <param name="crate">The locked crate being hacked.</param>
/// <returns>Returns null if the default behavior is allowed, otherwise returns a non-null value indicating that the default behavior should be overridden.</returns>
object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
{
    Puts("CanHackCrate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", msg.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);
			originalHackerPlayerId = msg.player.userID;
			originalHackerPlayer = msg.player;
			StartHacking();
		}
	}

```

## OnTurretToggle(AutoTurret)

```csharp
/// <summary>
/// Called when the turret's online status is toggled.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <returns>No return behavior.</returns>
void OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret.GetId()} has been {(turret.IsOn() ? "enabled" : "disabled")}");
}
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != IsOn() && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			if (online)
			{
				TryRegisterForInterferenceUpdate();
			}
			else
			{
				SetFlag(Flags.OnFire, b: false);
				UpdateInterferenceOnOthers();
			}
			booting = false;
			GetAttachedWeapon()?.SetLightsOn(online);
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
				authDirty = true;
			}
		}
	}

```

## OnPlayerInput(BasePlayer,InputState)

```csharp
Документация для OnPlayerInput(BasePlayer, InputState)

### Описание хука

Хук `OnPlayerInput` вызывается в методе `OnReceiveTick` и предназначен для обрабатывания ввода игрока. Он принимает два параметра: `BasePlayer` - объект игрока и `InputState` - текущее состояние ввода.

### Параметры

*   `BasePlayer`: Объект игрока.
*   `InputState`: Текущее состояние ввода.

### Документация метода

```csharp
/// <summary>
/// Хук вызывается в методе OnReceiveTick и предназначен для обрабатывания ввода игрока.
/// </summary>
/// <param name="player">Объект игрока.</param>
/// <param name="inputState">Текущее состояние ввода.</param>
public void OnPlayerInput(BasePlayer player, InputState inputState)
{
    // Код для обрабатывания ввода игрока
}
```

### Пример использования

```csharp
private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
{
    if (msg.inputState != null)
    {
        serverInput.Flip(msg.inputState);
    }
    
    // Вызов хука OnPlayerInput
    if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
    {
        return;
    }
    
    // Остальной код метода...
}
```

### Примечания

*   Хук `OnPlayerInput` вызывается в методе `OnReceiveTick`, поэтому убедитесь, что вы понимаете логику этого метода и как он взаимодействует с хуком.
*   В параметрах хука указаны два аргумента: `BasePlayer` и `InputState`. Убедитесь, что вы понимаете, что эти параметры представляют собой и что они используются в методе.
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		if (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)
		{
			UpdateActiveItem(restraintItemId.Value);
		}
		else
		{
			UpdateActiveItem(msg.activeItem);
		}
		UpdateModelStateFromTick(msg);
		if (IsIncapacitated())
		{
			return;
		}
		if (isMounted)
		{
			GetMounted().PlayerServerInput(serverInput, this);
		}
		UpdatePositionFromTick(msg, wasPlayerStalled);
		UpdateRotationFromTick(msg);
		int activeMission = GetActiveMission();
		if (activeMission >= 0 && activeMission < missions.Count)
		{
			BaseMission.MissionInstance missionInstance = missions[activeMission];
			if (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())
			{
				ProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);
			}
		}
		if (!TutorialIsland.EnforceTrespassChecks || IsAdmin || IsNpc || net == null || net.group == null)
		{
			return;
		}
		if (net.group.restricted)
		{
			bool flag = false;
			if (!IsInTutorial)
			{
				flag = true;
			}
			else
			{
				TutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();
				if (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)
				{
					flag = true;
				}
			}
			if (flag)
			{
				tutorialKickTime += UnityEngine.Time.deltaTime;
				if (tutorialKickTime > 3f)
				{
					Debug.LogWarning($"Killing player {displayName}/{userID} as they are on a tutorial island that doesn't belong them");
					Hurt(999f);
					tutorialKickTime = 0f;
				}
			}
			else
			{
				tutorialKickTime = 0f;
			}
		}
		else
		{
			if (!IsInTutorial || net.group.restricted)
			{
				return;
			}
			bool flag2 = false;
			TutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();
			if (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)
			{
				flag2 = true;
			}
			if (flag2)
			{
				tutorialKickTime += UnityEngine.Time.deltaTime;
				if (tutorialKickTime > 3f)
				{
					Debug.LogWarning($"Killing player {displayName}/{userID} as they are no longer on a tutorial island and are marked as being in a tutorial");
					Hurt(999f);
					tutorialKickTime = 0f;
				}
			}
			else
			{
				tutorialKickTime = 0f;
			}
		}
	}

```

## CanTrainCarCouple(TrainCar,TrainCar)

```csharp
/// <summary>
/// Called when a train car attempts to couple with another train car.
/// </summary>
/// <param name="car1">The first train car.</param>
/// <param name="car2">The second train car.</param>
/// <returns>Returns true if the coupling is allowed, false otherwise.</returns>
bool CanTrainCarCouple(TrainCar car1, TrainCar car2)
{
    Puts("CanTrainCarCouple called!");
    // Return true or false based on the specific logic for this hook
    return true; // Replace with actual logic
}
```

### Source Code from the Library

```csharp

	public bool TryCouple(TrainCoupling theirCoupling, bool reflect)
	{
		if (!isValid)
		{
			return false;
		}
		if (CoupledTo == theirCoupling)
		{
			return true;
		}
		if (IsCoupled)
		{
			return false;
		}
		object obj = Interface.CallHook("CanTrainCarCouple", owner, theirCoupling.owner);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (reflect && !theirCoupling.TryCouple(this, reflect: false))
		{
			return false;
		}
		controller.OnPreCouplingChange();
		CoupledTo = theirCoupling;
		owner.SetFlag(flag, b: true, recursive: false, networkupdate: false);
		owner.SendNetworkUpdate();
		return true;
	}

```

## OnFlameExplosion(FlameExplosive,UnityEngine.Collider)

```csharp
/// <summary>
/// Called when a flame explosion occurs.
/// </summary>
/// <param name="flameExplosive">The flame explosive that exploded.</param>
/// <param name="collider">The collider of the flame explosive.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnFlameExplosion(FlameExplosive flameExplosive, UnityEngine.Collider collider)
{
    Puts("OnFlameExplosion hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void FlameExplode(Vector3 surfaceNormal)
	{
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = base.transform.position;
		if (blockCreateUnderwater && WaterLevel.Test(position, waves: true, volumes: false))
		{
			base.Explode();
			return;
		}
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);
			if ((bool)baseEntity)
			{
				float num = (float)i / numToCreate;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);
				baseEntity.transform.SetPositionAndRotation(position, Quaternion.LookRotation(modifiedAimConeDirection));
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				baseEntity.Spawn();
				Interface.CallHook("OnFlameExplosion", this, component);
				Vector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * UnityEngine.Random.Range(1f, 1.1f));
				FireBall component2 = baseEntity.GetComponent<FireBall>();
				if (component2 != null)
				{
					component2.SetDelayedVelocity(vector);
				}
				else
				{
					baseEntity.SetVelocity(vector);
				}
			}
		}
		base.Explode();
	}

```

## OnEntityMounted(BaseMountable,BasePlayer)

```csharp
/// <summary>
/// Called when an entity is mounted by a player.
/// </summary>
/// <param name="entity">The entity being mounted.</param>
/// <param name="player">The player mounting the entity.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityMounted(BaseMountable entity, BasePlayer player)
{
    Puts("OnEntityMounted is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform transform = mountAnchor;
			player.MountObject(this);
			player.MovePosition(transform.position);
			player.transform.rotation = transform.rotation;
			player.ServerRotation = transform.rotation;
			player.OverrideViewAngles(transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(transform.rotation);
			player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), player.transform.position);
			Facepunch.Rust.Analytics.Azure.OnMountEntity(player, this, VehicleParent());
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
			if (this.IsValid() && player.IsValid())
			{
				player.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);
			}
		}
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that was locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign} locked by player {player}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## OnCorpsePopulate(HumanNPC,NPCPlayerCorpse)

```csharp
/// <summary>
/// Called when a new corpse is populated with data.
/// </summary>
/// <param name="npc">The Human NPC that died.</param>
/// <param name="corpse">The NPC's corpse.</param>
/// <returns>Returns the populated corpse, or null if no population occurred.</returns>
object OnCorpsePopulate(HumanNPC npc, NPCPlayerCorpse corpse)
{
    // Minimal code to demonstrate functionality
    Puts("OnCorpsePopulate is working!");
    
    return corpse;
}
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse("assets/prefabs/npc/scientist/scientist_corpse.prefab", flagsOnDeath, modelState) as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				if (NavAgent != null)
				{
					nPCPlayerCorpse.transform.position += Vector3.down * NavAgent.baseOffset;
				}
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);
				nPCPlayerCorpse.playerName = OverrideCorpseName();
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				nPCPlayerCorpse.TakeChildren(this);
				for (int i = 0; i < nPCPlayerCorpse.containers.Length; i++)
				{
					ItemContainer itemContainer = nPCPlayerCorpse.containers[i];
					if (i != 1)
					{
						itemContainer.Clear();
					}
				}
				object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
				if (obj is BaseCorpse)
				{
					return (BaseCorpse)obj;
				}
				if (LootSpawnSlots.Length != 0)
				{
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int j = 0; j < lootSpawnSlots.Length; j++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[j];
						for (int k = 0; k < lootSpawnSlot.numberToSpawn; k++)
						{
							if ((string.IsNullOrEmpty(lootSpawnSlot.onlyWithLoadoutNamed) || lootSpawnSlot.onlyWithLoadoutNamed == GetLoadoutName()) && UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## CanUpdateSign(BasePlayer,PhotoFrame)

```csharp
/// <summary>
/// Called when a player attempts to update the sign of a PhotoFrame.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="photoFrame">The PhotoFrame whose sign is being updated.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
object CanUpdateSign(BasePlayer player, PhotoFrame photoFrame)
{
    Puts("CanUpdateSign is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

```

## CanHelicopterDropCrate(CH47HelicopterAIController)

```csharp
/// <summary>
/// Called to determine if a helicopter can drop a crate.
/// </summary>
/// <param name="controller">The CH47HelicopterAIController instance.</param>
/// <returns>Returns true if the helicopter can drop a crate, and false otherwise.</returns>
bool CanHelicopterDropCrate(CH47HelicopterAIController controller)
{
    Puts("CanHelicopterDropCrate is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
/// <summary>
/// Called when the oven is toggled on or off.
/// </summary>
/// <param name="oven">The oven being toggled.</param>
/// <param name="player">The player who triggered the toggle.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts("OnOvenToggle is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	protected virtual void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnOvenToggle", this, msg.player) != null || flag == IsOn() || (needsBuildingPrivilegeToUse && !msg.player.CanBuild()))
		{
			return;
		}
		if (flag)
		{
			StartCooking();
			if (msg.player != null)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.STARTOVEN, new BaseMission.MissionEventPayload
				{
					UintIdentifier = prefabID,
					NetworkIdentifier = net.ID
				}, 1f);
			}
		}
		else
		{
			StopCooking();
		}
	}

```

## OnExplosiveDud(DudTimedExplosive)

```csharp
/// <summary>
/// Called when a timed explosive device fails to detonate and becomes a dud.
/// </summary>
/// <param name="dud">The timed explosive device that became a dud.</param>
/// <returns>Returns the dud object, allowing for further processing or logging.</returns>
object OnExplosiveDud(DudTimedExplosive dud)
{
    Puts("OnExplosiveDud called!");
    return dud;
}
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		if (creatorEntity != null && creatorEntity.IsNpc)
		{
			base.Explode();
		}
		else if (UnityEngine.Random.Range(0f, 1f) < dudChance && Interface.CallHook("OnExplosiveDud", this) == null)
		{
			BecomeDud();
		}
		else
		{
			base.Explode();
		}
	}

```

## OnGiveSoldItem(VendingMachine,Item,BasePlayer)

```csharp
/// <summary>
/// Called when a sold item is given to a player.
/// </summary>
/// <param name="vendingMachine">The vending machine that sold the item.</param>
/// <param name="item">The item being given to the player.</param>
/// <param name="player">The player receiving the item.</param>
/// <returns>No return behavior.</returns>
void OnGiveSoldItem(VendingMachine vendingMachine, Item item, BasePlayer player)
{
    Puts($"Item {item.name} sold to player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", this, soldItem, buyer) == null)
		{
			while (soldItem.amount > soldItem.MaxStackable())
			{
				Item item = soldItem.SplitItem(soldItem.MaxStackable());
				buyer.GiveItem(item, GiveItemReason.PickedUp);
			}
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

```

## OnPlayerCorpseSpawned(BasePlayer,PlayerCorpse)

```csharp
/// <summary>
/// Called when a player's corpse is spawned.
/// </summary>
/// <param name="player">The player whose corpse was spawned.</param>
/// <param name="corpse">The player's corpse.</param>
/// <returns>No return behavior.</returns>
void OnPlayerCorpseSpawned(BasePlayer player, PlayerCorpse corpse)
{
    Puts($"Player {player.displayName}'s corpse has been spawned.");
}
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? "assets/prefabs/player/player_corpse.prefab" : "assets/prefabs/player/player_corpse_new.prefab");
			bool flag = false;
			if (ConVar.Global.cinematicGingerbreadCorpses)
			{
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);
						flag = component.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.streamerName = RandomUsernames.Get(userID);
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				if (!CollectionEx.IsNullOrEmpty(triggersOnDeath))
				{
					foreach (TriggerBase item2 in triggersOnDeath)
					{
						if (item2 is TriggerParent triggerParent)
						{
							triggerParent.ForceParentEarly(playerCorpse);
						}
					}
				}
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			UnityEngine.Random.State state = UnityEngine.Random.state;
			UnityEngine.Random.InitState((int)(seed + steamid));
			float result = UnityEngine.Random.Range(0f, 1f);
			UnityEngine.Random.state = state;
			return result;
		}
	}

```

## OnNpcTargetSense(BaseEntity,BaseEntity,AIBrainSenses)

```csharp
/// <summary>
/// Called when an NPC senses a target.
/// </summary>
/// <param name="npc">The NPC sensing the target.</param>
/// <param name="target">The entity being sensed as a target.</param>
/// <param name="senses">The AI brain senses used to determine if the entity is a threat or not.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool OnNpcTargetSense(BaseEntity npc, BaseEntity target, AIBrainSenses senses)
{
    Puts("OnNpcTargetSense called!");
    
    // If the NPC has already sensed this entity as a threat, return immediately
    if (senses.IsThreat(target))
    {
        return true;
    }
    
    // Add the entity to the list of seen entities
    All.Add(new SeenInfo
    {
        Entity = target,
        Position = target.transform.position,
        Timestamp = UnityEngine.Time.realtimeSinceStartup
    });
    
    return false;
}
```

### Source Code from the Library

```csharp

	public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)
	{
		if (Interface.CallHook("OnNpcTargetSense", owner, ent, brainSenses) != null)
		{
			return;
		}
		IAISenses iAISenses = owner as IAISenses;
		BasePlayer basePlayer = ent as BasePlayer;
		if (basePlayer != null && PlayerIgnoreList.Contains(basePlayer))
		{
			return;
		}
		bool flag = false;
		if (iAISenses != null && iAISenses.IsThreat(ent))
		{
			flag = true;
			if (brainSenses != null)
			{
				brainSenses.LastThreatTimestamp = UnityEngine.Time.realtimeSinceStartup;
			}
		}
		for (int i = 0; i < All.Count; i++)
		{
			if (All[i].Entity == ent)
			{
				SeenInfo value = All[i];
				value.Position = ent.transform.position;
				value.Timestamp = Mathf.Max(UnityEngine.Time.realtimeSinceStartup, value.Timestamp);
				All[i] = value;
				return;
			}
		}
		if (basePlayer != null)
		{
			if (ConVar.AI.ignoreplayers && !basePlayer.IsNpc)
			{
				return;
			}
			Players.Add(ent);
		}
		if (iAISenses != null)
		{
			if (iAISenses.IsTarget(ent))
			{
				Targets.Add(ent);
			}
			if (iAISenses.IsFriendly(ent))
			{
				Friendlies.Add(ent);
			}
			if (flag)
			{
				Threats.Add(ent);
			}
		}
		All.Add(new SeenInfo
		{
			Entity = ent,
			Position = ent.transform.position,
			Timestamp = UnityEngine.Time.realtimeSinceStartup
		});
	}

```

## OnSleepingBagValidCheck(SleepingBag,ulong,bool)

```csharp
/// <summary>
/// Called to validate a sleeping bag.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being validated.</param>
/// <param name="playerID">The ID of the player validating the sleeping bag.</param>
/// <param name="ignoreTimers">Whether to ignore timers when validating the sleeping bag.</param>
/// <returns>Returns true if the sleeping bag is valid, false otherwise. If a custom validation rule is provided, returns the result of that rule.</returns>
object OnSleepingBagValidCheck(SleepingBag sleepingBag, ulong playerID, bool ignoreTimers)
{
    // Minimal code to demonstrate functionality
    Puts("OnSleepingBagValidCheck called!");
    
    // Return true if a custom validation rule is provided (not applicable in this case)
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		object obj = Interface.CallHook("OnSleepingBagValidCheck", this, playerID, ignoreTimers);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (deployerUserID == playerID)
		{
			if (!ignoreTimers)
			{
				return unlockTime < UnityEngine.Time.realtimeSinceStartup;
			}
			return true;
		}
		return false;
	}

```

## CanTakeCutting(BasePlayer,GrowableEntity)

```csharp
/// <summary>
/// Called when a player attempts to take a cutting from the growable entity.
/// </summary>
/// <param name="player">The player attempting to take the cutting.</param>
/// <param name="entity">The growable entity being harvested.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object CanTakeCutting(BasePlayer player, GrowableEntity entity)
{
    Puts("CanTakeCutting is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void TakeClones(BasePlayer player)
	{
		if (player == null || !CanClone() || Interface.CallHook("CanTakeCutting", player, this) != null)
		{
			return;
		}
		int num = Properties.BaseCloneCount + Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;
		if (num > 0)
		{
			Item item = ItemManager.Create(Properties.CloneItem, num, 0uL);
			GrowableGeneEncoding.EncodeGenesToItem(this, item);
			Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
			if (Properties.pickEffect.isValid)
			{
				Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
			}
			Die();
		}
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
/// <summary>
/// Called to determine if an NPC wants to eat a given entity.
/// </summary>
/// <param name="npc">The NPC in question.</param>
/// <param name="entity">The entity the NPC is considering eating.</param>
/// <returns>Returns true if the NPC wants to eat the entity, false otherwise.</returns>
bool CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts("CanNpcEat called!");
    return true; // Default behavior
}
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnMlrsTargetSet(MLRS,UnityEngine.Vector3,BasePlayer)

```csharp
/// <summary>
/// Called when a target is set for the MLRS.
/// </summary>
/// <param name="user">The user who set the target.</param>
/// <param name="worldPos">The position of the target in world coordinates.</param>
/// <param name="mounted">Whether the target is mounted or not.</param>
/// <returns>No return behavior.</returns>
void OnMlrsTargetSet(BasePlayer user, Vector3 worldPos, bool mounted)
{
    Puts($"MLRS target set at {worldPos} for user {user}");
}
```

### Source Code from the Library

```csharp

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 vector = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", this, worldPos, _mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Vector3 center = allSafeZone.triggerCollider.bounds.center;
				center.y = 0f;
				float num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 vector2 = trueTargetHitPos - center;
					trueTargetHitPos = center + vector2.normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", this, trueTargetHitPos, _mounted);
	}

```

## OnBookmarkDelete(ComputerStation,BasePlayer,string)

```csharp
/// <summary>
/// Called when a bookmark is deleted.
/// </summary>
/// <param name="station">The computer station where the deletion occurred.</param>
/// <param name="player">The player who initiated the deletion.</param>
/// <param name="bookmarkName">The name of the deleted bookmark.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkDelete(ComputerStation station, BasePlayer player, string bookmarkName)
{
    Puts($"Bookmark '{bookmarkName}' deleted by {player.UserIDString} at {station.GetWorldPosition().ToString()}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DeleteBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		string text = msg.read.String();
		if (IsValidIdentifier(text) && controlBookmarks.Contains(text) && Interface.CallHook("OnBookmarkDelete", this, player, text) == null)
		{
			controlBookmarks.Remove(text);
			SendControlBookmarks(player);
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if (baseEntity != null && baseEntity.TryGetComponent<IRemoteControllable>(out var component) && component.GetIdentifier() == text)
			{
				StopControl(player);
			}
		}
	}

```

## OnStashHidden(StashContainer,BasePlayer)

```csharp
/// <summary>
/// Called when a stash is hidden.
/// </summary>
/// <param name="stash">The stash container being hidden.</param>
/// <param name="player">The player hiding the stash.</param>
/// <returns>No return behavior.</returns>
void OnStashHidden(StashContainer stash, BasePlayer player)
{
    Puts($"Stash hidden by {player.UserIDString} at {stash.transform.position}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", rpc.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", this, rpc.player);
		}
	}

```

## OnExperimentEnd(Workbench)

```csharp
/// <summary>
/// Called when an experiment is completed.
/// </summary>
/// <param name="workbench">The workbench where the experiment was performed.</param>
/// <returns>No return behavior.</returns>
void OnExperimentEnd(Workbench workbench)
{
    Puts("OnExperimentEnd is working!");
}
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
/// <summary>
/// Called when a player lands after falling.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="velocity">The velocity of the fall.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerLand(BasePlayer player, float velocity)
{
    Puts("OnPlayerLand hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Facepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
/// <summary>
/// Called when an entity is spawned.
/// </summary>
/// <param name="entity">The spawned entity.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntitySpawned(BaseNetworkable entity)
{
    Puts("OnEntitySpawned is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		EntityProfiler.spawned++;
		if (EntityProfiler.mode >= 2)
		{
			EntityProfiler.OnSpawned(this);
		}
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		ServerInitPostNetworkGroupAssign();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		Invoke(SendGlobalNetworkUpdate, 0f);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that died.</param>
/// <param name="info">Information about the death event.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityDeath(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity} died.");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
		}
		health = 0f;
		lifestate = LifeState.Dead;
		Interface.CallHook("OnEntityDeath", this, info);
		if (info != null && (bool)info.InitiatorPlayer)
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)
			{
				initiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, prefabID, 1f);
			}
		}
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## CanResearchItem(BasePlayer,Item)

```csharp
/// <summary>
/// Called when a player attempts to research an item.
/// </summary>
/// <param name="player">The player attempting to research the item.</param>
/// <param name="item">The item being researched.</param>
/// <returns>Returns null if the default behavior is not overridden, indicating that the research can proceed.</returns>
object CanResearchItem(BasePlayer player, Item item)
{
    // Minimal code to demonstrate functionality
    Puts("CanResearchItem called!");
    
    // If no return value is specified, the method will return null by default
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Facepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnBonusItemDropped(Item,BasePlayer)

```csharp
/// <summary>
/// Called when a bonus item is dropped.
/// </summary>
/// <param name="item">The dropped item.</param>
/// <param name="player">The player who dropped the item.</param>
/// <returns>No return behavior.</returns>
void OnBonusItemDropped(Item item, BasePlayer player)
{
    Puts($"Bonus item {item} dropped by player {player}");
}
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Called when a hammer hits an entity.
/// </summary>
/// <param name="player">The player wielding the hammer.</param>
/// <param name="hitInfo">Information about the hit, including the entity and impact location.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnHammerHit(BasePlayer player, HitInfo hitInfo)
{
    Puts("OnHammerHit is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null && ownerPlayer != null && base.isServer)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			using (TimeWarning.New("DoRepair", 50))
			{
				baseCombatEntity.DoRepair(ownerPlayer);
			}
		}
		info.DoDecals = false;
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## OnBuildingPrivilege(BaseEntity,OBB)

```csharp
/// <summary>
/// Called when a privilege check for a building is performed.
/// </summary>
/// <param name="entity">The entity performing the privilege check.</param>
/// <param name="obb">The OBB (oriented bounding box) of the building being checked.</param>
/// <returns>The BuildingPrivilege associated with the building, or null if no privilege is found.</returns>
BuildingPrivilege OnBuildingPrivilege(BaseEntity entity, OBB obb)
{
    Puts("OnBuildingPrivilege hook called!");
    
    // If a non-null value is returned from Interface.CallHook, it will be used to determine the return type
    object obj = Interface.CallHook("OnBuildingPrivilege", entity, obb);
    
    if (obj is BuildingPrivilege)
    {
        return (BuildingPrivilege)obj;
    }
    
    // If no privilege is found, return null
    return null;
}
```

### Source Code from the Library

```csharp

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
	{
		object obj = Interface.CallHook("OnBuildingPrivilege", this, obb);
		if (obj is BuildingPrivlidge)
		{
			return (BuildingPrivlidge)obj;
		}
		BuildingBlock other = null;
		BuildingPrivlidge result = null;
		List<BuildingBlock> obj2 = Facepunch.Pool.GetList<BuildingBlock>();
		Vis.Entities(obb.position, 16f + obb.extents.magnitude, obj2, 2097152);
		for (int i = 0; i < obj2.Count; i++)
		{
			BuildingBlock buildingBlock = obj2[i];
			if (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) > 16f)
			{
				continue;
			}
			BuildingManager.Building building = buildingBlock.GetBuilding();
			if (building != null)
			{
				BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
				if (!(dominatingBuildingPrivilege == null))
				{
					other = buildingBlock;
					result = dominatingBuildingPrivilege;
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		return result;
	}

```

## OnTeamAcceptInvite(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
/// <summary>
/// Called when a player accepts an invitation to join a team.
/// </summary>
/// <param name="team">The team being joined.</param>
/// <param name="player">The player accepting the invitation.</param>
/// <returns>No return behavior.</returns>
void OnTeamAcceptInvite(PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.UserID} accepted invite to join team {team.Name}");
}
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void acceptinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamAcceptInvite", playerTeam, basePlayer) == null)
			{
				playerTeam.AcceptInvite(basePlayer);
			}
		}
	}

```

## OnBradleyApcThink(BradleyAPC)

```csharp
/// <summary>
/// Called when the Bradley APC thinks.
/// </summary>
/// <param name="apc">The Bradley APC instance.</param>
/// <returns>No return behavior.</returns>
void OnBradleyApcThink(BradleyAPC apc)
{
    Puts("OnBradleyApcThink is working!");
}
```

### Source Code from the Library

```csharp

	public void DoSimpleAI()
	{
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
		if (Interface.CallHook("OnBradleyApcThink", this) != null || !DoAI)
		{
			return;
		}
		SetTarget();
		if (mountingScientists || inDeployedState)
		{
			ClearPath();
		}
		else if (targetList.Count > 0)
		{
			UpdateMovement_Hunt();
		}
		else
		{
			UpdateMovement_Patrol();
		}
		AdvancePathMovement(force: false);
		float num = Vector3.Distance(base.transform.position, destination);
		float value = Vector3.Distance(base.transform.position, finalDestination);
		if (num > stoppingDist)
		{
			Vector3 lhs = Direction2D(destination, base.transform.position);
			float num2 = Vector3.Dot(lhs, base.transform.right);
			float num3 = Vector3.Dot(lhs, base.transform.right);
			float num4 = Vector3.Dot(lhs, -base.transform.right);
			if (Vector3.Dot(lhs, -base.transform.forward) > num2)
			{
				if (num3 >= num4)
				{
					turning = 1f;
				}
				else
				{
					turning = -1f;
				}
			}
			else
			{
				turning = Mathf.Clamp(num2 * 3f, -1f, 1f);
			}
			float throttleScaleFromTurn = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));
			AvoidObstacles(ref throttleScaleFromTurn);
			float num5 = Vector3.Dot(myRigidBody.velocity, base.transform.forward);
			if (!(throttle > 0f) || !(num5 < 0.5f))
			{
				timeSinceSeemingStuck = 0f;
			}
			else if ((float)timeSinceSeemingStuck > 10f)
			{
				timeSinceStuckReverseStart = 0f;
				timeSinceSeemingStuck = 0f;
			}
			float num6 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(base.transform.forward, Vector3.up));
			if ((float)timeSinceStuckReverseStart < 3f)
			{
				throttle = -0.75f;
				turning = 1f;
			}
			else
			{
				throttle = (0.1f + Mathf.InverseLerp(0f, 20f, value) * 1f) * throttleScaleFromTurn + num6;
			}
		}
		DoWeaponAiming();
		SendNetworkUpdate();
	}

```

## OnPlayerDeath(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Called when a player dies.
/// </summary>
/// <param name="player">The player who died.</param>
/// <param name="info">Information about the death event.</param>
/// <returns>The return value of the hook, or null if no custom behavior was provided.</returns>
object OnPlayerDeath(BasePlayer player, HitInfo info)
{
    Puts("OnPlayerDeath is working!");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead())
			{
				Handcuffs restraintItem = Belt.GetRestraintItem();
				if (restraintItem != null)
				{
					restraintItem.HeldWhenOwnerDied(this);
				}
				if (Belt != null && ShouldDropActiveItem())
				{
					Vector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + vector.normalized * 3f);
					inventory.DropBackpackOnDeath();
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDeath", this, info) == null)
				{
					SleepingBag.OnPlayerDeath(this);
					base.Die(info);
				}
			}
		}
	}

```

## OnVendingShopOpened(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine that was opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpened(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending shop opened by {player} at {vendingMachine}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", this, msg.player) == null)
		{
			OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", this, msg.player);
		}
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
/// <summary>
/// Called when a player starts looting an entity.
/// </summary>
/// <param name="player">The player performing the loot action.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnLootEntity(BasePlayer player, BaseEntity entity)
{
    Puts("OnLootEntity hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!targetEntity)
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		MarkDirty();
		if (targetEntity is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = base.baseEntity.userID;
		}
		return true;
	}

```

## OnMissionFailed(BaseMission,BaseMission.MissionInstance,BasePlayer,BaseMission.MissionFailReason)

```csharp
/// <summary>
/// Called when a mission fails.
/// </summary>
/// <param name="mission">The mission that failed.</param>
/// <param name="instance">The mission instance that failed.</param>
/// <param name="assignee">The player who was assigned the mission.</param>
/// <param name="failReason">The reason why the mission failed.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnMissionFailed(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee, BaseMission.MissionFailReason failReason)
{
    Puts("OnMissionFailed hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
	{
		if (!instance.GetMission().completeSilently)
		{
			assignee.ChatMessage("You have failed the mission : " + missionName.english);
		}
		DoMissionEffect(failedEffect.resourcePath, assignee);
		Facepunch.Rust.Analytics.Server.MissionFailed(this, failReason);
		Facepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, failReason);
		instance.status = MissionStatus.Failed;
		MissionEnded(instance, assignee);
		Interface.CallHook("OnMissionFailed", this, instance, assignee, failReason);
	}

```

## OnReactiveTargetReset(ReactiveTarget)

```csharp
/// <summary>
/// Called when the reactive target is reset.
/// </summary>
/// <param name="target">The reactive target being reset.</param>
/// <returns>No return behavior.</returns>
void OnReactiveTargetReset(ReactiveTarget target)
{
    Puts("OnReactiveTargetReset is working!");
}
```

### Source Code from the Library

```csharp

	public void ResetTarget()
	{
		if (IsLowered() && CanToggle() && CanReset())
		{
			CancelInvoke(ResetTarget);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Reserved1, b: false);
			knockdownHealth = 100f;
			SendPowerBurst();
			Interface.CallHook("OnReactiveTargetReset", this);
		}
	}

```

## CanDeployScientists(BradleyAPC,BaseEntity,System.Collections.Generic.List<GameObjectRef>,System.Collections.Generic.List<UnityEngine.Vector3>)

```csharp
/// <summary>
/// Called when a player attempts to deploy scientists.
/// </summary>
/// <param name="attacker">The entity attempting to deploy the scientists.</param>
/// <param name="scientistPrefabs">A list of scientist prefabs to be deployed.</param>
/// <param name="spawnPositions">A list of positions where the scientists will be spawned.</param>
/// <returns>Returns a boolean value indicating whether the deployment is allowed or not.</returns>
bool CanDeployScientists(BaseEntity attacker, List<GameObjectRef> scientistPrefabs, List<UnityEngine.Vector3> spawnPositions)
{
    // Minimal code to demonstrate functionality
    Puts("CanDeployScientists hook called!");
    
    // Return true if the default behavior is overridden
    return true;
}
```

### Source Code from the Library

```csharp

	private bool CanDeployScientists(BaseEntity attacker, List<GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)
	{
		object obj = Interface.CallHook("CanDeployScientists", this, attacker, scientistPrefabs, spawnPositions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int count = scientistPrefabs.Count;
		if (!inDeployedState && Vector3.Distance(attacker.transform.position, base.transform.position) > DeployAttackDistanceMax)
		{
			return false;
		}
		spawnPositions.Clear();
		bool flag = false;
		int num = 0;
		int num2 = 0;
		int layerMask = 8454144;
		while (!flag)
		{
			if (UnityEngine.Physics.Raycast(ScientistSpawnPoints[num2 % ScientistSpawnPoints.Count].transform.position + Vector3.up * 1f, Vector3.down, out var hitInfo, 2f, layerMask) && NavMesh.SamplePosition(hitInfo.point + Vector3.up * 0.3f, out var _, 6f, walkableAreaMask))
			{
				spawnPositions.Add(hitInfo.point + Vector3.up * 0.1f);
				num2++;
				if (num2 >= count)
				{
					break;
				}
			}
			else
			{
				num++;
				if (num > count * 2)
				{
					flag = true;
				}
			}
		}
		return !flag;
	}

```

## OnTeamInvite(BasePlayer,BasePlayer)

```csharp
/// <summary>
/// Called when a player is invited to join another player's team.
/// </summary>
/// <param name="inviter">The player inviting the other player to join their team.</param>
/// <param name="invitee">The player being invited to join the team.</param>
/// <returns>No return behavior.</returns>
void OnTeamInvite(BasePlayer inviter, BasePlayer invitee)
{
    Puts($"Player {inviter.UserIDString} invited player {invitee.UserIDString} to join their team.");
}
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void sendinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer)
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			return;
		}
		BasePlayer basePlayer2 = BaseNetworkable.serverEntities.Find(new NetworkableId(uLong)) as BasePlayer;
		if ((bool)basePlayer2 && basePlayer2 != basePlayer && !basePlayer2.IsNpc && basePlayer2.currentTeam == 0L)
		{
			float num = 7f;
			if (!(Vector3.Distance(basePlayer2.transform.position, basePlayer.transform.position) > num) && Interface.CallHook("OnTeamInvite", basePlayer, basePlayer2) == null)
			{
				playerTeam.SendInvite(basePlayer2);
			}
		}
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
/// <summary>
/// Called when a player lands after falling.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="velocity">The velocity of the fall.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerLanded(BasePlayer player, float velocity)
{
    Puts($"Player {player.UserIDString} landed with velocity {velocity}");
    return null;
}
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Facepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnPlayerSetInfo(Network.Connection,string,string)

```csharp
/// <summary>
/// Called when a player's information is updated.
/// </summary>
/// <param name="connection">The player's network connection.</param>
/// <param name="key">The key of the information being updated.</param>
/// <param name="value">The new value of the information.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerSetInfo(Network.Connection connection, string key, string value)
{
    Puts($"Player's info updated: {key} = {value}");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void SetInfo(string key, string val)
	{
		if (IsConnected)
		{
			Interface.CallHook("OnPlayerSetInfo", net.connection, key, val);
			net.connection.info.Set(key, val);
		}
	}

```

## OnStructureDemolish(StabilityEntity,BasePlayer,bool)

```csharp
/// <summary>
/// Called when a structure is demolished.
/// </summary>
/// <param name="entity">The stability entity being demolished.</param>
/// <param name="player">The player demolishing the structure.</param>
/// <param name="isPlayerDemolish">Whether the demolition was initiated by the player.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnStructureDemolish(StabilityEntity entity, BasePlayer player, bool isPlayerDemolish)
{
    Puts("OnStructureDemolish hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);
			Kill(DestroyMode.Gib);
		}
	}

```

## OnEntityStabilityCheck(StabilityEntity)

```csharp
/// <summary>
/// Called when the entity's stability is checked.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityStabilityCheck(StabilityEntity entity)
{
    Puts("OnEntityStabilityCheck is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void StabilityCheck()
	{
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			cachedDistanceFromGround = num;
			flag = true;
		}
		float num2 = SupportValue();
		if (Mathf.Abs(cachedStability - num2) > Stability.accuracy)
		{
			cachedStability = num2;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability();
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num2 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				UpdateStability();
				stabilityStrikes++;
			}
			else
			{
				Kill(DestroyMode.Gib);
			}
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

```

## CanSetBedPublic(BasePlayer,SleepingBag)

```csharp
/// <summary>
/// Called when a player attempts to set the public status of a sleeping bag.
/// </summary>
/// <param name="player">The player attempting to set the public status.</param>
/// <param name="sleepingBag">The sleeping bag being modified.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
bool CanSetBedPublic(BasePlayer player, SleepingBag sleepingBag)
{
    Puts("CanSetBedPublic is working!");
    return false;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public virtual void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != (ulong)msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag == IsPublic() || Interface.CallHook("CanSetBedPublic", msg.player, this) != null)
		{
			return;
		}
		SetPublic(flag);
		if (!IsPublic())
		{
			if (ConVar.Server.max_sleeping_bags > 0)
			{
				CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
				if (canAssignBedResult.HasValue)
				{
					if (canAssignBedResult.Value.Result == BagResultType.Ok)
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					else
					{
						msg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					}
					if (canAssignBedResult.Value.Result != 0)
					{
						return;
					}
				}
			}
			ulong num = deployerUserID;
			deployerUserID = msg.player.userID;
			NotifyPlayer(num);
			NotifyPlayer(deployerUserID);
			OnBagChangedOwnership(this, num);
			Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);
		}
		else
		{
			Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);
		}
		SendNetworkUpdate();
	}

```

## OnPatrolHelicopterKill(PatrolHelicopter,HitInfo)

```csharp
/// <summary>
/// Called when a patrol helicopter is killed.
/// </summary>
/// <param name="helicopter">The patrol helicopter that was killed.</param>
/// <param name="info">Information about the hit that caused the kill.</param>
/// <returns>No return behavior.</returns>
void OnPatrolHelicopterKill(PatrolHelicopter helicopter, HitInfo info)
{
    Puts($"Patrol helicopter {helicopter} was killed by a hit of type {info.damageTypes.Total()}");
}
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnPatrolHelicopterTakeDamage", this, info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			if (Interface.CallHook("OnPatrolHelicopterKill", this, info) != null)
			{
				return;
			}
			base.health = 10000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		myAI.OtherDamaged(info);
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

```

## OnRespawnInformationGiven(BasePlayer,System.Collections.Generic.List<ProtoBuf.RespawnInformation.SpawnOptions>)

```csharp
/// <summary>
/// Called when respawn information is given to the player.
/// </summary>
/// <param name="player">The player receiving the respawn information.</param>
/// <param name="spawnOptions">A list of spawn options available to the player.</param>
/// <returns>No return behavior.</returns>
void OnRespawnInformationGiven(BasePlayer player, List<ProtoBuf.RespawnInformation.SpawnOptions> spawnOptions)
{
    Puts($"Respawn information given to {player.UserIDString} with {spawnOptions.Count} spawn options.");
}
```

### Source Code from the Library

```csharp

	public void SendRespawnOptions()
	{
		if (NexusServer.Started && ZoneController.Instance.CanRespawnAcrossZones(this))
		{
			CollectExternalAndSend();
			return;
		}
		List<RespawnInformation.SpawnOptions> list = Facepunch.Pool.GetList<RespawnInformation.SpawnOptions>();
		GetRespawnOptionsForPlayer(list, userID);
		Interface.CallHook("OnRespawnInformationGiven", this, list);
		SendToPlayer(list, loading: false);
		async void CollectExternalAndSend()
		{
			List<RespawnInformation.SpawnOptions> list2 = Facepunch.Pool.GetList<RespawnInformation.SpawnOptions>();
			GetRespawnOptionsForPlayer(list2, userID);
			List<RespawnInformation.SpawnOptions> allSpawnOptions = Facepunch.Pool.GetList<RespawnInformation.SpawnOptions>();
			foreach (RespawnInformation.SpawnOptions item in list2)
			{
				allSpawnOptions.Add(item.Copy());
			}
			SendToPlayer(list2, loading: true);
			try
			{
				Request request = Facepunch.Pool.Get<Request>();
				request.spawnOptions = Facepunch.Pool.Get<SpawnOptionsRequest>();
				request.spawnOptions.userId = userID;
				using (NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(request, 10f))
				{
					foreach (KeyValuePair<string, Response> response in nexusRpcResult.Responses)
					{
						string key = response.Key;
						SpawnOptionsResponse spawnOptions2 = response.Value.spawnOptions;
						if (spawnOptions2 != null && spawnOptions2.spawnOptions.Count != 0)
						{
							foreach (RespawnInformation.SpawnOptions spawnOption in spawnOptions2.spawnOptions)
							{
								RespawnInformation.SpawnOptions spawnOptions3 = spawnOption.Copy();
								spawnOptions3.nexusZone = key;
								allSpawnOptions.Add(spawnOptions3);
							}
						}
					}
				}
				SendToPlayer(allSpawnOptions, loading: false);
			}
			catch (Exception exception)
			{
				Debug.LogException(exception);
			}
		}
		void SendToPlayer(List<RespawnInformation.SpawnOptions> spawnOptions, bool loading)
		{
			using RespawnInformation respawnInformation = Facepunch.Pool.Get<RespawnInformation>();
			respawnInformation.spawnOptions = spawnOptions;
			respawnInformation.loading = loading;
			if (ConVar.Server.max_shelters == LegacyShelter.FpShelterDefault && LegacyShelter.SheltersPerPlayer.ContainsKey(userID) && LegacyShelter.SheltersPerPlayer[userID].Count > 0)
			{
				respawnInformation.shelterPositions = Facepunch.Pool.GetList<Vector3>();
				foreach (LegacyShelter item2 in LegacyShelter.SheltersPerPlayer[userID])
				{
					respawnInformation.shelterPositions.Add(item2.transform.position);
				}
			}
			if (IsDead())
			{
				respawnInformation.previousLife = previousLifeStory;
				if (!ConVar.Server.skipDeathScreenFade)
				{
					respawnInformation.fadeIn = previousLifeStory != null && previousLifeStory.timeDied > Epoch.Current - 5;
				}
				else
				{
					respawnInformation.fadeIn = false;
				}
			}
			ClientRPC(RpcTarget.Player("OnRespawnInformation", this), respawnInformation);
		}
	}

```

## OnPlayerWantsDismount(BasePlayer,BaseMountable)

```csharp
/// <summary>
/// Called when a player wants to dismount an entity.
/// </summary>
/// <param name="player">The player attempting to dismount the entity.</param>
/// <param name="entity">The entity being dismounted.</param>
/// <returns>Returns null if the default behavior is allowed, or a non-null value if the default behavior is overridden.</returns>
object OnPlayerWantsDismount(BasePlayer player, BaseMountable entity)
{
    Puts("OnPlayerWantsDismount is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", player, this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", player, this) == null && (!(player != null) || !player.IsRestrained))
		{
			AttemptDismount(player);
		}
	}

```

## OnFuelAmountCheck(EntityFuelSystem,Item)

```csharp
/// <summary>
/// Called when the fuel amount of an entity's fuel system is checked.
/// </summary>
/// <param name="fuelSystem">The entity's fuel system.</param>
/// <param name="item">The item being used to check the fuel amount.</param>
/// <returns>Returns the actual fuel amount if overridden, or null if not overridden.</returns>
object OnFuelAmountCheck(EntityFuelSystem fuelSystem, Item item)
{
    Puts("OnFuelAmountCheck is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public int GetFuelAmount()
	{
		Item fuelItem = GetFuelItem();
		object obj = Interface.CallHook("OnFuelAmountCheck", this, fuelItem);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0;
		}
		return fuelItem.amount;
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
Документация для хука `OnWeaponFired`

**Описание**

Хук `OnWeaponFired` вызывается при выстреле оружия игроком. Он позволяет модифицировать поведение оружия и проектилей, которые оно стреляет.

**Параметры**

* `BaseProjectile`: Объект-проектиль, который будет создан после выстрела.
* `BasePlayer`: Игрок, который стреляет.
* `ItemModProjectile`: Модификатор проектиля, который используется в оружии.
* `ProtoBuf.ProjectileShoot`: Данные о выстреле, которые передаются в хук.

**Возвращаемые значения**

Нет возвращаемых значений.

**Примечания**

Хук вызывается после проверки, что игрок имеет право стрелять и что у него есть патроны. Если эти условия не выполняются, хук не будет вызван.

**Использование**

Чтобы использовать этот хук, необходимо создать модификатор проектиля `ItemModProjectile` и добавить его к оружию. Затем, когда игрок стреляет, хук будет вызван и сможет модифицировать поведение проектилей.

**Примеры использования**

* Модификатор проектиля может изменить скорость или траекторию полета проектилей.
* Хук можно использовать для добавления новых типов проектилей, которые не являются частью стандартного набора оружия.
* Хук можно использовать для изменения поведения проектилей в зависимости от типа оружия, которое используется.

**Сохранение**

Хук сохраняется в файле конфигурации игры и может быть изменен или удален при необходимости.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !base.UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_missing");
			return;
		}
		ItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (primaryMagazineAmmo.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_mismatch");
			return;
		}
		if (!base.UsingInfiniteAmmoCheat)
		{
			ModifyAmmoCount(-1);
		}
		ItemModProjectile component = primaryMagazineAmmo.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		if (player.InGesture)
		{
			return;
		}
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection, GetAttackEffect());
		player.CleanupExpiredProjectiles();
		Guid projectileGroupId = Guid.NewGuid();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.LogInvalid(player, this, "duplicate_id");
				continue;
			}
			Vector3 positionOffset = Vector3.zero;
			if (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))
			{
				if (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))
				{
					continue;
				}
				Vector3 position = player.eyes.position;
				positionOffset = position - projectile.startPos;
				projectile.startPos = position;
			}
			else if (!ValidateEyePos(player, projectile.startPos))
			{
				continue;
			}
			player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId, positionOffset);
			if (!player.limitNetworking)
			{
				CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
			}
		}
		player.MakeNoise(player.transform.position, BaseCombatEntity.ActionVolume.Loud);
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count(), (Stats)5);
		player.LifeStoryShotFired(this);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);
		player.MarkHostileFor();
		UpdateItemCondition();
		DidAttackServerside();
		float num = 0f;
		if (component.projectileObject != null)
		{
			GameObject gameObject = component.projectileObject.Get();
			if (gameObject != null)
			{
				Projectile component2 = gameObject.GetComponent<Projectile>();
				if (component2 != null)
				{
					foreach (DamageTypeEntry damageType in component2.damageTypes)
					{
						num += damageType.amount;
					}
				}
			}
		}
		BaseMountable mounted = player.GetMounted();
		if (mounted != null)
		{
			mounted.OnWeaponFired(this);
		}
		EACServer.LogPlayerUseWeapon(player, this);
	}

```

## OnSamSiteTarget(SamSite,SamSite.ISamSiteTarget)

```csharp
/// <summary>
/// Called when a SamSite target is detected.
/// </summary>
/// <param name="samSite">The SamSite instance.</param>
/// <param name="target">The detected target.</param>
/// <returns>No return behavior.</returns>
void OnSamSiteTarget(SamSite samSite, ISamSiteTarget target)
{
    Puts($"Detected target: {target}");
}
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (UnityEngine.Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> obj = Facepunch.Pool.GetList<ISamSiteTarget>();
		if (Interface.CallHook("OnSamSiteTargetScan", this, obj) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(obj, targetTypeVehicle.scanRadius);
			}
			AddMLRSRockets(obj, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in obj)
		{
			if (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!ObjectEx.IsUnityNull(samSiteTarget) && currentTarget != samSiteTarget)
		{
			lockOnTime = UnityEngine.Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!ObjectEx.IsUnityNull(currentTarget))
		{
			lastTargetVisibleTime = UnityEngine.Time.time;
		}
		Facepunch.Pool.FreeList(ref obj);
		if (ObjectEx.IsUnityNull(currentTarget))
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
	}

```

## OnItemRemove(Item)

```csharp
/// <summary>
/// Called when an item is removed.
/// </summary>
/// <param name="item">The item being removed.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemRemove(Item item)
{
    Puts("OnItemRemove hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = UnityEngine.Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		if (isServer)
		{
			ItemManager.RemoveItem(this, fTime);
		}
	}

```

## OnSignUpdated(Signage,BasePlayer,int)

```csharp
/// <summary>
/// Called when a sign is updated.
/// </summary>
/// <param name="signage">The signage being updated.</param>
/// <param name="player">The player who performed the update.</param>
/// <param name="index">The index of the sign being updated.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(Signage signage, BasePlayer player, int index)
{
    Puts($"Sign at index {index} updated by {player}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			UnityEngine.Debug.LogWarning($"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", this, msg.player, num);
	}

```

## OnInventoryAmmoItemFind(PlayerInventory,ItemDefinition)

```csharp
/// <summary>
/// Called when an ammo item is found in the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="itemDefinition">The definition of the ammo item to find.</param>
/// <returns>Returns the found ammo item, or null if not found.</returns>
Item OnInventoryAmmoItemFind(PlayerInventory inventory, ItemDefinition itemDefinition)
{
    Puts("OnInventoryAmmoItemFind is working!");
    // Return the found ammo item, or null if not found
    return null;
}
```

### Source Code from the Library

```csharp

	public Item GetAmmo()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		object obj = Interface.CallHook("OnInventoryAmmoItemFind", ownerPlayer.inventory, fuelType);
		if (obj is Item)
		{
			return (Item)obj;
		}
		return ownerPlayer.inventory.FindItemByItemName(fuelType.shortname);
	}

```

## OnNoGoZoneAdded(PatrolHelicopterAI,PatrolHelicopterAI.DangerZone)

```csharp
/// <summary>
/// Called when a new No-Go Zone is added.
/// </summary>
/// <param name="patrolHelicopterAI">The Patrol Helicopter AI instance.</param>
/// <param name="dangerZone">The newly added Danger Zone.</param>
/// <returns>Returns null if the default behavior is overridden, otherwise returns an object indicating the new state of the system.</returns>
object OnNoGoZoneAdded(PatrolHelicopterAI patrolHelicopterAI, PatrolHelicopterAI.DangerZone dangerZone)
{
    // Minimal code to demonstrate functionality
    Puts("OnNoGoZoneAdded hook called!");
    
    // If no return value is specified, return null
    return null;
}
```

### Source Code from the Library

```csharp

	private void NoGoZoneAdded(DangerZone zone)
	{
		if (use_danger_zones && Interface.CallHook("OnNoGoZoneAdded", this, zone) == null && zone.IsPointInside(base.transform.position))
		{
			_targetList.Clear();
			ExitCurrentState();
			Vector3 nearestEdge = zone.GetNearestEdge(base.transform.position);
			nearestEdge.y = UnityEngine.Random.Range(35f, 45f);
			State_Flee_Enter(nearestEdge);
		}
	}

```

## OnDieselEngineToggle(DieselEngine,BasePlayer)

```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off.
/// </summary>
/// <param name="engine">The diesel engine being toggled.</param>
/// <param name="player">The player who toggled the engine.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnDieselEngineToggle(DieselEngine engine, BasePlayer player)
{
    Puts("OnDieselEngineToggle is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(6f)]
	[RPC_Server]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnDieselEngineToggle", this, msg.player) != null)
		{
			return;
		}
		if (msg.read.Bit())
		{
			if (GetFuelAmount() > 0)
			{
				EngineOn();
				startedByPlayer = msg.player;
				if (Rust.GameInfo.HasAchievements && msg.player != null)
				{
					msg.player.stats.Add("excavator_activated", 1, Stats.All);
					msg.player.stats.Save(forceSteamSave: true);
				}
			}
		}
		else
		{
			EngineOff();
		}
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
/// <summary>
/// Called when a player starts looting an item.
/// </summary>
/// <param name="player">The player performing the loot action.</param>
/// <param name="item">The item being looted.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnLootItem(BasePlayer player, Item item)
{
    Puts("OnLootItem hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
			MarkDirty();
		}
	}

```

## OnPlanterBoxFertilize(PlanterBox)

```csharp
/// <summary>
/// Called when a planter box is fertilized.
/// </summary>
/// <param name="planterBox">The planter box being fertilized.</param>
/// <returns>No return behavior.</returns>
void OnPlanterBoxFertilize(PlanterBox planterBox)
{
    Puts($"Planter box {planterBox} has been fertilized.");
}
```

### Source Code from the Library

```csharp

	public void FertilizeGrowables()
	{
		if (Interface.CallHook("OnPlanterBoxFertilize", this) != null)
		{
			return;
		}
		int num = GetFertilizerCount();
		if (num <= 0)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			if (child == null)
			{
				continue;
			}
			GrowableEntity growableEntity = child as GrowableEntity;
			if (!(growableEntity == null) && !growableEntity.Fertilized && ConsumeFertilizer())
			{
				growableEntity.Fertilize();
				num--;
				if (num == 0)
				{
					break;
				}
			}
		}
	}

```

## OnVendingShopOpened(NPCVendingMachine,BasePlayer)

```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that was opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnVendingShopOpened(NPCVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending shop opened by {player} for NPC vending machine: {vendingMachine}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SV_OpenMenu(RPCMessage msg)
	{
		if (vendingMachine == null)
		{
			vendingMachine = GetComponentInChildren<NPCVendingMachine>();
		}
		if (Interface.CallHook("OnVendingShopOpen", vendingMachine, msg.player) == null)
		{
			vendingMachine.OpenShop(msg.player);
			Interface.CallHook("OnVendingShopOpened", vendingMachine, msg.player);
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
Документация для OnPlayerTick(BasePlayer, PlayerTick, bool):

**Описание:**

Функция OnPlayerTick вызывается при каждом тике игрока. Она позволяет модулю выполнять свои действия перед основным процессингом тика.

**Параметры:**

* `BasePlayer`: Объект игрока.
* `PlayerTick`: Объект, содержащий информацию о текущем тике.
* `bool`: Флаг, указывающий, был ли игрок заморожен в предыдущем тике.

**Действия:**

1. Если модуль вызывает функцию OnPlayerTick, он должен вернуть null, чтобы пропустить основный процессинг тика.
2. Модуль может выполнять свои действия перед основным процессингом тика.
3. После выполнения своих действий модуль должен вернуться к основному процессингу тика.

**Пример использования:**

```csharp
public void OnPlayerTick(BasePlayer player, PlayerTick tick, bool wasFrozen)
{
    // Выполняем свои действия перед основным процессингом тика.
    Debug.Log("Модуль выполнил свои действия.");

    // Возвращаем null, чтобы пропустить основный процессинг тика.
    return;
}
```

**Примечание:**

Функция OnPlayerTick вызывается при каждом тике игрока, поэтому модулю следует быть осторожным с ресурсами и не выполнять слишком сложных действий.
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		if (IsRestrained && restraintItemId.HasValue && restraintItemId.HasValue)
		{
			UpdateActiveItem(restraintItemId.Value);
		}
		else
		{
			UpdateActiveItem(msg.activeItem);
		}
		UpdateModelStateFromTick(msg);
		if (IsIncapacitated())
		{
			return;
		}
		if (isMounted)
		{
			GetMounted().PlayerServerInput(serverInput, this);
		}
		UpdatePositionFromTick(msg, wasPlayerStalled);
		UpdateRotationFromTick(msg);
		int activeMission = GetActiveMission();
		if (activeMission >= 0 && activeMission < missions.Count)
		{
			BaseMission.MissionInstance missionInstance = missions[activeMission];
			if (missionInstance.status == BaseMission.MissionStatus.Active && missionInstance.NeedsPlayerInput())
			{
				ProcessMissionEvent(BaseMission.MissionEventType.PLAYER_TICK, net.ID, 0f);
			}
		}
		if (!TutorialIsland.EnforceTrespassChecks || IsAdmin || IsNpc || net == null || net.group == null)
		{
			return;
		}
		if (net.group.restricted)
		{
			bool flag = false;
			if (!IsInTutorial)
			{
				flag = true;
			}
			else
			{
				TutorialIsland currentTutorialIsland = GetCurrentTutorialIsland();
				if (currentTutorialIsland == null || currentTutorialIsland.net.group != net.group)
				{
					flag = true;
				}
			}
			if (flag)
			{
				tutorialKickTime += UnityEngine.Time.deltaTime;
				if (tutorialKickTime > 3f)
				{
					Debug.LogWarning($"Killing player {displayName}/{userID} as they are on a tutorial island that doesn't belong them");
					Hurt(999f);
					tutorialKickTime = 0f;
				}
			}
			else
			{
				tutorialKickTime = 0f;
			}
		}
		else
		{
			if (!IsInTutorial || net.group.restricted)
			{
				return;
			}
			bool flag2 = false;
			TutorialIsland currentTutorialIsland2 = GetCurrentTutorialIsland();
			if (currentTutorialIsland2 == null || currentTutorialIsland2.net.group != net.group)
			{
				flag2 = true;
			}
			if (flag2)
			{
				tutorialKickTime += UnityEngine.Time.deltaTime;
				if (tutorialKickTime > 3f)
				{
					Debug.LogWarning($"Killing player {displayName}/{userID} as they are no longer on a tutorial island and are marked as being in a tutorial");
					Hurt(999f);
					tutorialKickTime = 0f;
				}
			}
			else
			{
				tutorialKickTime = 0f;
			}
		}
	}

```

## OnFishingStopped(BaseFishingRod,BaseFishingRod.FailReason)

```csharp
/// <summary>
/// Called when fishing is stopped.
/// </summary>
/// <param name="rod">The fishing rod that was being used.</param>
/// <param name="reason">The reason why fishing was stopped.</param>
/// <returns>No return behavior.</returns>
void OnFishingStopped(BaseFishingRod rod, FailReason reason)
{
    Puts($"Fishing stopped with reason: {reason}");
}
```

### Source Code from the Library

```csharp

	private void Server_Cancel(FailReason reason)
	{
		if (GetItem() != null)
		{
			GetItem().LoseCondition((reason == FailReason.Success) ? ConditionLossOnSuccess : ConditionLossOnFail);
		}
		SetFlag(Flags.Busy, b: false);
		UpdateFlags();
		CancelInvoke(CatchProcess);
		CurrentState = CatchState.None;
		SetFlag(Flags.Reserved1, b: false);
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		if (fishingBobber != null)
		{
			fishingBobber.Kill();
			currentBobber.Set(null);
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ResetLine"), (int)reason);
		Interface.CallHook("OnFishingStopped", this, reason);
	}

```

## OnBoomboxStationUpdated(BoomBox,string,BasePlayer)

```csharp
/// <summary>
/// Called when the boombox station is updated.
/// </summary>
/// <param name="boomBox">The boombox entity.</param>
/// <param name="stationIp">The new radio IP address.</param>
/// <param name="player">The player who updated the station.</param>
/// <returns>No return behavior.</returns>
void OnBoomboxStationUpdated(BoomBox boomBox, string stationIp, BasePlayer player)
{
    Puts($"Boombox station updated to {stationIp} by player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	public void Server_UpdateRadioIP(BaseEntity.RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnBoomboxStationUpdate", this, text, msg.player) == null && IsStationValid(text))
		{
			if (msg.player != null)
			{
				ulong assignedRadioBy = msg.player.userID.Get();
				AssignedRadioBy = assignedRadioBy;
			}
			CurrentRadioIp = text;
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("OnRadioIPChanged"), CurrentRadioIp);
			Interface.CallHook("OnBoomboxStationUpdated", this, text, msg.player);
			if (IsOn())
			{
				ServerTogglePlay(play: false);
			}
		}
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item was removed.</param>
/// <param name="item">The item that was removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item} removed from container {container}");
}
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		if (onPreItemRemove != null)
		{
			onPreItemRemove(item);
		}
		itemList.Remove(item);
		item.parent = null;
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: false);
		}
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## OnMlrsFiringEnded(MLRS)

```csharp
/// <summary>
/// Called when the MLRS firing has ended.
/// </summary>
/// <param name="mlrs">The MLRS instance that fired.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFiringEnded(MLRS mlrs)
{
    Puts("OnMlrsFiringEnded is working!");
}
```

### Source Code from the Library

```csharp

	public void EndFiring()
	{
		CancelInvoke(FireNextRocket);
		rocketOwnerRef.Set(null);
		if (TryGetAimingModule(out var item))
		{
			item.LoseCondition(1f);
		}
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Broken, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		timeSinceBroken = 0f;
		Interface.CallHook("OnMlrsFiringEnded", this);
	}

```

## IOnLoseCondition(Item,float)

```csharp
/// <summary>
/// Called when the item's condition is reduced.
/// </summary>
/// <param name="item">The item that lost condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts("IOnLoseCondition is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## OnDroppedItemCombined(DroppedItem)

```csharp
/// <summary>
/// Called when two dropped items are combined.
/// </summary>
/// <param name="di">The DroppedItem to combine.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnDroppedItemCombined(DroppedItem di)
{
    Puts("OnDroppedItemCombined is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || NeverCombine || di.NeverCombine || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.DestroyItem();
			di.Kill();
			Interface.CallHook("OnDroppedItemCombined", this);
			int worldModelIndex = item.info.GetWorldModelIndex(item.amount);
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
			int worldModelIndex2 = item.info.GetWorldModelIndex(item.amount);
			if (worldModelIndex != worldModelIndex2)
			{
				item.Drop(base.transform.position, Vector3.zero, base.transform.rotation);
			}
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
/// <summary>
/// Called when an item is dropped.
/// </summary>
/// <param name="item">The item being dropped.</param>
/// <param name="entity">The entity that the item was dropped on.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemDropped(Item item, BaseEntity entity)
{
    Puts("OnItemDropped hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		ulong droppedBy = GetRootContainer()?.playerOwner?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
		RemoveFromWorld();
		if (info.AlignWorldModelOnDrop)
		{
			rotation = Quaternion.Euler(0f, Quaternion.LookRotation(vVelocity.normalized, Vector3.up).eulerAngles.y, 0f);
			rotation = Quaternion.Euler(info.WorldModelDropOffset) * rotation;
		}
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
			if (baseEntity is DroppedItem droppedItem)
			{
				droppedItem.DroppedBy = droppedBy;
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## OnPhoneDialFailed(PhoneController,Telephone.DialFailReason,BasePlayer)

```csharp
/// <summary>
/// Called when a phone dial attempt fails.
/// </summary>
/// <param name="phoneController">The phone controller that failed to dial.</param>
/// <param name="reason">The reason for the dial failure.</param>
/// <param name="player">The player who attempted to make the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialFailed(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer player)
{
    Puts($"Phone dial failed with reason {reason} for player {player.UserID}");
}
```

### Source Code from the Library

```csharp

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", this, reason, currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientOnDialFailed"), (int)reason);
			activeCallTo = null;
			if (IsInvoking(TimeOutCall))
			{
				CancelInvoke(TimeOutCall);
			}
			if (IsInvoking(TriggerTimeOut))
			{
				CancelInvoke(TriggerTimeOut);
			}
			if (IsInvoking(TimeOutDialing))
			{
				CancelInvoke(TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", this, reason, currentPlayer);
		}
	}

```

## IOnPlayerBanned(Network.Connection,AuthResponse)

```csharp
/// <summary>
/// Called when a player is banned by the anticheat system.
/// </summary>
/// <param name="connection">The player's network connection.</param>
/// <param name="status">The reason for the ban (e.g. VACBanned, PublisherBanned).</param>
/// <returns>No return behavior.</returns>
void IOnPlayerBanned(Network.Connection connection, AuthResponse status)
{
    Puts($"Player {connection.username} banned by anticheat: {status}");
}
```

### Source Code from the Library

```csharp

	internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
	{
		if (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))
		{
			return;
		}
		Network.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) => x.userid == SteamId);
		if (connection == null)
		{
			UnityEngine.Debug.LogWarning($"Steam gave us a {Status} ticket response for unconnected id {SteamId}");
			return;
		}
		switch (Status)
		{
		case AuthResponse.OK:
			UnityEngine.Debug.LogWarning($"Steam gave us a 'ok' ticket response for already connected id {SteamId}");
			return;
		case AuthResponse.TimedOut:
			return;
		case AuthResponse.VACBanned:
		case AuthResponse.PublisherBanned:
			if (!bannedPlayerNotices.Contains(SteamId))
			{
				Interface.CallHook("IOnPlayerBanned", connection, Status);
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + connection.username.EscapeRichText() + " (banned by anticheat)");
				bannedPlayerNotices.Add(SteamId);
			}
			break;
		}
		UnityEngine.Debug.Log($"Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \"{Status.ToString()}\")");
		connection.authStatusSteam = Status.ToString();
		Network.Net.sv.Kick(connection, "Steam: " + Status);
	}

```

## OnTick()

```csharp
/// <summary>
/// Called every tick to perform various updates and checks.
/// </summary>
void OnTick()
{
    Puts("OnTick called!");
}
 
// No return statement is necessary since the method has a void return type.
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		Interface.CallHook("OnTick");
		RCon.Update();
		CompanionServer.Server.Update();
		NexusServer.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Network.Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## OnPayForPlacement(BasePlayer,Planner,Construction)

```csharp
/// <summary>
/// Called when a player pays for the placement of a construction.
/// </summary>
/// <param name="player">The player who paid for the placement.</param>
/// <param name="planner">The planner associated with the construction.</param>
/// <param name="construction">The construction being placed.</param>
/// <returns>No return behavior.</returns>
void OnPayForPlacement(BasePlayer player, Planner planner, Construction construction)
{
    Puts($"Player {player.UserIDString} paid for placement of construction: {construction.DisplayName}");
}
```

### Source Code from the Library

```csharp

	public void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", player, this, component) != null || (player.IsInCreativeMode && Creative.freeBuild))
		{
			return;
		}
		if (player.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
			if (currentTutorialIsland != null)
			{
				currentTutorialIsland.OnPlayerBuiltConstruction(player);
			}
		}
		if (isTypeDeployable)
		{
			GetItem().UseItem();
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in component.defaultGrade.CostToBuild())
		{
			player.inventory.Take(list, item.itemDef.itemid, (int)item.amount);
			player.Command("note.inv", item.itemDef.itemid, item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## OnPlayerRecover(BasePlayer)

```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player recovering.</param>
/// <returns>Returns the result of the hook, or null if no custom behavior is provided.</returns>
object OnPlayerRecover(BasePlayer player)
{
    Puts("OnPlayerRecover called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			if (IsCrawling())
			{
				base.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if ((bool)BaseGameMode.GetActiveGameMode(base.isServer))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", this);
		}
	}

```

## CanBeAwardedAdventGift(AdventCalendar,BasePlayer)

```csharp
/// <summary>
/// Called to determine if a player can be awarded an Advent gift.
/// </summary>
/// <param name="calendar">The Advent calendar.</param>
/// <param name="player">The player being evaluated.</param>
/// <returns>Returns true if the player can be awarded, false otherwise.</returns>
bool CanBeAwardedAdventGift(AdventCalendar calendar, BasePlayer player)
{
    Puts("CanBeAwardedAdventGift is working!");
    return true; // or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public bool WasAwardedTodaysGift(BasePlayer player)
	{
		object obj = Interface.CallHook("CanBeAwardedAdventGift", this, player);
		if (obj is bool)
		{
			return !(bool)obj;
		}
		if (!playerRewardHistory.ContainsKey(player.userID))
		{
			return false;
		}
		DateTime now = DateTime.Now;
		if (((overrideAdventCalendarMonth > 0) ? overrideAdventCalendarMonth : now.Month) != startMonth)
		{
			return true;
		}
		int num = ((overrideAdventCalendarDay > 0) ? overrideAdventCalendarDay : now.Day) - startDay;
		if (num < 0 || num >= days.Length)
		{
			return true;
		}
		if (playerRewardHistory[player.userID].Contains(num))
		{
			return true;
		}
		return false;
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
/// <summary>
/// Called when a bear trap is armed.
/// </summary>
/// <param name="trap">The bear trap being armed.</param>
/// <param name="player">The player who triggered the trap.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts("OnTrapArm hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## OnEntityEnter(TriggerComfort,BaseEntity)

```csharp
/// <summary>
/// Called when an entity enters a comfort zone.
/// </summary>
/// <param name="comfort">The comfort zone.</param>
/// <param name="entity">The entity entering the comfort zone.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityEnter(TriggerComfort comfort, BaseEntity entity)
{
    Puts("OnEntityEnter is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void OnEntityEnter(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityEnter", this, ent) == null)
		{
			_players.Add(basePlayer);
		}
	}

```

## OnVehicleHornPressed(VehicleModuleSeating,BasePlayer)

```csharp
/// <summary>
/// Called when the vehicle horn is pressed.
/// </summary>
/// <param name="module">The seating module of the vehicle.</param>
/// <param name="player">The player who pressed the horn.</param>
/// <returns>No return behavior.</returns>
void OnVehicleHornPressed(VehicleModuleSeating module, BasePlayer player)
{
    Puts($"Vehicle horn pressed by {player.Name}");
}
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (hornLoop != null && IsOnThisModule(player))
		{
			bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
			if (flag != HasFlag(Flags.Reserved8))
			{
				SetFlag(Flags.Reserved8, flag);
			}
			if (flag)
			{
				Interface.CallHook("OnVehicleHornPressed", this, player);
				hornPlayer = player;
			}
		}
	}

```

## OnConnectionQueue(Network.Connection)

```csharp
/// <summary>
/// Called when a connection is added to the queue.
/// </summary>
/// <param name="connection">The connection being queued.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnConnectionQueue(Network.Connection connection)
{
    Puts("OnConnectionQueue is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	internal void Join(Connection connection)
	{
		if (Interface.CallHook("OnConnectionQueue", connection) == null)
		{
			connection.state = Connection.State.InQueue;
			queue.Add(connection);
			nextMessageTime = 0f;
			if (CanJumpQueue(connection))
			{
				JoinGame(connection);
			}
		}
	}

```

## OnProjectileRicochet(BasePlayer,ProtoBuf.PlayerProjectileRicochet)

```csharp
/// <summary>
/// Called when a projectile ricochets.
/// </summary>
/// <param name="player">The player who fired the projectile.</param>
/// <param name="ricochetData">Data about the ricochet event.</param>
/// <returns>No return behavior.</returns>
void OnProjectileRicochet(BasePlayer player, ProtoBuf.PlayerProjectileRicochet ricochetData)
{
    Puts($"Projectile {ricochetData.projectileID} ricocheted for player {player.UserIDString}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void OnProjectileRicochet(RPCMessage msg)
	{
		PlayerProjectileRicochet playerProjectileRicochet = PlayerProjectileRicochet.Deserialize(msg.read);
		if (playerProjectileRicochet != null)
		{
			FiredProjectile value;
			if (playerProjectileRicochet.hitPosition.IsNaNOrInfinity() || playerProjectileRicochet.inVelocity.IsNaNOrInfinity() || playerProjectileRicochet.outVelocity.IsNaNOrInfinity() || playerProjectileRicochet.hitNormal.IsNaNOrInfinity() || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + playerProjectileRicochet.projectileID + ")", logToAnalytics: false);
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (value.firedTime < UnityEngine.Time.realtimeSinceStartup - 8f)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (Interface.CallHook("OnProjectileRicochet", this, playerProjectileRicochet) == null)
			{
				value.ricochets++;
				firedProjectiles[playerProjectileRicochet.projectileID] = value;
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
		}
	}

```

## OnEntityPickedUp(BaseCombatEntity,Item,BasePlayer)

```csharp
/// <summary>
/// Called when an entity is picked up by a player.
/// </summary>
/// <param name="entity">The entity that was picked up.</param>
/// <param name="item">The item that was used to pick up the entity.</param>
/// <param name="player">The player who picked up the entity.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityPickedUp(BaseCombatEntity entity, Item item, BasePlayer player)
{
    Puts("OnEntityPickedUp is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void OnPickedUp(Item createdItem, BasePlayer player)
	{
		Interface.CallHook("OnEntityPickedUp", this, createdItem, player);
	}

```

## OnNpcConversationResponded(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
/// <summary>
/// Called when a player responds to an NPC's conversation.
/// </summary>
/// <param name="npcTalking">The NPC initiating the conversation.</param>
/// <param name="player">The player responding to the conversation.</param>
/// <param name="conversationData">The data for the ongoing conversation.</param>
/// <param name="responseNode">The node representing the player's response.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnNpcConversationResponded(NPCTalking npcTalking, BasePlayer player, ConversationData conversationData, ConversationData.ResponseNode responseNode)
{
    // Minimal code to demonstrate functionality
    Puts("OnNpcConversationResponded called!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode == null || Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) != null)
		{
			return;
		}
		if (responseNode.conditions.Length != 0)
		{
			UpdateFlags();
		}
		bool flag = responseNode.PassesConditions(player, this);
		if (flag)
		{
			string actionString = responseNode.GetActionString();
			if (!string.IsNullOrEmpty(actionString))
			{
				OnConversationAction(player, actionString);
			}
		}
		int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
		if (speechNodeIndex == -1)
		{
			ForceEndConversation(player);
			return;
		}
		ForceSpeechNode(player, speechNodeIndex);
		Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
	}

```

## OnWorldProjectileCreate(HitInfo,Item)

```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="info">The hit info.</param>
/// <param name="item">The item being created.</param>
/// <returns>Returns the created item, or null if the default behavior is overridden.</returns>
object OnWorldProjectileCreate(HitInfo info, Item item)
{
    Puts("OnWorldProjectileCreate called!");
    return item;
}
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if (droppedItem != null)
			{
				droppedItem.StickIn();
			}
			else
			{
				baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			Rigidbody component = baseEntity.GetComponent<Rigidbody>();
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## OnCrateLanded(HackableLockedCrate)

```csharp
/// <summary>
/// Called when a hackable locked crate lands.
/// </summary>
/// <param name="crate">The landed crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateLanded(HackableLockedCrate crate)
{
    Puts("OnCrateLanded is working!");
}
```

### Source Code from the Library

```csharp

	public void LandCheck()
	{
		RaycastHit hitInfo;
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", this);
		}
		else if (UnityEngine.Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1084293377))
		{
			Effect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);
			hasLanded = true;
			CancelInvoke(LandCheck);
		}
	}

```

## OnExplosiveFuseSet(TimedExplosive,float)

```csharp
/// <summary>
/// Called when the explosive fuse is set.
/// </summary>
/// <param name="explosive">The TimedExplosive instance.</param>
/// <param name="fuseLength">The length of the fuse in seconds.</param>
/// <returns>The updated fuse length if overridden, or null for default behavior.</returns>
object OnExplosiveFuseSet(TimedExplosive explosive, float fuseLength)
{
    Puts("OnExplosiveFuseSet is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			object obj = Interface.CallHook("OnExplosiveFuseSet", this, fuseLength);
			if (obj is float)
			{
				fuseLength = (float)obj;
			}
			Invoke(Explode, fuseLength);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

```

## CanEquipItem(PlayerInventory,Item,int)

```csharp
/// <summary>
/// Called when a player attempts to equip an item.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The item being equipped.</param>
/// <param name="slot">The target slot for the item.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
object CanEquipItem(PlayerInventory inventory, Item item, int slot)
{
    Puts("CanEquipItem hook called!");
    
    // If the return value is a boolean, return it
    object obj = Interface.CallHook("CanEquipItem", inventory, item, slot);
    if (obj is bool) 
    {
        return (bool)obj;
    }
    
    // If the item is not allowed in the belt, return false
    if ((item.info.flags & ItemDefinition.Flag.NotAllowedInBelt) != 0)
    {
        return false;
    }
    
    // If the player is restrained and the restraint item is in the target slot, return false
    if (base.baseEntity != null && base.baseEntity.IsRestrained)
    {
        Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
        if (restraintItem != null && restraintItem.GetItem().position == slot)
        {
            return false;
        }
    }
    
    // If the item has a container restriction component, check if it can exist with other items in the inventory
    ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
    if (component != null)
    {
        Item[] array = inventory.itemList.ToArray();
        foreach (Item item2 in array)
        {
            if (item2 != item)
            {
                ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
                if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(inventory.main))
                {
                    item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
                }
            }
        }
    }
    
    // If none of the above conditions are met, return true
    return true;
}
```

### Source Code from the Library

```csharp

	public bool CanEquipItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanEquipItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((item.info.flags & ItemDefinition.Flag.NotAllowedInBelt) != 0)
		{
			return false;
		}
		if (base.baseEntity != null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if (restraintItem != null && restraintItem.GetItem().position == targetSlot)
			{
				return false;
			}
		}
		ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
		if (component == null)
		{
			return true;
		}
		Item[] array = containerBelt.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
				}
			}
		}
		return true;
	}

```

## OnRackedWeaponMounted(Item,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a weapon is mounted on a rack.
/// </summary>
/// <param name="item">The item being mounted.</param>
/// <param name="player">The player who performed the action.</param>
/// <param name="rack">The rack where the item was mounted.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponMounted(Item item, BasePlayer player, WeaponRack rack)
{
    Puts($"Weapon {item.info.itemid} mounted on rack {rack}");
}
```

### Source Code from the Library

```csharp

	private bool MountWeapon(Item item, BasePlayer player, int gridCellIndex, int rotation, bool sendUpdate = true)
	{
		if (item == null)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnRackedWeaponMount", item, player, this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		int itemid = item.info.itemid;
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			Debug.LogWarning("no rackmount config");
			return false;
		}
		if (!CanAcceptWeaponType(forItemDef))
		{
			return false;
		}
		if (!GridCellsFree(forItemDef, gridCellIndex, rotation, null))
		{
			return false;
		}
		if (item.MoveToContainer(base.inventory, -1, allowStack: false) && item.position >= 0 && item.position < gridSlots.Length)
		{
			WeaponRackSlot slot = gridSlots[item.position];
			SetSlotItem(slot, item, gridCellIndex, rotation);
			SetupSlot(slot);
			if (player != null)
			{
				ClientRPC(RpcTarget.Player("PlayMountSound", player), itemid);
			}
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponMounted", item, player, this);
		return true;
	}

```

## CanLootEntity(BasePlayer,ResourceContainer)

```csharp
/// <summary>
/// Called when a player attempts to loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="container">The container being looted.</param>
/// <returns>Returns null if the default behavior is allowed, or a non-null value if the default behavior is overridden.</returns>
object CanLootEntity(BasePlayer player, ResourceContainer container)
{
    Puts("CanLootEntity is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.IsVisible(3f)]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}

```

## InitLogging()

```csharp
/// <summary>
/// Initializes logging functionality.
/// </summary>
void InitLogging()
{
    Puts("InitLogging called!"); // Minimal code to demonstrate functionality
}
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

```

## OnPlayerColliderEnable(BasePlayer,UnityEngine.CapsuleCollider)

```csharp
/// <summary>
/// Called when the player's collider is enabled.
/// </summary>
/// <param name="player">The player whose collider is being enabled.</param>
/// <param name="collider">The capsule collider of the player.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerColliderEnable(BasePlayer player, UnityEngine.CapsuleCollider collider)
{
    Puts("OnPlayerColliderEnable is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void EnablePlayerCollider()
	{
		if (!playerCollider.enabled && Interface.CallHook("OnPlayerColliderEnable", this, playerCollider) == null)
		{
			RefreshColliderSize(forced: true);
			playerCollider.enabled = true;
		}
	}

```

## OnNpcAttack(BaseNpc,BaseEntity)

```csharp
/// <summary>
/// Called when an NPC attacks a target entity.
/// </summary>
/// <param name="npc">The NPC performing the attack.</param>
/// <param name="target">The entity being attacked.</param>
/// <returns>No return behavior.</returns>
void OnNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc} is attacking {target}");
}
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if ((bool)AttackTarget && AttackReady() && Interface.CallHook("OnNpcAttack", this, AttackTarget) == null && !((AttackTarget.ServerPosition - ServerPosition).magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(RpcTarget.NetworkGroup("Attack"), AttackTarget.ServerPosition);
			}
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
/// <summary>
/// Called when a client authenticates with the server.
/// </summary>
/// <param name="connection">The client's network connection.</param>
/// <returns>No return behavior.</returns>
void OnClientAuth(Network.Connection connection)
{
    Puts("OnClientAuth is working!");
}
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Network.Connection.State.Connecting;
		if (packet.read.UInt8() != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String(128);
		packet.connection.username = packet.read.String();
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.Unread >= 4)
		{
			text = packet.read.String(128);
		}
		Interface.CallHook("OnClientAuth", packet.connection);
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their branch is '" + text + "' not '" + branch + "'");
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2555)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2555);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2555)
		{
			DebugEx.Log("Kicking " + packet.connection?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2555);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize(512u);
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
				return;
			}
			packet.connection.anticheatId = packet.read.StringRaw(128);
			packet.connection.anticheatToken = packet.read.StringRaw(2048);
			packet.connection.clientChangeset = packet.read.Int32();
			packet.connection.clientBuildTime = packet.read.Int64();
			auth.OnNewConnection(packet.connection);
		}
	}

```

## OnInventoryItemsFind(PlayerInventory,int)

```csharp
/// <summary>
/// Called when an inventory search is performed.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="id">The item ID to search for.</param>
/// <returns>Returns a list of items found in the inventory, or null if no items were found.</returns>
object OnInventoryItemsFind(PlayerInventory inventory, int id)
{
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	public List<Item> FindItemsByItemID(int id)
	{
		object obj = Interface.CallHook("OnInventoryItemsFind", this, id);
		if (obj is List<Item>)
		{
			return (List<Item>)obj;
		}
		List<Item> list = new List<Item>();
		if (containerMain != null)
		{
			list.AddRange(containerMain.FindItemsByItemID(id));
		}
		if (containerBelt != null)
		{
			list.AddRange(containerBelt.FindItemsByItemID(id));
		}
		if (containerWear != null)
		{
			list.AddRange(containerWear.FindItemsByItemID(id));
		}
		return list;
	}

```

## OnNpcConversationEnded(NPCTalking,BasePlayer)

```csharp
/// <summary>
/// Called when a conversation with an NPC has ended.
/// </summary>
/// <param name="npc">The NPC that was being conversed with.</param>
/// <param name="player">The player who was having the conversation.</param>
/// <returns>No return behavior.</returns>
void OnNpcConversationEnded(NPCTalking npc, BasePlayer player)
{
    Puts($"Conversation with {npc.Name} ended for player {player.UserIDString}");
}
```

### Source Code from the Library

```csharp

	public virtual void OnConversationEnded(BasePlayer player)
	{
		Interface.CallHook("OnNpcConversationEnded", this, player);
		if (conversingPlayers.Contains(player))
		{
			conversingPlayers.Remove(player);
		}
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
Документация для OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

**Описание**

Этот хук вызывается после создания ресурсного депозита в методе `CreateFromPosition(Vector3 pos)` класса `ResourceDepositManager`.

**Параметры**

* `resourceDeposit`: Объект типа `ResourceDeposit`, который был создан и добавлен в коллекцию.

**Событие**

Этот хук вызывается после того, как ресурсный депозит был успешно создан и добавлен в коллекцию. Это событие можно использовать для реализации логирования, анализа или других бизнес-логик.

**Пример использования**

```csharp
public class MyResourceDepositManager : ResourceDepositManager
{
    public override void OnResourceDepositCreated(ResourceDeposit resourceDeposit)
    {
        // Реализуйте здесь свою бизнес-логику
        Debug.Log($"Ресурсный депозит создан: {resourceDeposit}");
        
        // Например, можно добавить ресурсный депозит в базу данных
        Database.AddResourceDeposit(resourceDeposit);
    }
}
```

**Примечания**

* Этот хук вызывается только один раз после создания ресурсного депозита.
* Параметр `resourceDeposit` содержит все свойства и методы класса `ResourceDeposit`.
* Эта документация предназначена для использования в качестве справки по API.
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		UnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)
		};
		if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else
		{
			bool flag = false;
			float num = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)
				{
					num += 0.25f;
				}
			}
			else
			{
				num += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(8f, 10f), ResourceDeposit.surveySpawnType.ITEM, liquid: true);
				flag = true;
			}
			if (!flag)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
				float num2 = 0f;
				num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num3 = 0f;
				num3 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num3)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num4 = 0f;
				if (World.Procedural)
				{
					if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
					{
						num4 += 0.25f;
					}
				}
				else
				{
					num4 += 0.15f;
				}
				if (UnityEngine.Random.Range(0f, 1f) >= 1f - num4)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
				}
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnHuntEventEnd(EggHuntEvent)

```csharp
/// <summary>
/// Called when the hunt event has ended.
/// </summary>
/// <param name="event">The EggHuntEvent that has ended.</param>
/// <returns>No return behavior.</returns>
void OnHuntEventEnd(EggHuntEvent event)
{
    Puts("OnHuntEventEnd is working!");
}
```

### Source Code from the Library

```csharp

	public void Update()
	{
		timeAlive += UnityEngine.Time.deltaTime;
		if (base.isServer && !base.IsDestroyed)
		{
			if (timeAlive - warmupTime > durationSeconds - warnTime)
			{
				SetFlag(Flags.Reserved1, b: true);
			}
			if (timeAlive - warmupTime > durationSeconds && !IsInvoking(Cooldown) && Interface.CallHook("OnHuntEventEnd", this) == null)
			{
				SetFlag(Flags.Reserved2, b: true);
				CleanupEggs();
				PrintWinnersAndAward();
				Invoke(Cooldown, 10f);
			}
		}
	}

```

## OnItemRepair(BasePlayer,Item)

```csharp
/// <summary>
/// Called when an item is being repaired.
/// </summary>
/// <param name="player">The player performing the repair.</param>
/// <param name="item">The item being repaired.</param>
/// <returns>No return behavior.</returns>
void OnItemRepair(BasePlayer player, Item item)
{
    Puts($"Item {item.info.shortname} is being repaired by player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
	{
		if (itemToRepair == null)
		{
			return;
		}
		ItemDefinition info = itemToRepair.info;
		ItemBlueprint component = info.GetComponent<ItemBlueprint>();
		if (!component)
		{
			return;
		}
		ItemModRepair component2 = itemToRepair.info.GetComponent<ItemModRepair>();
		if (!info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)
		{
			return;
		}
		if (mustKnowBlueprint)
		{
			ItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);
			if (!player.blueprints.HasUnlocked(itemDefinition) && (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))
			{
				return;
			}
		}
		if (Interface.CallHook("OnItemRepair", player, itemToRepair) != null)
		{
			return;
		}
		float num = RepairCostFraction(itemToRepair);
		bool flag = false;
		List<ItemAmount> obj = Facepunch.Pool.GetList<ItemAmount>();
		GetRepairCostList(component, obj);
		foreach (ItemAmount item in obj)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				if (Mathf.CeilToInt(item.amount * num) > amount)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Facepunch.Pool.FreeList(ref obj);
			return;
		}
		foreach (ItemAmount item2 in obj)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
				Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "repair", item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair);
			}
		}
		Facepunch.Pool.FreeList(ref obj);
		float conditionNormalized = itemToRepair.conditionNormalized;
		float maxConditionNormalized = itemToRepair.maxConditionNormalized;
		itemToRepair.DoRepair(maxConditionLostOnRepair);
		Facepunch.Rust.Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);
		if (Global.developer > 0)
		{
			Debug.Log("Item repaired! condition : " + itemToRepair.condition + "/" + itemToRepair.maxCondition);
		}
		string strName = "assets/bundled/prefabs/fx/repairbench/itemrepair.prefab";
		if (component2 != null && component2.successEffect?.Get() != null)
		{
			strName = component2.successEffect.resourcePath;
		}
		Effect.server.Run(strName, repairBenchEntity, 0u, Vector3.zero, Vector3.zero);
	}

```

## OnSignContentCopied(SignContent,ISignage,IUGCBrowserEntity)

```csharp
/// <summary>
/// Called when content is copied to a sign.
/// </summary>
/// <param name="signContent">The content being copied.</param>
/// <param name="signage">The sign that the content is being copied to.</param>
/// <param name="browserEntity">The browser entity associated with the sign.</param>
/// <returns>Returns null if no custom behavior is implemented.</returns>
object OnSignContentCopied(SignContent signContent, ISignage signage, IUGCBrowserEntity browserEntity)
{
    // Minimal code to demonstrate functionality
    Puts("OnSignContentCopied hook called!");
    
    // No return statement needed since the return type is object
}
```

### Source Code from the Library

```csharp

	public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)
	{
		FileStorage.server.ReassignEntityId(net.ID, s.NetworkID);
		s.SetTextureCRCs(textureIDs);
		b.EditingHistory.Clear();
		foreach (ulong item in editHistory)
		{
			b.EditingHistory.Add(item);
		}
		Interface.CallHook("OnSignContentCopied", this, s, b);
	}

```

## OnRackedWeaponTake(Item,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a weapon is taken from a rack.
/// </summary>
/// <param name="item">The item being taken.</param>
/// <param name="player">The player taking the item.</param>
/// <param name="rack">The rack from which the item was taken.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnRackedWeaponTake(Item item, BasePlayer player, WeaponRack rack)
{
    Puts("OnRackedWeaponTake is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	private void GivePlayerWeapon(BasePlayer player, int mountSlotIndex, int playerBeltIndex = -1, bool tryHold = true, bool sendUpdate = true)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null)
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponTake", slot, player, this) != null)
		{
			return;
		}
		ClearSlot(weaponAtIndex);
		if (slot.MoveToContainer(player.inventory.containerBelt, playerBeltIndex))
		{
			if ((tryHold && player.GetHeldEntity() == null) || playerBeltIndex != -1)
			{
				ClientRPC(RpcTarget.Player("SetActiveBeltSlot", player), slot.position, slot.uid);
			}
			ClientRPC(RpcTarget.Player("PlayGrabSound", player), slot.info.itemid);
		}
		else if (!slot.MoveToContainer(player.inventory.containerMain))
		{
			slot.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
		}
		if (sendUpdate)
		{
			ItemManager.DoRemoves();
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnRackedWeaponTaken", slot, player, this);
	}

```

## OnBookmarkControlStarted(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
/// <summary>
/// Called when a player starts controlling a bookmark.
/// </summary>
/// <param name="computerStation">The computer station where the control is being initiated.</param>
/// <param name="player">The player initiating the control.</param>
/// <param name="bookmarkName">The name of the bookmark being controlled.</param>
/// <param name="remoteControllable">The remote controllable entity being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlStarted(ComputerStation computerStation, BasePlayer player, string bookmarkName, IRemoteControllable remoteControllable)
{
    Puts($"Player {player.UserIDString} started controlling bookmark '{bookmarkName}'");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## OnPlayerWound(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Called when a player is wounded.
/// </summary>
/// <param name="player">The player who was wounded.</param>
/// <param name="hitInfo">Information about the hit that caused the wound.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnPlayerWound(BasePlayer player, HitInfo hitInfo)
{
    Puts("OnPlayerWound hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void BecomeWounded(HitInfo info = null)
	{
		if (IsWounded() || Interface.CallHook("OnPlayerWound", this, info) != null)
		{
			return;
		}
		bool flag = info != null && info.damageTypes.GetMajorityDamageType() == DamageType.Fall;
		if (IsCrawling())
		{
			woundedByFallDamage |= flag;
			GoToIncapacitated(info);
			return;
		}
		woundedByFallDamage = flag;
		if (flag || !ConVar.Server.crawlingenabled)
		{
			GoToIncapacitated(info);
		}
		else
		{
			GoToCrawling(info);
		}
	}

```

## CanWearItem(PlayerInventory,Item,int)

```csharp
/// <summary>
/// Called when a player attempts to wear an item.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The item being worn.</param>
/// <param name="slot">The target slot for the item.</param>
/// <returns>Returns true if the item can be worn, and false otherwise.</returns>
bool CanWearItem(PlayerInventory inventory, Item item, int slot)
{
    Puts("CanWearItem is working!");
    return true; // Default behavior
}
```

### Source Code from the Library

```csharp

	public bool CanWearItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanWearItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CanWearItem(item, canAdjustClothing: true, targetSlot);
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
/// <summary>
/// Called to determine whether the active item should be dropped.
/// </summary>
/// <param name="player">The player attempting to drop the active item.</param>
/// <returns>Returns <c>true</c> if the active item should be dropped, and <c>false</c> otherwise.</returns>
bool CanDropActiveItem(BasePlayer player)
{
    Puts("CanDropActiveItem is working!");
    return false; // Default behavior: do not drop the active item
}
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnDebrisSpawn(DecayEntity,UnityEngine.Vector3,UnityEngine.Quaternion,bool)

```csharp
/// <summary>
/// Called when debris is spawned.
/// </summary>
/// <param name="entity">The entity that spawned the debris.</param>
/// <param name="position">The position where the debris was spawned.</param>
/// <param name="rotation">The rotation of the debris.</param>
/// <param name="dropToTerrain">Whether the debris should drop to terrain.</param>
/// <returns>No return behavior.</returns>
void OnDebrisSpawn(DecayEntity entity, Vector3 position, Quaternion rotation, bool dropToTerrain)
{
    Puts($"Debris spawned at {position} with rotation {rotation} and drop to terrain {dropToTerrain}");
}
```

### Source Code from the Library

```csharp

	private void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)
	{
		if (Interface.CallHook("OnDebrisSpawn", this, localPos, rot, dropToTerrain) != null)
		{
			return;
		}
		Vector3 vector = base.transform.TransformPoint(localPos);
		if (dropToTerrain && UnityEngine.Physics.Raycast(vector, Vector3.down, out var hitInfo, 6f, 8388608))
		{
			float num = vector.y - hitInfo.point.y;
			vector.y = hitInfo.point.y;
			localPos.y -= num;
		}
		List<DebrisEntity> list = Facepunch.Pool.GetList<DebrisEntity>();
		Vis.Entities(vector, 0.1f, list, 256);
		if (list.Count <= 0)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(debrisPrefab.resourcePath, base.transform.TransformPoint(localPos), base.transform.rotation * rot);
			if ((bool)baseEntity)
			{
				baseEntity.SetParent(parentEntity.Get(serverside: true), worldPositionStays: true);
				baseEntity.Spawn();
			}
		}
	}

```

## OnBookmarkAdd(ComputerStation,BasePlayer,string)

```csharp
/// <summary>
/// Called when a bookmark is added.
/// </summary>
/// <param name="station">The computer station where the bookmark was added.</param>
/// <param name="player">The player who added the bookmark.</param>
/// <param name="text">The text of the bookmark.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnBookmarkAdd(ComputerStation station, BasePlayer player, string text)
{
    Puts($"Bookmark added by {player} at {station}");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void AddBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		if (UnityEngine.Time.realtimeSinceStartup < nextAddTime)
		{
			player.ChatMessage("Slow down...");
			return;
		}
		if (controlBookmarks.Count >= 128)
		{
			player.ChatMessage("Too many bookmarks, delete some");
			return;
		}
		nextAddTime = UnityEngine.Time.realtimeSinceStartup + 1f;
		string text = msg.read.String();
		if (Interface.CallHook("OnBookmarkAdd", this, player, text) == null)
		{
			ForceAddBookmark(text);
			SendControlBookmarks(player);
		}
	}

```

## OnVendingShopRename(VendingMachine,string,BasePlayer)

```csharp
/// <summary>
/// Called when a vending shop's name is updated.
/// </summary>
/// <param name="vendingMachine">The vending machine being renamed.</param>
/// <param name="newName">The new name for the vending shop.</param>
/// <param name="player">The player who initiated the rename operation.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnVendingShopRename(VendingMachine vendingMachine, string newName, BasePlayer player)
{
    Puts($"Vending shop '{vendingMachine.Name}' renamed by {player.Name} to '{newName}'");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_UpdateShopName(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string obj = msg.read.String(32);
		if (CanPlayerAdmin(player) && Interface.CallHook("OnVendingShopRename", this, obj, player) == null)
		{
			shopName = obj;
			UpdateMapMarker();
		}
	}

```

## OnSignUpdated(PhotoFrame,BasePlayer)

```csharp
/// <summary>
/// Called when a sign's image is updated.
/// </summary>
/// <param name="sign">The PhotoFrame that was updated.</param>
/// <param name="player">The BasePlayer who performed the update.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(PhotoFrame sign, BasePlayer player)
{
    Puts($"Sign at {sign.GetPosition()} updated by {player.UserIDString}.");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (!(msg.player == null) && CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				LogEdit(msg.player);
				SendNetworkUpdate();
				Interface.CallHook("OnSignUpdated", this, msg.player);
			}
		}
	}

```

## OnPhoneCallStart(PhoneController,PhoneController,BasePlayer)

```csharp
/// <summary>
/// Called when a phone call starts.
/// </summary>
/// <param name="caller">The PhoneController of the caller.</param>
/// <param name="callee">The PhoneController of the callee.</param>
/// <param name="currentPlayer">The BasePlayer making the call.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnPhoneCallStart(PhoneController caller, PhoneController callee, BasePlayer currentPlayer)
{
    Puts("OnPhoneCallStart is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", this, activeCallTo, currentPlayer) == null)
		{
			if (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)
			{
				_ = currentPlayer != null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			Invoke(TimeOutCall, TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", this, activeCallTo, currentPlayer);
		}
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
/// <summary>
/// Called to determine if the Bradley APC can target a given entity.
/// </summary>
/// <param name="bradleyAPC">The Bradley APC instance.</param>
/// <param name="entity">The entity to check targeting for.</param>
/// <returns>Returns true if the Bradley APC can target the entity, false otherwise.</returns>
bool CanBradleyApcTarget(BradleyAPC bradleyAPC, BaseEntity entity)
{
    Puts("CanBradleyApcTarget is working!");
    
    // If the return value from Interface.CallHook is a boolean, use it
    object obj = Interface.CallHook("CanBradleyApcTarget", this, entity);
    if (obj is bool)
    {
        return (bool)obj;
    }
    
    // Otherwise, default to returning false
    return false;
}
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.transform.position, base.transform.position) < viewDistance))
		{
			return false;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			flag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position + Vector3.up * 0.1f, position);
			if (!flag && basePlayer.isMounted && basePlayer.GetMounted().VehicleParent() != null && basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)
			{
				flag = IsVisible(basePlayer.GetMounted().VehicleParent().bounds.center, position);
			}
			if (flag)
			{
				flag = !UnityEngine.Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);
			}
		}
		else
		{
			Debug.LogWarning("Standard vis test!");
			flag = IsVisible(ent.CenterPoint());
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return flag;
	}

```

## CanDesignFirework(BasePlayer,PatternFirework)

```csharp
/// <summary>
/// Called to determine if a player can design a firework.
/// </summary>
/// <param name="player">The player attempting to design the firework.</param>
/// <param name="firework">The firework being designed.</param>
/// <returns>Returns true if the player has permission, false otherwise.</returns>
bool CanDesignFirework(BasePlayer player, PatternFirework firework)
{
    Puts("CanDesignFirework is working!");
    return true; // Replace with actual logic to determine design permissions
}
```

### Source Code from the Library

```csharp

	private bool PlayerCanModify(BasePlayer player)
	{
		if (player == null || !player.CanInteract())
		{
			return false;
		}
		object obj = Interface.CallHook("CanDesignFirework", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		if (buildingPrivilege != null && !buildingPrivilege.CanAdministrate(player))
		{
			return false;
		}
		return true;
	}

```

## OnDispenserGather(ResourceDispenser,BasePlayer,Item)

```csharp
/// <summary>
/// Called when a resource is gathered from a dispenser.
/// </summary>
/// <param name="dispenser">The dispenser that was used to gather the resource.</param>
/// <param name="player">The player who gathered the resource.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts("OnDispenserGather called!");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		f = Mathf.Round(f);
		float num3 = f * destroyFraction * 2f;
		if (itemAmt.amount <= f + num3)
		{
			float num4 = (f + num3) / itemAmt.amount;
			f /= num4;
			num3 /= num4;
		}
		itemAmt.amount -= Mathf.Floor(f);
		itemAmt.amount -= Mathf.Floor(num3);
		if (f < 1f)
		{
			f = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (f >= 1f)
		{
			int num5 = CalculateGatherBonus(entity, itemAmt, f);
			int iAmount = Mathf.FloorToInt(f) + num5;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (Interface.CallHook("OnDispenserGather", this, entity, item) == null && item != null)
			{
				OverrideOwnership(item, attackWeapon);
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
				Interface.CallHook("OnDispenserGathered", this, entity, item);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnElevatorMove(Elevator,int)

```csharp
/// <summary>
/// Called when an elevator is moved to a new floor.
/// </summary>
/// <param name="elevator">The elevator being moved.</param>
/// <param name="targetFloor">The target floor of the elevator move.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
object OnElevatorMove(Elevator elevator, int targetFloor)
{
    Puts($"Elevator {elevator.GetId()} moved to floor {targetFloor}");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)
	{
		timeToTravel = 0f;
		if (Interface.CallHook("OnElevatorMove", this, targetFloor) != null)
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (!IsStatic && ioEntity != null && !ioEntity.IsPowered())
		{
			return false;
		}
		if (!IsValidFloor(targetFloor))
		{
			return false;
		}
		int num = LiftPositionToFloor();
		if (num == targetFloor)
		{
			OpenDoorsAtFloor(num);
			return false;
		}
		if (!liftEntity.CanMove())
		{
			return false;
		}
		Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);
		if (!GamePhysics.LineOfSight(liftEntity.transform.position, worldSpaceFloorPosition, 2097152))
		{
			return false;
		}
		OnMoveBegin();
		Vector3 vector = base.transform.InverseTransformPoint(worldSpaceFloorPosition);
		timeToTravel = TimeToTravelDistance(Mathf.Abs(liftEntity.transform.localPosition.y - vector.y));
		LeanTween.moveLocalY(liftEntity.gameObject, vector.y, timeToTravel).delay = LiftMoveDelay;
		timeToTravel += LiftMoveDelay;
		SetFlag(Flags.Busy, b: true);
		if (targetFloor < Floor)
		{
			liftEntity.ToggleHurtTrigger(state: true);
		}
		Invoke(ClearBusy, timeToTravel + 1f);
		liftEntity.NotifyNewFloor(targetFloor, Floor);
		if (ioEntity != null)
		{
			ioEntity.SetFlag(Flags.Busy, b: true);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		return true;
	}

```

## OnEngineStatsRefreshed(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
/// <summary>
/// Called when the engine performance stats are refreshed.
/// </summary>
/// <param name="engine">The vehicle module engine.</param>
/// <param name="storage">The engine storage data.</param>
/// <returns>No return behavior.</returns>
void OnEngineStatsRefreshed(VehicleModuleEngine engine, Rust.Modular.EngineStorage storage)
{
    Puts("OnEngineStatsRefreshed is working!");
}
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## OnPlayerVoice(BasePlayer,byte[])

```csharp
/// <summary>
/// Called when a player sends voice data.
/// </summary>
/// <param name="player">The player sending the voice data.</param>
/// <param name="data">The voice data sent by the player.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerVoice(BasePlayer player, byte[] data)
{
    Puts("OnPlayerVoice called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void OnReceivedVoice(byte[] data)
	{
		if (Interface.CallHook("OnPlayerVoice", this, data) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.VoiceData);
			netWrite.EntityID(net.ID);
			netWrite.BytesWithSize(data);
			float num = 0f;
			if (HasPlayerFlag(PlayerFlags.VoiceRangeBoost))
			{
				num = Voice.voiceRangeBoostAmount;
			}
			netWrite.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f + num))
			{
				priority = Priority.Immediate
			});
			if (activeTelephone != null)
			{
				activeTelephone.OnReceivedVoiceFromUser(data);
			}
		}
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
/// <summary>
/// Called when a structure is rotated.
/// </summary>
/// <param name="block">The building block being rotated.</param>
/// <param name="player">The player performing the rotation.</param>
/// <returns>No return behavior.</returns>
void OnStructureRotate(BuildingBlock block, BasePlayer player)
{
    Puts($"Structure rotated by {player} for block: {block}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotateAfterPlacement && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			UpdateSkin(force: true);
			RefreshNeighbours(linkToNeighbours: false);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.NetworkGroup("RefreshSkin"));
			if (!globalNetworkCooldown)
			{
				globalNetworkCooldown = true;
				GlobalNetworkHandler.server.TrySendNetworkUpdate(this);
				CancelInvoke(ResetGlobalNetworkCooldown);
				Invoke(ResetGlobalNetworkCooldown, 15f);
			}
		}
	}

```

## OnCargoShipSpawnCrate(CargoShip)

```csharp
/// <summary>
/// Called when a cargo ship spawns a crate.
/// </summary>
/// <param name="cargoShip">The cargo ship that spawned the crate.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipSpawnCrate(CargoShip cargoShip)
{
    Puts("OnCargoShipSpawnCrate is working!");
}
```

### Source Code from the Library

```csharp

	public void RespawnLoot()
	{
		if (Interface.CallHook("OnCargoShipSpawnCrate", this) == null)
		{
			InvokeRepeating(PlayHorn, 0f, 8f);
			SpawnCrate(lockedCratePrefab.resourcePath);
			SpawnCrate(eliteCratePrefab.resourcePath);
			for (int i = 0; i < 4; i++)
			{
				SpawnCrate(militaryCratePrefab.resourcePath);
			}
			for (int j = 0; j < 4; j++)
			{
				SpawnCrate(junkCratePrefab.resourcePath);
			}
			lootRoundsPassed++;
			if (lootRoundsPassed >= loot_rounds)
			{
				CancelInvoke(RespawnLoot);
			}
		}
	}

```

## OnNpcEquipWeapon(NPCPlayer,Item)

```csharp
/// <summary>
/// Called when an NPC attempts to equip a weapon.
/// </summary>
/// <param name="npc">The NPC attempting to equip the weapon.</param>
/// <param name="weapon">The weapon being equipped.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool OnNpcEquipWeapon(NPCPlayer npc, Item weapon)
{
    Puts("OnNpcEquipWeapon called!");
    // If you want to override the default behavior, return true
    // Otherwise, return false or null
    return false;
}
```

### Source Code from the Library

```csharp

	public virtual void EquipWeapon(bool skipDeployDelay = false)
	{
		if (base.inventory == null || base.inventory.containerBelt == null)
		{
			return;
		}
		Item slot = base.inventory.containerBelt.GetSlot(0);
		if (Interface.CallHook("OnNpcEquipWeapon", this, slot) != null || slot == null)
		{
			return;
		}
		UpdateActiveItem(base.inventory.containerBelt.GetSlot(0).uid);
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		AttackEntity component = heldEntity.GetComponent<AttackEntity>();
		if (component != null)
		{
			if (skipDeployDelay)
			{
				component.ResetAttackCooldown();
			}
			component.TopUpAmmo();
		}
	}

```

## OnExcavatorGather(ExcavatorArm,Item)

```csharp
/// <summary>
/// Called when an excavator arm gathers an item.
/// </summary>
/// <param name="excavatorArm">The excavator arm that gathered the item.</param>
/// <param name="item">The item gathered by the excavator arm.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnExcavatorGather(ExcavatorArm excavatorArm, Item item)
{
    Puts("OnExcavatorGather called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void ProduceResources()
	{
		float num = resourceProductionTickRate / timeForFullResources;
		float num2 = resourcesToMine[resourceMiningIndex].amount * num;
		pendingResources[resourceMiningIndex].amount += num2;
		ItemAmount[] array = pendingResources;
		foreach (ItemAmount itemAmount in array)
		{
			if (!(itemAmount.amount >= (float)outputPiles.Count))
			{
				continue;
			}
			int num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);
			itemAmount.amount -= num3 * 2;
			foreach (ExcavatorOutputPile outputPile in outputPiles)
			{
				Item item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);
				if (Interface.CallHook("OnExcavatorGather", this, item) != null)
				{
					return;
				}
				Facepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);
				if (!item.MoveToContainer(outputPile.inventory))
				{
					item.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());
				}
			}
		}
	}

```

## CanSpectateTarget(BasePlayer,string)

```csharp
/// <summary>
/// Called when a player attempts to spectate a target.
/// </summary>
/// <param name="player">The player attempting to spectate.</param>
/// <param name="targetName">The name of the target to spectate.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool CanSpectateTarget(BasePlayer player, string targetName)
{
    Puts("CanSpectateTarget is working!");
    // If this hook returns null, the default behavior will be executed
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdateSpectateTarget(string strName)
	{
		if (Interface.CallHook("CanSpectateTarget", this, strName) != null)
		{
			return;
		}
		spectateFilter = strName;
		IEnumerable<BaseEntity> enumerable = null;
		if (spectateFilter.StartsWith("@"))
		{
			string filter = spectateFilter.Substring(1);
			enumerable = (from x in BaseNetworkable.serverEntities
				where x.name.Contains(filter, CompareOptions.IgnoreCase)
				where x != this
				select x).Cast<BaseEntity>();
		}
		else
		{
			IEnumerable<BasePlayer> source = activePlayerList.Where((BasePlayer x) => !x.IsSpectating() && !x.IsDead() && !x.IsSleeping());
			if (strName.Length > 0)
			{
				source = from x in source
					where x.displayName.Contains(spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)
					where x != this
					select x;
			}
			source = source.OrderBy((BasePlayer x) => x.displayName);
			enumerable = source.Cast<BaseEntity>();
		}
		BaseEntity[] array = enumerable.ToArray();
		if (array.Length == 0)
		{
			ChatMessage("No valid spectate targets!");
			return;
		}
		BaseEntity baseEntity = array[SpectateOffset % array.Length];
		if (baseEntity != null)
		{
			SpectatePlayer(baseEntity);
		}
	}

```

## OnShopCancelClick(ShopFront,BasePlayer)

```csharp
/// <summary>
/// Called when a player cancels the shop click.
/// </summary>
/// <param name="shopFront">The shop front.</param>
/// <param name="player">The player who canceled the shop click.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnShopCancelClick(ShopFront shopFront, BasePlayer player)
{
    Puts("OnShopCancelClick is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", this, msg.player) == null)
		{
			_ = (bool)vendorPlayer;
			_ = (bool)customerPlayer;
			ResetTrade();
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
/// <summary>
/// Called when a trade is completed in the shop.
/// </summary>
/// <param name="shopFront">The shop front where the trade was completed.</param>
/// <returns>No return behavior.</returns>
void OnShopCompleteTrade(ShopFront shopFront)
{
    Puts("OnShopCompleteTrade is working!");
}
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			try
			{
				swappingItems = true;
				for (int num = vendorInventory.capacity - 1; num >= 0; num--)
				{
					Item slot = vendorInventory.GetSlot(num);
					Item slot2 = customerInventory.GetSlot(num);
					if ((bool)customerPlayer && slot != null)
					{
						customerPlayer.GiveItem(slot);
					}
					if ((bool)vendorPlayer && slot2 != null)
					{
						vendorPlayer.GiveItem(slot2);
					}
				}
			}
			finally
			{
				swappingItems = false;
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnLootEntityEnd(BasePlayer,ItemBasedFlowRestrictor)

```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="restrictor">The item-based flow restrictor that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ItemBasedFlowRestrictor restrictor)
{
    Puts($"Player {player.Name} stopped looting entity with {restrictor.GetItemCount()} items");
}
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
	}

```

## OnPlayerCorpseSpawn(BasePlayer)

```csharp
/// <summary>
/// Called when a player's corpse is spawned.
/// </summary>
/// <param name="player">The player whose corpse is being spawned.</param>
/// <returns>Returns the spawned corpse, or null if the default behavior is overridden.</returns>
object OnPlayerCorpseSpawn(BasePlayer player)
{
    Puts("OnPlayerCorpseSpawn is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = ((!(ConVar.Physics.serversideragdolls || forceServerSide)) ? "assets/prefabs/player/player_corpse.prefab" : "assets/prefabs/player/player_corpse_new.prefab");
			bool flag = false;
			if (ConVar.Global.cinematicGingerbreadCorpses)
			{
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);
						flag = component.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab, posOnDeath, rotOnDeath, flagsOnDeath, modelState) as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(this, inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.streamerName = RandomUsernames.Get(userID);
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				if (!CollectionEx.IsNullOrEmpty(triggersOnDeath))
				{
					foreach (TriggerBase item2 in triggersOnDeath)
					{
						if (item2 is TriggerParent triggerParent)
						{
							triggerParent.ForceParentEarly(playerCorpse);
						}
					}
				}
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			UnityEngine.Random.State state = UnityEngine.Random.state;
			UnityEngine.Random.InitState((int)(seed + steamid));
			float result = UnityEngine.Random.Range(0f, 1f);
			UnityEngine.Random.state = state;
			return result;
		}
	}

```

## OnTechTreeNodeUnlock(Workbench,TechTreeData.NodeInstance,BasePlayer)

```csharp
/// <summary>
/// Called when a tech tree node is unlocked.
/// </summary>
/// <param name="workbench">The workbench instance.</param>
/// <param name="nodeInstance">The tech tree node instance being unlocked.</param>
/// <param name="player">The player unlocking the node.</param>
/// <returns>Returns null if the default behavior is not overridden.</returns>
object OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance nodeInstance, BasePlayer player)
{
    Puts("OnTechTreeNodeUnlock called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int id = msg.read.Int32();
		int level = msg.read.Int32();
		TechTreeData techTreeForLevel = GetTechTreeForLevel(level);
		if (techTreeForLevel == null)
		{
			return;
		}
		TechTreeData.NodeInstance byID = techTreeForLevel.GetByID(id);
		if (byID == null)
		{
			Debug.Log("Node for unlock not found :" + id);
		}
		else
		{
			if (!techTreeForLevel.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTreeForLevel.GetByID(output);
					if (byID2 != null && byID2.itemDef != null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", 0, this);
					}
				}
				Debug.Log("Player unlocked group :" + byID.groupName);
			}
			else if (byID.itemDef != null && Interface.CallHook("OnTechTreeNodeUnlock", this, byID, player) == null)
			{
				int tax;
				int num = ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out tax);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num + tax)
				{
					player.inventory.Take(null, itemid, num + tax);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", this, byID, player);
					Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", num + tax, this);
				}
			}
		}
	}

```

## OnBedMade(SleepingBag,BasePlayer)

```csharp
/// <summary>
/// Called when a player makes their bed.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being used.</param>
/// <param name="player">The player making their bed.</param>
/// <returns>Returns the sleeping bag, or null if no sleeping bag is assigned.</returns>
object OnBedMade(SleepingBag sleepingBag, BasePlayer player)
{
    Puts("OnBedMade hook called!");
    return sleepingBag;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_MakeBed(RPCMessage msg)
	{
		if (!canBePublic || !IsPublic() || !msg.player.CanInteract())
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
			if (canAssignBedResult.HasValue)
			{
				if (canAssignBedResult.Value.Result != 0)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, cannotMakeBedPhrase);
				}
				else
				{
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num = deployerUserID;
		deployerUserID = msg.player.userID;
		NotifyPlayer(num);
		NotifyPlayer(deployerUserID);
		OnBagChangedOwnership(this, num);
		Interface.CallHook("OnBedMade", this, msg.player);
		SendNetworkUpdate();
	}

```

## OnEngineStart(MotorRowboat,BasePlayer)

```csharp
/// <summary>
/// Called when the engine of a motorized rowboat is started.
/// </summary>
/// <param name="rowboat">The motorized rowboat.</param>
/// <param name="driver">The driver of the rowboat.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnEngineStart(MotorRowboat rowboat, BasePlayer driver)
{
    Puts("OnEngineStart hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.On, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
			if (wantsOn)
			{
				rigidBody.WakeUp();
				buoyancy.Wake();
			}
		}
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int,ItemContainer)

```csharp
Документация для OnVendingTransaction(VendingMachine,BasePlayer,int,int,ItemContainer)

**Описание**

Функция OnVendingTransaction вызывается при выполнении транзакции на автомате. Она позволяет модулю проверить и подтвердить транзакцию.

**Параметры**

* `VendingMachine`: Объект автомата.
* `BasePlayer`: Игрок, совершивший покупку.
* `sellOrderId`: Номер заказа продажи.
* `numberOfTransactions`: Количество транзакций.
* `ItemContainer`: Контейнер для хранения проданного товара.

**Возвращаемые значения**

Функция возвращает `bool` значение, указывающее, была ли транзакция успешно выполнена.

**Описание процесса**

1. Функция проверяет, является ли номер заказа продажи корректным.
2. Если контейнер для хранения проданного товара не задан и расстояние между игроком и автоматом превышает 4 единиц, функция возвращает `false`.
3. Функция вызывает OnVendingTransaction хук с параметрами: `VendingMachine`, `BasePlayer`, `sellOrderId`, `numberOfTransactions` и `ItemContainer`.
4. Если результат OnVendingTransaction хука является `bool` значением, функция возвращает его.
5. Иначе функция продолжает выполнение транзакции.

**Примечания**

* Функция может быть вызвана только один раз для каждой транзакции.
* Если транзакция не удалась, функция вернет `false`.
* Если транзакция успешно завершена, функция вернет `true`.
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions, targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> obj2 = Facepunch.Pool.GetList<Item>();
		GetItemsToSell(sellOrder, obj2);
		if (obj2 == null || obj2.Count == 0)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = obj2.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		List<Item> source = buyer.inventory.FindItemsByItemID(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = (from x in source
			where !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)
			where x.GetItemVolume() <= maxCurrencyVolume
			select x).ToList();
		if (source.Count == 0)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = GetTotalPriceForOrder(sellOrder) * numberOfTransactions;
		if (num3 < num4)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			TakeCurrencyItem(item);
			onCurrencyRemoved?.Invoke(buyer, item);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		Facepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, num4, sellOrder.currencyIsBP, numberOfTransactions, sellOrder.priceMultiplier, droneMarketTerminal);
		int num7 = 0;
		foreach (Item item4 in obj2)
		{
			int num8 = num - num7;
			Item item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);
			if (item2 == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item2.amount;
				object obj3 = Interface.CallHook("CanPurchaseItem", buyer, item2, onItemPurchased, this, targetContainer);
				if (obj3 != null)
				{
					if (!(obj3 is bool))
					{
						return false;
					}
					return (bool)obj3;
				}
				RecordSaleAnalytics(item2, sellOrderId);
				if (targetContainer == null)
				{
					GiveSoldItem(item2, buyer);
				}
				else if (!item2.MoveToContainer(targetContainer))
				{
					item2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
				}
				onItemPurchased?.Invoke(buyer, item2);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## OnClientCommand(Network.Connection,string)

```csharp
/// <summary>
/// Called when a client sends a command to the server.
/// </summary>
/// <param name="connection">The client's connection.</param>
/// <param name="command">The command sent by the client.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns the result of the hook.</returns>
object OnClientCommand(Network.Connection connection, string command)
{
    // Minimal code to demonstrate functionality
    Puts("OnClientCommand called!");
    
    return null;
}
```

### Source Code from the Library

```csharp

	internal static void OnClientCommand(Message packet)
	{
		if (packet.read.Unread > ConVar.Server.maxpacketsize_command)
		{
			UnityEngine.Debug.LogWarning("Dropping client command due to size");
			return;
		}
		timer.Restart();
		string text = packet.read.StringRaw();
		if (packet.connection == null || !packet.connection.connected)
		{
			UnityEngine.Debug.LogWarning("Client without connection tried to run command: " + text);
		}
		else if (Interface.CallHook("OnClientCommand", packet.connection, text) == null)
		{
			string text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text);
			if (!string.IsNullOrEmpty(text2))
			{
				SendClientReply(packet.connection, text2);
			}
			if (timer.Elapsed > RuntimeProfiler.ConsoleCommandWarningThreshold)
			{
				LagSpikeProfiler.ConsoleCommand(timer.Elapsed, packet, text);
			}
		}
	}

```

## OnResearchCostDetermine(ItemDefinition)

```csharp
/// <summary>
/// Called to determine the research cost of an item.
/// </summary>
/// <param name="info">The item definition.</param>
/// <returns>The research cost, or null if not overridden.</returns>
object OnResearchCostDetermine(ItemDefinition info)
{
    Puts("OnResearchCostDetermine is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public static int ScrapForResearch(ItemDefinition info)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", info);
		if (obj is int)
		{
			return (int)obj;
		}
		if (info.isRedirectOf != null)
		{
			return ScrapForResearch(info.isRedirectOf);
		}
		int result = 0;
		if (info.rarity == Rarity.Common)
		{
			result = 20;
		}
		if (info.rarity == Rarity.Uncommon)
		{
			result = 75;
		}
		if (info.rarity == Rarity.Rare)
		{
			result = 125;
		}
		if (info.rarity == Rarity.VeryRare || info.rarity == Rarity.None)
		{
			result = 500;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(info);
		if (itemBlueprint != null && itemBlueprint.defaultBlueprint)
		{
			return ConVar.Server.defaultBlueprintResearchCost;
		}
		return result;
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player who is falling asleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has started sleeping.");
}
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping())
		{
			Interface.CallHook("OnPlayerSleep", this);
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: false);
			}
			if (InSafeZone() && !IsInvoking(ScheduledDeath))
			{
				Invoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);
			}
			BaseMountable baseMountable = GetMounted();
			if (baseMountable != null && !AllowSleeperMounting(baseMountable))
			{
				EnsureDismounted();
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			sleepStartTime = UnityEngine.Time.time;
			sleepingPlayerList.TryAdd(this);
			bots.Remove(this);
			CancelInvoke(InventoryUpdate);
			CancelInvoke(TeamUpdate);
			CancelInvoke(UpdateClanLastSeen);
			inventory.loot.Clear();
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			EnablePlayerCollider();
			if (!IsLoadingAfterTransfer())
			{
				RemovePlayerRigidbody();
				TurnOffAllLights();
			}
			SetServerFall(wantsOn: true);
		}
	}

```

## OnXmasLootDistribute(XMasRefill)

```csharp
/// <summary>
/// Called when Christmas loot is distributed.
/// </summary>
/// <param name="refill">The XMasRefill object.</param>
/// <returns>No return behavior.</returns>
void OnXmasLootDistribute(XMasRefill refill)
{
    Puts("OnXmasLootDistribute is working!");
}
```

### Source Code from the Library

```csharp

	public override void ServerInit()
	{
		base.ServerInit();
		if (!XMas.enabled)
		{
			Invoke(RemoveMe, 0.1f);
			return;
		}
		goodKids = ((BasePlayer.activePlayerList != null) ? new List<BasePlayer>(BasePlayer.activePlayerList) : new List<BasePlayer>());
		stockings = ((Stocking.stockings != null) ? new List<Stocking>(Stocking.stockings.Values) : new List<Stocking>());
		Invoke(RemoveMe, 60f);
		if (Interface.CallHook("OnXmasLootDistribute", this) == null)
		{
			InvokeRepeating(DistributeLoot, 3f, 0.02f);
			Invoke(SendBells, 0.5f);
		}
	}

```

## OnItemStacked(Item,Item,ItemContainer,int)

```csharp
Документация для OnItemStacked(Item, Item, ItemContainer, int)

**Описание**

Этот хук вызывается при попытке стэкнуть предметы в контейнере. Он позволяет модулю или плагину отслеживать и реагировать на события стэкинга предметов.

**Параметры**

* `Item`: Предмет, который будет стэкнут.
* `ItemContainer`: Контейнер, в который будет стэкнут предмет.
* `int`: Количество предметов, которые будут стэкнуты.

**Событие**

Этот хук вызывается после того, как предмет был успешно стэкнут в контейнер. Он позволяет модулю или плагину отслеживать и реагировать на события стэкинга предметов.

**Пример использования**

Например, вы можете использовать этот хук для отображения количества стэкнутых предметов в игре:
```csharp
public void OnItemStacked(Item item, ItemContainer container, int amount)
{
    // Отображаем количество стэкнутых предметов
    Console.WriteLine($"Предмет {item.name} стэкнут в контейнере {container.name} ({amount} шт.)");
}
```
**Примечания**

Этот хук вызывается только при успешном стэкинге предмета. Если попытка стэкинга не удалась, этот хук не будет вызван.
```

### Source Code from the Library

```csharp

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		using (TimeWarning.New("MoveToContainer"))
		{
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					foreach (Item item3 in from x in newcontainer.FindItemsByItemID(info.itemid)
						orderby x.position
						select x)
					{
						if (item3.CanStack(this) && (ignoreStackLimit || item3.amount < item3.MaxStackable()))
						{
							iTargetPos = item3.position;
						}
					}
				}
				if (iTargetPos == -1 && newcontainer.GetEntityOwner(returnHeldEntity: true) is IIdealSlotEntity idealSlotEntity)
				{
					iTargetPos = idealSlotEntity.GetIdealSlot(sourcePlayer, newcontainer, this);
					if (iTargetPos == int.MinValue)
					{
						return false;
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.availableSlots != null && newcontainer.availableSlots.Count > 0 && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						newcontainer.onItemAddedToStack?.Invoke(slot2, num2);
						amount -= num2;
						slot2.MarkDirty();
						Interface.CallHook("OnItemStacked", slot2, this, newcontainer, num2);
						MarkDirty();
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer newcontainer2 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					if (itemContainer2.maxStackSize > 0 && slot2.amount > itemContainer2.maxStackSize)
					{
						Item item = slot2.SplitItem(slot2.amount - itemContainer2.maxStackSize);
						if (item == null || !item.MoveToContainer(newcontainer2, -1, allowStack: false, ignoreStackLimit: false, sourcePlayer, allowSwap: false))
						{
							slot2.amount += item.amount;
							item.Remove();
							return false;
						}
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(newcontainer2);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item2 = SplitItem(newcontainer.maxStackSize);
				if (item2 != null && !item2.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item2.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					DroppedItem droppedItem = item2.Drop(newcontainer.dropPosition, newcontainer.dropVelocity) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DroppedBy = sourcePlayer?.userID ?? ((BasePlayer.EncryptedValue<ulong>)0uL);
					}
				}
				Interface.CallHook("OnItemStacked", item2, this, newcontainer);
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
	}

```

## OnCargoShipHarborArrived(CargoShip)

```csharp
/// <summary>
/// Called when a cargo ship arrives at the harbor.
/// </summary>
/// <param name="cargoShip">The cargo ship that arrived.</param>
/// <returns>No return behavior.</returns>
void OnCargoShipHarborArrived(CargoShip cargoShip)
{
    Puts("OnCargoShipHarborArrived is working!");
}
```

### Source Code from the Library

```csharp

	public void OnArrivedAtHarbor()
	{
		SetFlag(Flags.Reserved1, b: true);
		List<Transform> obj = Pool.GetList<Transform>();
		float num = UnityEngine.Random.Range(dock_time * 0.05f, dock_time * 0.1f);
		foreach (HarborCraneContainerPickup allCrane in HarborCraneContainerPickup.AllCranes)
		{
			if (allCrane == null || allCrane.isClient || allCrane.Distance2D(this) > 150f)
			{
				continue;
			}
			obj.Clear();
			CargoShipContainerDestination[] array = containerDestinations;
			foreach (CargoShipContainerDestination cargoShipContainerDestination in array)
			{
				if (allCrane.IsDestinationValidForCrane(cargoShipContainerDestination))
				{
					obj.Add(cargoShipContainerDestination.transform);
				}
			}
			if (obj.Count > 0)
			{
				allCrane.AssignDestination(obj, this, num);
				num += dock_time * UnityEngine.Random.Range(0.1f, 0.15f);
			}
		}
		Pool.FreeList(ref obj);
		Invoke(PreHarborLeaveHorn, dock_time - 60f);
		if (refresh_loot_on_dock)
		{
			RespawnLoot();
		}
		if (harborIndex == 0)
		{
			SetFlag(Flags.Reserved3, b: true);
		}
		else if (harborIndex == 1)
		{
			SetFlag(Flags.Reserved4, b: true);
		}
		Invoke(LeaveHarbor, dock_time);
		Interface.CallHook("OnCargoShipHarborArrived", this);
	}

```

## OnPhoneAnswered(PhoneController,PhoneController)

```csharp
/// <summary>
/// Called when a phone call is answered.
/// </summary>
/// <param name="phoneController">The controller of the phone that was answered.</param>
/// <param name="activeCallTo">The entity being called.</param>
/// <returns>No return behavior.</returns>
void OnPhoneAnswered(PhoneController phoneController, PhoneController activeCallTo)
{
    Puts("Phone call answered!");
}
```

### Source Code from the Library

```csharp

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (IsInvoking(TimeOutDialing))
		{
			CancelInvoke(TimeOutDialing);
		}
		if (!(activeCallTo == null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", this, activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", this, activeCallTo);
			}
		}
	}

```

## IOnRconInitialize()

```csharp
/// <summary>
/// Called when the RCON initialization process begins.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRconInitialize()
{
    Puts("IOnRconInitialize is working!");
}
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", ""));
		if (Password == "password" || Password == "")
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)
			{
				Command item = JsonConvert.DeserializeObject<Command>(msg);
				item.Ip = ip;
				item.ConnectionId = id;
				Commands.Enqueue(item);
			};
			listenerNew.Start();
			UnityEngine.Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			UnityEngine.Debug.Log("RCon Started on " + Port);
			UnityEngine.Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## CanUseHBHFSensor(BasePlayer,HBHFSensor)

```csharp
/// <summary>
/// Called to determine if a player can use the HBHF sensor.
/// </summary>
/// <param name="player">The player attempting to use the sensor.</param>
/// <param name="sensor">The HBHF sensor being used.</param>
/// <returns>Returns true if the player can use the sensor, and false otherwise.</returns>
bool CanUseHBHFSensor(BasePlayer player, HBHFSensor sensor)
{
    Puts("CanUseHBHFSensor is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public bool CanUse(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseHBHFSensor", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnTeamCreate(BasePlayer)

```csharp
/// <summary>
/// Called when a team is created.
/// </summary>
/// <param name="player">The player who created the team.</param>
/// <returns>Returns null if the default behavior is not overridden.</returns>
object OnTeamCreate(BasePlayer player)
{
    Puts("OnTeamCreate called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Facepunch.Rust.Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
/// <summary>
/// Called when a rocket is launched.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="baseEntity">The entity that was launched.</param>
/// <returns>No return behavior.</returns>
void OnRocketLaunched(BasePlayer player, BaseEntity baseEntity)
{
    Puts($"Rocket launched by {player.name} at {baseEntity.transform.position}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (!base.UsingInfiniteAmmoCheat)
		{
			if (primaryMagazine.contents <= 0)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "magazine_empty");
				return;
			}
			ModifyAmmoCount(-1);
		}
		SignalBroadcast(Signal.Attack, string.Empty, player.net.connection);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		bool num = msg.read.Bit();
		BaseEntity mounted = player.GetParentEntity();
		if (mounted == null)
		{
			mounted = player.GetMounted();
		}
		if (num)
		{
			if (mounted != null)
			{
				vector = mounted.transform.TransformPoint(vector);
				vector2 = mounted.transform.TransformDirection(vector2);
			}
			else
			{
				vector = player.eyes.position;
				vector2 = player.eyes.BodyForward();
			}
		}
		if (!ValidateEyePos(player, vector))
		{
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		float num2 = GetAimCone() + component.projectileSpread;
		if (num2 > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);
		}
		float num3 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1237003025))
		{
			num3 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num3);
		if (baseEntity == null)
		{
			return;
		}
		baseEntity.creatorEntity = player;
		ServerProjectile component2 = baseEntity.GetComponent<ServerProjectile>();
		if ((bool)component2)
		{
			component2.InitializeVelocity(GetInheritedVelocity(player, vector2) + vector2 * component2.speed * initialSpeedMultiplier);
		}
		baseEntity.Spawn();
		ProjectileLaunched_Server(component2);
		Facepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity, this);
		Interface.CallHook("OnRocketLaunched", player, baseEntity);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			if (!base.UsingInfiniteAmmoCheat)
			{
				ownerItem.LoseCondition(UnityEngine.Random.Range(1f, 2f));
			}
			BaseMountable mounted2 = player.GetMounted();
			if (mounted2 != null)
			{
				mounted2.OnWeaponFired(this);
			}
		}
	}

```

## OnHorseHitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
/// <summary>
/// Called when a ridable horse is hitched to a hitch trough.
/// </summary>
/// <param name="horse">The ridable horse being hitched.</param>
/// <param name="hitchSpot">The spot where the horse is being hitched.</param>
/// <returns>Returns true if the horse was successfully hitched, and false otherwise.</returns>
bool OnHorseHitch(RidableHorse horse, HitchTrough.HitchSpot hitchSpot)
{
    Puts("OnHorseHitch called!");
    // Minimal code to demonstrate functionality
    return true;
}
```

### Source Code from the Library

```csharp

	public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch = null)
	{
		if (horse == null)
		{
			return false;
		}
		if (hitch == null)
		{
			hitch = GetClosest(horse.transform.position);
		}
		if (hitch != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", horse, hitch);
			if (obj is bool)
			{
				return (bool)obj;
			}
			hitch.SetOccupiedBy(horse);
			horse.SetHitch(this);
			horse.transform.SetPositionAndRotation(hitch.spot.position, hitch.spot.rotation);
			horse.DismountAllPlayers();
			return true;
		}
		return false;
	}

```

## OnCoalingTowerGather(CoalingTower,Item)

```csharp
/// <summary>
/// Called when a coaling tower gathers an item.
/// </summary>
/// <param name="coalingTower">The coaling tower gathering the item.</param>
/// <param name="item">The item being gathered.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns the result of the hook.</returns>
object OnCoalingTowerGather(CoalingTower coalingTower, Item item)
{
    // Minimal code to demonstrate functionality
    Puts("OnCoalingTowerGather called!");
    
    // Return the result of the hook if it's not null
    return Interface.CallHook("OnCoalingTowerGather", coalingTower, item);
}
```

### Source Code from the Library

```csharp

	private void EmptyTenPercent()
	{
		if (!IsPowered())
		{
			EndEmptyProcess(ActionAttemptStatus.GenericError);
			return;
		}
		if (!HasUnloadableLinedUp)
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		TrainCarUnloadable activeUnloadable = GetActiveUnloadable();
		if (tcUnloadingNow == null || activeUnloadable != tcUnloadingNow)
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		StorageContainer storageContainer = tcUnloadingNow.GetStorageContainer();
		if (storageContainer.inventory == null || !TrainWagonLootData.instance.TryGetLootFromIndex(LootTypeIndex, out var lootOption))
		{
			EndEmptyProcess(ActionAttemptStatus.NoTrainCar);
			return;
		}
		bool flag = tcUnloadingNow.wagonType != TrainCarUnloadable.WagonType.Fuel;
		ItemContainer itemContainer = null;
		PercentFullStorageContainer percentFullStorageContainer = (flag ? GetOreStorage() : GetFuelStorage());
		if (percentFullStorageContainer != null)
		{
			itemContainer = percentFullStorageContainer.inventory;
		}
		if (itemContainer == null)
		{
			EndEmptyProcess(ActionAttemptStatus.GenericError);
			return;
		}
		ItemContainer inventory = storageContainer.inventory;
		ItemContainer newcontainer = itemContainer;
		int iAmount = Mathf.RoundToInt((float)lootOption.maxLootAmount / 10f);
		List<Item> obj = Facepunch.Pool.GetList<Item>();
		int num = inventory.Take(obj, lootOption.lootItem.itemid, iAmount);
		bool flag2 = true;
		if (num > 0)
		{
			foreach (Item item in obj)
			{
				if (tcUnloadingNow.wagonType == TrainCarUnloadable.WagonType.Lootboxes)
				{
					item.Remove();
					continue;
				}
				if (Interface.CallHook("OnCoalingTowerGather", this, item) != null)
				{
					item.Remove();
					continue;
				}
				bool flag3 = item.MoveToContainer(newcontainer);
				if (!flag2 || flag3)
				{
					continue;
				}
				item.MoveToContainer(inventory);
				flag2 = false;
				break;
			}
		}
		Facepunch.Pool.FreeList(ref obj);
		float orePercent = tcUnloadingNow.GetOrePercent();
		if (orePercent == 0f)
		{
			EndEmptyProcess(ActionAttemptStatus.NoError);
		}
		else if (!flag2)
		{
			EndEmptyProcess(ActionAttemptStatus.OutputIsFull);
		}
		else if (flag)
		{
			tcUnloadingNow.SetVisualOreLevel(orePercent);
		}
	}

```

## OnBookmarkControl(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
/// <summary>
/// Called when a player starts controlling a bookmark.
/// </summary>
/// <param name="computerStation">The computer station being controlled.</param>
/// <param name="player">The player controlling the bookmark.</param>
/// <param name="bookmarkName">The name of the bookmark being controlled.</param>
/// <param name="remoteControllable">The remote controllable entity being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControl(ComputerStation computerStation, BasePlayer player, string bookmarkName, IRemoteControllable remoteControllable)
{
    Puts($"Player {player.UserIDString} started controlling bookmark {bookmarkName}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## OnCollectiblePickedup(CollectibleEntity,BasePlayer,Item)

```csharp
/// <summary>
/// Called when a collectible item is picked up by a player.
/// </summary>
/// <param name="entity">The collectible entity being picked up.</param>
/// <param name="player">The player who picked up the collectible.</param>
/// <param name="item">The item that was picked up.</param>
/// <returns>No return behavior.</returns>
void OnCollectiblePickedup(CollectibleEntity entity, BasePlayer player, Item item)
{
    Puts($"Collectible {entity} picked up by player {player}");
}
```

### Source Code from the Library

```csharp

	public void DoPickup(BasePlayer reciever, bool eat = false)
	{
		if (itemList == null || Interface.CallHook("OnCollectiblePickup", this, reciever, eat) != null)
		{
			return;
		}
		ItemAmount[] array = itemList;
		foreach (ItemAmount itemAmount in array)
		{
			if (reciever != null && reciever.IsInTutorial && itemAmount.ignoreInTutorial)
			{
				continue;
			}
			Item item = ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL);
			if (item == null)
			{
				continue;
			}
			if (eat && item.info.category == ItemCategory.Food && reciever != null)
			{
				ItemModConsume component = item.info.GetComponent<ItemModConsume>();
				if (component != null)
				{
					component.DoAction(item, reciever);
					continue;
				}
			}
			if ((bool)reciever)
			{
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever);
				Interface.CallHook("OnCollectiblePickedup", this, reciever, item);
				reciever.GiveItem(item, GiveItemReason.ResourceHarvested);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up);
			}
		}
		itemList = null;
		if (pickupEffect.isValid)
		{
			Effect.server.Run(pickupEffect.resourcePath, base.transform.position, base.transform.up);
		}
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(reciever, base.transform.position);
		}
		Kill();
	}

```

## CanAssignBed(BasePlayer,SleepingBag,ulong)

```csharp
/// <summary>
/// Called when a player attempts to assign a bed.
/// </summary>
/// <param name="player">The player attempting to assign the bed.</param>
/// <param name="sleepingBag">The sleeping bag being assigned.</param>
/// <param name="ownerID">The ID of the owner.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object CanAssignBed(BasePlayer player, SleepingBag sleepingBag, ulong ownerID)
{
    Puts("CanAssignBed is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (!msg.player.CanInteract() || deployerUserID != (ulong)msg.player.userID)
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num == 0L || Interface.CallHook("CanAssignBed", msg.player, this, num) != null)
		{
			return;
		}
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanAssignBedResult? canAssignBedResult = CanAssignBed(msg.player, this, num);
			if (canAssignBedResult.HasValue)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(num);
				if (canAssignBedResult.Value.Result == BagResultType.TooManyBags)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, cannotAssignBedPhrase, basePlayer?.displayName ?? "other player");
				}
				else if (canAssignBedResult.Value.Result == BagResultType.BagBlocked)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, bedAssigningBlocked);
				}
				else if (canAssignBedResult.Value.Result == BagResultType.TargetIsPlayingTutorial)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, tutorialPhrase);
				}
				else
				{
					basePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, (GetSleepingBagCount(msg.player.userID) - 1).ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (canAssignBedResult.Value.Result != 0)
				{
					return;
				}
			}
		}
		ulong num2 = deployerUserID;
		deployerUserID = num;
		NotifyPlayer(num2);
		NotifyPlayer(deployerUserID);
		OnBagChangedOwnership(this, num2);
		Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);
		SendNetworkUpdate();
	}

```

## CanSwapToSeat(BasePlayer,BaseMountable)

```csharp
/// <summary>
/// Called when a player attempts to swap seats with the entity.
/// </summary>
/// <param name="player">The player attempting to swap seats.</param>
/// <param name="entity">The entity being swapped with.</param>
/// <returns>Returns true if the default behavior is allowed, and false otherwise.</returns>
bool CanSwapToSeat(BasePlayer player, BaseMountable entity)
{
    Puts("CanSwapToSeat is working!");
    return true;
}
```

### Source Code from the Library

```csharp

	public virtual bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnEntityDestroy(BradleyAPC)

```csharp
Документация для OnEntityDestroy(BradleyAPC):

/// <summary>
/// Called when a Bradley APC is destroyed.
/// </summary>

public void OnEntityDestroy(BaseEntity entity)
{
    // Minimal code to demonstrate functionality
    if (entity == null || !(entity is BradleyAPC))
        return;

    // Additional logic can be added here as needed
}
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (base.isClient || Interface.CallHook("OnEntityDestroy", this) != null)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);
		Vector3 zero = Vector3.zero;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);
		for (int i = 0; i < 12 - maxCratesToSpawn; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);
			if (!baseEntity)
			{
				continue;
			}
			float minInclusive = 3f;
			float maxInclusive = 10f;
			Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
			baseEntity.transform.position = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * UnityEngine.Random.Range(-4f, 4f);
			Collider component = baseEntity.GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(zero + onUnitSphere * UnityEngine.Random.Range(minInclusive, maxInclusive));
			foreach (ServerGib item in list)
			{
				UnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;
			onUnitSphere2.y = 0f;
			onUnitSphere2.Normalize();
			Vector3 pos = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if ((bool)lootContainer)
			{
				lootContainer.Invoke(lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = baseEntity2.GetComponent<Collider>();
			Rigidbody rigidbody = baseEntity2.gameObject.AddComponent<Rigidbody>();
			rigidbody.useGravity = true;
			rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
			rigidbody.mass = 2f;
			rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
			rigidbody.velocity = zero + onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);
			rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
			rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if ((bool)fireBall)
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				fireBall.GetComponent<Rigidbody>().isKinematic = true;
				fireBall.GetComponent<Collider>().enabled = false;
			}
			baseEntity2.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);
			foreach (ServerGib item2 in list)
			{
				UnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);
			}
		}
		KillSpawnedScientists();
		if (info != null && info.InitiatorPlayer != null && info.InitiatorPlayer.serverClan != null)
		{
			info.InitiatorPlayer.AddClanScore(ClanScoreEventType.DestroyedBradley);
		}
		base.OnKilled(info);
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
/// <summary>
/// Called when an item is attempted to be accepted into a container.
/// </summary>
/// <param name="container">The container attempting to accept the item.</param>
/// <param name="item">The item being accepted.</param>
/// <param name="targetPos">The target position in the container where the item will be placed.</param>
/// <returns>Returns a CanAcceptResult indicating whether the item can be accepted or not.</returns>
CanAcceptResult CanAcceptItem(ItemContainer container, Item item, int targetPos)
{
    Puts("CanAcceptItem is working!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (isServer && availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			if (item.isBroken)
			{
				return CanAcceptResult.CannotAccept;
			}
			int num = 0;
			foreach (ItemSlot availableSlot in availableSlots)
			{
				num |= (int)availableSlot;
			}
			if (((uint)num & (uint)item.info.occupySlots) != (uint)item.info.occupySlots)
			{
				return CanAcceptResult.CannotAcceptRightNow;
			}
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (HasLimitedAllowedItems)
		{
			bool flag = false;
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if (onlyAllowedItems[i] == item.info)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return CanAcceptResult.CannotAccept;
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		if (blockedItems != null && blockedItems.Contains(item.info))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (item.GetItemVolume() > containerVolume)
		{
			return CanAcceptResult.CannotAccept;
		}
		return CanAcceptResult.CanAccept;
	}

```

## OnItemSplit(Item,int)

```csharp
/// <summary>
/// Called when an item is split into multiple items.
/// </summary>
/// <param name="item">The original item being split.</param>
/// <param name="splitAmount">The amount to split the item by.</param>
/// <returns>Returns a new item if the default behavior is overridden, otherwise returns null.</returns>
object OnItemSplit(Item item, int splitAmount)
{
    Puts("OnItemSplit hook called!");
    // If the return value is used to determine the correct return type
    // (e.g., obj is Item), then this method should return a new item.
    // Otherwise, it can simply return null or another value depending on the method's functionality.
    return null;
}
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		item.skin = skin;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		if (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
		}
		if (instanceData != null && instanceData.dataInt > 0 && info != null && info.Blueprint != null && info.Blueprint.workbenchLevelRequired == 3)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
			item.SetFlag(Flag.IsOn, IsOn());
		}
		MarkDirty();
		return item;
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
/// <summary>
/// Called when an item is upgraded.
/// </summary>
/// <param name="item">The original item.</param>
/// <param name="upgradedItem">The upgraded item.</param>
/// <param name="player">The player who performed the upgrade.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemUpgrade(Item item, Item upgradedItem, BasePlayer player)
{
    Puts("OnItemUpgrade hook called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (UnityEngine.Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnHelicopterDropDoorOpen(CH47HelicopterAIController)

```csharp
/// <summary>
/// Called when the helicopter's drop door is opened or closed.
/// </summary>
/// <param name="controller">The AI controller of the CH47 helicopter.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnHelicopterDropDoorOpen(CH47HelicopterAIController controller)
{
    Puts("OnHelicopterDropDoorOpen is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The storage container being used for looting.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.Name} finished looting entity.");
}
</prompt>
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnExperimentStarted(Workbench,BasePlayer)

```csharp
/// <summary>
/// Called when an experiment is started.
/// </summary>
/// <param name="workbench">The workbench where the experiment is being conducted.</param>
/// <param name="player">The player who initiated the experiment.</param>
/// <returns>No return behavior.</returns>
void OnExperimentStarted(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment started by {player.displayName} on workbench {workbench.name}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## OnItemCraft(IndustrialCrafter,ItemBlueprint)

```csharp
/// <summary>
/// Called when an item is being crafted using an industrial crafter.
/// </summary>
/// <param name="crafter">The industrial crafter performing the craft.</param>
/// <param name="blueprint">The blueprint for the item being crafted.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemCraft(IndustrialCrafter crafter, ItemBlueprint blueprint)
{
    Puts("OnItemCraft hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	protected override void RunJob()
	{
		base.RunJob();
		if (ConVar.Server.industrialCrafterFrequency <= 0f || HasFlag(Flags.Reserved1) || currentlyCrafting != null)
		{
			return;
		}
		for (int i = 0; i <= 3; i++)
		{
			Item targetBlueprint = GetTargetBlueprint(i);
			if (targetBlueprint == null || GetWorkbench() == null || GetWorkbench().Workbenchlevel < targetBlueprint.blueprintTargetDef.Blueprint.workbenchLevelRequired)
			{
				continue;
			}
			ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;
			if (Interface.CallHook("OnItemCraft", this, blueprint) != null)
			{
				break;
			}
			bool flag = true;
			foreach (ItemAmount ingredient in blueprint.ingredients)
			{
				if ((float)GetInputAmount(ingredient.itemDef) < ingredient.amount)
				{
					flag = false;
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			flag = false;
			for (int j = 8; j <= 11; j++)
			{
				Item slot = inventory.GetSlot(j);
				if (slot == null || (slot.info == targetBlueprint.blueprintTargetDef && slot.amount + blueprint.amountToCreate <= slot.MaxStackable()))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				SetFlag(Flags.Reserved2, b: true);
				continue;
			}
			SetFlag(Flags.Reserved2, b: false);
			foreach (ItemAmount ingredient2 in blueprint.ingredients)
			{
				ConsumeInputIngredient(ingredient2);
			}
			currentlyCrafting = targetBlueprint.blueprintTargetDef;
			currentlyCraftingAmount = blueprint.amountToCreate;
			float time = blueprint.time;
			Invoke(CompleteCraft, time);
			jobFinishes = time;
			SetFlag(Flags.Reserved1, b: true);
			ClientRPC(RpcTarget.NetworkGroup("ClientUpdateCraftTimeRemaining"), (float)jobFinishes, jobFinishes.Duration);
			break;
		}
	}

```

## CanChangeCode(BasePlayer,CodeLock,string,bool)

```csharp
/// <summary>
/// Called when a player attempts to change the code of an entity.
/// </summary>
/// <param name="player">The player attempting to change the code.</param>
/// <param name="entity">The entity being modified.</param>
/// <param name="newCode">The new code being set.</param>
/// <param name="isGuest">Whether the new code is for a guest or not.</param>
/// <returns>Returns null if the default behavior is overridden, otherwise returns a non-null value.</returns>
object CanChangeCode(BasePlayer player, CodeLock entity, string newCode, bool isGuest)
{
    Puts("CanChangeCode is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (!IsLocked() && text.Length == 4 && text.IsNumeric() && !(!hasCode && flag) && Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!hasCode && !flag)
			{
				SetFlag(Flags.Locked, b: true);
			}
			Facepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			Interface.CallHook("OnCodeChanged", rpc.player, this, text, flag);
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnTurretStartup(AutoTurret)

```csharp
/// <summary>
/// Called when the AutoTurret is starting up.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts("OnTurretStartup called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnEntityReskin(BaseEntity,ItemSkinDirectory.Skin,BasePlayer)

```csharp
This is a C# code snippet that appears to be part of a game server implementation. It's handling the reskining of an entity (a game object) on the server side. Here's a breakdown of what it does:

**Reskinning Process**

The `Reskin` method takes several parameters, including:

* `baseEntity`: The entity being reskinned.
* `skin`: The new skin to apply.
* `msg`: A message object containing information about the player who initiated the reskin request.

The method performs the following steps:

1. **Save Entity Storage**: It saves the current inventory and storage of the entity in a dictionary (`dictionary2`).
2. **Remove Old Skin**: If the entity has an old skin, it removes that skin.
3. **Apply New Skin**: It applies the new skin to the entity.
4. **Restore Entity Storage**: It restores the saved inventory and storage of the entity from the dictionary.

**Additional Steps**

The method also performs some additional steps:

* **Update Entity Health**: If the entity is a combat entity, it updates its health.
* **Update Building Privileges**: If the entity is a building privilege entity, it updates its authorized players list.
* **Notify Clients**: It notifies clients that the reskinning process has completed.

**Error Handling**

The method also handles errors:

* **Reskin Fail Response**: If the reskining fails for any reason, it sends a fail response to clients with an error code.

Overall, this code snippet is responsible for handling the reskining of entities on the server side, including saving and restoring entity storage, applying new skins, updating entity health and building privileges, and notifying clients.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	private void ChangeItemSkin(RPCMessage msg)
	{
		if (IsBusy())
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		int targetSkin = msg.read.Int32();
		if (msg.player == null || !msg.player.CanBuild())
		{
			return;
		}
		bool flag = false;
		if (msg.player.UnlockAllSkins)
		{
			flag = true;
		}
		if (targetSkin != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(targetSkin, msg.player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return;
		}
		if (baseNetworkable != null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if ((object)baseEntity2 != null)
			{
				Vector3 position = baseEntity2.WorldSpaceBounds().ClosestPoint(msg.player.eyes.position);
				if (!msg.player.IsVisible(position, 3f))
				{
					SprayFailResponse(SprayFailReason.LineOfSight);
					return;
				}
				if (baseNetworkable is Door door)
				{
					if (!door.GetPlayerLockPermission(msg.player))
					{
						msg.player.ChatMessage("Door must be openable");
						return;
					}
					if (door.IsOpen())
					{
						msg.player.ChatMessage("Door must be closed");
						return;
					}
				}
				if (!GetItemDefinitionForEntity(baseEntity2, out var def))
				{
					SprayFailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin(def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", baseEntity2, skin, msg.player) != null)
				{
					return;
				}
				if (skin.invItem != null && skin.invItem is ItemSkin itemSkin)
				{
					if (itemSkin.Redirect != null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) && def.isRedirectOf != null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if (def.isRedirectOf != null || (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) && def.isRedirectOf != null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if (itemDefinition == null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2))
					{
						SprayFailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning("Cannot find resource path of redirect entity to spawn! " + itemDefinition.gameObject.name);
						SprayFailResponse(SprayFailReason.InvalidItem);
						return;
					}
					Vector3 localPosition = baseEntity2.transform.localPosition;
					Quaternion localRotation = baseEntity2.transform.localRotation;
					BaseEntity baseEntity3 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					HashSet<PlayerNameID> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag2 = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> obj = Facepunch.Pool.GetList<ChildPreserveInfo>();
					if (flag2)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							obj.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = child.transform.localPosition,
								LocalRotation = child.transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in obj)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity3);
					baseEntity2.transform.localPosition = localPosition;
					baseEntity2.transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity)
					{
						decayEntity.AttachToBuilding(null);
					}
					baseEntity2.Spawn();
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag2)
						{
							for (int j = 0; j < baseEntity2.children.Count; j++)
							{
								RestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item2 in dictionary2)
						{
							foreach (Item item3 in item2.Value)
							{
								Debug.Log($"Deleting {item3} as it has no new container");
								item3.Remove();
							}
						}
						Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
					}
					if (flag2)
					{
						foreach (ChildPreserveInfo item4 in obj)
						{
							item4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);
							item4.TargetEntity.transform.localPosition = item4.LocalPosition;
							item4.TargetEntity.transform.localRotation = item4.LocalRotation;
							item4.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Interface.CallHook("OnEntityReskinned", baseEntity2, skin, msg.player);
					Facepunch.Pool.FreeList(ref obj);
				}
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		LoseCondition(ConditionLossPerReskin);
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (copy.ContainsKey(key))
				{
					foreach (Item item5 in copy[key])
					{
						item5.MoveToContainer(itemContainerEntity.inventory);
					}
					copy.Remove(key);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (!dictionary.ContainsKey(key2))
				{
					dictionary.Add(key2, new List<Item>());
					foreach (Item item6 in itemContainerEntity2.inventory.itemList)
					{
						dictionary[key2].Add(item6);
					}
					{
						foreach (Item item7 in dictionary[key2])
						{
							item7.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log("Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
		void SprayFailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
	}

```

## OnPlayerSpawn(BasePlayer,Network.Connection)

```csharp
/// <summary>
/// Called when a new player spawns.
/// </summary>
/// <param name="player">The newly spawned player.</param>
/// <param name="connection">The network connection of the player.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerSpawn(BasePlayer player, Network.Connection connection)
{
    Puts("OnPlayerSpawn hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public BasePlayer SpawnNewPlayer(Network.Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer, connection) != null)
		{
			return basePlayer;
		}
		basePlayer.health = 0f;
		basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
		basePlayer.ResetLifeStateOnSpawn = false;
		basePlayer.limitNetworking = true;
		if (connection == null)
		{
			basePlayer.EnableTransferProtection();
		}
		basePlayer.Spawn();
		basePlayer.limitNetworking = false;
		if (connection != null)
		{
			basePlayer.PlayerInit(connection);
			if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer);
			}
			else if (UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife))
			{
				basePlayer.Respawn();
			}
			DebugEx.Log($"{basePlayer.displayName} with steamid {basePlayer.userID} joined from ip {basePlayer.net.connection.ipaddress}");
			DebugEx.Log($"\tNetworkId {basePlayer.userID} is {basePlayer.net.ID} ({basePlayer.displayName})");
			if (basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
			{
				DebugEx.Log($"\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}");
			}
		}
		return basePlayer;
	}

```

## CanFastTrackCraftTask(ItemCrafter,ItemCraftTask,int)

```csharp
/// <summary>
/// Called when a player attempts to fast track a craft task.
/// </summary>
/// <param name="craftTask">The craft task being fast tracked.</param>
/// <param name="taskID">The ID of the task being fast tracked.</param>
/// <returns>Returns true if the task can be fast tracked, false otherwise.</returns>
object CanFastTrackCraftTask(ItemCrafter craftTask, ItemCraftTask itemCraftTask, int taskID)
{
    // Minimal code to demonstrate functionality
    Puts("CanFastTrackCraftTask is working!");
    
    // If ReturnType is void, do not include the return statement
    return true; // Or another value depending on the method’s functionality
}
```

### Source Code from the Library

```csharp

	public bool FastTrackTask(int taskID)
	{
		int taskID2 = taskID;
		if (queue.Count == 0)
		{
			return false;
		}
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask value = queue.First.Value;
		if (value == null)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == taskID2 && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		if (itemCraftTask == value)
		{
			return false;
		}
		object obj = Interface.CallHook("CanFastTrackCraftTask", this, itemCraftTask, taskID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		value.endTime = 0f;
		queue.Remove(itemCraftTask);
		queue.AddFirst(itemCraftTask);
		owner.Command("note.craft_fasttracked", taskID2);
		return true;
	}

```

## CanRenameBed(BasePlayer,SleepingBag,string)

```csharp
/// <summary>
/// Called when a player attempts to rename a bed.
/// </summary>
/// <param name="player">The player attempting to rename the bed.</param>
/// <param name="bed">The bed being renamed.</param>
/// <param name="newName">The new name for the bed.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object CanRenameBed(BasePlayer player, SleepingBag bed, string newName)
{
    // Minimal code to demonstrate functionality
    Puts("CanRenameBed hook called!");
    
    // If no custom behavior is provided, return null
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("CanRenameBed", msg.player, this, text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
			NotifyPlayer(deployerUserID);
		}
	}

```

## OnAirdrop(CargoPlane,UnityEngine.Vector3)

```csharp
/// <summary>
/// Called when a cargo plane is about to drop something.
/// </summary>
/// <param name="cargoPlane">The cargo plane performing the airdrop.</param>
/// <param name="dropPosition">The position where the cargo will be dropped.</param>
/// <returns>No return behavior.</returns>
void OnAirdrop(CargoPlane cargoPlane, Vector3 dropPosition)
{
    Puts($"Cargo plane {cargoPlane} is dropping something at position {dropPosition}");
}
```

### Source Code from the Library

```csharp

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		startPos.Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);
		base.transform.position = startPos;
		base.transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", this, newDropPosition);
	}

```

## CanFireLiquidWeapon(BasePlayer,LiquidWeapon)

```csharp
/// <summary>
/// Called when a player attempts to fire a liquid weapon.
/// </summary>
/// <param name="player">The player attempting to fire the liquid weapon.</param>
/// <param name="liquidWeapon">The liquid weapon being fired.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
object CanFireLiquidWeapon(BasePlayer player, LiquidWeapon liquidWeapon)
{
    Puts("CanFireLiquidWeapon is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	private bool CanFire(BasePlayer player)
	{
		object obj = Interface.CallHook("CanFireLiquidWeapon", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequiresPumping && pressure < PressureLossPerTick)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		if (HasFlag(Flags.Open))
		{
			return false;
		}
		if (AmountHeld() <= 0)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (!player.CanAttack() || player.IsRunning())
		{
			return false;
		}
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return false;
		}
		return true;
	}

```

## OnNetworkGroupLeft(BaseNetworkable,Network.Visibility.Group)

```csharp
/// <summary>
/// Called when a player leaves a network group.
/// </summary>
/// <param name="group">The group that was left.</param>
/// <returns>Returns the visibility of the group after the player's departure.</returns>
object OnNetworkGroupLeft(BaseNetworkable group, Network.Visibility.Group)
{
    Puts("OnNetworkGroupLeft is working!");
    return group.GetVisibility();
}
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", this, group);
	}

```

## OnBigWheelLoss(BigWheelGame,Item,BigWheelBettingTerminal)

```csharp
/// <summary>
/// Called when a player loses a Big Wheel game.
/// </summary>
/// <param name="game">The Big Wheel game being played.</param>
/// <param name="item">The item that was lost.</param>
/// <param name="terminal">The betting terminal where the loss occurred.</param>
/// <returns>No return behavior.</returns>
void OnBigWheelLoss(BigWheelGame game, Item item, BigWheelBettingTerminal terminal)
{
    Puts($"Player lost a Big Wheel game at terminal {terminal.Id}");
}
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) == null)
				{
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanAssignMission(BasePlayer,BaseMission,IMissionProvider)

```csharp
/// <summary>
/// Called when a player is assigned to a mission.
/// </summary>
/// <param name="player">The player being assigned the mission.</param>
/// <param name="mission">The mission being assigned.</param>
/// <param name="provider">The provider of the mission.</param>
/// <returns>Returns true if the assignment was successful, and false otherwise.</returns>
bool CanAssignMission(BasePlayer player, BaseMission mission, IMissionProvider provider)
{
    Puts("CanAssignMission is working!");
    return true;
}
```

### Source Code from the Library

```csharp

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", assignee, mission, provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = assignee.missions.FindIndexWith((MissionInstance i) => i.missionID, mission.id);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", mission, provider, assignee);
		return true;
	}

```

## OnWeaponModChange(BaseProjectile,BasePlayer)

```csharp
/// <summary>
/// Called when the weapon mod is changed.
/// </summary>
/// <param name="projectile">The projectile being modified.</param>
/// <param name="player">The player who made the change.</param>
/// <returns>No return behavior.</returns>
void OnWeaponModChange(BaseProjectile projectile, BasePlayer player)
{
    Puts("OnWeaponModChange is working!");
}
```

### Source Code from the Library

```csharp

	public void DelayedModsChanged()
	{
		if (Interface.CallHook("OnWeaponModChange", this, GetOwnerPlayer()) != null)
		{
			return;
		}
		int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)primaryMagazine.definition.builtInSize);
		if (num == primaryMagazine.capacity)
		{
			return;
		}
		if (primaryMagazine.contents > 0 && primaryMagazine.contents > num)
		{
			_ = primaryMagazine.ammoType;
			int contents = primaryMagazine.contents;
			BasePlayer ownerPlayer = GetOwnerPlayer();
			ItemContainer itemContainer = null;
			if (ownerPlayer != null)
			{
				itemContainer = ownerPlayer.inventory.containerMain;
			}
			else if (GetCachedItem() != null)
			{
				itemContainer = GetCachedItem().parent;
			}
			SetAmmoCount(0);
			if (itemContainer != null)
			{
				Item item = ItemManager.Create(primaryMagazine.ammoType, contents, 0uL);
				if (!item.MoveToContainer(itemContainer))
				{
					Vector3 vPos = base.transform.position;
					if (itemContainer.entityOwner != null)
					{
						vPos = itemContainer.entityOwner.transform.position + Vector3.up * 0.25f;
					}
					item.Drop(vPos, Vector3.up * 5f);
				}
			}
		}
		primaryMagazine.capacity = num;
		SendNetworkUpdate();
	}

```

## OnVehicleModulesAssigned(ModularCar,Rust.Modular.ItemModVehicleModule[])

```csharp
/// <summary>
/// Called when vehicle modules are assigned to a Modular Car.
/// </summary>
/// <param name="vehicle">The Modular Car.</param>
/// <param name="modules">A list of ItemModVehicleModule items to be assigned.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModulesAssigned(ModularCar vehicle, Rust.Modular.ItemModVehicleModule[] modules)
{
    Puts("OnVehicleModulesAssigned is working!");
}
```

### Source Code from the Library

```csharp

	public void SpawnPreassignedModules()
	{
		if (!spawnSettings.useSpawnSettings || CollectionEx.IsNullOrEmpty(spawnSettings.configurationOptions))
		{
			return;
		}
		ModularCarPresetConfig modularCarPresetConfig = spawnSettings.configurationOptions[UnityEngine.Random.Range(0, spawnSettings.configurationOptions.Length)];
		if (Interface.CallHook("OnVehicleModulesAssign", this, modularCarPresetConfig.socketItemDefs) != null)
		{
			return;
		}
		for (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)
		{
			ItemModVehicleModule itemModVehicleModule = modularCarPresetConfig.socketItemDefs[i];
			if (itemModVehicleModule != null && base.Inventory.SocketsAreFree(i, itemModVehicleModule.socketsTaken))
			{
				Item item = ItemManager.Create(itemModVehicleModule.GetComponent<ItemDefinition>(), 1, 0uL);
				float num = UnityEngine.Random.Range(spawnSettings.minStartHealthPercent, spawnSettings.maxStartHealthPercent);
				item.condition = item.maxCondition * num;
				if (!TryAddModule(item))
				{
					item.Remove();
				}
			}
		}
		Interface.CallHook("OnVehicleModulesAssigned", this, modularCarPresetConfig.socketItemDefs);
		Invoke(HandleAdminBonus, 0f);
	}

```

## OnRackedWeaponSwap(Item,WeaponRackSlot,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a player swaps their held weapon with a weapon on the rack.
/// </summary>
/// <param name="item">The player's held item.</param>
/// <param name="weaponSlot">The slot on the rack where the swap occurred.</param>
/// <param name="player">The player performing the swap.</param>
/// <param name="rack">The weapon rack involved in the swap.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnRackedWeaponSwap(Item item, WeaponRackSlot weaponSlot, BasePlayer player, WeaponRack rack)
{
    Puts("OnRackedWeaponSwap called!");
    // Minimal code to demonstrate functionality
}
```

### Source Code from the Library

```csharp

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", item, weaponAtIndex, player, this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", item, weaponAtIndex, player, this);
			}
		}
	}

```

## OnTakeCurrencyItem(NPCVendingMachine,Item)

```csharp
/// <summary>
/// Called when a currency item is taken from an NPC vending machine.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that the item was taken from.</param>
/// <param name="item">The currency item that was taken.</param>
/// <returns>Returns null if the default behavior should be executed, otherwise returns a non-null value to override the default behavior.</returns>
object OnTakeCurrencyItem(NPCVendingMachine vendingMachine, Item item)
{
    Puts("OnTakeCurrencyItem is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null)
		{
			takenCurrencyItem.MoveToContainer(base.inventory);
			takenCurrencyItem.RemoveFromContainer();
			takenCurrencyItem.Remove();
		}
	}

```

## OnItemAction(Item,string,BasePlayer)

```csharp
/// <summary>
/// Called when an item is used or interacted with.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="action">The action being performed on the item (e.g. "use", "drop", etc.).</param>
/// <param name="player">The player performing the action.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemAction(Item item, string action, BasePlayer player)
{
    Puts("OnItemAction is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		if ((msg.player != null && msg.player.IsWounded()) || base.baseEntity.IsTransferring())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		string text = msg.read.String();
		Item item = FindItemByUID(id);
		if (item == null || Interface.CallHook("OnItemAction", item, text, msg.player) != null)
		{
			return;
		}
		BaseEntity entityOwner = item.GetEntityOwner();
		if ((entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering) || item.IsLocked() || (item.parent != null && item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item))
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.Unread >= 4)
			{
				num = msg.read.Int32();
			}
			if (!msg.player.isMounted && !msg.player.HasParent() && !GamePhysics.LineOfSight(msg.player.transform.position, msg.player.eyes.position, 1218519041))
			{
				return;
			}
			base.baseEntity.stats.Add("item_drop", 1, (Stats)5);
			if (num < item.amount)
			{
				Item item2 = item.SplitItem(num);
				if (item2 != null)
				{
					DroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DropReason = DroppedItem.DropReasonEnum.Player;
						droppedItem.DroppedBy = base.baseEntity.userID;
						droppedItem.DroppedTime = DateTime.UtcNow;
						Facepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);
					}
				}
			}
			else
			{
				DroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;
				if (droppedItem2 != null)
				{
					droppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;
					droppedItem2.DroppedBy = base.baseEntity.userID;
					droppedItem2.DroppedTime = DateTime.UtcNow;
					Facepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);
				}
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnItemUnwrap(Item,BasePlayer,ItemModUnwrap)

```csharp
/// <summary>
/// Called when an item is unwrapped.
/// </summary>
/// <param name="item">The item being unwrapped.</param>
/// <param name="player">The player who initiated the unwrap command.</param>
/// <param name="modUnwrap">The item modification that triggered the unwrap.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemUnwrap(Item item, BasePlayer player, ItemModUnwrap modUnwrap)
{
    Puts("OnItemUnwrap is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "unwrap" && item.amount > 0 && Interface.CallHook("OnItemUnwrap", item, player, this) == null)
		{
			item.UseItem();
			int num = UnityEngine.Random.Range(minTries, maxTries + 1);
			for (int i = 0; i < num; i++)
			{
				revealList.SpawnIntoContainer(player.inventory.containerMain);
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnItemDeployed(Deployer,ItemModDeployable,BaseEntity)

```csharp
/// <summary>
/// Called when an item is deployed.
/// </summary>
/// <param name="deployer">The entity that deployed the item.</param>
/// <param name="itemModDeployable">The mod deployable item being deployed.</param>
/// <param name="baseEntity">The base entity created from the deployment.</param>
/// <returns>No return behavior.</returns>
void OnItemDeployed(BaseEntity deployer, ItemModDeployable itemModDeployable, BaseEntity baseEntity)
{
    Puts($"Item {itemModDeployable.entityPrefab.resourcePath} deployed by {deployer.UserID}");
}
```

### Source Code from the Library

```csharp

	public void DoDeploy_Regular(Deployable deployable, Ray ray)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ChatMessage("Building is blocked at player position!");
		}
		else if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
		}
		else
		{
			if (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))
			{
				return;
			}
			Vector3 point = hitInfo.point;
			Quaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);
			Item ownerItem = GetOwnerItem();
			ItemModDeployable modDeployable = GetModDeployable();
			if (ownerPlayer.Distance(point) > 3f)
			{
				ownerPlayer.ChatMessage("Too far away!");
				return;
			}
			if (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))
			{
				ownerPlayer.ChatMessage("Building is blocked at placement position!");
				return;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);
			if (!baseEntity)
			{
				Debug.LogWarning("Couldn't create prefab:" + modDeployable.entityPrefab.resourcePath);
				return;
			}
			baseEntity.skinID = ownerItem.skin;
			baseEntity.SendMessage("SetDeployedBy", ownerPlayer, SendMessageOptions.DontRequireReceiver);
			baseEntity.OwnerID = ownerPlayer.userID;
			baseEntity.Spawn();
			modDeployable.OnDeployed(baseEntity, ownerPlayer);
			Interface.CallHook("OnItemDeployed", this, modDeployable, baseEntity);
			Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
			UseItemAmount(1);
		}
	}

```

## OnMissionStarted(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
/// <summary>
/// Called when a mission is started.
/// </summary>
/// <param name="mission">The mission instance.</param>
/// <param name="instance">The mission instance identifier.</param>
/// <param name="assignee">The player assigned to the mission.</param>
/// <returns>No return behavior.</returns>
void OnMissionStarted(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts("OnMissionStarted is working!");
}
```

### Source Code from the Library

```csharp

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", this, instance, assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", this, instance, assignee);
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="message">The text of the message.</param>
/// <param name="player">The player who sent the message.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Player {player.UserID} said: {message}");
    return null;
}
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 2, 0, msg);
		}
	}

```

## OnStashOcclude(StashContainer)

```csharp
/// <summary>
/// Called when the stash container is occluded by an object.
/// </summary>
/// <param name="stashContainer">The stash container being occluded.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnStashOcclude(StashContainer stashContainer)
{
    Puts("OnStashOcclude is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void DoOccludedCheck()
	{
		if (UnityEngine.Physics.SphereCast(new Ray(base.transform.position + Vector3.up * 5f, Vector3.down), 0.25f, 5f, 2097152) && Interface.CallHook("OnStashOcclude", this) == null)
		{
			DropItems();
			Kill();
		}
	}

```

## OnFireBallSpread(FireBall,BaseEntity)

```csharp
/// <summary>
/// Called when a fireball spreads to a new entity.
/// </summary>
/// <param name="fireBall">The original fireball entity.</param>
/// <param name="newEntity">The newly created entity that the fireball has spread to.</param>
/// <returns>No return behavior.</returns>
void OnFireBallSpread(FireBall fireBall, BaseEntity newEntity)
{
    Puts($"Fireball has spread to a new entity: {newEntity}");
}
```

### Source Code from the Library

```csharp

	public void TryToSpread()
	{
		float num = 0.9f - generation * 0.1f;
		if (UnityEngine.Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", this, baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));
				baseEntity.SendMessage("SetGeneration", generation + 1f);
			}
		}
	}

```

## OnRackedWeaponLoaded(Item,ItemDefinition,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a weapon is loaded on a rack.
/// </summary>
/// <param name="slot">The slot where the weapon was loaded.</param>
/// <param name="itemDefinition">The definition of the item being loaded.</param>
/// <param name="player">The player who loaded the weapon.</param>
/// <param name="weaponRack">The rack on which the weapon was loaded.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponLoaded(Item slot, ItemDefinition itemDefinition, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Weapon {itemDefinition.name} loaded on rack for player {player.displayName}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void LoadWeaponAmmo(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!player)
		{
			return;
		}
		int gridIndex = msg.read.Int32();
		int num = msg.read.Int32();
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (heldEntity == null)
		{
			return;
		}
		BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
		if (component == null)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null || Interface.CallHook("OnRackedWeaponLoad", slot, itemDefinition, player, this) != null)
		{
			return;
		}
		if (itemDefinition == SnowballGun.SnowballInventoryItem)
		{
			itemDefinition = SnowballGun.SnowballAmmoItem;
			if (!(itemDefinition != null))
			{
				return;
			}
			num = itemDefinition.itemid;
		}
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component2 = itemDefinition.GetComponent<ItemModProjectile>();
		if (!(component2 == null) && component2.IsAmmo(component.primaryMagazine.definition.ammoTypes))
		{
			if (num != component.primaryMagazine.ammoType.itemid && component.primaryMagazine.contents > 0)
			{
				player.GiveItem(ItemManager.CreateByItemID(component.primaryMagazine.ammoType.itemid, component.primaryMagazine.contents, 0uL));
				component.SetAmmoCount(0);
			}
			component.primaryMagazine.ammoType = itemDefinition;
			component.TryReloadMagazine(player.inventory);
			SetSlotAmmoDetails(weaponAtIndex, slot);
			SendNetworkUpdateImmediate();
			ClientRPC(RpcTarget.Player("PlayAmmoSound", player), itemDefinition.itemid, 0);
			Interface.CallHook("OnRackedWeaponLoaded", slot, itemDefinition, player, this);
		}
	}

```

## OnBoomboxStationValidate(string)

```csharp
/// <summary>
/// Called to validate a Boombox station URL.
/// </summary>
/// <param name="url">The URL of the Boombox station to be validated.</param>
/// <returns>Returns <c>true</c> if the station is valid, and <c>false</c> otherwise.</returns>
bool OnBoomboxStationValidate(string url)
{
    Puts($"Validating Boombox station: {url}");
    // Minimal code to demonstrate functionality
    return true;
}
```

### Source Code from the Library

```csharp

	public static bool IsStationValid(string url)
	{
		ParseServerUrlList();
		object obj = Interface.CallHook("OnBoomboxStationValidate", url);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ValidStations == null || !ValidStations.ContainsValue(url))
		{
			if (ServerValidStations != null)
			{
				return ServerValidStations.ContainsValue(url);
			}
			return false;
		}
		return true;
	}

```

## OnPortalUse(BasePlayer,BasePortal)

```csharp
/// <summary>
/// Called when a player uses a portal.
/// </summary>
/// <param name="player">The player using the portal.</param>
/// <param name="portal">The portal being used.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPortalUse(BasePlayer player, BasePortal portal)
{
    Puts("OnPortalUse is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void UsePortal(BasePlayer player)
	{
		if (Interface.CallHook("OnPortalUse", player, this) != null)
		{
			return;
		}
		LinkPortal();
		if (targetPortal != null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			Vector3 position = player.transform.position;
			Vector3 vector = targetPortal.GetLocalEntryExitPosition();
			Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 vector3 = vector2;
			if (isMirrored)
			{
				Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);
				vector = targetPortal.relativeAnchor.transform.TransformPoint(position2);
				vector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);
			}
			else
			{
				vector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, vector, Vector3.up);
			}
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(vector);
			player.ForceUpdateTriggers();
			player.ClientRPC(RpcTarget.Player("ForceViewAnglesTo", player), vector3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			player.ClientRPC(RpcTarget.Player("StartLoading_Quick", player), arg1: true);
			Interface.CallHook("OnPortalUsed", player, this);
		}
		else
		{
			Debug.Log("No portal...");
		}
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <returns>Returns the result of the hook, or null if no custom behavior is provided.</returns>
object OnTrapTrigger(BearTrap trap, UnityEngine.GameObject obj)
{
    Puts("OnTrapTrigger called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## OnRidableAnimalClaim(BaseRidableAnimal,BasePlayer,Item)

```csharp
/// <summary>
/// Called when a player claims a ridable animal using a purchase token.
/// </summary>
/// <param name="animal">The ridable animal being claimed.</param>
/// <param name="player">The player claiming the animal.</param>
/// <param name="token">The purchase token used to claim the animal.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnRidableAnimalClaim(BaseRidableAnimal animal, BasePlayer player, Item token)
{
    Puts("OnRidableAnimalClaim called!");
    // Minimal code to demonstrate functionality
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsForSale())
		{
			int tokenItemID = msg.read.Int32();
			Item item = GetPurchaseToken(player, tokenItemID);
			if (item != null && Interface.CallHook("OnRidableAnimalClaim", this, player, item) == null)
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(item);
				item.UseItem();
				Facepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);
				Facepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## CanLock(BasePlayer,KeyLock)

```csharp
/// <summary>
/// Called when a player attempts to lock the entity.
/// </summary>
/// <param name="player">The player attempting to lock the entity.</param>
/// <param name="lock">The key lock being used.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
bool CanLock(BasePlayer player, KeyLock lock)
{
    Puts("CanLock hook called!");
    // If you want to override the default behavior, return true
    // Otherwise, return false or null (see example below)
    return false;
}
```

### Source Code from the Library

```csharp

	private void Lock(BasePlayer player)
	{
		if (!(player == null) && player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", player, this) == null && HasLockPermission(player))
		{
			LockLock(player);
			SendNetworkUpdate();
		}
	}

```

## OnNpcDuck(HumanNPC)

```csharp
/// <summary>
/// Called when an NPC's ducking state is updated.
/// </summary>
/// <param name="npc">The HumanNPC instance whose ducking state has been updated.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnNpcDuck(HumanNPC npc)
{
    Puts("OnNpcDuck hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void SetDucked(bool flag)
	{
		if (Interface.CallHook("OnNpcDuck", this) == null)
		{
			modelState.ducked = flag;
			SendNetworkUpdate();
		}
	}

```

## OnElevatorButtonPress(ElevatorLift,BasePlayer,Elevator.Direction,bool)

```csharp
/// <summary>
/// Called when an elevator button is pressed.
/// </summary>
/// <param name="lift">The elevator lift.</param>
/// <param name="player">The player who pressed the button.</param>
/// <param name="direction">The direction of the elevator (Up or Down).</param>
/// <param name="flag">A boolean flag indicating some additional information.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnElevatorButtonPress(ElevatorLift lift, BasePlayer player, Elevator.Direction direction, bool flag)
{
    Puts("OnElevatorButtonPress is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Server_RaiseLowerFloor(RPCMessage msg)
	{
		Elevator.Direction direction = (Elevator.Direction)msg.read.Int32();
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnElevatorButtonPress", this, msg.player, direction, flag) == null)
		{
			SetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);
			owner.Server_RaiseLowerElevator(direction, flag);
			Invoke(ClearDirection, 0.7f);
			if (liftButtonPressedEffect.isValid)
			{
				Effect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
/// <summary>
/// Called when a trap is triggered by an entity.
/// </summary>
/// <param name="landmine">The landmine that was triggered.</param>
/// <param name="entity">The entity that triggered the landmine.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnTrapTrigger(Landmine landmine, UnityEngine.GameObject entity)
{
    Puts("OnTrapTrigger is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## OnRidableAnimalClaimed(BaseRidableAnimal,BasePlayer)

```csharp
/// <summary>
/// Called when a player claims a ridable animal.
/// </summary>
/// <param name="animal">The ridable animal being claimed.</param>
/// <param name="player">The player claiming the animal.</param>
/// <returns>No return behavior.</returns>
void OnRidableAnimalClaimed(BaseRidableAnimal animal, BasePlayer player)
{
    Puts($"Player {player.UserID} has claimed a {animal.ShortPrefabName}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsForSale())
		{
			int tokenItemID = msg.read.Int32();
			Item item = GetPurchaseToken(player, tokenItemID);
			if (item != null && Interface.CallHook("OnRidableAnimalClaim", this, player, item) == null)
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(item);
				item.UseItem();
				Facepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);
				Facepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## OnTeamKick(RelationshipManager.PlayerTeam,BasePlayer,ulong)

```csharp
/// <summary>
/// Called when a member is kicked from a team.
/// </summary>
/// <param name="team">The team being modified.</param>
/// <param name="kickedMember">The player being removed from the team.</param>
/// <param name="newTeamID">The ID of the new team the player will be moved to.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer kickedMember, ulong newTeamID)
{
    Puts($"Member {kickedMember.UserID} kicked from team {team.Name}");
    return null;
}
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void kickmember(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer == null)
		{
			return;
		}
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam != null && !(playerTeam.GetLeader() != basePlayer))
		{
			ulong uLong = arg.GetULong(0, 0uL);
			if ((ulong)basePlayer.userID != uLong && Interface.CallHook("OnTeamKick", playerTeam, basePlayer, uLong) == null)
			{
				playerTeam.RemovePlayer(uLong);
			}
		}
	}

```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
/// <summary>
/// Called to determine if a player can be targeted by the flame turret.
/// </summary>
/// <param name="player">The player being checked.</param>
/// <param name="turret">The flame turret performing the check.</param>
/// <returns>Returns true if the player can be targeted, false otherwise.</returns>
bool CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts("CanBeTargeted is working!");
    return true; // Replace with actual logic to determine if player can be targeted
}
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = item.GetComponent<BasePlayer>();
				if (component.IsSleeping() || !component.IsAlive())
				{
					continue;
				}
				object obj2 = Interface.CallHook("CanBeTargeted", component, this);
				if (obj2 is bool)
				{
					Pool.FreeList(ref obj);
					return (bool)obj2;
				}
				if (!(component.transform.position.y <= GetEyePosition().y + 0.5f) || component.IsBuildingAuthed())
				{
					continue;
				}
				obj.Clear();
				GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
				for (int i = 0; i < obj.Count; i++)
				{
					BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
					if (entity != null && (entity == this || entity.EqualNetID(this)))
					{
						flag = true;
						break;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeList(ref obj);
		return flag;
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
/// <summary>
/// Called when a player stops spectating.
/// </summary>
/// <param name="player">The player who stopped spectating.</param>
/// <param name="spectateFilter">The filter used for spectating.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
{
    Puts($"Player {player.UserIDString} has stopped spectating.");
}
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## CanUseVending(BasePlayer,VendingMachine)

```csharp
/// <summary>
/// Called to determine if a player can use the vending machine.
/// </summary>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <returns>Returns true if the player can use the vending machine, and false otherwise.</returns>
bool CanUseVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts("CanUseVending is working!");
    return true; // Replace with actual logic to determine if the player can use the vending machine
}
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		object obj = Interface.CallHook("CanUseVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

```

## OnServerInitialize()

```csharp
/// <summary>
/// Called when the server is initializing.
/// </summary>
/// <returns>Returns true if the server was loaded from a save, and false otherwise.</returns>
bool OnServerInitialize()
{
    Puts("OnServerInitialize called!");
    // Minimal code to demonstrate functionality
    return World.LoadedFromSave;
}
```

### Source Code from the Library

```csharp

	public bool Initialize(bool loadSave = true, string saveFile = "", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)
	{
		Interface.CallHook("OnServerInitialize");
		persistance = new UserPersistance(ConVar.Server.rootFolder);
		playerStateManager = new PlayerStateManager(persistance);
		TutorialIsland.GenerateIslandSpawnPoints(loadingSave: true);
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			using (TimeWarning.New("SpawnHandler.UpdateDistributions"))
			{
				SingletonComponent<SpawnHandler>.Instance.UpdateDistributions();
			}
		}
		if (loadSave)
		{
			World.LoadedFromSave = true;
			World.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));
		}
		else
		{
			SaveRestore.SaveCreatedTime = DateTime.UtcNow;
			World.LoadedFromSave = false;
		}
		if (!World.LoadedFromSave)
		{
			SaveRestore.SpawnMapEntities(SaveRestore.FindMapEntities());
		}
		SaveRestore.InitializeWipeId();
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			if (!skipInitialSpawn)
			{
				using (TimeWarning.New("SpawnHandler.InitialSpawn", 200))
				{
					SingletonComponent<SpawnHandler>.Instance.InitialSpawn();
				}
			}
			using (TimeWarning.New("SpawnHandler.StartSpawnTick", 200))
			{
				SingletonComponent<SpawnHandler>.Instance.StartSpawnTick();
			}
		}
		CreateImportantEntities();
		auth = GetComponent<ConnectionAuth>();
		Facepunch.Rust.Analytics.Azure.Initialize();
		return World.LoadedFromSave;
	}

```

## IOnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
/// <summary>
/// Called when an entity is saved.
/// </summary>
/// <param name="entity">The entity being saved.</param>
/// <param name="saveInfo">Information about the save operation.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object IOnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts("IOnEntitySaved is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void ToStream(Stream stream, SaveInfo saveInfo)
	{
		using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError(this?.ToString() + ": ToStream - no BaseEntity!?");
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError(this?.ToString() + ": ToStream - no baseNetworkable!?");
			}
			Interface.CallHook("IOnEntitySaved", this, saveInfo);
			saveInfo.msg.ToProto(stream);
			PostSave(saveInfo);
		}
	}

```

## OnTeamDisbanded(RelationshipManager.PlayerTeam)

```csharp
/// <summary>
/// Called when a player's team is disbanded.
/// </summary>
/// <param name="team">The disbanding team.</param>
/// <returns>No return behavior.</returns>
void OnTeamDisbanded(PlayerTeam team)
{
    Puts($"Team {team.teamID} has been disbanded.");
}
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Facepunch.Pool.Free(ref teamToDisband);
		}
	}

```

## OnHorseUnhitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
/// <summary>
/// Called when a horse is unhitched from a hitch trough.
/// </summary>
/// <param name="horse">The horse being unhitched.</param>
/// <param name="hitchSpot">The hitch spot where the horse was hitched.</param>
/// <returns>No return behavior.</returns>
void OnHorseUnhitch(RidableHorse horse, HitchTrough.HitchSpot hitchSpot)
{
    Puts($"Horse {horse.GetId()} unhitched from {hitchSpot.GetId()}");
}
```

### Source Code from the Library

```csharp

	public void Unhitch(RidableHorse horse)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHorse(base.isServer) == horse)
			{
				if (Interface.CallHook("OnHorseUnhitch", horse, hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				horse.SetHitch(null);
			}
		}
	}

```

## OnMissionAssigned(BaseMission,IMissionProvider,BasePlayer)

```csharp
/// <summary>
/// Called when a mission is assigned to a player.
/// </summary>
/// <param name="mission">The mission being assigned.</param>
/// <param name="provider">The mission provider.</param>
/// <param name="assignee">The player receiving the mission assignment.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnMissionAssigned(BaseMission mission, IMissionProvider provider, BasePlayer assignee)
{
    Puts("OnMissionAssigned hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", assignee, mission, provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		int num = assignee.missions.FindIndexWith((MissionInstance i) => i.missionID, mission.id);
		MissionInstance missionInstance;
		int activeMission;
		if (num >= 0)
		{
			missionInstance = assignee.missions[num];
			activeMission = num;
			missionInstance.Reset();
		}
		else
		{
			missionInstance = Pool.Get<MissionInstance>();
			activeMission = assignee.missions.Count;
			assignee.missions.Add(missionInstance);
		}
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int j = 0; j < mission.objectives.Length; j++)
		{
			missionInstance.objectiveStatuses[j] = new MissionInstance.ObjectiveStatus();
		}
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(activeMission);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", mission, provider, assignee);
		return true;
	}

```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
/// <summary>
/// Called when the stock of a vending machine is refreshed.
/// </summary>
/// <param name="vendingMachine">The vending machine being refreshed.</param>
/// <param name="itemDefinition">The item definition for which the stock is being refreshed.</param>
/// <returns>Returns the total amount of items in stock, or null if not overridden.</returns>
object OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDefinition)
{
    // Minimal code to demonstrate functionality
    Puts("OnRefreshVendingStock called!");
    
    // Return the total amount of items in stock
    return null;
}
```

### Source Code from the Library

```csharp

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		int num = 0;
		foreach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (!(itemDef == null) && itemDef.itemid != sellOrder.itemToSellID)
			{
				continue;
			}
			List<Item> obj = Facepunch.Pool.GetList<Item>();
			GetItemsToSell(sellOrder, obj);
			int inStock;
			if (obj.Count < 0)
			{
				inStock = 0;
			}
			else
			{
				List<Item> source = obj;
				Func<Item, int> selector = (Item x) => x.amount;
				Interface.CallHook("OnRefreshVendingStock", this, itemDef);
				inStock = source.Sum(selector) / sellOrder.itemToSellAmount;
			}
			sellOrder.inStock = inStock;
			float itemCondition = 0f;
			float itemConditionMax = 0f;
			int instanceData = 0;
			List<int> list = Facepunch.Pool.GetList<int>();
			int totalAttachmentSlots = 0;
			int ammoType = 0;
			int ammoCount = 0;
			if (obj.Count > 0)
			{
				if (obj[0].hasCondition)
				{
					itemCondition = obj[0].condition;
					itemConditionMax = obj[0].maxCondition;
				}
				if (obj[0].info != null && obj[0].info.amountType == ItemDefinition.AmountType.Genetics && obj[0].instanceData != null)
				{
					instanceData = obj[0].instanceData.dataInt;
					sellOrder.inStock = obj[0].amount;
				}
				if (obj[0].contents != null && obj[0].contents.capacity > 0 && obj[0].contents.HasFlag(ItemContainer.Flag.ShowSlotsOnIcon))
				{
					foreach (Item item in obj[0].contents.itemList)
					{
						list.Add(item.info.itemid);
					}
					totalAttachmentSlots = obj[0].contents.capacity;
				}
				if (obj[0].ammoCount.HasValue)
				{
					ammoCount = obj[0].ammoCount.Value;
					BaseEntity heldEntity = obj[0].GetHeldEntity();
					if ((bool)heldEntity)
					{
						BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
						if ((bool)component)
						{
							ammoType = component.primaryMagazine.ammoType.itemid;
						}
					}
				}
			}
			sellOrder.ammoType = ammoType;
			sellOrder.ammoCount = ammoCount;
			sellOrder.itemCondition = itemCondition;
			sellOrder.itemConditionMax = itemConditionMax;
			sellOrder.instanceData = instanceData;
			if (sellOrder.attachmentsList != null)
			{
				Facepunch.Pool.FreeList(ref sellOrder.attachmentsList);
			}
			sellOrder.attachmentsList = list;
			sellOrder.totalAttachmentSlots = totalAttachmentSlots;
			sellOrder.priceMultiplier = GetDiscountForSlot(num, sellOrder);
			num++;
			Facepunch.Pool.FreeList(ref obj);
		}
	}

```

## OnTreeMarkerHit(TreeEntity,HitInfo)

```csharp
/// <summary>
/// Called when a tree marker is hit.
/// </summary>
/// <param name="treeEntity">The tree entity that was hit.</param>
/// <param name="hitInfo">Information about the hit, including the position and normal of the hit.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
object OnTreeMarkerHit(TreeEntity treeEntity, HitInfo hitInfo)
{
    Puts("OnTreeMarkerHit is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool DidHitMarker(HitInfo info)
	{
		if (xMarker == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnTreeMarkerHit", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PrefabAttribute.server.Find<TreeMarkerData>(prefabID) != null)
		{
			if (new Bounds(xMarker.transform.position, Vector3.one * 0.2f).Contains(info.HitPositionWorld))
			{
				return true;
			}
		}
		else
		{
			Vector3 lhs = Vector3Ex.Direction2D(base.transform.position, xMarker.transform.position);
			Vector3 attackNormal = info.attackNormal;
			float num = Vector3.Dot(lhs, attackNormal);
			float num2 = Vector3.Distance(xMarker.transform.position, info.HitPositionWorld);
			if (num >= 0.3f && num2 <= 0.2f)
			{
				return true;
			}
		}
		return false;
	}

```

## OnShopAcceptClick(ShopFront,BasePlayer)

```csharp
/// <summary>
/// Called when a player clicks the "Accept" button in a shop.
/// </summary>
/// <param name="shopFront">The shop front where the click occurred.</param>
/// <param name="player">The player who clicked the button.</param>
/// <returns>No return behavior.</returns>
void OnShopAcceptClick(ShopFront shopFront, BasePlayer player)
{
    Puts("OnShopAcceptClick is working!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !(vendorPlayer == null) && !(customerPlayer == null) && Interface.CallHook("OnShopAcceptClick", this, msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				Invoke(CompleteTrade, 2f);
			}
		}
	}

```

## OnEngineLoadoutRefresh(Rust.Modular.EngineStorage)

```csharp
/// <summary>
/// Called when the engine loadout is refreshed.
/// </summary>
/// <param name="engineStorage">The engine storage data.</param>
/// <returns>No return behavior.</returns>
void OnEngineLoadoutRefresh(Rust.Modular.EngineStorage engineStorage)
{
    Puts("OnEngineLoadoutRefresh is working!");
}
```

### Source Code from the Library

```csharp

	public void RefreshLoadoutData()
	{
		if (Interface.CallHook("OnEngineLoadoutRefresh", this) == null)
		{
			isUsable = base.inventory.IsFull() && base.inventory.itemList.All((Item item) => !item.isBroken);
			accelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;
			topSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;
			fuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;
			SendNetworkUpdate();
			GetEngineModule()?.RefreshPerformanceStats(this);
		}
	}

```

## OnItemRecycle(Item,Recycler)

```csharp
Документация для OnItemRecycle(Item, Recycler)

**Описание**

Хук `OnItemRecycle` вызывается в методе `RecycleThink()` и позволяет модулю или плагину изменить поведение процесса переработки предмета.

**Параметры**

* `Item`: предмет, который подлежит переработке.
* `Recycler`: объект-перерабатыватель, который выполняет процесс переработки.

**Возвращаемые значения**

Хук не возвращает никаких значений. Если модуль или плагин не изменяет поведение процесса переработки, он должен вернуть значение `null`.

**Примечания**

* Хук вызывается только один раз для каждого предмета, который подлежит переработке.
* Если модуль или плагин не изменяет поведение процесса переработки, процесс переработки будет продолжен как обычно.

**Пример использования**

Например, если вы хотите изменить поведение процесса переработки для определенного предмета, вы можете использовать хук следующим образом:
```csharp
public void OnItemRecycle(Item item, Recycler recycler)
{
    // Измените поведение процесса переработки для предмета item
    if (item.info.shortname == "example_item")
    {
        // Добавьте дополнительные действия или изменения в процесс переработки
        Debug.Log("Перерабатываем example_item");
    }
}
```
В этом примере, когда предмет `example_item` подлежит переработке, модуль или плагин будет вызывать хук и изменять поведение процесса переработки.
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", slot, this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", slot, num3, this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					float num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 *= slot.conditionNormalized;
					}
					float num5 = num / 0.5f;
					num4 *= num5;
					int num6 = Mathf.FloorToInt(num4);
					float num7 = num4 - (float)num6;
					scrapRemainder += num7;
					if (scrapRemainder >= 1f)
					{
						int num8 = Mathf.FloorToInt(scrapRemainder);
						scrapRemainder -= num8;
						num6 += num8;
					}
					if (num6 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num6, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj2 = Facepunch.Pool.GetList<BasePlayer>();
					Vis.Entities(base.transform.position, 3f, obj2, 131072);
					foreach (BasePlayer item3 in obj2)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Facepunch.Pool.FreeList(ref obj2);
				}
				Facepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;
					int num10 = Mathf.FloorToInt(num9);
					float num11 = num9 - (float)num10;
					if (num11 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num11)
					{
						num10++;
					}
					if (num10 <= 0)
					{
						continue;
					}
					int num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);
					for (int i = 0; i < num12; i++)
					{
						int num13 = ((num10 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);
						Item item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
						if (!MoveItemToOutput(item2))
						{
							flag = true;
						}
						num10 -= num13;
						if (num10 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int,bool)

```csharp
/// <summary>
/// Called when a player attempts to craft an item.
/// </summary>
/// <param name="craftTask">The task associated with the crafting attempt.</param>
/// <param name="blueprint">The blueprint for the item being crafted.</param>
/// <param name="amount">The number of items being crafted.</param>
/// <param name="free">Whether the crafting is free or not.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise returns true if the crafting can be performed and false otherwise.</returns>
object CanCraft(ItemCrafter craftTask, ItemBlueprint blueprint, int amount, bool free)
{
    // Minimal code to demonstrate functionality
    Puts("CanCraft hook called!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)
	{
		if (base.baseEntity != null && base.baseEntity.IsRestrained)
		{
			Handcuffs restraintItem = base.baseEntity.Belt.GetRestraintItem();
			if (restraintItem != null && restraintItem.BlockCrafting)
			{
				return false;
			}
		}
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount, free);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
			if (ingredient.itemDef.condition.enabled && !DoesHaveOKConditionItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
/// <summary>
/// Called to determine if a locked entity can be used by the player.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="lock">The lock on the entity.</param>
/// <returns>Returns true if the player is allowed to use the locked entity, false otherwise.</returns>
bool CanUseLockedEntity(BasePlayer player, KeyLock lock)
{
    Puts("CanUseLockedEntity is working!");
    return true; // Default behavior: allow player to use locked entity
}
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## OnElevatorCall(Elevator,Elevator)

```csharp
/// <summary>
/// Called when an elevator is called.
/// </summary>
/// <param name="elevator1">The first elevator.</param>
/// <param name="elevator2">The second elevator.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnElevatorCall(Elevator elevator1, Elevator elevator2)
{
    Puts("OnElevatorCall is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void CallElevator()
	{
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.IsTop && Interface.CallHook("OnElevatorCall", this, elevatorEnt) == null)
			{
				elevatorEnt.RequestMoveLiftTo(Floor, out var _, this);
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

```

## OnBookmarkControlEnd(ComputerStation,BasePlayer,BaseEntity)

```csharp
/// <summary>
/// Called when control over a computer station is ended.
/// </summary>
/// <param name="computerStation">The computer station being controlled.</param>
/// <param name="player">The player who was controlling the computer station.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnd(ComputerStation computerStation, BasePlayer player, BaseEntity entity)
{
    Puts("OnBookmarkControlEnd is working!");
}
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if ((bool)ply)
		{
			ply.net.SwitchSecondaryGroup(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
		CancelInvoke(CheckCCTVAchievement);
		Interface.CallHook("OnBookmarkControlEnded", this, ply, baseEntity);
	}

```

## CanHideStash(BasePlayer,StashContainer)

```csharp
/// <summary>
/// Called to determine if a stash can be hidden.
/// </summary>
/// <param name="player">The player attempting to hide the stash.</param>
/// <param name="stashContainer">The stash container being hidden.</param>
/// <returns>Returns true if the stash can be hidden, and false otherwise.</returns>
bool CanHideStash(BasePlayer player, StashContainer stashContainer)
{
    Puts("CanHideStash is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", rpc.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", this, rpc.player);
		}
	}

```

## OnPlayerDismountFailed(BasePlayer,BaseMountable)

```csharp
/// <summary>
/// Called when a player's dismount attempt fails.
/// </summary>
/// <param name="player">The player attempting to dismount.</param>
/// <param name="entity">The entity being dismounted from.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDismountFailed(BasePlayer player, BaseMountable entity)
{
    Puts($"Player {player.UserIDString} failed to dismount from {entity.DisplayName}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", player, this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", player, this) == null && (!(player != null) || !player.IsRestrained))
		{
			AttemptDismount(player);
		}
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
/// <summary>
/// Called when an item is picked up by a player.
/// </summary>
/// <param name="item">The item being picked up.</param>
/// <param name="player">The player who picked up the item.</param>
/// <returns>No return behavior.</returns>
void OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Item {item} picked up by player {player}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && this.item != null && allowPickup && Interface.CallHook("OnItemPickup", this.item, msg.player) == null && CanOpenInSafeZone(msg.player))
		{
			ClientRPC(RpcTarget.NetworkGroup("PickupSound"));
			Item item = this.item;
			Facepunch.Rust.Analytics.Azure.OnItemPickup(msg.player, this);
			RemoveItem();
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
/// <summary>
/// Called when a player's authorization to use an AutoTurret is deauthorized.
/// </summary>
/// <param name="turret">The AutoTurret that was deauthorized.</param>
/// <param name="player">The player who lost authorization.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Authorization to use {turret} by {player} has been removed.");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			authDirty = true;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnItemDespawn(Item)

```csharp
/// <summary>
/// Called when an item despawns.
/// </summary>
/// <param name="item">The item that has despawned.</param>
/// <returns>No return behavior.</returns>
void OnItemDespawn(Item item)
{
    Puts($"Item {item} has despawned.");
}
```

### Source Code from the Library

```csharp

	public void IdleDestroy()
	{
		Interface.CallHook("OnItemDespawn", item);
		Facepunch.Rust.Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);
		DestroyItem();
		Kill();
	}

```

## OnNpcTarget(HumanNPC,BaseEntity)

```csharp
/// <summary>
/// Called when an NPC targets a base entity.
/// </summary>
/// <param name="npc">The NPC performing the targeting.</param>
/// <param name="target">The target entity being targeted by the NPC.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value indicating the result of the targeting action.</returns>
object OnNpcTarget(HumanNPC npc, BaseEntity target)
{
    Puts("OnNpcTarget hook called!");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	public BaseEntity GetBestTarget()
	{
		BaseEntity result = null;
		float num = -1f;
		foreach (BaseEntity player in Brain.Senses.Players)
		{
			if (!(player == null) && !(player.Health() <= 0f) && Interface.CallHook("OnNpcTarget", this, player) == null)
			{
				float value = Vector3.Distance(player.transform.position, base.transform.position);
				float num2 = 1f - Mathf.InverseLerp(1f, Brain.SenseRange, value);
				float value2 = Vector3.Dot((player.transform.position - base.eyes.position).normalized, base.eyes.BodyForward());
				num2 += Mathf.InverseLerp(Brain.VisionCone, 1f, value2) / 2f;
				num2 += (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);
				if (num2 > num)
				{
					result = player;
					num = num2;
				}
			}
		}
		return result;
	}

```

## OnSprayCreate(SprayCan,UnityEngine.Vector3,UnityEngine.Quaternion)

```csharp
/// <summary>
/// Called when a spray can is created.
/// </summary>
/// <param name="sprayCan">The spray can being created.</param>
/// <param name="position">The position of the spray can.</param>
/// <param name="rotation">The rotation of the spray can.</param>
/// <returns>No return behavior.</returns>
void OnSprayCreate(SprayCan sprayCan, Vector3 position, Quaternion rotation)
{
    Puts($"Spray can created at {position} with rotation {rotation}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void CreateSpray(RPCMessage msg)
	{
		if (IsBusy())
		{
			return;
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3();
		Vector3 point = msg.read.Vector3();
		int num = msg.read.Int32();
		if (!(Vector3.Distance(vector, base.transform.position) > 4.5f))
		{
			Quaternion quaternion = Quaternion.LookRotation((new Plane(vector2, vector).ClosestPointOnPlane(point) - vector).normalized, vector2);
			quaternion *= Quaternion.Euler(0f, 0f, 90f);
			bool flag = false;
			if (msg.player.IsDeveloper)
			{
				flag = true;
			}
			if (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))
			{
				Debug.Log($"SprayCan.ChangeItemSkin player does not have item :{num}:");
			}
			else if (Interface.CallHook("OnSprayCreate", this, vector, quaternion) == null)
			{
				ulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);
				BaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, vector, quaternion);
				baseEntity.skinID = num2;
				baseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());
				baseEntity.Spawn();
				CheckAchievementPosition(vector);
				LoseCondition(ConditionLossPerSpray);
			}
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
/// <summary>
/// Called when a player attempts to update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="signage">The signage being updated.</param>
/// <returns>Returns <c>true</c> if the default behavior is overridden, and <c>false</c> otherwise.</returns>
object CanUpdateSign(BasePlayer player, Signage signage)
{
    Puts("CanUpdateSign is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return true;
	}

```

## OnPlayerRespawn(BasePlayer,SleepingBag)

```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who is respawning.</param>
/// <param name="sleepingBag">The sleeping bag that the player is using to respawn.</param>
/// <returns>Returns the updated sleeping bag if the default behavior is overridden, otherwise returns null.</returns>
object OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag)
{
    Puts("OnPlayerRespawn hook called!");
    // If you want to override the default behavior, return an object (e.g., a new sleeping bag state)
    return null;
}
```

### Source Code from the Library

```csharp

	public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)
	{
		BasePlayer player2 = player;
		SleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);
		SleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) => x.ValidForPlayer(player2.userID, ignoreTimers: false) && x.net.ID == sleepingBag && x.unlockTime < UnityEngine.Time.realtimeSinceStartup);
		if (sleepingBag2 == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", player, sleepingBag2);
		if (obj is SleepingBag)
		{
			sleepingBag2 = (SleepingBag)obj;
		}
		if (sleepingBag2.GetRespawnState(player2.userID) != RespawnInformation.SpawnOptions.RespawnState.OK)
		{
			return false;
		}
		sleepingBag2.GetSpawnPos(out var pos, out var rot);
		player2.RespawnAt(pos, rot, sleepingBag2);
		sleepingBag2.PostPlayerSpawn(player2);
		SleepingBag[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			SetBagTimer(array2[i], pos, SleepingBagResetReason.Respawned, player2);
		}
		return true;
	}

```

## CanUnlockTechTreeNodePath(BasePlayer,TechTreeData.NodeInstance,TechTreeData)

```csharp
/// <summary>
/// Called to determine if a player can unlock a specific tech tree node path.
/// </summary>
/// <param name="player">The player attempting to unlock the tech tree node path.</param>
/// <param name="node">The tech tree node instance for which to check unlocking.</param>
/// <param name="techTreeData">Additional data related to the tech tree.</param>
/// <returns>Returns true if the player can unlock the tech tree node path, false otherwise.</returns>
bool CanUnlockTechTreeNodePath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)
{
    Puts("CanUnlockTechTreeNodePath is working!");
    // Minimal code to demonstrate functionality
    return true; // Replace with actual logic to determine if the player can unlock the tech tree node path
}
```

### Source Code from the Library

```csharp

	public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNodePath", player, node, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		NodeInstance entryNode = GetEntryNode();
		if (entryNode == null)
		{
			return false;
		}
		return CheckChainRecursive(player, entryNode, node);
	}

```

## OnRackedWeaponSwapped(Item,WeaponRackSlot,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a player swaps their held weapon with a weapon on the rack.
/// </summary>
/// <param name="item">The player's held item.</param>
/// <param name="weaponSlot">The slot on the rack where the swap occurred.</param>
/// <param name="player">The player performing the swap.</param>
/// <param name="rack">The weapon rack involved in the swap.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponSwapped(Item item, WeaponRackSlot weaponSlot, BasePlayer player, WeaponRack rack)
{
    Puts($"Player {player.UserIDString} swapped held weapon with a weapon on the rack.");
}
```

### Source Code from the Library

```csharp

	private void SwapPlayerWeapon(BasePlayer player, int gridCellIndex, int takeFromBeltIndex, int rotation)
	{
		Item item = player.GetHeldEntity()?.GetItem();
		if (item == null)
		{
			return;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(item.info);
		if (forItemDef == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(gridCellIndex);
		if (weaponAtIndex != null)
		{
			int mountSlotIndex = gridCellIndex;
			if (CustomRackType != 0)
			{
				gridCellIndex = 0;
			}
			int bestPlacementCellIndex = GetBestPlacementCellIndex(GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);
			if (bestPlacementCellIndex != -1 && Interface.CallHook("OnRackedWeaponSwap", item, weaponAtIndex, player, this) == null)
			{
				item.RemoveFromContainer();
				GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, tryHold: false);
				MountWeapon(item, player, bestPlacementCellIndex, rotation, sendUpdate: false);
				ItemManager.DoRemoves();
				SendNetworkUpdateImmediate();
				Interface.CallHook("OnRackedWeaponSwapped", item, weaponAtIndex, player, this);
			}
		}
	}

```

## OnEntityReskinned(BaseEntity,ItemSkinDirectory.Skin,BasePlayer)

```csharp
This is a C# code snippet that appears to be part of a game server implementation. It's handling the reskining of an entity (a game object) on the server side. Here's a breakdown of what it does:

**Reskinning Process**

The `Reskin` method takes several parameters, including:

* `baseEntity`: The entity being reskinned.
* `skin`: The new skin to apply.
* `msg`: A message object containing information about the player who initiated the reskin request.

The method performs the following steps:

1. **Save Entity Storage**: It saves the current inventory and storage of the entity in a dictionary (`dictionary2`).
2. **Remove Old Skin**: If the entity has an old skin, it removes that skin.
3. **Apply New Skin**: It applies the new skin to the entity.
4. **Restore Entity Storage**: It restores the saved inventory and storage of the entity from the dictionary.

**Additional Steps**

The method also performs some additional steps:

* **Update Entity Health**: If the entity is a combat entity, it updates its health.
* **Update Building Privileges**: If the entity is a building privilege entity, it updates its authorized players list.
* **Notify Clients**: It notifies clients that the reskinning process has completed.

**Error Handling**

The method also handles errors:

* **Reskin Fail Response**: If the reskining fails for any reason, it sends a fail response to clients with an error code.

Overall, this code snippet is responsible for handling the reskining of entities on the server side, including saving and restoring entity storage, applying new skins, updating entity health and building privileges, and notifying clients.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.CallsPerSecond(2uL)]
	private void ChangeItemSkin(RPCMessage msg)
	{
		if (IsBusy())
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		int targetSkin = msg.read.Int32();
		if (msg.player == null || !msg.player.CanBuild())
		{
			return;
		}
		bool flag = false;
		if (msg.player.UnlockAllSkins)
		{
			flag = true;
		}
		if (targetSkin != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(targetSkin, msg.player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return;
		}
		if (baseNetworkable != null)
		{
			BaseEntity baseEntity2 = baseNetworkable as BaseEntity;
			if ((object)baseEntity2 != null)
			{
				Vector3 position = baseEntity2.WorldSpaceBounds().ClosestPoint(msg.player.eyes.position);
				if (!msg.player.IsVisible(position, 3f))
				{
					SprayFailResponse(SprayFailReason.LineOfSight);
					return;
				}
				if (baseNetworkable is Door door)
				{
					if (!door.GetPlayerLockPermission(msg.player))
					{
						msg.player.ChatMessage("Door must be openable");
						return;
					}
					if (door.IsOpen())
					{
						msg.player.ChatMessage("Door must be closed");
						return;
					}
				}
				if (!GetItemDefinitionForEntity(baseEntity2, out var def))
				{
					SprayFailResponse(SprayFailReason.InvalidItem);
					return;
				}
				ItemDefinition itemDefinition = null;
				ulong num = ItemDefinition.FindSkin(def.itemid, targetSkin);
				ItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
				if (Interface.CallHook("OnEntityReskin", baseEntity2, skin, msg.player) != null)
				{
					return;
				}
				if (skin.invItem != null && skin.invItem is ItemSkin itemSkin)
				{
					if (itemSkin.Redirect != null)
					{
						itemDefinition = itemSkin.Redirect;
					}
					else if (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) && def.isRedirectOf != null)
					{
						itemDefinition = def.isRedirectOf;
					}
				}
				else if (def.isRedirectOf != null || (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) && def.isRedirectOf != null))
				{
					itemDefinition = def.isRedirectOf;
				}
				if (itemDefinition == null)
				{
					baseEntity2.skinID = num;
					baseEntity2.SendNetworkUpdate();
					Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
				}
				else
				{
					if (!CanEntityBeRespawned(baseEntity2, out var reason2))
					{
						SprayFailResponse(reason2);
						return;
					}
					if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
					{
						Debug.LogWarning("Cannot find resource path of redirect entity to spawn! " + itemDefinition.gameObject.name);
						SprayFailResponse(SprayFailReason.InvalidItem);
						return;
					}
					Vector3 localPosition = baseEntity2.transform.localPosition;
					Quaternion localRotation = baseEntity2.transform.localRotation;
					BaseEntity baseEntity3 = baseEntity2.GetParentEntity();
					float health = baseEntity2.Health();
					EntityRef[] slots = baseEntity2.GetSlots();
					ulong ownerID = baseEntity2.OwnerID;
					float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
					HashSet<PlayerNameID> hashSet = null;
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge)
					{
						hashSet = new HashSet<PlayerNameID>(buildingPrivlidge.authorizedPlayers);
					}
					bool flag2 = baseEntity2 is Door || baseEntity2 is BuildingPrivlidge;
					Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
					SaveEntityStorage(baseEntity2, dictionary2, 0);
					List<ChildPreserveInfo> obj = Facepunch.Pool.GetList<ChildPreserveInfo>();
					if (flag2)
					{
						foreach (BaseEntity child in baseEntity2.children)
						{
							obj.Add(new ChildPreserveInfo
							{
								TargetEntity = child,
								TargetBone = child.parentBone,
								LocalPosition = child.transform.localPosition,
								LocalRotation = child.transform.localRotation
							});
						}
						foreach (ChildPreserveInfo item in obj)
						{
							item.TargetEntity.SetParent(null, worldPositionStays: true);
						}
					}
					else
					{
						for (int i = 0; i < baseEntity2.children.Count; i++)
						{
							SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
						}
					}
					baseEntity2.Kill();
					baseEntity2 = GameManager.server.CreateEntity(resourcePath, (baseEntity3 != null) ? baseEntity3.transform.TransformPoint(localPosition) : localPosition, (baseEntity3 != null) ? (baseEntity3.transform.rotation * localRotation) : localRotation);
					baseEntity2.SetParent(baseEntity3);
					baseEntity2.transform.localPosition = localPosition;
					baseEntity2.transform.localRotation = localRotation;
					baseEntity2.OwnerID = ownerID;
					if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)
					{
						baseEntity2.skinID = 0uL;
					}
					else
					{
						baseEntity2.skinID = num;
					}
					if (baseEntity2 is DecayEntity decayEntity)
					{
						decayEntity.AttachToBuilding(null);
					}
					baseEntity2.Spawn();
					if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
					{
						baseCombatEntity2.SetHealth(health);
						baseCombatEntity2.lastAttackedTime = lastAttackedTime;
					}
					if (baseEntity2 is BuildingPrivlidge buildingPrivlidge2 && hashSet != null)
					{
						buildingPrivlidge2.authorizedPlayers = hashSet;
					}
					if (dictionary2.Count > 0)
					{
						RestoreEntityStorage(baseEntity2, 0, dictionary2);
						if (!flag2)
						{
							for (int j = 0; j < baseEntity2.children.Count; j++)
							{
								RestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);
							}
						}
						foreach (KeyValuePair<ContainerSet, List<Item>> item2 in dictionary2)
						{
							foreach (Item item3 in item2.Value)
							{
								Debug.Log($"Deleting {item3} as it has no new container");
								item3.Remove();
							}
						}
						Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
					}
					if (flag2)
					{
						foreach (ChildPreserveInfo item4 in obj)
						{
							item4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);
							item4.TargetEntity.transform.localPosition = item4.LocalPosition;
							item4.TargetEntity.transform.localRotation = item4.LocalRotation;
							item4.TargetEntity.SendNetworkUpdate();
						}
						baseEntity2.SetSlots(slots);
					}
					Interface.CallHook("OnEntityReskinned", baseEntity2, skin, msg.player);
					Facepunch.Pool.FreeList(ref obj);
				}
				ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 1, baseEntity2.net.ID);
			}
		}
		LoseCondition(ConditionLossPerReskin);
		ClientRPC(RpcTarget.NetworkGroup("Client_ChangeSprayColour"), -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (copy.ContainsKey(key))
				{
					foreach (Item item5 in copy[key])
					{
						item5.MoveToContainer(itemContainerEntity.inventory);
					}
					copy.Remove(key);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (!dictionary.ContainsKey(key2))
				{
					dictionary.Add(key2, new List<Item>());
					foreach (Item item6 in itemContainerEntity2.inventory.itemList)
					{
						dictionary[key2].Add(item6);
					}
					{
						foreach (Item item7 in dictionary[key2])
						{
							item7.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log("Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
		void SprayFailResponse(SprayFailReason reason)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_ReskinResult"), 0, (int)reason);
		}
	}

```

## OnPlayerDig(BasePlayer,BaseDiggableEntity)

```csharp
/// <summary>
/// Called when a player attempts to dig an entity.
/// </summary>
/// <param name="player">The player attempting to dig the entity.</param>
/// <param name="entity">The entity being dug.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerDig(BasePlayer player, BaseDiggableEntity entity)
{
    Puts("OnPlayerDig hook called!");
    // If the entity is fully dug, return null to allow further digging
    if (entity.digsRemaining <= 0) 
    {
        return null;
    }
    // Otherwise, prevent further digging by returning a non-null value
    else 
    {
        return true;
    }
}
```

### Source Code from the Library

```csharp

	public virtual void Dig(BasePlayer player)
	{
		if (Interface.CallHook("OnPlayerDig", player, this) != null)
		{
			return;
		}
		if (digsRemaining == RequiredDigCount)
		{
			OnFirstDig(player);
		}
		ClientRPC(RpcTarget.NetworkGroup("RPC_OnDig"), RequiredDigCount - digsRemaining, RequiredDigCount);
		digsRemaining--;
		base.health = digsRemaining;
		SendNetworkUpdate();
		OnSingleDig(player);
		if (digsRemaining <= 0)
		{
			OnFullyDug(player);
			if (DestroyOnDug)
			{
				Kill();
			}
		}
	}

```

## OnPlayerAddModifiers(BasePlayer,Item,ItemModConsumable)

```csharp
/// <summary>
/// Called when a player consumes an item and its modifiers.
/// </summary>
/// <param name="player">The player consuming the item.</param>
/// <param name="item">The item being consumed.</param>
/// <param name="modifiers">The modifiers of the item being consumed.</param>
/// <returns>No return behavior.</returns>
void OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable modifiers)
{
    Puts($"Adding modifiers to player {player.displayName} for item {item.info.itemid}");
}
```

### Source Code from the Library

```csharp

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount < 1)
		{
			return;
		}
		GameObjectRef gameObjectRef = GetConsumeEffect();
		if (gameObjectRef.isValid)
		{
			Vector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));
			Effect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);
		}
		player.metabolism.MarkConsumption();
		ItemModConsumable consumable = GetConsumable();
		if (!string.IsNullOrEmpty(consumable.achievementWhenEaten))
		{
			player.GiveAchievement(consumable.achievementWhenEaten);
		}
		Facepunch.Rust.Analytics.Azure.OnConsumableUsed(player, item);
		float num = Mathf.Max(consumable.amountToConsume, 1);
		float num2 = Mathf.Min(item.amount, num);
		float num3 = num2 / num;
		float num4 = item.conditionNormalized;
		if (consumable.conditionFractionToLose > 0f)
		{
			num4 = consumable.conditionFractionToLose;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
		{
			if (Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)
			{
				continue;
			}
			if (effect.type == MetabolismAttribute.Type.Health)
			{
				if (effect.amount < 0f)
				{
					player.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, player.transform.position + player.transform.forward * 1f));
				}
				else
				{
					player.health += effect.amount * num3 * num4;
				}
			}
			else
			{
				player.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);
			}
		}
		player.ProcessMissionEvent(BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);
		if (player.modifiers != null && Interface.CallHook("OnPlayerAddModifiers", player, item, consumable) == null)
		{
			player.modifiers.Add(consumable.modifiers);
		}
		if (product != null)
		{
			ItemAmountRandom[] array = product;
			foreach (ItemAmountRandom itemAmountRandom in array)
			{
				int num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);
				if (num5 > 0)
				{
					Item item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);
					player.GiveItem(item2);
				}
			}
		}
		if (string.IsNullOrEmpty(eatGesture))
		{
			player.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);
		}
		Facepunch.Rust.Analytics.Server.Consume(base.gameObject.name);
		if (consumable.conditionFractionToLose > 0f)
		{
			item.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);
		}
		else
		{
			item.UseItem((int)num2);
		}
	}

```

## OnStructureUpgraded(BuildingBlock,BasePlayer,BuildingGrade.Enum,ulong)

```csharp
/// <summary>
/// Called when a building block is upgraded to a new grade.
/// </summary>
/// <param name="block">The building block being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="grade">The new grade of the building block.</param>
/// <param name="upgradeId">The ID of the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnStructureUpgraded(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade, ulong upgradeId)
{
    Puts($"Building block upgraded to grade {grade} by player {player.UserIDString}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoUpgradeToGrade_Delayed(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
		ulong num = msg.read.UInt64();
		ConstructionGrade constructionGrade = blockDefinition.GetGrade(@enum, num);
		if (!(constructionGrade == null) && CanChangeToGrade(@enum, num, msg.player) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum, num) == null && CanAffordUpgrade(@enum, num, msg.player) && !(base.SecondsSinceAttacked < 30f) && (num == 0L || msg.player.blueprints.steamInventory.HasItem((int)num)))
		{
			PayForUpgrade(constructionGrade, msg.player);
			if (msg.player != null)
			{
				playerCustomColourToApply = msg.player.LastBlockColourChangeId;
			}
			ClientRPC(RpcTarget.NetworkGroup("DoUpgradeEffect"), (int)@enum, num);
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, @enum, playerCustomColourToApply, num);
			OnSkinChanged(skinID, num);
			ChangeGrade(@enum, playEffect: true);
			Interface.CallHook("OnStructureUpgraded", this, msg.player, @enum, num);
		}
	}

```

## CanSeeStash(BasePlayer,StashContainer)

```csharp
/// <summary>
/// Called when a player attempts to see a stash container.
/// </summary>
/// <param name="player">The player attempting to see the stash.</param>
/// <param name="stashContainer">The stash container being viewed.</param>
/// <returns>Returns true if the player can see the stash, and false otherwise.</returns>
bool CanSeeStash(BasePlayer player, StashContainer stashContainer)
{
    Puts("CanSeeStash is working!");
    // Minimal code to demonstrate functionality
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	private void CheckStashRevealInvoke()
	{
		for (int i = 0; i < nearbyStashes.Count; i++)
		{
			NearbyStash nearbyStash = nearbyStashes[i];
			if (nearbyStash.Entity == null || nearbyStash.Entity.IsDestroyed)
			{
				nearbyStashes.RemoveAt(i);
			}
			else if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))
			{
				nearbyStash.LookingAtTime += StashContainer.PlayerDetectionTickRate;
				if (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)
				{
					if (Interface.CallHook("CanSeeStash", this, nearbyStash.Entity) != null)
					{
						break;
					}
					nearbyStash.Entity.SetHidden(isHidden: false);
					Facepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);
					Interface.CallHook("OnStashExposed", nearbyStash.Entity, this);
				}
			}
			else
			{
				nearbyStash.LookingAtTime = 0f;
			}
		}
	}

```

## OnDeleteVendingOffer(VendingMachine,int)

```csharp
/// <summary>
/// Called when a vending offer is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was deleted from.</param>
/// <param name="index">The index of the deleted offer in the vending machine's sell orders list.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, int index)
{
    Puts($"Vending offer at index {index} deleted from vending machine {vendingMachine}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", this, num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[num];
				Facepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, added: false);
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## OnIORefCleared(IOEntity.IORef,IOEntity)

```csharp
/// <summary>
/// Called when an IO reference is cleared.
/// </summary>
/// <param name="entity">The entity that owns the cleared IO reference.</param>
/// <param name="ioRef">The cleared IO reference.</param>
/// <returns>No return behavior.</returns>
void OnIORefCleared(IOEntity entity, IOEntity.IORef ioRef)
{
    Puts($"IO reference cleared for entity {entity}");
}
```

### Source Code from the Library

```csharp

		public void Clear()
		{
			IOEntity obj = ioEnt;
			ioEnt = null;
			entityRef.Set(null);
			Interface.CallHook("OnIORefCleared", this, obj);
		}

```

## OnPlayerRespawn(BasePlayer,BasePlayer.SpawnPoint)

```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who is respawning.</param>
/// <param name="spawnPoint">The point where the player will respawn.</param>
/// <returns>Returns a non-null SpawnPoint if the default spawn point is overridden.</returns>
object OnPlayerRespawn(BasePlayer player, BasePlayer.SpawnPoint spawnPoint)
{
    Puts("OnPlayerRespawn hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this);
		if (ConVar.Server.respawnAtDeathPosition && ServerCurrentDeathNote != null)
		{
			spawnPoint.pos = ServerCurrentDeathNote.worldPosition;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", this, spawnPoint);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnWeaponReload(BaseProjectile,BasePlayer)

```csharp
/// <summary>
/// Called when a player attempts to reload their weapon.
/// </summary>
/// <param name="projectile">The projectile being reloaded.</param>
/// <param name="player">The player attempting to reload the weapon.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns an object representing the result of the hook.</returns>
object OnWeaponReload(BaseProjectile projectile, BasePlayer player)
{
    Puts("OnWeaponReload called!");
    // Minimal code to demonstrate functionality
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnWeaponReload", this, player) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			fractionalInsertCounter = 0;
			if (CanRefundAmmo)
			{
				SwitchAmmoTypesIfNeeded(player.inventory);
			}
			OnReloadStarted();
			StartReloadCooldown(GetReloadDuration());
		}
	}

```

## OnCrateHackEnd(HackableLockedCrate)

```csharp
/// <summary>
/// Called when a hack on a locked crate is completed.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateHackEnd(HackableLockedCrate crate)
{
    Puts("OnCrateHackEnd is working!");
}
```

### Source Code from the Library

```csharp

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", this);
			Facepunch.Rust.Analytics.Azure.OnLockedCrateFinished(originalHackerPlayerId, this);
			if (originalHackerPlayer != null && originalHackerPlayer.serverClan != null)
			{
				originalHackerPlayer.AddClanScore(ClanScoreEventType.HackedCrate);
			}
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			CancelInvoke(HackProgress);
		}
		ClientRPC(RpcTarget.NetworkGroup("UpdateHackProgress"), (int)hackSeconds, (int)requiredHackSeconds);
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
Документация для метода `OnMeleeThrown`:

```csharp
/// <summary>
/// Called when a melee attack is thrown.
/// </summary>
/// <param name="player">The player who threw the attack.</param>
/// <param name="item">The item that was thrown.</param>
/// <returns>No return behavior.</returns>
void OnMeleeThrown(BasePlayer player, Item item)
{
    // Minimal code to demonstrate functionality
}
```

Этот метод вызывается в методе `CLProject` после того, как был проверен и подтвержден бросок предмета. Метод принимает на вход двух параметров: игрока (`player`) и предмет (`item`).
```

### Source Code from the Library

```csharp

	[RPC_Server.FromOwner]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (player == null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsProjectile)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "item_missing");
				return;
			}
			ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
			if (component == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "mod_missing");
				return;
			}
			ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
			if (projectileShoot.projectiles.Count != 1)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "count_mismatch");
				return;
			}
			player.CleanupExpiredProjectiles();
			Guid projectileGroupId = Guid.NewGuid();
			foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.LogInvalid(player, this, "duplicate_id");
					continue;
				}
				Vector3 positionOffset = Vector3.zero;
				if (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))
				{
					if (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))
					{
						continue;
					}
					Vector3 position = player.eyes.position;
					positionOffset = position - projectile.startPos;
					projectile.startPos = position;
				}
				else if (!ValidateEyePos(player, projectile.startPos))
				{
					continue;
				}
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, projectileGroupId, positionOffset, item);
				Effect effect = new Effect();
				effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
				effect.scale = 1f;
				effect.pooledString = component.projectileObject.resourcePath;
				effect.number = projectile.seed;
				EffectNetwork.Send(effect);
			}
			projectileShoot?.Dispose();
			item.SetParent(null);
			Interface.CallHook("OnMeleeThrown", player, item);
			if (!canAiHearIt)
			{
				return;
			}
			float num = 0f;
			if (component.projectileObject == null)
			{
				return;
			}
			GameObject gameObject = component.projectileObject.Get();
			if (!(gameObject != null))
			{
				return;
			}
			Projectile component2 = gameObject.GetComponent<Projectile>();
			if (!(component2 != null))
			{
				return;
			}
			foreach (DamageTypeEntry damageType in component2.damageTypes)
			{
				num += damageType.amount;
			}
		}
	}

```

## OnEntityDistanceCheck(BaseEntity,BasePlayer,uint,string,float,bool)

```csharp
/// <summary>
/// Called when a distance check is performed on an entity.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <param name="player">The player performing the check.</param>
/// <param name="id">A unique identifier for the check.</param>
/// <param name="debugName">A debug-friendly name for the check.</param>
/// <param name="maximumDistance">The maximum distance allowed for the check.</param>
/// <param name="checkParent">Whether to also check the entity's parent.</param>
/// <returns>Returns true if the entity is within the maximum distance, and false otherwise. If overridden, returns a non-null value indicating whether the default behavior should be skipped.</returns>
object OnEntityDistanceCheck(BaseEntity entity, BasePlayer player, uint id, string debugName, float maximumDistance, bool checkParent)
{
    Puts("OnEntityDistanceCheck is working!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance, bool checkParent = false)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityDistanceCheck", ent, player, id, debugName, maximumDistance, checkParent);
				if (obj is bool)
				{
					return (bool)obj;
				}
				bool flag = ent.Distance(player.eyes.position) <= maximumDistance;
				if (checkParent && !flag)
				{
					BaseEntity parentEntity = ent.GetParentEntity();
					flag = parentEntity != null && parentEntity.Distance(player.eyes.position) <= maximumDistance;
				}
				return flag;
			}

```

## OnMapMarkerAdded(BasePlayer,ProtoBuf.MapNote)

```csharp
/// <summary>
/// Called when a new map marker is added.
/// </summary>
/// <param name="player">The player who added the marker.</param>
/// <param name="mapNote">The newly added map note.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"New map marker added by {player.UserIDString} at position: {mapNote.Position}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 13L;
			if (State.pointsOfInterest == null)
			{
				State.pointsOfInterest = Facepunch.Pool.GetList<MapNote>();
			}
			if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
			{
				msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, ConVar.Server.maximumMapMarkers.ToString());
				return;
			}
			MapNote mapNote = MapNote.Deserialize(msg.read);
			ValidateMapNote(mapNote);
			mapNote.colourIndex = FindUnusedPointOfInterestColour();
			State.pointsOfInterest.Add(mapNote);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, mapNote);
		}
	}

```

## OnDemoRecordingStop(string,BasePlayer)

```csharp
/// <summary>
/// Called when a demo recording is stopped.
/// </summary>
/// <param name="filename">The filename of the recorded demo.</param>
/// <param name="player">The player who initiated the stop.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStop(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped: {filename}");
}
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnDefaultItemsReceive(PlayerInventory)

```csharp
/// <summary>
/// Called when default items are received by the player.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <returns>No return behavior.</returns>
void OnDefaultItemsReceive(PlayerInventory inventory)
{
    Puts("OnDefaultItemsReceive is working!");
}
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas() && !base.baseEntity.IsInTutorial)
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.CheckSkinOwnership(infoInt, base.baseEntity.userID) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);
			}
		}
	}

```

## OnCupboardDeauthorize(BuildingPrivlidge,BasePlayer)

```csharp
/// <summary>
/// Called when a player's authorization on a cupboard is deauthorized.
/// </summary>
/// <param name="buildingPrivilege">The building privilege being deauthorized.</param>
/// <param name="player">The player whose authorization was deauthorized.</param>
/// <returns>No return behavior.</returns>
void OnCupboardDeauthorize(BuildingPrivlidge buildingPrivilege, BasePlayer player)
{
    Puts($"Authorization on cupboard {buildingPrivilege} for player {player.UserIDString} has been deauthorized.");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (rpc2.player.CanInteract() && CanAdministrate(rpc2.player) && Interface.CallHook("OnCupboardDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Called to determine if a player can be wounded.
/// </summary>
/// <param name="player">The player being checked.</param>
/// <param name="info">Information about the hit that triggered this hook.</param>
/// <returns>Returns true if the player can be wounded, false otherwise.</returns>
bool CanBeWounded(BasePlayer player, HitInfo info)
{
    Puts("CanBeWounded is working!");
    return true; // Default to allowing wounding
}
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsWounded())
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (!IsWounded() && UnityEngine.Time.realtimeSinceStartup - lastWoundedStartTime < ConVar.Server.rewounddelay)
		{
			return false;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((bool)activeGameMode && !activeGameMode.allowWounding)
		{
			return false;
		}
		if (triggers != null)
		{
			for (int i = 0; i < triggers.Count; i++)
			{
				if (triggers[i] is IHurtTrigger)
				{
					return false;
				}
			}
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnItemRecycleAmount(Item,int,Recycler)

```csharp
Документация для OnItemRecycleAmount(Item,int,Recycler)

**Описание**

Хук OnItemRecycleAmount вызывается в методе RecycleThink() и используется для определения количества предметов, которые можно разобрать из данного предмета.

**Параметры**

* `Item`: Объект предмета, который нужно разобрать.
* `int`: Количество предметов, которое можно разобрать.
* `Recycler`: Объект recycler, который вызывает этот хук.

**Возвращаемое значение**

Хук возвращает количество предметов, которые можно разобрать из данного предмета. Если возвращаемое значение не является целым числом, оно будет округлено до ближайшего целого числа.

**Примечания**

* Этот хук вызывается после проверки, что предмет можно разобрать (см. метод CanBeRecycled).
* Если возвращаемое значение не является целым числом, оно будет округлено до ближайшего целого числа.
* Этот хук используется для определения количества предметов, которые можно разобрать из данного предмета, и для обновления статистики recycler.

**Пример использования**

```csharp
public void RecycleThink()
{
    // ...
    Item slot = base.inventory.GetSlot(num2);
    if (!CanBeRecycled(slot))
    {
        num2++;
        continue;
    }
    int amountToRecycle = 1;
    object obj = Interface.CallHook("OnItemRecycleAmount", slot, amountToRecycle, this);
    if (obj is int)
    {
        amountToRecycle = (int)obj;
    }
    // ...
}
```

В этом примере хук OnItemRecycleAmount вызывается с параметрами `slot` и `amountToRecycle`, а возвращаемое значение используется для обновления статистики recycler.
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = (IsSafezoneRecycler() ? safezoneRecycleEfficiency : radtownRecycleEfficiency);
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", slot, this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", slot, num3, this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					float num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 *= slot.conditionNormalized;
					}
					float num5 = num / 0.5f;
					num4 *= num5;
					int num6 = Mathf.FloorToInt(num4);
					float num7 = num4 - (float)num6;
					scrapRemainder += num7;
					if (scrapRemainder >= 1f)
					{
						int num8 = Mathf.FloorToInt(scrapRemainder);
						scrapRemainder -= num8;
						num6 += num8;
					}
					if (num6 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num6, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj2 = Facepunch.Pool.GetList<BasePlayer>();
					Vis.Entities(base.transform.position, 3f, obj2, 131072);
					foreach (BasePlayer item3 in obj2)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Facepunch.Pool.FreeList(ref obj2);
				}
				Facepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num9 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate * num * (float)num3;
					int num10 = Mathf.FloorToInt(num9);
					float num11 = num9 - (float)num10;
					if (num11 > float.Epsilon && UnityEngine.Random.Range(0f, 1f) <= num11)
					{
						num10++;
					}
					if (num10 <= 0)
					{
						continue;
					}
					int num12 = Mathf.CeilToInt((float)num10 / (float)ingredient.itemDef.stackable);
					for (int i = 0; i < num12; i++)
					{
						int num13 = ((num10 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num10);
						Item item2 = ItemManager.Create(ingredient.itemDef, num13, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
						if (!MoveItemToOutput(item2))
						{
							flag = true;
						}
						num10 -= num13;
						if (num10 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

```

## OnQueueMessage(Network.Connection,int)

```csharp
/// <summary>
/// Called when a message is sent to the queue.
/// </summary>
/// <param name="connection">The connection that sent the message.</param>
/// <param name="position">The position of the message in the queue.</param>
/// <returns>Returns null if the default behavior should be executed, otherwise returns a non-null value.</returns>
object OnQueueMessage(Network.Connection connection, int position)
{
    // Minimal code to demonstrate functionality
    Puts($"OnQueueMessage called for connection {connection} with position {position}");
    
    return null;
}
```

### Source Code from the Library

```csharp

	public void SendMessage(Connection c, int position)
	{
		if (Interface.CallHook("OnQueueMessage", c, position) == null)
		{
			string empty = string.Empty;
			empty = ((position <= 0) ? string.Format("YOU'RE NEXT - {1:N0} PLAYERS BEHIND YOU", position, queue.Count - position - 1) : $"{position:N0} PLAYERS AHEAD OF YOU, {queue.Count - position - 1:N0} PLAYERS BEHIND");
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.Message);
			netWrite.String("QUEUE");
			netWrite.String(empty);
			netWrite.Send(new SendInfo(c));
		}
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
/// <summary>
/// Called when an entity's ground is missing.
/// </summary>
/// <param name="entity">The entity whose ground is missing.</param>
/// <returns>No return behavior. The method will destroy the entity if it has a combat component, otherwise it will gib the entity.</returns>
void OnEntityGroundMissing(BaseEntity entity)
{
    Puts("OnEntityGroundMissing called!");
    
    // If the entity has a combat component, die it
    BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
    if (baseCombatEntity != null)
    {
        baseCombatEntity.Die();
    }
    else
    {
        // Otherwise, gib the entity
        entity.Kill(BaseNetworkable.DestroyMode.Gib);
    }
}
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (baseEntity != null && Interface.CallHook("OnEntityGroundMissing", baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}

```

## CanNetworkTo(BaseEntity,BasePlayer)

```csharp
/// <summary>
/// Called to determine whether the entity should network to a specific player.
/// </summary>
/// <param name="entity">The entity in question.</param>
/// <param name="player">The player to check networking for.</param>
/// <returns>Returns true if the entity should network to the player, false otherwise.</returns>
object CanNetworkTo(BaseEntity entity, BasePlayer player)
{
    Puts("CanNetworkTo is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		if (player == this)
		{
			return true;
		}
		if (IsTransferProtected())
		{
			return false;
		}
		BaseEntity baseEntity = GetParentEntity();
		if (base.limitNetworking)
		{
			if (baseEntity == null)
			{
				return false;
			}
			if (baseEntity != player)
			{
				return false;
			}
		}
		if (baseEntity != null)
		{
			object obj = Interface.CallHook("CanNetworkTo", this, player);
			if (obj is bool)
			{
				return (bool)obj;
			}
			return baseEntity.ShouldNetworkTo(player);
		}
		return base.ShouldNetworkTo(player);
	}

```

## OnWindmillUpdated(ElectricWindmill)

```csharp
/// <summary>
/// Called when the windmill's state is updated.
/// </summary>
/// <param name="windmill">The ElectricWindmill instance that was updated.</param>
/// <returns>No return behavior.</returns>
void OnWindmillUpdated(ElectricWindmill windmill)
{
    Puts($"Windmill {windmill.GetId()} updated.");
}
```

### Source Code from the Library

```csharp

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", this);
		}
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
Документация для хука `OnEntityBuilt(Planner,UnityEngine.GameObject)`

**Описание**

Хук `OnEntityBuilt` вызывается после того, как объект был успешно развернут на игровом поле. Этот хук позволяет модулю или плагину реагировать на создание нового объекта.

**Параметры**

* `Planner`: Объект-развертыватель, который вызвал этот хук.
* `UnityEngine.GameObject`: Созданный объект.

**Пример использования**

Например, вы можете использовать этот хук для обновления игрового состояния или для выполнения каких-либо действий после создания нового объекта. Например:

```csharp
public class MyPlugin : MonoBehaviour
{
    public void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
    {
        // Обновите игровое состояние или выполните какие-либо действия
        Debug.Log("Новый объект создан: " + gameObject.name);
    }
}
```

**Примечания**

* Этот хук вызывается только после того, как объект был успешно развернут на игровом поле.
* Вы можете использовать этот хук для реагирования на создание любого типа объекта.
* Если вы хотите отменить действие этого хука, вы можете вернуть `null` из метода `OnEntityBuilt`.
```

### Source Code from the Library

```csharp

	public BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		if (RayEx.IsNaNOrInfinity(target.ray))
		{
			return null;
		}
		if (target.position.IsNaNOrInfinity())
		{
			return null;
		}
		if (target.normal.IsNaNOrInfinity())
		{
			return null;
		}
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ChatMessage("Target socket is not female. (" + target.socket.socketName + ")");
				return null;
			}
			if (target.entity != null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ChatMessage("Target socket is occupied. (" + target.socket.socketName + ")");
				return null;
			}
			if (target.onTerrain)
			{
				ownerPlayer.ChatMessage("Target on terrain is not allowed when attaching to socket. (" + target.socket.socketName + ")");
				return null;
			}
		}
		Vector3 vector = ((target.entity != null && target.socket != null) ? target.GetWorldPosition() : target.position);
		if (AntiHack.TestIsBuildingInsideSomething(target, vector))
		{
			ownerPlayer.ChatMessage("Can't deploy inside objects");
			return null;
		}
		if (ConVar.AntiHack.eye_protection >= 2)
		{
			Vector3 center = ownerPlayer.eyes.center;
			Vector3 position = ownerPlayer.eyes.position;
			Vector3 origin = target.ray.origin;
			Vector3 p = vector;
			int num = 2097152;
			int num2 = 2162688;
			if (ConVar.AntiHack.build_terraincheck)
			{
				num2 |= 0x800000;
			}
			if (ConVar.AntiHack.build_vehiclecheck)
			{
				num2 |= 0x8000000;
			}
			float num3 = ConVar.AntiHack.build_losradius;
			float padding = ConVar.AntiHack.build_losradius + 0.01f;
			int layerMask = num2;
			if (target.socket != null)
			{
				num3 = 0f;
				padding = 0.5f;
				layerMask = num;
			}
			if (component.isSleepingBag)
			{
				num3 = ConVar.AntiHack.build_losradius_sleepingbag;
				padding = ConVar.AntiHack.build_losradius_sleepingbag + 0.01f;
				layerMask = num2;
			}
			if (num3 > 0f)
			{
				p += target.normal.normalized * num3;
			}
			if (target.entity != null)
			{
				DeployShell deployShell = PrefabAttribute.server.Find<DeployShell>(target.entity.prefabID);
				if (deployShell != null)
				{
					p += target.normal.normalized * deployShell.LineOfSightPadding();
				}
			}
			if (!GamePhysics.LineOfSightRadius(center, position, layerMask, num3) || !GamePhysics.LineOfSightRadius(position, origin, layerMask, num3) || !GamePhysics.LineOfSightRadius(origin, p, layerMask, num3, 0f, padding))
			{
				ownerPlayer.ChatMessage("Line of sight blocked.");
				return null;
			}
		}
		Construction.lastPlacementError = "No Error";
		if (ConVar.Server.max_sleeping_bags > 0)
		{
			CanBuildResult? result = SleepingBag.CanBuildBed(ownerPlayer, component);
			if (HandleCanBuild(result, ownerPlayer))
			{
				return null;
			}
		}
		if (ConVar.Server.max_shelters > 0)
		{
			CanBuildResult? result2 = LegacyShelter.CanBuildShelter(ownerPlayer, component);
			if (HandleCanBuild(result2, ownerPlayer))
			{
				return null;
			}
		}
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			ownerPlayer.ChatMessage("Can't place: " + Construction.lastPlacementError);
		}
		if (gameObject != null)
		{
			Interface.CallHook("OnEntityBuilt", this, gameObject);
			Deployable deployable = GetDeployable();
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
			if (baseEntity != null && deployable != null)
			{
				if (ShouldParent(target.entity, deployable))
				{
					if (target.socket is Socket_Specific_Female socket_Specific_Female)
					{
						if (socket_Specific_Female.parentToBone)
						{
							baseEntity.SetParent(target.entity, socket_Specific_Female.boneName, worldPositionStays: true);
						}
						else
						{
							baseEntity.SetParent(target.entity, worldPositionStays: true);
						}
					}
					else
					{
						baseEntity.SetParent(target.entity, worldPositionStays: true);
					}
				}
				if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
				{
					(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
				}
				if (deployable.copyInventoryFromItem)
				{
					StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
					if ((bool)component2)
					{
						component2.ReceiveInventoryFromItem(GetOwnerItem());
					}
				}
				ItemModDeployable modDeployable = GetModDeployable();
				if (modDeployable != null)
				{
					modDeployable.OnDeployed(baseEntity, ownerPlayer);
				}
				baseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer, GetOwnerItem());
				if (deployable.placeEffect.isValid)
				{
					if ((bool)target.entity && target.socket != null)
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up);
					}
					else
					{
						Effect.server.Run(deployable.placeEffect.resourcePath, target.position, target.normal);
					}
				}
			}
			if (baseEntity != null)
			{
				Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
				if (GetOwnerItemDefinition() != null)
				{
					ownerPlayer.ProcessMissionEvent(BaseMission.MissionEventType.DEPLOY, new BaseMission.MissionEventPayload
					{
						WorldPosition = baseEntity.transform.position,
						UintIdentifier = baseEntity.prefabID,
						IntIdentifier = GetOwnerItemDefinition().itemid
					}, 1f);
				}
			}
			PayForPlacement(ownerPlayer, component);
			return baseEntity;
		}
		return null;
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
/// <summary>
/// Called when a bonus item is dispensed from a resource dispenser.
/// </summary>
/// <param name="dispenser">The resource dispenser dispensing the bonus.</param>
/// <param name="player">The player receiving the bonus.</param>
/// <param name="item">The bonus item being dispensed.</param>
/// <returns>The modified item, or null if no modification was made.</returns>
object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    // Minimal code to demonstrate functionality
    Puts("OnDispenserBonus called!");
    
    // If the return value is used as an Item, modify it accordingly
    if (item != null)
    {
        // Modify the item's properties or behavior here
        item.amount += 1; // Example modification
    }
    
    return item;
}
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", this, player, item);
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnBookmarksSendControl(ComputerStation,BasePlayer,string)

```csharp
/// <summary>
/// Called when a player's control bookmarks are sent.
/// </summary>
/// <param name="station">The computer station that initiated the bookmark send.</param>
/// <param name="player">The player who received the bookmarks.</param>
/// <param name="bookmarks">The string representation of the bookmarks being sent.</param>
/// <returns>No return behavior.</returns>
void OnBookmarksSendControl(ComputerStation station, BasePlayer player, string bookmarks)
{
    Puts($"Bookmarks sent to {player} from {station}");
}
```

### Source Code from the Library

```csharp

	public void SendControlBookmarks(BasePlayer player)
	{
		if (!(player == null))
		{
			string text = GenerateControlBookmarkString();
			if (Interface.CallHook("OnBookmarksSendControl", this, player, text) == null)
			{
				ClientRPC(RpcTarget.Player("ReceiveBookmarks", player), text);
			}
		}
	}

```

## OnEntityFlagsNetworkUpdate(BaseEntity)

```csharp
/// <summary>
/// Called when the entity's network update flags are changed.
/// </summary>
/// <param name="entity">The entity whose flags were updated.</param>
/// <returns>No return behavior.</returns>
void OnEntityFlagsNetworkUpdate(BaseEntity entity)
{
    Puts($"Entity {entity} flags updated.");
}
 
Метод OnEntityFlagsNetworkUpdate не имеет возвращаемого значения, поскольку он вызывается только для информирования и не влияет на поведение игры.
```

### Source Code from the Library

```csharp

	public void SendNetworkUpdate_Flags()
	{
		if (Rust.Application.isLoading || Rust.Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		using (TimeWarning.New("SendNetworkUpdate_Flags"))
		{
			LogEntry(LogEntryType.Network, 2, "SendNetworkUpdate_Flags");
			if (Interface.CallHook("OnEntityFlagsNetworkUpdate", this) == null)
			{
				List<Connection> subscribers = GetSubscribers();
				if (subscribers != null && subscribers.Count > 0)
				{
					NetWrite netWrite = Network.Net.sv.StartWrite();
					netWrite.PacketID(Message.Type.EntityFlags);
					netWrite.EntityID(net.ID);
					netWrite.Int32((int)flags);
					SendInfo info = new SendInfo(subscribers);
					netWrite.Send(info);
				}
				base.gameObject.SendOnSendNetworkUpdate(this);
			}
		}
	}

```

## OnWireClear(BasePlayer,IOEntity,int,IOEntity,bool)

```csharp
/// <summary>
/// Called when a wire is cleared.
/// </summary>
/// <param name="player">The player attempting to clear the wire.</param>
/// <param name="ioEntity">The IO entity containing the wire.</param>
/// <param name="clearIndex">The index of the wire being cleared.</param>
/// <param name="connectedTo">The entity connected to the wire.</param>
/// <param name="isInput">Whether the wire is an input or output.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise returns false.</returns>
object OnWireClear(BasePlayer player, IOEntity ioEntity, int clearIndex, IOEntity connectedTo, bool isInput)
{
    Puts("OnWireClear called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public static bool AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)
	{
		IOEntity iOEntity = ((clearEnt != null) ? clearEnt.GetComponent<IOEntity>() : null);
		IOEntity iOEntity2 = (IOEntity)(object)(isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);
		if (((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get() == null)
		{
			return false;
		}
		iOEntity2 = ((IOEntity.IOSlot)(object)iOEntity2).connectedTo.Get();
		object obj = Interface.CallHook("OnWireClear", ply, iOEntity, clearIndex, iOEntity2, isInput);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (iOEntity == null)
		{
			return false;
		}
		if (ply != null && !CanModifyEntity(ply, iOEntity))
		{
			return false;
		}
		return iOEntity.Disconnect(clearIndex, isInput);
	}

```

## OnEntityControl(PoweredRemoteControlEntity,ulong)

```csharp
/// <summary>
/// Called when a player attempts to control the entity.
/// </summary>
/// <param name="entity">The entity being controlled.</param>
/// <param name="playerID">The ID of the player attempting to control the entity.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
bool OnEntityControl(PoweredRemoteControlEntity entity, ulong playerID)
{
    Puts("OnEntityControl is working!");
    return true;
}
```

### Source Code from the Library

```csharp

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", this, playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsPowered())
		{
			return IsStatic();
		}
		return true;
	}

```

## OnLockRemove(ModularCar,BasePlayer)

```csharp
/// <summary>
/// Called when a lock is removed from a modular car.
/// </summary>
/// <param name="car">The modular car that the lock was removed from.</param>
/// <param name="player">The player who requested to remove the lock.</param>
/// <returns>No return behavior.</returns>
void OnLockRemove(ModularCar car, BasePlayer player)
{
    Puts($"Lock removed from {car} by {player}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_RequestRemoveLock(RPCMessage msg)
	{
		if (HasOccupant && carOccupant.CarLock.HasALock && Interface.CallHook("OnLockRemove", carOccupant, msg.player) == null)
		{
			carOccupant.CarLock.RemoveLock();
			Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

```

## OnBroadcastCommand(string,object[])

```csharp
/// <summary>
/// Called when a broadcast command is sent to all clients.
/// </summary>
/// <param name="command">The command being broadcast.</param>
/// <param name="args">Arguments for the command.</param>
/// <returns>No return behavior if default behavior is overridden, otherwise returns a non-null value.</returns>
void OnBroadcastCommand(string command, object[] args)
{
    Puts($"Broadcasting command: {command} with arguments: [{string.Join(", ", args)}]");
}
</prompt>
```

### Source Code from the Library

```csharp

	public static void BroadcastToAllClients(string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnBroadcastCommand", strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			netWrite.String(ConsoleSystem.BuildCommand(strCommand, args));
			netWrite.Send(new SendInfo(Network.Net.sv.connections));
		}
	}

```

## CanUnlock(BasePlayer,CodeLock)

```csharp
/// <summary>
/// Called when a player attempts to unlock the code lock.
/// </summary>
/// <param name="player">The player attempting to unlock the code lock.</param>
/// <param name="codeLock">The code lock being unlocked.</param>
/// <returns>Returns null if the default behavior is allowed, or a non-null value if the default behavior is overridden.</returns>
object CanUnlock(BasePlayer player, CodeLock codeLock)
{
    Puts("CanUnlock hook called!");
    // If you want to override the default behavior, return a non-null value
    // For example:
    // return true; // Allow unlocking
    // return false; // Prevent unlocking
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	[RPC_Server]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && !IsCodeEntryBlocked() && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnComposterUpdate(Composter)

```csharp
/// <summary>
/// Called when the composting process is updated.
/// </summary>
/// <param name="composter">The composter instance.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnComposterUpdate(Composter composter)
{
    Puts("OnComposterUpdate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdateComposting()
	{
		if (Interface.CallHook("OnComposterUpdate", this) != null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				CompostItem(slot);
			}
		}
	}

```

## OnTakeCurrencyItem(VendingMachine,Item)

```csharp
/// <summary>
/// Called when a currency item is taken from the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine that lost the currency item.</param>
/// <param name="item">The currency item that was taken.</param>
/// <returns>Returns null if the default behavior is not overridden, or another value depending on the method's functionality.</returns>
object OnTakeCurrencyItem(VendingMachine vendingMachine, Item item)
{
    Puts("OnTakeCurrencyItem hook called!");
    // Add custom logic here to handle taking currency items
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null && !takenCurrencyItem.MoveToContainer(base.inventory))
		{
			takenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);
		}
	}

```

## OnXmasGiftsDistribute(XMasRefill,BasePlayer)

```csharp
/// <summary>
/// Called when Christmas gifts are being distributed to a player.
/// </summary>
/// <param name="refill">The XMasRefill object.</param>
/// <param name="player">The BasePlayer receiving the gifts.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnXmasGiftsDistribute(XMasRefill refill, BasePlayer player)
{
    Puts("OnXmasGiftsDistribute hook called!");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	public bool DistributeGiftsForPlayer(BasePlayer player)
	{
		if (Interface.CallHook("OnXmasGiftsDistribute", this, player) != null)
		{
			return false;
		}
		int num = GiftsPerPlayer();
		int num2 = GiftSpawnAttempts();
		for (int i = 0; i < num2; i++)
		{
			if (num <= 0)
			{
				break;
			}
			Vector2 vector = UnityEngine.Random.insideUnitCircle * GiftRadius();
			Vector3 pos = player.transform.position + new Vector3(vector.x, 10f, vector.y);
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			if (DropToGround(ref pos))
			{
				string resourcePath = giftPrefabs[UnityEngine.Random.Range(0, giftPrefabs.Length)].resourcePath;
				BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);
				if ((bool)baseEntity)
				{
					baseEntity.Spawn();
					num--;
				}
			}
		}
		return true;
	}

```

## OnFuelItemCheck(EntityFuelSystem,StorageContainer)

```csharp
/// <summary>
/// Called when checking the fuel item in a storage container.
/// </summary>
/// <param name="entity">The entity's fuel system.</param>
/// <param name="container">The storage container being checked.</param>
/// <returns>Returns an Item if the default behavior is overridden, otherwise returns null or the first slot of the container inventory.</returns>
object OnFuelItemCheck(EntityFuelSystem entity, StorageContainer container)
{
    Puts("OnFuelItemCheck is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public Item GetFuelItem()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("OnFuelItemCheck", this, fuelContainer);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (fuelContainer == null)
		{
			return null;
		}
		return fuelContainer.inventory.GetSlot(0);
	}

```

## OnItemRefill(Item,BasePlayer)

```csharp
/// <summary>
/// Called when an item is refilled.
/// </summary>
/// <param name="item">The item being refilled.</param>
/// <param name="player">The player performing the refill action.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnItemRefill(Item item, BasePlayer player)
{
    Puts("OnItemRefill hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", item, player) == null)
		{
			float conditionNormalized = item.conditionNormalized;
			float maxConditionNormalized = item.maxConditionNormalized;
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
			Facepunch.Rust.Analytics.Azure.OnItemRepaired(player, player.GetCachedCraftLevelWorkbench(), item, conditionNormalized, maxConditionNormalized);
		}
	}

```

## OnRackedWeaponUnloaded(Item,BasePlayer,WeaponRack)

```csharp
/// <summary>
/// Called when a weapon is unloaded from a rack.
/// </summary>
/// <param name="item">The item being unloaded.</param>
/// <param name="player">The player who unloaded the weapon.</param>
/// <param name="weaponRack">The weapon rack where the weapon was loaded.</param>
/// <returns>No return behavior.</returns>
void OnRackedWeaponUnloaded(Item item, BasePlayer player, WeaponRack weaponRack)
{
    Puts($"Weapon {item.ShortPrefabName} unloaded from rack by player {player.UserIDString}");
}
```

### Source Code from the Library

```csharp

	private void UnloadWeapon(BasePlayer player, int mountSlotIndex)
	{
		if (player == null)
		{
			return;
		}
		WeaponRackSlot weaponAtIndex = GetWeaponAtIndex(mountSlotIndex);
		if (weaponAtIndex == null || !weaponAtIndex.CanBeReloadedAtWeaponRack())
		{
			return;
		}
		Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);
		if (slot == null || Interface.CallHook("OnRackedWeaponUnload", slot, player, this) != null)
		{
			return;
		}
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity == null))
		{
			BaseProjectile component = heldEntity.GetComponent<BaseProjectile>();
			if (!(component == null))
			{
				ItemDefinition ammoType = component.primaryMagazine.ammoType;
				component.UnloadAmmo(slot, player);
				SetSlotAmmoDetails(weaponAtIndex, slot);
				SendNetworkUpdateImmediate();
				ClientRPC(RpcTarget.Player("PlayAmmoSound", player), ammoType.itemid, 1);
				Interface.CallHook("OnRackedWeaponUnloaded", slot, player, this);
			}
		}
	}

```

## OnMlrsTarget(MLRS,UnityEngine.Vector3,BasePlayer)

```csharp
/// <summary>
/// Called when a MLRS target is hit.
/// </summary>
/// <param name="user">The user who fired the MLRS.</param>
/// <param name="worldPos">The position of the target in world space.</param>
/// <param name="mounted">Whether the MLRS was mounted or not.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnMlrsTarget(BasePlayer user, Vector3 worldPos, bool mounted)
{
    Puts("OnMlrsTarget is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 vector = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", this, worldPos, _mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Vector3 center = allSafeZone.triggerCollider.bounds.center;
				center.y = 0f;
				float num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 vector2 = trueTargetHitPos - center;
					trueTargetHitPos = center + vector2.normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", this, trueTargetHitPos, _mounted);
	}

```

## OnHelicopterOutOfCrates(CH47HelicopterAIController)

```csharp
/// <summary>
/// Called when a helicopter's crates are depleted.
/// </summary>
/// <param name="helicopterController">The AI controller of the helicopter.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
bool OnHelicopterOutOfCrates(CH47HelicopterAIController helicopterController)
{
    Puts("OnHelicopterOutOfCrates called!");
    return false;
}
```

### Source Code from the Library

```csharp

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

```

## OnNpcAlert(ScientistNPC)

```csharp
/// <summary>
/// Called when an NPC alerts the player.
/// </summary>
/// <param name="npc">The NPC that alerted the player.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnNpcAlert(ScientistNPC npc)
{
    Puts("OnNpcAlert is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void Alert()
	{
		if (Interface.CallHook("OnNpcAlert", this) == null)
		{
			lastAlertedTime = Time.time;
			SetChatterType(RadioChatterType.Alert);
		}
	}

```

## OnCupboardClearList(BuildingPrivlidge,BasePlayer)

```csharp
/// <summary>
/// Called when the cupboard clear list functionality is invoked.
/// </summary>
/// <param name="privilege">The building privilege.</param>
/// <param name="player">The player performing the action.</param>
/// <returns>No return behavior.</returns>
void OnCupboardClearList(BuildingPrivlidge privilege, BasePlayer player)
{
    Puts("OnCupboardClearList is working!");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ClearList(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player) && Interface.CallHook("OnCupboardClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnInterferenceUpdate(AutoTurret)

```csharp
/// <summary>
/// Called when the interference status of an AutoTurret is updated.
/// </summary>
/// <param name="turret">The AutoTurret whose interference status has been updated.</param>
/// <returns>No return behavior.</returns>
void OnInterferenceUpdate(AutoTurret turret)
{
    Puts($"AutoTurret {turret.name} interference update!");
}
```

### Source Code from the Library

```csharp

	public void UpdateInterference()
	{
		if (!IsOn() || Interface.CallHook("OnInterferenceUpdate", this) != null)
		{
			return;
		}
		float num = 0f;
		foreach (AutoTurret nearbyTurret in nearbyTurrets)
		{
			if (!nearbyTurret.isClient && nearbyTurret.IsValid() && nearbyTurret.gameObject.activeSelf && !nearbyTurret.EqualNetID(net.ID) && nearbyTurret.IsOn() && !nearbyTurret.HasInterference())
			{
				num += 1f;
			}
		}
		SetFlag(Flags.OnFire, num >= (float)Sentry.maxinterference);
	}

```

## OnIngredientsCollect(ItemCrafter,ItemBlueprint,ItemCraftTask,int,BasePlayer)

```csharp
/// <summary>
/// Called when ingredients are collected for crafting.
/// </summary>
/// <param name="craftTask">The craft task being performed.</param>
/// <param name="blueprint">The item blueprint being crafted.</param>
/// <param name="amount">The amount of ingredients to collect.</param>
/// <param name="player">The player collecting the ingredients.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnIngredientsCollect(ItemCrafter craftTask, ItemBlueprint blueprint, ItemCraftTask task, int amount, BasePlayer player)
{
    Puts("OnIngredientsCollect is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null)
	{
		if (Interface.CallHook("OnIngredientsCollect", this, bp, task, amount, player) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			CollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list);
		}
		foreach (Item item in list)
		{
			item.CollectedForCrafting(player);
		}
		task.takenItems = list;
	}

```

## OnEngineStatsRefresh(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
/// <summary>
/// Called when the engine performance stats are refreshed.
/// </summary>
/// <param name="engine">The vehicle module engine.</param>
/// <param name="storage">The engine storage data.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEngineStatsRefresh(VehicleModuleEngine engine, Rust.Modular.EngineStorage storage)
{
    Puts("OnEngineStatsRefresh called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## CanSwapToSeat(BasePlayer,ModularCarSeat)

```csharp
/// <summary>
/// Called when a player attempts to swap seats in a vehicle.
/// </summary>
/// <param name="player">The player attempting to swap seats.</param>
/// <param name="seat">The seat being swapped with.</param>
/// <returns>Returns true if the default behavior is allowed, and false otherwise.</returns>
bool CanSwapToSeat(BasePlayer player, ModularCarSeat seat)
{
    Puts("CanSwapToSeat is working!");
    return true;
}
```

### Source Code from the Library

```csharp

	public override bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (associatedSeatingModule.DoorsAreLockable)
		{
			ModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;
			if (modularCar != null)
			{
				return modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
			}
		}
		return true;
	}

```

## OnHuntEventStart(EggHuntEvent)

```csharp
/// <summary>
/// Called when the hunt event starts.
/// </summary>
/// <param name="event">The EggHuntEvent instance.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnHuntEventStart(EggHuntEvent event)
{
    Puts("OnHuntEventStart hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	private void StartEvent()
	{
		if (Interface.CallHook("OnHuntEventStart", this) == null)
		{
			if (initialSpawnIndex <= BasePlayer.activePlayerList.Count)
			{
				eggSpawningFrameBudget = float.PositiveInfinity;
			}
			EnableEggs();
		}
	}

```

## OnVehicleModuleSelected(Item,ModularCarGarage,BasePlayer)

```csharp
/// <summary>
/// Called when a vehicle module is selected.
/// </summary>
/// <param name="item">The item being selected.</param>
/// <param name="garage">The modular car garage.</param>
/// <param name="player">The player selecting the module.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnVehicleModuleSelected(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts("OnVehicleModuleSelected is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!ObjectEx.IsUnityNull(container))
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!ObjectEx.IsUnityNull(container2))
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## OnPlayerReported(BasePlayer,string,string,string,string,string)

```csharp
/// <summary>
/// Called when a player reports another player.
/// </summary>
/// <param name="reporter">The player who made the report.</param>
/// <param name="targetId">The ID of the player being reported.</param>
/// <param name="targetName">The name of the player being reported.</param>
/// <param name="subject">The subject of the report (e.g. "cheating").</param>
/// <param name="message">A detailed message about the report.</param>
/// <param name="type">The type of report (e.g. "player", "server", etc.).</param>
/// <returns>No return behavior.</returns>
void OnPlayerReported(BasePlayer reporter, string targetId, string targetName, string subject, string message, string type)
{
    Puts($"Player {reporter.displayName} reported player {targetName} for {subject}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnPlayerReported(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		string text3 = msg.read.String();
		string text4 = msg.read.String();
		string text5 = msg.read.String();
		DebugEx.Log($"[PlayerReport] {this} reported {text5}[{text4}] - \"{text}\"");
		RCon.Broadcast(RCon.LogType.Report, new
		{
			PlayerId = UserIDString,
			PlayerName = displayName,
			TargetId = text4,
			TargetName = text5,
			Subject = text,
			Message = text2,
			Type = text3
		});
		Interface.CallHook("OnPlayerReported", this, text5, text4, text, text2, text3);
	}

```

## OnPhotoCapture(PhotoEntity,Item,BasePlayer,byte[])

```csharp
/// <summary>
/// Called when a photo is captured.
/// </summary>
/// <param name="photoEntity">The entity that the photo was taken of.</param>
/// <param name="item">The item used to take the photo.</param>
/// <param name="player">The player who took the photo.</param>
/// <param name="imageData">The image data of the captured photo.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPhotoCapture(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] imageData)
{
    Puts("OnPhotoCapture called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(3uL)]
	private void TakePhoto(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Item item = GetItem();
		if (player == null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError("Failed to create photo item");
			return;
		}
		if (!item2.instanceData.subEntity.IsValid)
		{
			item2.Remove();
			Debug.LogError("Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if (baseNetworkable == null)
		{
			item2.Remove();
			Debug.LogError("Sub-entity was not found");
			return;
		}
		if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError("Sub-entity is not a photo");
			return;
		}
		photoEntity.SetImageData(player.userID, array);
		if (Interface.CallHook("OnPhotoCapture", photoEntity, item, player, array) != null)
		{
			return;
		}
		if (!player.inventory.GiveItem(item2))
		{
			item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
		}
		EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));
		if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
		{
			Vector3 position = GetOwnerPlayer().eyes.position;
			Vector3 vector = GetOwnerPlayer().eyes.HeadForward();
			List<BasePlayer> obj = Facepunch.Pool.GetList<BasePlayer>();
			Vis.Entities(position + vector * 5f, 5f, obj, 131072);
			foreach (BasePlayer item3 in obj)
			{
				if (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
				{
					hasSentAchievement = true;
					GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
					break;
				}
			}
			Facepunch.Pool.FreeList(ref obj);
		}
		item.LoseCondition(1f);
		Interface.CallHook("OnPhotoCaptured", photoEntity, item, player, array);
	}

```

## CanExplosiveStick(TimedExplosive,BaseEntity)

```csharp
/// <summary>
/// Called when attempting to stick an explosive device to a base entity.
/// </summary>
/// <param name="explosive">The explosive device being attached.</param>
/// <param name="entity">The base entity the explosive is being attached to.</param>
/// <returns>Returns true if the attachment is allowed, false otherwise.</returns>
bool CanExplosiveStick(TimedExplosive explosive, BaseEntity entity)
{
    Puts("CanExplosiveStick called!");
    return true; // Default behavior allows attachment
}
```

### Source Code from the Library

```csharp

	public virtual bool CanStickTo(BaseEntity entity)
	{
		object obj = Interface.CallHook("CanExplosiveStick", this, entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (entity.TryGetComponent<DecorDeployable>(out var _))
		{
			return false;
		}
		if (entity is Drone)
		{
			return false;
		}
		if (entity is TravellingVendor)
		{
			return false;
		}
		return true;
	}

```

## OnVehicleLockableCheck(ModularCarCodeLock)

```csharp
/// <summary>
/// Called to check if a vehicle is lockable.
/// </summary>
/// <param name="vehicle">The vehicle being checked.</param>
/// <returns>Returns true if the vehicle is lockable, and false otherwise.</returns>
bool OnVehicleLockableCheck(ModularCarCodeLock vehicle)
{
    Puts("OnVehicleLockableCheck called!");
    return true; // Return value based on the usage in CanHaveALock method
}
```

### Source Code from the Library

```csharp

	public bool CanHaveALock()
	{
		object obj = Interface.CallHook("OnVehicleLockableCheck", this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		if (!owner.IsDead())
		{
			return owner.HasDriverMountPoints();
		}
		return false;
	}

```

## CanAdministerVending(BasePlayer,VendingMachine)

```csharp
/// <summary>
/// Called to determine if a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <returns>Returns true if the player can administer the vending machine, and false otherwise.</returns>
bool CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts("CanAdministerVending is working!");
    return true; // Replace with actual logic to determine if player can administer vending machine
}
```

### Source Code from the Library

```csharp

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

```

## OnItemResearched(ResearchTable,int)

```csharp
/// <summary>
/// Called when an item is researched.
/// </summary>
/// <param name="table">The research table used for the research.</param>
/// <param name="amount">The amount of resources required to complete the research.</param>
/// <returns>Returns the actual amount of resources used, or null if the default behavior is overridden.</returns>
object OnItemResearched(ResearchTable table, int amount)
{
    Puts("OnItemResearched hook called!");
    // If the return value is not null, it means the default behavior was overridden
    return null;
}
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", this, num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount == num)
				{
					base.inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				base.inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
				item.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);
				if (!item.MoveToContainer(base.inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## OnPhotoCaptured(PhotoEntity,Item,BasePlayer,byte[])

```csharp
/// <summary>
/// Called when a photo is captured.
/// </summary>
/// <param name="photoEntity">The entity that the photo was taken of.</param>
/// <param name="item">The item used to take the photo.</param>
/// <param name="player">The player who took the photo.</param>
/// <param name="imageData">The image data of the captured photo.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPhotoCaptured(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] imageData)
{
    Puts("OnPhotoCaptured is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(3uL)]
	private void TakePhoto(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Item item = GetItem();
		if (player == null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError("Failed to create photo item");
			return;
		}
		if (!item2.instanceData.subEntity.IsValid)
		{
			item2.Remove();
			Debug.LogError("Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if (baseNetworkable == null)
		{
			item2.Remove();
			Debug.LogError("Sub-entity was not found");
			return;
		}
		if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError("Sub-entity is not a photo");
			return;
		}
		photoEntity.SetImageData(player.userID, array);
		if (Interface.CallHook("OnPhotoCapture", photoEntity, item, player, array) != null)
		{
			return;
		}
		if (!player.inventory.GiveItem(item2))
		{
			item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
		}
		EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));
		if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
		{
			Vector3 position = GetOwnerPlayer().eyes.position;
			Vector3 vector = GetOwnerPlayer().eyes.HeadForward();
			List<BasePlayer> obj = Facepunch.Pool.GetList<BasePlayer>();
			Vis.Entities(position + vector * 5f, 5f, obj, 131072);
			foreach (BasePlayer item3 in obj)
			{
				if (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
				{
					hasSentAchievement = true;
					GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
					break;
				}
			}
			Facepunch.Pool.FreeList(ref obj);
		}
		item.LoseCondition(1f);
		Interface.CallHook("OnPhotoCaptured", photoEntity, item, player, array);
	}

```

## OnRemoveDying(GrowableEntity,BasePlayer)

```csharp
/// <summary>
/// Called when a growing entity is removed due to being dying.
/// </summary>
/// <param name="entity">The growing entity being removed.</param>
/// <param name="player">The player who initiated the removal, or null if no player was involved.</param>
/// <returns>No return behavior.</returns>
void OnRemoveDying(GrowableEntity entity, BasePlayer player)
{
    Puts($"Growable entity {entity} removed due to being dying.");
}
```

### Source Code from the Library

```csharp

	public void RemoveDying(BasePlayer receiver)
	{
		if (State == PlantProperties.State.Dying && !(Properties.removeDyingItem == null) && Interface.CallHook("OnRemoveDying", this, receiver) == null)
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, Vector3.up);
			}
			Item item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);
			if (receiver != null)
			{
				receiver.GiveItem(item, GiveItemReason.PickedUp);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
			}
			Die();
		}
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Called when a player attacks an entity.
/// </summary>
/// <param name="player">The player performing the attack.</param>
/// <param name="info">Information about the attack, including the hit info and any effects.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerAttack(BasePlayer player, HitInfo info)
{
    Puts("OnPlayerAttack hook called!");
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", GetOwnerPlayer(), info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (info.DoHitEffects)
		{
			if (base.isServer)
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.server.ImpactEffect(info);
				}
			}
			else
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.client.ImpactEffect(info);
				}
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay);
		}
	}

```

## OnMlrsFired(MLRS,BasePlayer)

```csharp
/// <summary>
/// Called when the MLRS is fired.
/// </summary>
/// <param name="mlrs">The MLRS instance.</param>
/// <param name="owner">The player who fired the MLRS.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFired(MLRS mlrs, BasePlayer owner)
{
    Puts("OnMlrsFired is working!");
}
```

### Source Code from the Library

```csharp

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !(_mounted == null) && Interface.CallHook("OnMlrsFire", this, owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			InvokeRepeating(FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", this, owner);
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the entity.</param>
/// <param name="entity">The locked entity being used.</param>
/// <returns>Returns true if the player can use the entity, false otherwise.</returns>
bool CanUseLockedEntity(BasePlayer player, CodeLock entity)
{
    Puts("CanUseLockedEntity is working!");
    return true; // Default behavior
}
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
/// <summary>
/// Called when a player's looting session ends.
/// </summary>
/// <param name="loot">The PlayerLoot object representing the ended looting session.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot loot)
{
    Puts("OnPlayerLootEnd is working!");
}
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		containers.Clear();
		entitySource = null;
		itemSource = null;
	}

```

## CanBeHomingTargeted(AttackHeliPilotFlare)

```csharp
/// <summary>
/// Called to determine if the current entity can be targeted by a homing attack.
/// </summary>
/// <returns>Returns <c>true</c> if the entity can be targeted, and <c>false</c> otherwise.</returns>
bool CanBeHomingTargeted(AttackHeliPilotFlare flare)
{
    Puts("CanBeHomingTargeted is working!");
    return true;
}
```

### Source Code from the Library

```csharp

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnRemoteIdentifierUpdate(PoweredRemoteControlEntity,string)

```csharp
/// <summary>
/// Called when a remote control entity's identifier is updated.
/// </summary>
/// <param name="entity">The remote control entity whose identifier was updated.</param>
/// <param name="newID">The new identifier assigned to the remote control entity.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnRemoteIdentifierUpdate(PoweredRemoteControlEntity entity, string newID)
{
    Puts($"Identifier of {entity} updated to {newID}");
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		if (Interface.CallHook("OnRemoteIdentifierUpdate", this, newID) != null)
		{
			return;
		}
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!RemoteControlEntity.IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			if (!Rust.Application.isLoadingSave)
			{
				SendNetworkUpdate();
			}
		}
	}

```

## OnEntitySnapshot(BaseNetworkable,Network.Connection)

```csharp
/// <summary>
/// Called when an entity's snapshot is sent over the network.
/// </summary>
/// <param name="entity">The entity whose snapshot is being sent.</param>
/// <param name="connection">The network connection to which the snapshot is being sent.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntitySnapshot(BaseNetworkable entity, Network.Connection connection)
{
    Puts("OnEntitySnapshot called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void SendEntitySnapshot(BaseNetworkable ent)
	{
		if (Interface.CallHook("OnEntitySnapshot", ent, net.connection) != null)
		{
			return;
		}
		using (TimeWarning.New("SendEntitySnapshot"))
		{
			if (!(ent == null) && ent.net != null && ent.ShouldNetworkTo(this))
			{
				NetWrite netWrite = Network.Net.sv.StartWrite();
				net.connection.validate.entityUpdates++;
				SaveInfo saveInfo = default(SaveInfo);
				saveInfo.forConnection = net.connection;
				saveInfo.forDisk = false;
				SaveInfo saveInfo2 = saveInfo;
				netWrite.PacketID(Message.Type.Entities);
				netWrite.UInt32(net.connection.validate.entityUpdates);
				ent.ToStreamForNetwork(netWrite, saveInfo2);
				netWrite.Send(new SendInfo(net.connection));
			}
		}
	}

```

## OnTurretIdentifierSet(AutoTurret,BasePlayer,string)

```csharp
/// <summary>
/// Called when a turret's identifier is set.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <param name="player">The player who initiated the change.</param>
/// <param name="newIdentifier">The new identifier to be set.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnTurretIdentifierSet(AutoTurret turret, BasePlayer player, string newIdentifier)
{
    // Minimal code to demonstrate functionality
    Puts($"Identifier changed for turret {turret} by player {player}");
    
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_SetID(RPCMessage msg)
	{
		if (msg.player == null || !CanChangeID(msg.player))
		{
			return;
		}
		string text = msg.read.String();
		if (string.IsNullOrEmpty(text) || ComputerStation.IsValidIdentifier(text))
		{
			string text2 = msg.read.String();
			if (ComputerStation.IsValidIdentifier(text2) && text == GetIdentifier() && Interface.CallHook("OnTurretIdentifierSet", this, msg.player, text2) == null)
			{
				Debug.Log("SetID success!");
				UpdateIdentifier(text2);
			}
		}
	}

```

## OnPlayerKeepAlive(BasePlayer,BasePlayer)

```csharp
/// <summary>
/// Called when a player's keep alive is triggered.
/// </summary>
/// <param name="attacker">The player who triggered the keep alive.</param>
/// <param name="victim">The player being kept alive.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerKeepAlive(BasePlayer attacker, BasePlayer victim)
{
    Puts("OnPlayerKeepAlive is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_KeepAlive(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerKeepAlive", this, msg.player) == null)
		{
			ProlongWounding(10f);
		}
	}

```

## OnCargoPlaneSignaled(BaseEntity,SupplySignal)

```csharp
/// <summary>
/// Called when a cargo plane is signaled.
/// </summary>
/// <param name="entity">The entity that triggered the signal.</param>
/// <param name="signal">The type of signal sent by the entity.</param>
object OnCargoPlaneSignaled(BaseEntity entity, SupplySignal signal)
{
    Puts("OnCargoPlaneSignaled is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		BaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);
		if ((bool)baseEntity)
		{
			Vector3 vector = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));
			baseEntity.SendMessage("InitDropPosition", base.transform.position + vector, SendMessageOptions.DontRequireReceiver);
			baseEntity.Spawn();
			Interface.CallHook("OnCargoPlaneSignaled", baseEntity, this);
		}
		Invoke(FinishUp, 210f);
		SetFlag(Flags.On, b: true);
		SendNetworkUpdateImmediate();
	}

```

## OnBigWheelWin(BigWheelGame,Item,BigWheelBettingTerminal,int)

```csharp
/// <summary>
/// Called when a player wins on the Big Wheel.
/// </summary>
/// <param name="game">The current Big Wheel game.</param>
/// <param name="item">The item that was won.</param>
/// <param name="terminal">The betting terminal where the win occurred.</param>
/// <param name="amount">The amount of money won.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnBigWheelWin(BigWheelGame game, Item item, BigWheelBettingTerminal terminal, int amount)
{
    Puts("OnBigWheelWin called!");
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) == null)
				{
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(RpcTarget.NetworkGroup("WinOrLoseSound"), flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanEntityBeHostile(BasePlayer)

```csharp
/// <summary>
/// Called to determine if an entity can be hostile.
/// </summary>
/// <param name="entity">The entity in question.</param>
/// <returns>Returns a boolean value indicating whether the entity can be hostile.</returns>
bool CanEntityBeHostile(BasePlayer entity)
{
    Puts("CanEntityBeHostile is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public override bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return State.unHostileTimestamp > TimeEx.currentTimestamp;
	}

```

## OnSamSiteModeToggle(SamSite,BasePlayer,bool)

```csharp
/// <summary>
/// Called when the defender mode of a Sam Site is toggled.
/// </summary>
/// <param name="samSite">The Sam Site whose defender mode is being toggled.</param>
/// <param name="player">The player who triggered the toggle.</param>
/// <param name="enabled">Whether to enable or disable the defender mode.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnSamSiteModeToggle(SamSite samSite, BasePlayer player, bool enabled)
{
    Puts("OnSamSiteModeToggle called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ToggleDefenderMode(RPCMessage msg)
	{
		if (staticRespawn)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!(player == null) && player.CanBuild())
		{
			bool flag = msg.read.Bit();
			if (flag != IsInDefenderMode() && Interface.CallHook("OnSamSiteModeToggle", this, player, flag) == null)
			{
				SetFlag(Flag_ManuallySetMode, flag);
				SetFlag(Flag_TargetMode, flag);
			}
		}
	}

```

## OnHelicopterAttack(CH47HelicopterAIController,HitInfo)

```csharp
/// <summary>
/// Called when a helicopter attacks the entity.
/// </summary>
/// <param name="helicopter">The helicopter AI controller that attacked.</param>
/// <param name="info">Information about the attack.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnHelicopterAttack(CH47HelicopterAIController helicopter, HitInfo info)
{
    Puts("OnHelicopterAttack is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttack", this, info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved9, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

```

## OnSleepingBagDestroyed(SleepingBag,ulong)

```csharp
/// <summary>
/// Called when a player's sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The destroyed sleeping bag.</param>
/// <param name="userID">The ID of the player who owned the sleeping bag.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnSleepingBagDestroyed(SleepingBag sleepingBag, ulong userID)
{
    Puts("OnSleepingBagDestroyed hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(ulong userID, NetworkableId sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(userID, ignoreTimers: true).FirstOrDefault((SleepingBag x) => x.net.ID == sleepingBag);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, userID) != null)
		{
			return false;
		}
		RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);
		sleepingBag2.deployerUserID = 0uL;
		sleepingBag2.SendNetworkUpdate();
		BasePlayer basePlayer = BasePlayer.FindByID(userID);
		if (basePlayer != null)
		{
			basePlayer.SendRespawnOptions();
			Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, userID);
			Facepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);
		}
		return true;
	}

```

## CanAdministerVending(BasePlayer,NPCVendingMachine)

```csharp
/// <summary>
/// Called to determine if a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <returns>Returns true if the player can administer the vending machine, and false otherwise.</returns>
bool CanAdministerVending(BasePlayer player, NPCVendingMachine vendingMachine)
{
    Puts("CanAdministerVending is working!");
    return true; // Replace with actual logic to determine if the player can administer the vending machine
}
```

### Source Code from the Library

```csharp

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
/// <summary>
/// Called when a helicopter turret sets its target.
/// </summary>
/// <param name="turret">The helicopter turret setting the target.</param>
/// <param name="target">The entity being targeted by the turret.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts("OnHelicopterTarget hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## OnFishCaught(ItemDefinition,BaseFishingRod,BasePlayer)

```csharp
Документация для OnFishCaught(ItemDefinition, BaseFishingRod, BasePlayer)

**Описание**

Этот хук вызывается при улове рыбы. Он позволяет модулю изменить поведение игрока и предметов в зависимости от типа пойманной рыбы.

**Параметры**

* `ItemDefinition`: Объект класса ItemDefinition, представляющий тип пойманной рыбы.
* `BaseFishingRod`: Объект класса BaseFishingRod, представляющий рыболовную удочку.
* `BasePlayer`: Объект класса BasePlayer, представляющий игрока.

**Возвращаемые значения**

Нет возвращаемых значений.

**Примечания**

Этот хук вызывается после того, как рыба была поймана и перед тем, как она будет добавлена в инвентарь игрока. Модуль может изменить поведение игрока или предметов в зависимости от типа пойманной рыбы.

**Использование**

Чтобы использовать этот хук, необходимо вызвать его метод `OnFishCaught` с тремя параметрами: `ItemDefinition`, `BaseFishingRod` и `BasePlayer`. Например:
```csharp
public class MyMod : MonoBehaviour
{
    public void OnEnable()
    {
        Interface.CallHook("OnFishCaught", this);
    }

    public void OnFishCaught(ItemDefinition item, BaseFishingRod rod, BasePlayer player)
    {
        // Код модуля, который будет выполняться при улове рыбы
    }
}
```
**Примеры**

* Если модуль хочет изменить поведение игрока при улове определенного типа рыбы, он может использовать следующий код:
```csharp
public void OnFishCaught(ItemDefinition item, BaseFishingRod rod, BasePlayer player)
{
    if (item.itemid == "fish.golden")
    {
        // Код модуля, который будет выполняться при улове золотой рыбы
    }
}
```
* Если модуль хочет добавить новый предмет в инвентарь игрока при улове определенного типа рыбы, он может использовать следующий код:
```csharp
public void OnFishCaught(ItemDefinition item, BaseFishingRod rod, BasePlayer player)
{
    if (item.itemid == "fish.golden")
    {
        // Код модуля, который будет выполняться при улове золотой рыбы
        Item newItem = ItemManager.Create("new_item", 1, 0uL);
        player.GiveItem(newItem, GiveItemReason.Crafted);
    }
}
```
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else if (num2 <= FishCatchDistance || ForceSuccess)
		{
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
		}
		else
		{
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
/// <summary>
/// Called to determine if a world projectile can be created.
/// </summary>
/// <param name="info">The hit information.</param>
/// <param name="itemDef">The item definition.</param>
/// <returns>Returns true if the projectile can be created, and false otherwise.</returns>
bool CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
{
    Puts("CanCreateWorldProjectile is working!");
    return true; // Replace with actual logic to determine if the projectile can be created
}
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			DroppedItem droppedItem = baseEntity as DroppedItem;
			if (droppedItem != null)
			{
				droppedItem.StickIn();
			}
			else
			{
				baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			}
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			Rigidbody component = baseEntity.GetComponent<Rigidbody>();
			component.AddForce(projectileVelocity.normalized * 200f);
			component.WakeUp();
		}
	}

```

## OnInventoryItemsCount(PlayerInventory,int)

```csharp
/// <summary>
/// Called when the count of inventory items is requested.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="itemid">The ID of the item to count.</param>
/// <returns>Returns the total amount of the specified item in the inventory, or null if the default behavior is overridden.</returns>
object OnInventoryItemsCount(PlayerInventory inventory, int itemid)
{
    Puts("OnInventoryItemsCount called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public int GetAmount(int itemid)
	{
		if (itemid == 0)
		{
			return 0;
		}
		object obj = Interface.CallHook("OnInventoryItemsCount", this, itemid);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerWear != null)
		{
			num += containerWear.GetAmount(itemid, onlyUsableAmounts: true);
		}
		return num;
	}

```

## OnMlrsRocketFired(MLRS,ServerProjectile)

```csharp
/// <summary>
/// Called when an MLRS rocket is fired.
/// </summary>
/// <param name="mlrs">The MLRS entity that fired the rocket.</param>
/// <param name="projectile">The server projectile representing the fired rocket.</param>
/// <returns>No return behavior.</returns>
void OnMlrsRocketFired(MLRS mlrs, ServerProjectile projectile)
{
    Puts("OnMlrsRocketFired is working!");
}
```

### Source Code from the Library

```csharp

	public void FireNextRocket()
	{
		RocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount(AmmoTypes.MLRS_ROCKET);
		if (nextRocketIndex < 0 || nextRocketIndex >= RocketAmmoCount || IsBroken())
		{
			EndFiring();
			return;
		}
		StorageContainer rocketContainer = GetRocketContainer();
		Vector3 firingPos = firingPoint.position + firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;
		float num = 1f;
		if (radiusModIndex < radiusMods.Length)
		{
			num = radiusMods[radiusModIndex];
		}
		radiusModIndex++;
		Vector2 vector = UnityEngine.Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;
		Vector3 target = TrueHitPos + new Vector3(vector.x, 0f, vector.y);
		float requiredGravity;
		Vector3 aimToTarget = Ballistics.GetAimToTarget(firingPoint.position, target, rocketSpeed, vRotMax, rocketBaseGravity, minRange, out requiredGravity);
		if (TryFireProjectile(rocketContainer, AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))
		{
			projectile.gravityModifier = requiredGravity / (0f - UnityEngine.Physics.gravity.y);
			Interface.CallHook("OnMlrsRocketFired", this, projectile);
			nextRocketIndex--;
		}
		else
		{
			EndFiring();
		}
	}

```

## OnBackpackDrop(Item,PlayerInventory)

```csharp
/// <summary>
/// Called when a player attempts to drop their backpack.
/// </summary>
/// <param name="item">The dropped item.</param>
/// <param name="inventory">The player's inventory.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnBackpackDrop(Item item, PlayerInventory inventory)
{
    Puts("OnBackpackDrop hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void TryDropBackpack()
	{
		Item anyBackpack = GetAnyBackpack();
		if (anyBackpack != null && base.baseEntity.isServer && Interface.CallHook("OnBackpackDrop", anyBackpack, this) == null)
		{
			anyBackpack.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
		}
	}

```

## CanDemolish(BasePlayer,StabilityEntity)

```csharp
/// <summary>
/// Called when a player attempts to demolish an entity.
/// </summary>
/// <param name="player">The player attempting to demolish the entity.</param>
/// <param name="entity">The entity being demolished.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
object CanDemolish(BasePlayer player, StabilityEntity entity)
{
    Puts("CanDemolish is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CanBeDemolished && IsDemolishable())
		{
			return HasDemolishPrivilege(player);
		}
		return false;
	}

```

## OnEntityVisibilityCheck(BaseEntity,BasePlayer,uint,string,float)

```csharp
/// <summary>
/// Called when the visibility of an entity is checked.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <param name="player">The player performing the check.</param>
/// <param name="id">A unique identifier for the check.</param>
/// <param name="debugName">A debug-friendly name for the check.</param>
/// <param name="maximumDistance">The maximum distance to consider when checking visibility.</param>
/// <returns>Returns a boolean value indicating whether the entity is visible or not.</returns>
bool OnEntityVisibilityCheck(BaseEntity entity, BasePlayer player, uint id, string debugName, float maximumDistance)
{
    // Minimal code to demonstrate functionality
    Puts($"OnEntityVisibilityCheck called for {debugName} with ID {id}");
    
    // Return the result of the visibility check
    return true; // Replace with actual logic based on entity and player positions
}
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityVisibilityCheck", ent, player, id, debugName, maximumDistance);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 1218519041))
				{
					if (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))
					{
						return ent.IsVisible(player.eyes.position, maximumDistance);
					}
					return true;
				}
				return false;
			}

```

## OnScientistRecalled(BradleyAPC,ScientistNPC)

```csharp
/// <summary>
/// Called when a Scientist NPC is recalled.
/// </summary>
/// <param name="apc">The Bradley APC that recalled the Scientist.</param>
/// <param name="scientist">The recalled Scientist NPC.</param>
/// <returns>No return behavior.</returns>
void OnScientistRecalled(BradleyAPC apc, ScientistNPC scientist)
{
    Puts($"Scientist {scientist.name} recalled by Bradley APC {apc.name}");
}
```

### Source Code from the Library

```csharp

	public void OnScientistMounted(ScientistNPC scientist)
	{
		if (!(scientist == null))
		{
			if (scientistPrefabLookUp.TryGetValue(scientist.prefabID, out var value))
			{
				mountedScientistPrefabs.Add(value);
			}
			activeScientists.Remove(scientist);
			numberOfScientistsToSpawn++;
			Interface.CallHook("OnScientistRecalled", this, scientist);
		}
	}

```

## CanUpdateSign(BasePlayer,CarvablePumpkin)

```csharp
/// <summary>
/// Called when a player attempts to update the sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="pumpkin">The Carvable Pumpkin being updated.</param>
/// <returns>Returns true if the player can update the sign, false otherwise.</returns>
bool CanUpdateSign(BasePlayer player, CarvablePumpkin pumpkin)
{
    Puts("CanUpdateSign is working!");
    return true;
}
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return (ulong)player.userID == base.OwnerID;
		}
		return true;
	}

```

## OnPlayerKicked(BasePlayer,string)

```csharp
/// <summary>
/// Called when a player is kicked from the game.
/// </summary>
/// <param name="player">The player who was kicked.</param>
/// <param name="reason">The reason for kicking the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason)
{
    Puts($"Player {player.Name} kicked with reason: {reason}");
}
```

### Source Code from the Library

```csharp

	public void Kick(string reason)
	{
		if (IsConnected)
		{
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason);
		}
	}

```

## OnExperimentStart(Workbench,BasePlayer)

```csharp
/// <summary>
/// Called when an experiment starts.
/// </summary>
/// <param name="workbench">The workbench where the experiment is being conducted.</param>
/// <param name="player">The player conducting the experiment.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnExperimentStart(Workbench workbench, BasePlayer player)
{
    Puts("OnExperimentStart called!");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## CanSetRelationship(BasePlayer,BasePlayer,RelationshipManager.RelationshipType,int)

```csharp
/// <summary>
/// Called when a player attempts to set their relationship with another player.
/// </summary>
/// <param name="player">The player attempting to set the relationship.</param>
/// <param name="otherPlayer">The other player involved in the relationship.</param>
/// <param name="type">The type of relationship being set (e.g. Friend, Enemy, etc.).</param>
/// <param name="weight">The weight or importance of the relationship being set.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object CanSetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipManager.RelationshipType type, int weight)
{
    // Minimal code to demonstrate functionality
    Puts("CanSetRelationship is working!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight = 1, bool sendImmediate = false)
	{
		if (!contacts)
		{
			return;
		}
		ulong num = player.userID.Get();
		ulong num2 = otherPlayer.userID.Get();
		if (player == null || player == otherPlayer || player.IsNpc || (otherPlayer != null && otherPlayer.IsNpc) || Interface.CallHook("CanSetRelationship", player, otherPlayer, type, weight) != null)
		{
			return;
		}
		PlayerRelationships playerRelationships = GetRelationships(num);
		if (!CleanupOldContacts(playerRelationships, num))
		{
			CleanupOldContacts(playerRelationships, num, RelationshipType.Enemy);
		}
		PlayerRelationshipInfo relations = playerRelationships.GetRelations(num2);
		bool flag = false;
		if (relations.type != type)
		{
			flag = true;
			relations.weight = 0;
		}
		relations.type = type;
		relations.weight += weight;
		float num3 = UnityEngine.Time.realtimeSinceStartup - relations.lastMugshotTime;
		if (flag || relations.mugshotCrc == 0 || num3 >= mugshotUpdateInterval)
		{
			bool flag2 = otherPlayer.IsAlive();
			bool num4 = player.SecondsSinceAttacked > 10f && !player.IsAiming;
			float num5 = 100f;
			if (num4)
			{
				Vector3 normalized = (otherPlayer.eyes.position - player.eyes.position).normalized;
				bool flag3 = Vector3.Dot(player.eyes.HeadForward(), normalized) >= 0.6f;
				float num6 = Vector3Ex.Distance2D(player.transform.position, otherPlayer.transform.position);
				if (flag2 && num6 < num5 && flag3)
				{
					ClientRPC(RpcTarget.Player("CLIENT_DoMugshot", player), num2);
					relations.lastMugshotTime = UnityEngine.Time.realtimeSinceStartup;
				}
			}
		}
		if (sendImmediate)
		{
			SendRelationshipsFor(player);
		}
		else
		{
			MarkRelationshipsDirtyFor(player);
		}
	}

```

## OnPlayerSleepEnd(BasePlayer)

```csharp
/// <summary>
/// Called when a player's sleep ends.
/// </summary>
/// <param name="player">The player whose sleep has ended.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnd(BasePlayer player)
{
    Puts($"Player {player.UserIDString} woke up from sleep.");
}
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", this) == null)
		{
			if (IsRestrained)
			{
				inventory.SetLockedByRestraint(flag: true);
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if ((ulong)userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			CancelInvoke(ScheduledDeath);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
			}
			InvokeRandomized(UpdateClanLastSeen, 300f, 300f, 60f);
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				RemoveFromTriggers();
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", this);
			EACServer.LogPlayerSpawn(this);
			if (TotalPingCount > 0)
			{
				SendPingsToClient();
			}
			if (TutorialIsland.ShouldPlayerBeAskedToStartTutorial(this))
			{
				ClientRPC(RpcTarget.Player("PromptToStartTutorial", this));
			}
		}
	}

```

## OnMissionStart(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
/// <summary>
/// Called when a mission starts.
/// </summary>
/// <param name="mission">The mission instance.</param>
/// <param name="instance">The mission instance identifier.</param>
/// <param name="assignee">The player assigned to the mission.</param>
/// <returns>No return behavior.</returns>
void OnMissionStart(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts("OnMissionStart is working!");
}
```

### Source Code from the Library

```csharp

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", this, instance, assignee) != null)
		{
			return;
		}
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance, assignee);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.spawnOnMissionStart)
			{
				instance.GetMissionEntity(missionEntityEntry.identifier, assignee);
			}
		}
		if (AllowedTutorialItems != 0)
		{
			assignee.SetTutorialAllowance(AllowedTutorialItems);
		}
		Interface.CallHook("OnMissionStarted", this, instance, assignee);
	}

```

## CanBuild(Planner,Construction,Construction.Target)

```csharp
/// <summary>
/// Called when a player attempts to build something.
/// </summary>
/// <param name="planner">The planner object.</param>
/// <param name="construction">The construction object.</param>
/// <param name="target">The target object.</param>
/// <returns>null if the build is allowed, otherwise the result of the hook call.</returns>
public bool CanBuild(Planner planner, Construction construction, Construction.Target target)
{
    // Minimal code to demonstrate functionality
    return true; // or false depending on your logic
}
```

### Source Code from the Library

```csharp

	public void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ChatMessage("Couldn't find Construction " + msg.blockID);
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			ownerPlayer.ChatMessage("Can't afford to place!");
			using ItemAmountList itemAmountList = Facepunch.Pool.Get<ItemAmountList>();
			itemAmountList.amount = Facepunch.Pool.GetList<float>();
			itemAmountList.itemID = Facepunch.Pool.GetList<int>();
			GetConstructionCost(itemAmountList, construction);
			ownerPlayer.ClientRPC(RpcTarget.Player("Client_OnRepairFailedResources", ownerPlayer), itemAmountList);
			return;
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ChatMessage("Building is blocked!");
			return;
		}
		Deployable deployable = GetDeployable();
		if (construction.deployable != deployable)
		{
			ownerPlayer.ChatMessage("Deployable mismatch!");
			AntiHack.NoteAdminHack(ownerPlayer);
			return;
		}
		Construction.Target target = default(Construction.Target);
		if (msg.entity.IsValid)
		{
			target.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if (target.entity == null)
			{
				NetworkableId entity = msg.entity;
				ownerPlayer.ChatMessage("Couldn't find entity " + entity.ToString());
				return;
			}
			msg.ray = new Ray(target.entity.transform.TransformPoint(msg.ray.origin), target.entity.transform.TransformDirection(msg.ray.direction));
			msg.position = target.entity.transform.TransformPoint(msg.position);
			msg.normal = target.entity.transform.TransformDirection(msg.normal);
			msg.rotation = target.entity.transform.rotation * msg.rotation;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != "")
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				if (target.socket == null)
				{
					ownerPlayer.ChatMessage("Couldn't find socket " + msg.socket);
					return;
				}
			}
			else if (target.entity is Door)
			{
				ownerPlayer.ChatMessage("Can't deploy on door");
				return;
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.isHoldingShift = msg.isHoldingShift;
		target.valid = true;
		if (Interface.CallHook("CanBuild", this, construction, target) != null)
		{
			return;
		}
		if (ShouldParent(target.entity, deployable))
		{
			Vector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);
			float num = target.entity.Distance(position);
			if (num > 1f)
			{
				ownerPlayer.ChatMessage("Parent too far away: " + num);
				return;
			}
		}
		BaseEntity baseEntity = DoBuild(target, construction);
		if (baseEntity != null && ownerPlayer.IsInCreativeMode && Creative.freeBuild && baseEntity is BuildingBlock buildingBlock)
		{
			ConstructionGrade constructionGrade = construction.grades[msg.setToGrade];
			if (buildingBlock.currentGrade != constructionGrade)
			{
				buildingBlock.ChangeGradeAndSkin(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);
			}
		}
	}

```

## OnInventoryNetworkUpdate(PlayerInventory,ItemContainer,ProtoBuf.UpdateItemContainer,PlayerInventory.Type,PlayerInventory.NetworkInventoryMode)

```csharp
/// <summary>
/// Called when the inventory network is updated.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="container">The item container being updated.</param>
/// <param name="updateItemContainer">The update item container data.</param>
/// <param name="type">The type of the inventory.</param>
/// <param name="mode">The network inventory mode.</param>
/// <returns>No return behavior.</returns>
void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, PlayerInventory.NetworkInventoryMode mode)
{
    Puts($"Inventory network updated for player {inventory.playerId} with type {type} and mode {mode}");
}
```

### Source Code from the Library

```csharp

	public void SendUpdatedInventoryInternal(Type type, ItemContainer container, NetworkInventoryMode mode)
	{
		using UpdateItemContainer updateItemContainer = Facepunch.Pool.Get<UpdateItemContainer>();
		updateItemContainer.type = (int)type;
		if (container != null)
		{
			container.dirty = false;
			updateItemContainer.container = Facepunch.Pool.Get<List<ProtoBuf.ItemContainer>>();
			bool bIncludeContainer = type != Type.Wear || mode == NetworkInventoryMode.LocalPlayer;
			updateItemContainer.container.Add(container.Save(bIncludeContainer));
		}
		if (Interface.CallHook("OnInventoryNetworkUpdate", this, container, updateItemContainer, type, mode) != null)
		{
			return;
		}
		switch (mode)
		{
		case NetworkInventoryMode.Everyone:
			base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("UpdatedItemContainer"), updateItemContainer);
			break;
		case NetworkInventoryMode.LocalPlayer:
			base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", base.baseEntity), updateItemContainer);
			break;
		case NetworkInventoryMode.EveryoneButLocal:
			if (base.baseEntity.net?.group?.subscribers == null)
			{
				break;
			}
			{
				foreach (Connection subscriber in base.baseEntity.net.group.subscribers)
				{
					if (subscriber.player is BasePlayer basePlayer && basePlayer != base.baseEntity)
					{
						base.baseEntity.ClientRPC(RpcTarget.Player("UpdatedItemContainer", basePlayer), updateItemContainer);
					}
				}
				break;
			}
		}
	}

```

## OnTeamDisband(RelationshipManager.PlayerTeam)

```csharp
/// <summary>
/// Called when a player's team is disbanded.
/// </summary>
/// <param name="team">The team being disbanded.</param>
/// <returns>No return behavior.</returns>
void OnTeamDisband(RelationshipManager.PlayerTeam team)
{
    Puts($"Team {team.teamID} has been disbanded.");
}
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Facepunch.Pool.Free(ref teamToDisband);
		}
	}

```

## CanCheckFuel(EntityFuelSystem,StorageContainer,BasePlayer)

```csharp
/// <summary>
/// Called to check if a player can interact with the fuel system.
/// </summary>
/// <param name="fuelSystem">The fuel system entity.</param>
/// <param name="container">The storage container containing the fuel.</param>
/// <param name="player">The player attempting to interact with the fuel system.</param>
/// <returns>Returns true if the player can interact, false otherwise.</returns>
bool CanCheckFuel(EntityFuelSystem fuelSystem, StorageContainer container, BasePlayer player)
{
    Puts("CanCheckFuel is working!");
    return true; // Return value determined by Interface.CallHook
}
```

### Source Code from the Library

```csharp

	public bool IsInFuelInteractionRange(BasePlayer player)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanCheckFuel", this, fuelContainer, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (fuelContainer != null)
		{
			float num = 0f;
			if (isServer)
			{
				num = 3f;
			}
			return fuelContainer.Distance(player.eyes.position) <= num;
		}
		return false;
	}

```

## CanBeHomingTargeted(CH47Helicopter)

```csharp
/// <summary>
/// Called to determine if the CH47Helicopter can be targeted by homing missiles.
/// </summary>
/// <param name="helicopter">The helicopter being evaluated.</param>
/// <returns>Returns true if the helicopter can be targeted, and false otherwise.</returns>
bool CanBeHomingTargeted(CH47Helicopter helicopter)
{
    Puts("CanBeHomingTargeted is working!");
    return true; // Or another value depending on the method's functionality
}
```

### Source Code from the Library

```csharp

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnEntityDismounted(BaseMountable,BasePlayer)

```csharp
/// <summary>
/// Called when a player dismounts an entity.
/// </summary>
/// <param name="entity">The entity being dismounted.</param>
/// <param name="player">The player dismounting the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityDismounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.displayName} dismounted from entity: {entity.gameObject.name}");
}
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.transform.rotation = Quaternion.identity;
			_mounted.ClientRPC(RpcTarget.Player("ForcePositionTo", _mounted), res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			string[] obj = new string[6] { "Killing player due to invalid dismount point :", player.displayName, " / ", null, null, null };
			BasePlayer.EncryptedValue<ulong> userID = player.userID;
			obj[3] = userID.ToString();
			obj[4] = " on obj : ";
			obj[5] = base.gameObject.name;
			Debug.LogWarning(string.Concat(obj));
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
		}
		else
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.SendModelState(force: true);
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", player), baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), res);
			}
			Facepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnActiveItemChanged(BasePlayer,Item,Item)

```csharp
/// <summary>
/// Called when the active item is changed.
/// </summary>
/// <param name="player">The player whose active item has been changed.</param>
/// <param name="oldItem">The old active item.</param>
/// <param name="newItem">The new active item.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
{
    Puts("OnActiveItemChanged is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(ItemId itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnSendCommand(System.Collections.Generic.List<Network.Connection>,string,object[])

```csharp
/// <summary>
/// Called when a client command is sent to the server.
/// </summary>
/// <param name="connections">A list of connections that received the command.</param>
/// <param name="command">The command being sent.</param>
/// <param name="args">Arguments for the command.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object OnSendCommand(List<Network.Connection> connections, string command, object[] args)
{
    // Minimal code to demonstrate functionality
    Puts($"Received client command: {command} with arguments: [{string.Join(", ", args)}]");
    
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(List<Connection> cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnSendCommand", cn, strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			netWrite.String(ConsoleSystem.BuildCommand(strCommand, args));
			netWrite.Send(new SendInfo(cn));
		}
	}

```

## IOnServerShutdown()

```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
void IOnServerShutdown()
{
    Puts("Server shutdown hook called!");
}
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("IOnServerShutdown");
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## OnDecayHeal(DecayEntity)

```csharp
/// <summary>
/// Called when a decay entity's upkeep timer is about to expire.
/// </summary>
/// <param name="entity">The decay entity.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool OnDecayHeal(DecayEntity entity)
{
    Puts("OnDecayHeal called!");
    // If you want to override the default behavior, return true
    // Otherwise, return false
    return false;
}
```

### Source Code from the Library

```csharp

	public virtual void DecayTick()
	{
		if (decay == null)
		{
			return;
		}
		float num = decay.GetDecayTickOverride();
		if (num == 0f)
		{
			num = ConVar.Decay.tick;
		}
		float num2 = UnityEngine.Time.time - lastDecayTick;
		if (num2 < num)
		{
			return;
		}
		lastDecayTick = UnityEngine.Time.time;
		if (HasParent() || !decay.ShouldDecay(this))
		{
			return;
		}
		float num3 = num2 * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num3;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if (buildingPrivilege != null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", this) == null)
				{
					float num4 = num2 / GetEntityDecayDuration() * GetEntityHealScale();
					Heal(MaxHealth() * num4);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num3;
		if (decayTimer < GetEntityDecayDelay())
		{
			return;
		}
		using (TimeWarning.New("DecayTick"))
		{
			float num5 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num5 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num5 -= decayPoint.protection;
					}
				}
			}
			if (Interface.CallHook("OnDecayDamage", this) == null && num5 > 0f)
			{
				float num6 = num3 / GetEntityDecayDuration() * MaxHealth();
				Hurt(num6 * num5 * decayVariance, DamageType.Decay);
			}
		}
	}

```

## OnItemCraftCancelled(ItemCraftTask,ItemCrafter)

```csharp
/// <summary>
/// Called when an item craft task is cancelled.
/// </summary>
/// <param name="task">The cancelled item craft task.</param>
/// <param name="crafter">The entity that was crafting the item.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task, ItemCrafter crafter)
{
    Puts($"Item craft task {task.taskUID} cancelled by {crafter.name}");
}
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID, bool ReturnItems)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		if (owner != null && owner.IsTransferring())
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask, this);
		owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0 && ReturnItems)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(owner.inventory.containerMain))
					{
						takenItem.Drop(owner.inventory.containerMain.dropPosition + UnityEngine.Random.value * Vector3.down + UnityEngine.Random.insideUnitSphere, owner.inventory.containerMain.dropVelocity);
						owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
		}
		return true;
	}

```

## OnPhoneDialTimedOut(PhoneController,PhoneController,BasePlayer)

```csharp
/// <summary>
/// Called when a phone call times out.
/// </summary>
/// <param name="activeCallTo">The phone controller that was making the call.</param>
/// <param name="this">The current phone controller.</param>
/// <param name="currentPlayer">The player who initiated the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialTimedOut(PhoneController activeCallTo, PhoneController this, BasePlayer currentPlayer)
{
    Puts("OnPhoneDialTimedOut is working!");
}
```

### Source Code from the Library

```csharp

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", activeCallTo, this, activeCallTo.currentPlayer) == null)
		{
			if (activeCallTo != null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", activeCallTo, this, activeCallTo.currentPlayer);
		}
	}

```

## OnBookmarkControlEnded(ComputerStation,BasePlayer,BaseEntity)

```csharp
/// <summary>
/// Called when the bookmark control has ended.
/// </summary>
/// <param name="computerStation">The computer station where the bookmark was controlled.</param>
/// <param name="player">The player who was controlling the bookmark.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer player, BaseEntity entity)
{
    Puts("OnBookmarkControlEnded is working!");
}
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if ((bool)ply)
		{
			ply.net.SwitchSecondaryGroup(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
		CancelInvoke(CheckCCTVAchievement);
		Interface.CallHook("OnBookmarkControlEnded", this, ply, baseEntity);
	}

```

## OnCorpsePopulate(FrankensteinPet,BaseCorpse)

```csharp
/// <summary>
/// Called when a corpse is populated.
/// </summary>
/// <param name="pet">The FrankensteinPet instance.</param>
/// <param name="corpse">The BaseCorpse instance.</param>
/// <returns>Returns the populated corpse if overridden, otherwise returns null.</returns>
object OnCorpsePopulate(FrankensteinPet pet, BaseCorpse corpse)
{
    // Minimal code to demonstrate functionality
    Puts("OnCorpsePopulate is working!");
    
    return null;
}
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse(PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<TriggerBase> triggersOnDeath, bool forceServerSide = false)
	{
		BaseCorpse baseCorpse;
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse("assets/rust.ai/agents/NPCPlayer/pet/frankensteinpet_corpse.prefab", flagsOnDeath, modelState) as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(this, base.inventory.containerMain, base.inventory.containerWear, base.inventory.containerBelt);
				nPCPlayerCorpse.playerName = OverrideCorpseName();
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
			}
			baseCorpse = nPCPlayerCorpse;
		}
		object obj = Interface.CallHook("OnCorpsePopulate", this, baseCorpse);
		if (obj is BaseCorpse)
		{
			return (BaseCorpse)obj;
		}
		return baseCorpse;
	}

```

## IOnCupboardAuthorize(ulong,BasePlayer,BuildingPrivlidge)

```csharp
/// <summary>
/// Called to authorize a player's interaction with a cupboard.
/// </summary>
/// <param name="id">The ID of the cupboard.</param>
/// <param name="player">The player attempting to interact with the cupboard.</param>
/// <param name="privilege">The privilege level required to access the cupboard.</param>
/// <returns>Returns null if the default behavior is not overridden, otherwise returns a non-null value.</returns>
object IOnCupboardAuthorize(ulong id, BasePlayer player, BuildingPrivlidge privilege)
{
    // Minimal code to demonstrate functionality
    Puts("IOnCupboardAuthorize hook called!");
    
    // Return null if the default behavior is not overridden
    return null;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void AddAuthorize(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanAdministrate(rpc.player))
		{
			ulong num = rpc.read.UInt64();
			if (Interface.CallHook("IOnCupboardAuthorize", num, rpc.player, this) == null)
			{
				AddPlayer(rpc.player, num);
				SendNetworkUpdate();
			}
		}
	}

```

## OnFishingRodCast(BaseFishingRod,BasePlayer,Item)

```csharp
/// <summary>
/// Called when a fishing rod is cast.
/// </summary>
/// <param name="rod">The fishing rod being cast.</param>
/// <param name="player">The player casting the rod.</param>
/// <param name="lure">The lure being used.</param>
/// <returns>No return behavior.</returns>
void OnFishingRodCast(BaseFishingRod rod, BasePlayer player, Item lure)
{
    Puts($"Fishing rod cast by {player.displayName} with {lure.info}");
}
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	private void Server_RequestCast(RPCMessage msg)
	{
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		ItemModCompostable component = (ItemModCompostable)Interface.CallHook("CanCastFishingRod", ownerPlayer, this, currentLure, pos);
		if (!(component is bool) || (bool)(object)component)
		{
			FishingBobber component2 = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();
			component2.transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component2.Spawn();
			component2.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);
			int usedLureAmount = 0;
			if (FishLookup.Instance != null)
			{
				currentFishTarget = FishLookup.Instance.GetFish(component2.transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);
			}
			lureUsed = currentLure.info;
			currentLure.UseItem(usedLureAmount);
			lastFish = fishableModifier;
			currentBobber.Set(component2);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReceiveCastPoint"), component2.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));
			catchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;
			float val = (lureUsed.TryGetComponent<ItemModCompostable>(out component) ? component.BaitValue : 0f);
			val = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);
			catchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);
			playerStartPosition = ownerPlayer.transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			InvokeRepeating(CatchProcess, 0f, 0f);
			inQueue = false;
			Interface.CallHook("OnFishingRodCast", this, ownerPlayer, currentLure);
		}
	}

```

## IOnRunCommandLine()

```csharp
/// <summary>
/// Called when the command line is updated.
/// </summary>
/// <param name="command">The command to run.</param>
/// <param name="argument">The argument for the command.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object IOnRunCommandLine(string command, string argument)
{
    Puts($"Running command: {command} with argument: {argument}");
    return null;
}
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The console system argument.</param>
/// <returns>Returns <c>true</c> if the default behavior is overridden, and <c>false</c> otherwise.</returns>
object IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts("IOnServerCommand hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null && string.IsNullOrWhiteSpace(arg.Reply))
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## OnClientDisconnected(Network.Connection,string)

```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The client's connection.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnected(Network.Connection connection, string reason)
{
    Puts($"Client disconnected with reason: {reason}");
}
```

### Source Code from the Library

```csharp

	protected void OnDisconnected(string strReason, Connection cn)
	{
		if (cn != null)
		{
			RecordDisconnection(cn);
			cn.connected = false;
			cn.active = false;
			if (callbackHandler != null)
			{
				callbackHandler.OnDisconnected(strReason, cn);
			}
			Interface.CallHook("OnClientDisconnected", cn, strReason);
			RemoveConnection(cn);
		}
	}

```

## OnNetworkSubscriptionsUpdate(Network.Networkable,System.Collections.Generic.List<Network.Visibility.Group>,unknown)

```csharp
/// <summary>
/// Called when network subscriptions are updated.
/// </summary>
/// <param name="networkable">The networkable object.</param>
/// <param name="groups">The list of groups that were added or removed.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnNetworkSubscriptionsUpdate(Network.Networkable networkable, System.Collections.Generic.List<Network.Visibility.Group> groups)
{
    Puts("OnNetworkSubscriptionsUpdate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool UpdateHighPrioritySubscriptions()
	{
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateHighPrioritySubscriptions"))
		{
			List<Group> obj = Pool.GetList<Group>();
			List<Group> obj2 = Pool.GetList<Group>();
			sv.visibility.GetVisibleFromNear(this.group, obj2);
			AddVisibleFromNear(secondaryGroup, obj2);
			subscriber.subscribed.Compare(obj2, obj, null, null);
			if (Interface.CallHook("OnNetworkSubscriptionsUpdate", this, obj, null) == null)
			{
				for (int i = 0; i < obj.Count; i++)
				{
					Group group = obj[i];
					subscriber.Subscribe(group);
					if (handler != null)
					{
						handler.OnNetworkGroupEnter(group);
					}
				}
			}
			Pool.FreeList(ref obj);
			Pool.FreeList(ref obj2);
		}
		return true;
	}

```

## OnNetworkSubscriptionsUpdate(Network.Networkable,System.Collections.Generic.List<Network.Visibility.Group>,System.Collections.Generic.List<Network.Visibility.Group>)

```csharp
/// <summary>
/// Called when network subscriptions are updated.
/// </summary>
/// <param name="networkable">The networkable that triggered the update.</param>
/// <param name="groupsToAdd">A list of groups to add to the subscription.</param>
/// <param name="groupsToRemove">A list of groups to remove from the subscription.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnNetworkSubscriptionsUpdate(Network.Networkable networkable, List<Network.Visibility.Group> groupsToAdd, List<Network.Visibility.Group> groupsToRemove)
{
    Puts("OnNetworkSubscriptionsUpdate is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	public bool UpdateSubscriptions(int removeLimit, int addLimit)
	{
		if (!updateSubscriptions)
		{
			return false;
		}
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateSubscriptions"))
		{
			updateSubscriptions = false;
			List<Group> obj = Pool.GetList<Group>();
			List<Group> obj2 = Pool.GetList<Group>();
			List<Group> obj3 = Pool.GetList<Group>();
			sv.visibility.GetVisibleFromFar(this.group, obj3);
			AddVisibleFromNear(secondaryGroup, obj3);
			subscriber.subscribed.Compare(obj3, obj, obj2, null);
			if (Interface.CallHook("OnNetworkSubscriptionsUpdate", this, obj, obj2) == null)
			{
				for (int i = 0; i < obj2.Count; i++)
				{
					Group group = obj2[i];
					if (removeLimit > 0)
					{
						subscriber.Unsubscribe(group);
						if (handler != null)
						{
							handler.OnNetworkGroupLeave(group);
						}
						removeLimit -= group.networkables.Count;
					}
					else
					{
						updateSubscriptions = true;
					}
				}
				for (int j = 0; j < obj.Count; j++)
				{
					Group group2 = obj[j];
					if (addLimit > 0)
					{
						subscriber.Subscribe(group2);
						if (handler != null)
						{
							handler.OnNetworkGroupEnter(group2);
						}
						addLimit -= group2.networkables.Count;
					}
					else
					{
						updateSubscriptions = true;
					}
				}
			}
			Pool.FreeList(ref obj);
			Pool.FreeList(ref obj2);
			Pool.FreeList(ref obj3);
		}
		return true;
	}

```

## OnGroupCreated(string,string,int)

```csharp
/// <summary>
/// Called when a new group is created.
/// </summary>
/// <param name="groupName">The name of the newly created group.</param>
/// <param name="groupTitle">The title of the newly created group.</param>
/// <param name="groupRank">The rank of the newly created group.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnGroupCreated(string groupName, string groupTitle, int groupRank)
{
    Puts($"Group '{groupName}' created with title: {groupTitle} and rank: {groupRank}");
    return null;
}
```

### Source Code from the Library

```csharp

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string groupName, string groupTitle, int groupRank)
	{
		if (GroupExists(groupName) || string.IsNullOrEmpty(groupName))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = groupTitle,
			Rank = groupRank
		};
		groupsData.Add(groupName, value);
		Interface.CallHook("OnGroupCreated", groupName, groupTitle, groupRank);
		return true;
	}

```

## OnUserNameUpdated(string,string,string)

```csharp
/// <summary>
/// Called when a player's saved nickname is updated.
/// </summary>
/// <param name="id">The player's ID.</param>
/// <param name="oldName">The player's old nickname.</param>
/// <param name="newName">The player's new nickname.</param>
/// <returns>No return behavior.</returns>
void OnUserNameUpdated(string id, string oldName, string newName)
{
    Puts($"Player's name changed from {oldName} to {newName} for ID {id}");
}
```

### Source Code from the Library

```csharp

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string playerId, string playerName)
	{
		if (UserExists(playerId))
		{
			UserData userData = GetUserData(playerId);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = playerName.Sanitize();
			userData.LastSeenNickname = playerName.Sanitize();
			Interface.CallHook("OnUserNameUpdated", playerId, lastSeenNickname, obj);
		}
	}

```

## OnGroupRankSet(string,int)

```csharp
/// <summary>
/// Called when a group's rank is set.
/// </summary>
/// <param name="groupName">The name of the group.</param>
/// <param name="groupRank">The new rank of the group.</param>
/// <returns>Returns <c>true</c> if the group's rank was successfully updated, and <c>false</c> otherwise.</returns>
bool OnGroupRankSet(string groupName, int groupRank)
{
    Puts($"Group '{groupName}' rank set to {groupRank}");
    return true;
}
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string groupName, int groupRank)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Rank == groupRank)
		{
			return true;
		}
		value.Rank = groupRank;
		Interface.CallHook("OnGroupRankSet", groupName, groupRank);
		return true;
	}

```

## OnGroupTitleSet(string,string)

```csharp
/// <summary>
/// Called when a group's title is set.
/// </summary>
/// <param name="groupName">The name of the group.</param>
/// <param name="groupTitle">The new title of the group.</param>
/// <returns>Returns <c>true</c> if the group's title was successfully updated, and <c>false</c> otherwise.</returns>
bool OnGroupTitleSet(string groupName, string groupTitle)
{
    Puts($"Group title set for {groupName} to '{groupTitle}'");
    return true;
}
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string groupName, string groupTitle)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Title == groupTitle)
		{
			return true;
		}
		value.Title = groupTitle;
		Interface.CallHook("OnGroupTitleSet", groupName, groupTitle);
		return true;
	}

```

## OnPermissionRegistered(string,Oxide.Core.Plugins.Plugin)

```csharp
/// <summary>
/// Called when a new permission is registered.
/// </summary>
/// <param name="permission">The newly registered permission.</param>
/// <param name="owner">The plugin that registered the permission.</param>
/// <returns>No return behavior.</returns>
void OnPermissionRegistered(string permission, Oxide.Core.Plugins.Plugin owner)
{
    Puts($"Permission '{permission}' registered by plugin {owner.Title}");
}
```

### Source Code from the Library

```csharp

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string permission, Plugin owner)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return;
		}
		if (PermissionExists(permission))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", permission, owner.Title);
			return;
		}
		if (!registeredPermissions.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			registeredPermissions.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(permission);
		Interface.CallHook("OnPermissionRegistered", permission, owner);
		if (!permission.StartsWith(owner.Name + ".", StringComparison.OrdinalIgnoreCase) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", owner.Name.ToLower(), permission, owner.Title);
		}
	}

```

## OnGroupParentSet(string,string)

```csharp
/// <summary>
/// Called when the parent group of a group is set.
/// </summary>
/// <param name="groupName">The name of the group whose parent is being set.</param>
/// <param name="parentGroupName">The name of the new parent group.</param>
/// <returns>Returns true if the operation was successful, false otherwise.</returns>
bool OnGroupParentSet(string groupName, string parentGroupName)
{
    Puts($"Group '{groupName}' parent set to '{parentGroupName}'");
    return true;
}
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string groupName, string parentGroupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parentGroupName))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))
		{
			return false;
		}
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parentGroupName))
		{
			return true;
		}
		if (HasCircularParent(groupName, parentGroupName))
		{
			return false;
		}
		value.ParentGroup = parentGroupName;
		Interface.CallHook("OnGroupParentSet", groupName, parentGroupName);
		return true;
	}

```

## OnGroupDeleted(string)

```csharp
/// <summary>
/// Called when a group is deleted.
/// </summary>
/// <param name="groupName">The name of the deleted group.</param>
/// <returns>No return behavior.</returns>
void OnGroupDeleted(string groupName)
{
    Puts($"Group '{groupName}' has been deleted.");
}
```

### Source Code from the Library

```csharp

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		bool flag = groupsData.Remove(groupName);
		if (flag)
		{
			foreach (GroupData item in groupsData.Values.Where((GroupData g) => g.ParentGroup == groupName))
			{
				item.ParentGroup = string.Empty;
			}
		}
		if (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(groupName)))
		{
			SaveUsers();
		}
		if (flag)
		{
			Interface.CallHook("OnGroupDeleted", groupName);
		}
		return true;
	}

```

## OnDestroyUI(BasePlayer,string)

```csharp
/// <summary>
/// Called when a UI element is destroyed.
/// </summary>
/// <param name="player">The player whose UI element was destroyed.</param>
/// <param name="elem">The ID of the destroyed UI element.</param>
/// <returns>No return behavior.</returns>
void OnDestroyUI(BasePlayer player, string elem)
{
    Puts($"UI element '{elem}' destroyed for player {player.Name}");
}
```

### Source Code from the Library

```csharp

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		if (player?.net != null)
		{
			Interface.CallHook("OnDestroyUI", player, elem);
			CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("DestroyUI", player.net.connection), elem);
			return true;
		}
		return false;
	}

```

## OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
/// <summary>
/// Called when a user attempts to execute a command.
/// </summary>
/// <param name="player">The player who executed the command.</param>
/// <param name="command">The command that was executed.</param>
/// <param name="args">Arguments passed with the command.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnUserCommand(IPlayer player, string command, string[] args)
{
    Puts("OnUserCommand is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnApplicationCommand(BasePlayer,string,string[])

```csharp
/// <summary>
/// Called when a player attempts to execute an application command.
/// </summary>
/// <param name="player">The player attempting to execute the command.</param>
/// <param name="command">The command being executed.</param>
/// <param name="args">Arguments passed with the command.</param>
/// <returns>Returns true if the default behavior is overridden, false otherwise.</returns>
bool OnApplicationCommand(BasePlayer player, string command, string args)
{
    Puts("OnApplicationCommand called!");
    // Add your custom logic here
    return false;
}
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
/// <summary>
/// Called when a player's language is changed.
/// </summary>
/// <param name="player">The player whose language was changed.</param>
/// <param name="newLanguage">The new language set for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(IPlayer player, string newLanguage)
{
    Puts($"Player's language changed to {newLanguage}");
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnPlayerLanguageChanged(BasePlayer,string)

```csharp
/// <summary>
/// Called when a player's language is changed.
/// </summary>
/// <param name="player">The player whose language was changed.</param>
/// <param name="newLanguage">The new language set for the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(BasePlayer player, string newLanguage)
{
    Puts($"Player's language changed to {newLanguage} for ID {player.UserIDString}");
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>Returns the result of the hook, or null if no hook is registered.</returns>
object OnUserRespawn(IPlayer player)
{
    Puts("OnUserRespawn called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.CallHook("OnUserRespawn", iPlayer);
	}

```

## OnApplicationCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
/// <summary>
/// Called when a player attempts to execute an application command.
/// </summary>
/// <param name="player">The player executing the command.</param>
/// <param name="command">The command being executed.</param>
/// <param name="args">Arguments passed with the command.</param>
/// <returns>No return behavior.</returns>
void OnApplicationCommand(IPlayer player, string command, string args)
{
    Puts($"Player '{player.Id}' attempted to execute application command: {command} ({args})");
}
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## OnRconCommand(System.Net.IPAddress,string,string[])

```csharp
/// <summary>
/// Called when an RCON command is received.
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the command.</param>
/// <param name="command">The actual RCON command being sent.</param>
/// <param name="args">Any arguments passed with the command.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnRconCommand(System.Net.IPAddress ipAddress, string command, string[] args)
{
    Puts("OnRconCommand is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", ipAddress, message) != null)
			{
				return true;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnEntityTakeDamage(BaseCombatEntity,HitInfo)

```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that took the damage.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts("OnEntityTakeDamage is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.CallHook("OnEntityTakeDamage", entity, hitInfo);
		}
		return null;
	}

```

## OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>Returns the player's ID if it is used in the method, otherwise returns null or void.</returns>
object OnUserRespawned(IPlayer player)
{
    Puts($"Player {player.Id} has respawned!");
    return player.Id;
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", iPlayer);
		}
	}

```

## OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
/// <summary>
/// Called when a user disconnects from the game.
/// </summary>
/// <param name="player">The player who disconnected.</param>
/// <param name="reason">The reason for disconnection.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnUserDisconnected(IPlayer player, string reason)
{
    Puts($"Player {player.Id} disconnected with reason: {reason}");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer basePlayer, string reason)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(basePlayer);
	}

```

## OnServerInitialized(bool)

```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
/// <param name="initialized">Whether the server has been initialized.</param>
/// <returns>No return behavior.</returns>
void OnServerInitialized(bool initialized)
{
    Puts("OnServerInitialized called!");
}
 
Окончательный ответ:

void OnServerInitialized(bool initialized)
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			Analytics.Collect();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", serverInitialized);
		}
	}

```

## OnCupboardAssign(BuildingPrivlidge,ulong,BasePlayer)

```csharp
/// <summary>
/// Called when a player attempts to assign a building privilege to another user.
/// </summary>
/// <param name="privlidge">The building privilege being assigned.</param>
/// <param name="userID">The ID of the user being assigned the privilege.</param>
/// <param name="player">The player attempting to assign the privilege.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnCupboardAssign(BuildingPrivlidge privlidge, ulong userID, BasePlayer player)
{
    Puts("OnCupboardAssign called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnCupboardAuthorize")]
	private object IOnCupboardAuthorize(ulong userID, BasePlayer player, BuildingPrivlidge privlidge)
	{
		if (userID == (ulong)player.userID)
		{
			if (Interface.CallHook("OnCupboardAuthorize", privlidge, player) != null)
			{
				return true;
			}
		}
		else if (Interface.CallHook("OnCupboardAssign", privlidge, userID, player) != null)
		{
			return true;
		}
		return null;
	}

```

## CanUserLogin(string,string,string)

```csharp
/// <summary>
/// Called when a user attempts to login.
/// </summary>
/// <param name="username">The username of the user.</param>
/// <param name="text">The text representation of the user's ID.</param>
/// <param name="obj">The IP address of the user, with any sensitive information removed.</param>
/// <returns>Returns a non-null value if the default behavior is overridden. If the return value is a string, it represents a reason for rejecting the login attempt. If the return value is a boolean and false, it indicates that the login should be rejected.</returns>
object CanUserLogin(string username, string text, string obj)
{
    Puts("CanUserLogin called!");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnPlayerChat(BasePlayer,string,ConVar.Chat.ChatChannel)

```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The text of the chat message.</param>
/// <param name="channel">The channel on which the chat message was sent.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise returns null.</returns>
object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
{
    Puts("OnPlayerChat hook called!");
    // If you want to override the default behavior, return a non-null value here
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnUserUnbanned(string,string,string)

```csharp
/// <summary>
/// Called when a user is unbanned.
/// </summary>
/// <param name="name">The name of the user.</param>
/// <param name="steamId">The Steam ID of the user.</param>
/// <param name="address">The IP address of the user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string name, string steamId, string address)
{
    Puts($"User '{name}' unbanned with Steam ID {steamId} and IP address {address}");
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## CanClientLogin(Network.Connection)

```csharp
/// <summary>
/// Called when a client attempts to login.
/// </summary>
/// <param name="connection">The client's connection.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, or null otherwise.</returns>
object CanClientLogin(Network.Connection connection)
{
    Puts("CanClientLogin called!");
    
    // If ReturnType is void, do not include the return statement
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnRconMessage(System.Net.IPAddress,Oxide.Core.RemoteConsole.RemoteMessage)

```csharp
/// <summary>
/// Called when a remote console message is received.
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the message.</param>
/// <param name="message">The remote console message.</param>
/// <returns>Returns true if the default behavior is overridden, otherwise returns null.</returns>
object OnRconMessage(System.Net.IPAddress ipAddress, Oxide.Core.RemoteConsole.RemoteMessage message)
{
    Puts("OnRconMessage called!");
    
    // If the message is not empty and has a valid command
    if (!string.IsNullOrEmpty(message.Message))
    {
        // Get the command from the message
        string command = message.Message;
        
        // Call the OnRconCommand hook with the command and arguments
        object obj = Interface.CallHook("OnRconCommand", ipAddress, command);
        
        // If the hook returns a non-null value, return true to override the default behavior
        if (obj != null)
        {
            return true;
        }
    }
    
    // Return null to allow the default behavior to proceed
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", ipAddress, message) != null)
			{
				return true;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnPlayerBanned(string,ulong,string,string,long)

```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="name">The player's name.</param>
/// <param name="steamId">The player's Steam ID.</param>
/// <param name="address">The player's address.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The expiry time of the ban in seconds.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string name, ulong steamId, string address, string reason, long expiry)
{
    Puts($"Player '{name}' banned with Steam ID {steamId} and address {address}. Reason: {reason}, Expiry: {expiry} seconds");
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnPlayerOfflineChat(ulong,string,string,ConVar.Chat.ChatChannel)

```csharp
/// <summary>
/// Called when a player's chat message is processed and they are offline.
/// </summary>
/// <param name="id">The player's ID.</param>
/// <param name="name">The player's name.</param>
/// <param name="message">The player's chat message.</param>
/// <param name="channel">The channel where the message was sent.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerOfflineChat(ulong id, string name, string message, Chat.ChatChannel channel)
{
    Puts($"Player '{name}' ({id}) is offline and sent chat message: {message}");
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
/// <summary>
/// Called when an NPC targets a base entity.
/// </summary>
/// <param name="npc">The NPC that is targeting the entity.</param>
/// <param name="target">The entity being targeted by the NPC.</param>
/// <returns>Returns a non-null value if the default behavior is overridden, otherwise returns null.</returns>
object OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts("OnNpcTarget hook called!");
    // If Interface.CallHook returns a non-null value, it means the default behavior was overridden
    return Interface.CallHook("OnNpcTarget", npc, target) ?? null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcTarget", npc, target) != null)
		{
			npc.SetFact(BaseNpc.Facts.HasEnemy, 0);
			npc.SetFact(BaseNpc.Facts.EnemyRange, 3);
			npc.SetFact(BaseNpc.Facts.AfraidRange, 1);
			npc.playerTargetDecisionStartTime = 0f;
			return 0f;
		}
		return null;
	}

```

## OnPlayerBanned(Network.Connection,string)

```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="connection">The network connection of the banned player.</param>
/// <param name="status">The ban status.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerBanned(Network.Connection connection, string status)
{
    Puts($"Player banned: {connection} with reason: {status}");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerBanned")]
	private void IOnPlayerBanned(Connection connection, AuthResponse status)
	{
		Interface.CallHook("OnPlayerBanned", connection, status.ToString());
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The player who was kicked.</param>
/// <param name="reason">The reason for the kick.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnUserKicked(IPlayer player, string reason)
{
    Puts($"Player {player.Name} was kicked with reason: {reason}");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer basePlayer, string reason)
	{
		if (basePlayer.IPlayer != null)
		{
			Interface.CallHook("OnUserKicked", basePlayer.IPlayer, reason);
		}
	}

```

## OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
/// <summary>
/// Called when a user connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
/// <returns>No return behavior.</returns>
void OnUserConnected(IPlayer player)
{
    Puts($"User {player.UserIDString} connected.");
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnServerCommand(string,string[])

```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="command">The full name of the command.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
object OnServerCommand(string command, string[] args)
{
    Puts($"OnServerCommand called with command: {command} and args: [{string.Join(", ", args)}]");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnLoseCondition(object[])

```csharp
/// <summary>
/// Called when an item's condition is reduced to a point where it can no longer be used.
/// </summary>
/// <param name="item">The item that has lost its condition.</param>
/// <returns>Returns true if the default behavior is executed, and false otherwise.</returns>
object OnLoseCondition(object item)
{
    Puts("OnLoseCondition called!");
    return true;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

```

## OnServerCommand(ConsoleSystem.Arg)

```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The argument containing the command and its parameters.</param>
/// <returns>Returns <c>true</c> if the default behavior is overridden, and <c>null</c> otherwise.</returns>
object OnServerCommand(ConsoleSystem.Arg arg)
{
    Puts("OnServerCommand called!");
    
    // If the return value from Interface.CallHook is not null, return true
    object obj = Interface.CallHook("OnServerCommand", arg);
    if (obj != null)
    {
        return true;
    }
    
    // Otherwise, return null
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnServerShutdown()

```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
void OnServerShutdown()
{
    Puts("Server shutdown hook called!");
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerShutdown")]
	private void IOnServerShutdown()
	{
		Interface.Oxide.CallHook("OnServerShutdown");
		Interface.Oxide.OnShutdown();
		Covalence.PlayerManager.SavePlayerData();
	}

```

## OnUserBanned(string,string,string,string,long)

```csharp
/// <summary>
/// Called when a user is banned.
/// </summary>
/// <param name="name">The name of the user being banned.</param>
/// <param name="steamId">The Steam ID of the user being banned.</param>
/// <param name="address">The IP address of the user being banned.</param>
/// <param name="reason">The reason for banning the user.</param>
/// <param name="expiry">The time at which the ban will expire.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnUserBanned(string name, string steamId, string address, string reason, long expiry)
{
    Puts($"User {name} banned with reason: {reason}");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnEntityTakeDamage(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Called when a player takes damage from an entity.
/// </summary>
/// <param name="player">The player taking the damage.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>Returns true if the default behavior is overridden, otherwise returns null.</returns>
object OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
{
    Puts("OnEntityTakeDamage called!");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)
	{
		if (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", basePlayer, hitInfo) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			basePlayer.OnAttacked(hitInfo);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

```

## OnUserApproved(string,string,string)

```csharp
/// <summary>
/// Called when a user is approved.
/// </summary>
/// <param name="username">The username of the approved user.</param>
/// <param name="text">The text associated with the approved user.</param>
/// <param name="obj">The object associated with the approved user.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnUserApproved(string username, string text, string obj)
{
    Puts($"User {username} approved.");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
/// <summary>
/// Called when a user sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The text of the chat message.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnUserChat(IPlayer player, string message)
{
    Puts("OnUserChat hook called!");
    // Minimal code to demonstrate functionality
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		string chatCommandPrefix = CommandHandler.GetChatCommandPrefix(message);
		if (chatCommandPrefix != null)
		{
			TryRunPlayerCommand(basePlayer, message, chatCommandPrefix);
			return false;
		}
		message = message.EscapeRichText();
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnPlayerConnected(BasePlayer)

```csharp
/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(BasePlayer player)
{
    Puts("OnPlayerConnected is working!");
}
 
 /// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(BasePlayer player)
{
    Puts("OnPlayerConnected is working!");
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
/// <summary>
/// Called when an entity is saved.
/// </summary>
/// <param name="entity">The entity being saved.</param>
/// <param name="saveInfo">Information about the save operation.</param>
/// <returns>No return behavior.</returns>
void OnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity} saved with info: {saveInfo}");
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnEntitySaved")]
	private void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)
	{
		if (serverInitialized && saveInfo.forConnection != null)
		{
			Interface.CallHook("OnEntitySaved", baseNetworkable, saveInfo);
		}
	}

```

## OnPlayerCommand(BasePlayer,string,string[])

```csharp
/// <summary>
/// Called when a player attempts to execute a command.
/// </summary>
/// <param name="player">The player attempting to execute the command.</param>
/// <param name="command">The command being executed.</param>
/// <param name="args">Arguments passed with the command.</param>
/// <returns>Returns a non-null value if the default behavior is overridden.</returns>
object OnPlayerCommand(BasePlayer player, string command, string args)
{
    Puts("OnPlayerCommand is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	private void TryRunPlayerCommand(BasePlayer basePlayer, string message, string commandPrefix)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text))
		{
			return;
		}
		ParseCommand(text.Substring(commandPrefix.Length), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(Environment.NewLine, " "), Environment.NewLine, stackTrace));
		}
	}

```

## CanUseUI(BasePlayer,string)

```csharp
/// <summary>
/// Called to determine if a player can use the UI.
/// </summary>
/// <param name="player">The player attempting to use the UI.</param>
/// <param name="json">The JSON data related to the UI.</param>
/// <returns>Returns null if the default behavior is overridden, and non-null otherwise.</returns>
object CanUseUI(BasePlayer player, string json)
{
    Puts("CanUseUI hook called!");
    return null;
}
```

### Source Code from the Library

```csharp

	public static bool AddUi(BasePlayer player, string json)
	{
		if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
		{
			CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", player.net.connection), json);
			return true;
		}
		return false;
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="name">The name of the player.</param>
/// <param name="steamId">The Steam ID of the player.</param>
/// <param name="address">The IP address of the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string name, ulong steamId, string address)
{
    Puts($"Player '{name}' has been unbanned from the server.");
}
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## OnUserApprove(Network.Connection)

```csharp
/// <summary>
/// Called when a user's connection is approved.
/// </summary>
/// <param name="connection">The user's network connection.</param>
/// <returns>Returns the result of the OnUserApproved hook, or null if not overridden.</returns>
object OnUserApprove(Network.Connection connection)
{
    Puts("OnUserApprove called!");
    
    // If the OnUserApproved hook is overridden, return its result
    object result = Interface.CallHook("OnUserApproved", connection.username, connection.userid.ToString(), connection.ipaddress);
    if (result != null)
    {
        return result;
    }
    
    // Otherwise, return null
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## CanPickupEntity(BasePlayer,DoorCloser)

```csharp
/// <summary>
/// Called when a player attempts to pickup an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>Returns true if the default behavior is overridden, and false otherwise.</returns>
object CanPickupEntity(BasePlayer player, DoorCloser entity)
{
    Puts("CanPickupEntity is working!");
    return null;
}
```

### Source Code from the Library

```csharp

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)
	{
		object obj = Interface.CallHook("CanPickupEntity", basePlayer, entity);
		if (!(obj is bool) || (bool)obj)
		{
			return null;
		}
		return true;
	}

```

## OnClanMemberAdded(long,ulong)

```csharp
/// <summary>
/// Called when a new member is added to a clan.
/// </summary>
/// <param name="clanId">The ID of the clan.</param>
/// <param name="steamId">The Steam ID of the new member.</param>
/// <returns>No return behavior.</returns>
void OnClanMemberAdded(long clanId, ulong steamId)
{
    Puts($"New member added to clan {clanId} with Steam ID {steamId}");
}
```

### Source Code from the Library

```csharp

	public bool AcceptInvite(long clanId, ulong steamId)
	{
		BeginTransaction();
		try
		{
			if (DeleteInvite(clanId, steamId) && CreateMember(clanId, steamId))
			{
				Commit();
				Interface.CallHook("OnClanMemberAdded", clanId, steamId);
				return true;
			}
			Rollback();
			return false;
		}
		catch
		{
			Rollback();
			throw;
		}
	}

```

