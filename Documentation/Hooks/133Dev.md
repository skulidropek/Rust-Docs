# Hook Definitions

## OnItemResearchEnd(ResearchTable,float)

```csharp
/// <summary>
/// Вызывается, когда исследование предмета завершено.
/// </summary>
/// <param name="researchTable">Таблица исследований.</param>
/// <param name="result">Результат исследования (float).</param>
/// <returns>Возвращает значение float, если поведение по умолчанию переопределено.</returns>
object OnItemResearchEnd(ResearchTable researchTable, float result)
{
    Puts("OnItemResearchEnd вызван!");
    return null;
}
```

## OnDispenserGather(ResourceDispenser,BaseEntity,Item)

```csharp
/// <summary>
/// Вызывается при сборе ресурса из диспенсера.
/// </summary>
/// <param name="dispenser">Диспенсер, из которого собран ресурс.</param>
/// <param name="entity">Сущность, которая собрала ресурс.</param>
/// <param name="item">Собранный ресурс.</param>
object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
{
    Puts("OnDispenserGather вызван!");
    return null;
}
```

## OnPlayerViolation(BasePlayer,AntiHackType,float)

```csharp
/// <summary>
/// Вызывается при обнаружении нарушения игроком.
/// </summary>
/// <param name="player">Игрок, совершивший нарушение.</param>
/// <param name="type">Тип нарушения (например, AntiHackType).</param>
/// <param name="amount">Количество нарушений.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
{
    Puts("OnPlayerViolation работает!");
    return null;
}
```

## OnShopCompleteTrade(ShopFront)

```csharp
/// <summary>
/// Вызывается после завершения торговли в магазине.
/// </summary>
/// <param name="shopFront">Фронт магазина.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnShopCompleteTrade(ShopFront shopFront)
{
    Puts("OnShopCompleteTrade работает!");
    return null;
}
```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
/// <summary>
/// Вызывается при запуске ракеты.
/// </summary>
/// <param name="player">Игрок, запустивший ракету.</param>
/// <param name="entity">Сущность ракеты.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnRocketLaunched(BasePlayer player, BaseEntity entity)
{
    Puts($"Ракета запущена игроком {player.displayName}.");
}

```

## OnTurretToggle(AutoTurret)

```csharp
/// <summary>
/// Вызывается, когда таран автоматически включается или выключается.
/// </summary>
/// <param name="turret">Таран, который был включен или выключен.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTurretToggle(AutoTurret turret)
{
    Puts("OnTurretToggle работает!");
    return null;
}
```

## OnItemDropped(Item,BaseEntity)

```csharp
/// <summary>
/// Вызывается при выпадении предмета.
/// </summary>
/// <param name="item">Выпавший предмет.</param>
/// <param name="entity">Сущность, на которой лежит предмет.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemDropped(Item item, BaseEntity entity)
{
    Puts("OnItemDropped работает!");
    return null;
}
```

## OnServerShutdown(unknown)

```csharp
/// <summary>
/// Вызывается при закрытии сервера.
/// </summary>
/// <param name="unknown">Неизвестный параметр.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnServerShutdown(unknown)
{
    Puts("Сервер закрывается!");
}
```

## CanSetBedPublic(SleepingBag,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается сделать кровать публичной.
/// </summary>
/// <param name="sleepingBag">Кровать.</param>
/// <param name="player">Игрок, пытающийся сделать кровать публичной.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object CanSetBedPublic(SleepingBag sleepingBag, BasePlayer player)
{
    Puts("CanSetBedPublic работает!");
    return null;
}
```

## CanPickupLock(BasePlayer,BaseLock)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается взять ключ.
/// </summary>
/// <param name="player">Игрок, пытающийся взять ключ.</param>
/// <param name="lock">Ключ, который нужно взять.</param>
/// <returns>Возвращает true, если игрок может взять ключ, иначе false.</returns>
bool CanPickupLock(BasePlayer player, BaseLock lock)
{
    Puts("CanPickupLock работает!");
    // Здесь можно добавить дополнительную логическую проверку, например:
    // if (player.HasItemInInventory(lock)) return false;
    return true;
}
```

## CanPickupEntity(BaseCombatEntity,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается поднять сущность.
/// </summary>
/// <param name="entity">Сущность, которую хочет поднять игрок.</param>
/// <param name="player">Игрок, пытающийся поднять сущность.</param>
/// <returns>Возвращает true, если игрок может поднять сущность, и false в противном случае.</returns>
bool CanPickupEntity(BaseCombatEntity entity, BasePlayer player)
{
    Puts("CanPickupEntity работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnItemResearchStart(ResearchTable)

```csharp
/// <summary>
/// Вызывается перед началом исследования предмета.
/// </summary>
/// <param name="researchTable">Таблица исследований.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnItemResearchStart(ResearchTable researchTable)
{
    Puts("OnItemResearchStart работает!");
}
```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
/// <summary>
/// Вызывается после удаления предмета из контейнера.
/// </summary>
/// <param name="container">Контейнер, из которого был удален предмет.</param>
/// <param name="item">Удаленный предмет.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts("OnItemRemovedFromContainer работает!");
    return null;
}
```

## CanEquipItem(PlayerInventory,Item)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается одеть предмет.
/// </summary>
/// <param name="inventory">Инвентарь игрока.</param>
/// <param name="item">Предмет, который хочет одеть игрок.</param>
/// <returns>Возвращает true, если предмет можно одеть, и false в противном случае.</returns>
bool CanEquipItem(PlayerInventory inventory, Item item)
{
    Puts("CanEquipItem вызван!");
    
    // Если возвращаемое значение не равно null, то метод переопределен
    object obj = Interface.CallHook("CanEquipItem", inventory, item);
    if (obj is bool)
    {
        return (bool)obj;
    }
    
    // Если предмет имеет компонент ItemModContainerRestriction, проверяем его возможности с другими предметами в инвентаре
    ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
    if (component != null)
    {
        Item[] array = inventory.itemList.ToArray();
        foreach (Item item2 in array)
        {
            if (item2 != item)
            {
                ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
                if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(inventory.containerMain))
                {
                    item2.Drop(base.baseEntity.eyes.position, base.baseEntity.eyes.BodyForward() * 2f);
                }
            }
        }
    }
    
    // Если все проверки пройдены, возвращаем true
    return true;
}
```

## CanLock(CodeLock,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается открыть замок.
/// </summary>
/// <param name="codeLock">Замок.</param>
/// <param name="player">Игрок.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object CanLock(CodeLock codeLock, BasePlayer player)
{
    Puts("CanLock работает!");
    return null;
}
```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается выстрелить в объект.
/// </summary>
/// <param name="player">Игрок, пытающийся выстрелить.</param>
/// <param name="trap">Объект, на который стреляет игрок.</param>
/// <returns>Возвращает true, если игрок может быть целью, и false в противном случае.</returns>
bool CanBeTargeted(BasePlayer player, GunTrap trap)
{
    Puts("CanBeTargeted работает!");
    // Здесь можно добавить дополнительную логику для определения, может ли игрок быть целью
    return true; // или другое значение в зависимости от функциональности метода
}
```

## OnCollectiblePickup(Item,BasePlayer,CollectibleEntity)

```csharp
/// <summary>
/// Вызывается при снятии коллекционного предмета.
/// </summary>
/// <param name="item">Снятый коллекционный предмет.</param>
/// <param name="player">Игрок, который снял предмет.</param>
/// <param name="entity">Сущность, из которой был снят предмет.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
{
    Puts($"Игрок {player.UserIDString} собрал коллекционный предмет: {item.info.name}");
}
```

## OnServerInitialized(unknown)

```csharp
/// <summary>
/// Вызывается после инициализации сервера.
/// </summary>
/// <param name="unknown">Неизвестный параметр.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnServerInitialized(unknown)
{
    Puts("OnServerInitialized вызван!");
}
```

## CanAdministerVending(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается администрировать автомат.
/// </summary>
/// <param name="vendingMachine">Автомат.</param>
/// <param name="player">Игрок.</param>
/// <returns>Возвращает true, если игрок может администрировать автомат, и false в противном случае.</returns>
bool CanAdministerVending(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("CanAdministerVending работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum)

```csharp
/// <summary>
/// Вызывается при обновлении структуры.
/// </summary>
/// <param name="block">Блок, который был использован для обновления.</param>
/// <param name="player">Игрок, который выполнил обновление.</param>
/// <param name="grade">Новая степень строения.</param>
/// <returns>Возвращает null, если поведение по умолчанию не было переопределено.</returns>
object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
{
    Puts("OnStructureUpgrade вызван!");
    return null;
}
```

## OnPlayerSleep(BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок ложится спать.
/// </summary>
/// <param name="player">Игрок, который ложится спать.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerSleep(BasePlayer player)
{
    Puts("OnPlayerSleep работает!");
    return null;
}
```

## OnCupboardDeauthorize(BuildingPrivlidge,BasePlayer)

```csharp
/// <summary>
/// Вызывается при отмене авторизации шкафа.
/// </summary>
/// <param name="buildingPrivilege">Права на здание.</param>
/// <param name="player">Игрок, который отменил авторизацию.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnCupboardDeauthorize(BuildingPrivlidge buildingPrivilege, BasePlayer player)
{
    Puts("OnCupboardDeauthorize вызван!");
}
</return_type_instructions>

В этом методе нет оператора return после Interface.CallHook, что указывает на то, что тип возвращаемого значения равен void.
```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
/// <summary>
/// Вызывается при нанесении урона сущности.
/// </summary>
/// <param name="entity">Сущность, получившая урон.</param>
/// <param name="info">Информация о нанесенном уроне.</param>
/// <returns>Возвращаемое значение хука. Если оно не равно null, то дальнейшие действия в методе Hurt() будут пропущены.</returns>
public virtual object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo info)
{
    // Метод должен содержать минимальный код для демонстрации функциональности.
    return null;
}
```

## IOnPlayerAttack(BaseMelee,HitInfo)

```csharp
/// <summary>
/// Вызывается, когда игрок совершает атаку.
/// </summary>
/// <param name="melee">Оружие, с помощью которого совершается атака.</param>
/// <param name="info">Информация о хите.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object IOnPlayerAttack(BaseMelee melee, HitInfo info)
{
    Puts("IOnPlayerAttack работает!");
    return null;
}
```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Вызывается при изменении флага отображения бродкастов в торговом автомате.
/// </summary>
/// <param name="vendingMachine">Торговый автомат.</param>
/// <param name="player">Игрок, который вызвал хук.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnToggleVendingBroadcast работает!");
}
```

## OnDoorOpened(Door,BasePlayer)

```csharp
/// <summary>
/// Вызывается при открытии двери.
/// </summary>
/// <param name="door">Дверь, которую открывают.</param>
/// <param name="player">Игрок, который открывает дверь.</param>
object OnDoorOpened(Door door, BasePlayer player)
{
    Puts("OnDoorOpened вызван!");
    // Здесь можно добавить код для обработки открытия двери
    return null;
}
```

## OnReloadMagazine(BasePlayer,BaseProjectile)

```csharp
/// <summary>
/// Вызывается при перезарядке магазина.
/// </summary>
/// <param name="player">Владелец оружия.</param>
/// <param name="projectile">Проектиль, который перезарядают.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
{
    Puts("OnReloadMagazine работает!");
}
```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
/// <summary>
/// Вызывается, когда изменяется цель вертолета.
/// </summary>
/// <param name="turret">Вертолет.</param>
/// <param name="newTarget">Новая цель.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity newTarget)
{
    Puts("OnHelicopterTarget работает!");
    return null;
}
```

## OnPlayerDie(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Вызывается, когда игрок умирает.
/// </summary>
/// <param name="player">Игрок, который умер.</param>
/// <param name="info">Информация о смерти.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerDie(BasePlayer player, HitInfo info)
{
    Puts("OnPlayerDie работает!");
    return null;
}
```

## OnPlayerBanned(Network.Connection,string)

```csharp
/// <summary>
/// Вызывается при бане игрока.
/// </summary>
/// <param name="connection">Информация о подключении игрока.</param>
/// <param name="authStatus">Статус аутентификации игрока.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnPlayerBanned(Network.Connection connection, string authStatus)
{
    Puts($"Игрок {connection.username} забанен.");
}
</promt>
```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
Документация для метода `IOnBasePlayerHurt(BasePlayer, HitInfo)`:

```rust
/// <summary>
/// Вызывается при получении урона игроком.
/// </summary>
/// <param name="player">Игрок, получивший урон.</param>
/// <param name="info">Информация о полученном уроне.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void IOnBasePlayerHurt(BasePlayer player, HitInfo info)
{
    // Модифицируйте или отмените действие игрока здесь
}
```

Примечание: Этот метод вызывается в методе `Hurt` класса `BasePlayer`, когда игрок получает урон. Если этот хук не вызван, то урон будет передан дальше по цепочке вызовов.

Например:

```rust
public override void Hurt(HitInfo info)
{
    if (IsDead() || IsImmortal() || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
    {
        return;
    }
    // ...
}
```

В этом примере метод `IOnBasePlayerHurt` вызывается перед тем, как урон будет передан дальше по цепочке вызовов. Если этот хук не вызван, то урон будет передан дальше.
```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Вызывается для проверки возможности нанесения урона игроку.
/// </summary>
/// <param name="player">Игрок, на которого может быть нанесен урон.</param>
/// <param name="hitInfo">Информация о выстреле или атаке.</param>
/// <returns>Возвращает true, если игрок может быть ранен, и false в противном случае.</returns>
bool CanBeWounded(BasePlayer player, HitInfo hitInfo)
{
    Puts("CanBeWounded вызван!");
    
    // Если возвращаемое значение не bool, вернуть null
    return null;
}
```

## OnPlayerRecover(BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок выздоровеет.
/// </summary>
/// <param name="player">Игрок, выздоровевший.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerRecover(BasePlayer player)
{
    Puts("OnPlayerRecover работает!");
    return null;
}
```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
/// <summary>
/// Вызывается при обновлении запаса товаров в автомате.
/// </summary>
/// <param name="vendingMachine">Автомат, у которого обновляется запас.</param>
/// <param name="itemDefinition">Определение товара, для которого обновляется запас (может быть null).</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDefinition)
{
    Puts("OnRefreshVendingStock работает!");
}
```

## OnItemUse(Item,int)

```csharp
/// <summary>
/// Вызывается, когда игрок использует предмет.
/// </summary>
/// <param name="item">Предмет, который использован.</param>
/// <param name="amount">Количество использованного предмета.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemUse(Item item, int amount)
{
    Puts($"Предмет {item.Name} использован в количестве {amount}");
    return null;
}
```

## CanMoveItem(Item,PlayerInventory,uint,int,int)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается переместить предмет из своего инвентаря в другой контейнер.
/// </summary>
/// <param name="item">Перемещаемый предмет.</param>
/// <param name="playerInventory">Инвентарь игрока.</param>
/// <param name="containerId">Идентификатор контейнера, куда переместить предмет.</param>
/// <param name="slot">Номер слота в инвентаре, из которого переместить предмет.</param>
/// <param name="amount">Количество предметов для перемещения.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object CanMoveItem(Item item, PlayerInventory playerInventory, uint containerId, int slot, int amount)
{
    Puts("CanMoveItem работает!");
    return null;
}
```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
Документация для хука `OnWeaponFired`

**Описание**

Хук `OnWeaponFired` вызывается при выстреле оружия игроком. Он позволяет модификаторам и плагинам реагировать на этот событие.

**Параметры**

* `BaseProjectile`: Объект-проходной пули.
* `BasePlayer`: Игрок, который произвел выстрел.
* `ItemModProjectile`: Компонент оружия, который управляет выстрелом.
* `ProtoBuf.ProjectileShoot`: Данные о выстреле.

**Использование**

Чтобы использовать этот хук, необходимо вызвать его в методе, который реагирует на событие выстрела. Например:
```csharp
Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
```
В этом примере `this` — это объект, который вызывает хук, `msg.player` — игрок, который произвел выстрел, `component` — компонент оружия, и `projectileShoot` — данные о выстреле.

**Примеры использования**

* В методе `CLProject` из примера кода, этот хук вызывается после проверки, что игрок имеет право на выстрел и что у него есть патроны.
* В плагине или модификаторе можно вызвать этот хук в методе, который реагирует на событие выстрела.

**Связанные функции**

* `VerifyClientAttack`: Функция проверки права игрока на выстрел.
* `HasReloadCooldown`: Функция проверки коoldown перезарядки оружия.
* `NoteFiredProjectile`: Функция записи данных о выстреле в базу данных.
```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игроку необходимо авторизовать таранную туретту.
/// </summary>
/// <param name="turret">Таранная туретта.</param>
/// <param name="player">Игрок, который требует авторизации.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts("OnTurretAuthorize работает!");
    return null;
}
```

## OnCupboardClearList(BuildingPrivlidge,BasePlayer)

```csharp
/// <summary>
/// Вызывается при очистке списка в шкафу.
/// </summary>
/// <param name="buildingPrivilege">Права на постройку.</param>
/// <param name="player">Игрок, выполняющий действие.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnCupboardClearList(BuildingPrivlidge buildingPrivilege, BasePlayer player)
{
    Puts("OnCupboardClearList работает!");
}
</summary>

В этом методе нет оператора return, что указывает на то, что тип возвращаемого значения равен void.
```

## CanAcceptItem(ItemContainer,Item)

```csharp
/// <summary>
/// Вызывается, когда предмет пытается быть добавлен в контейнер.
/// </summary>
/// <param name="container">Контейнер, в который пытается добавить предмет.</param>
/// <param name="item">Предмет, который пытается быть добавлен.</param>
/// <returns>Возвращает CanAcceptResult, указывающий на результат проверки.</returns>
object CanAcceptItem(ItemContainer container, Item item)
{
    Puts("CanAcceptItem вызван!");
    
    // Если предмет не может быть добавлен в контейнер по определенным причинам, вернуть соответствующий результат
    if (canAcceptItem != null && !canAcceptItem(item))
    {
        return CanAcceptResult.CannotAccept;
    }
    if ((allowedContents & item.info.itemType) != item.info.itemType)
    {
        return CanAcceptResult.CannotAccept;
    }
    if (onlyAllowedItem != null && onlyAllowedItem != item.info)
    {
        return CanAcceptResult.CannotAccept;
    }
    
    // Если контейнер имеет ограничения по количеству слотов, проверить,是否 есть доступные слоты для предмета
    if (availableSlots != null && availableSlots.Count > 0)
    {
        int[] array = new int[32];
        foreach (ItemSlot availableSlot in availableSlots)
        {
            array[(int)Mathf.Log((float)availableSlot, 2f)]++;
        }
        foreach (Item item2 in itemList)
        {
            for (int i = 0; i < 32; i++)
            {
                if (((uint)item2.info.occupySlots & (uint)(1 << i)) != 0)
                {
                    array[i]--;
                }
            }
        }
        for (int j = 0; j < 32; j++)
        {
            if (((uint)item.info.occupySlots & (uint)(1 << j)) != 0 && array[j] <= 0)
            {
                return CanAcceptResult.CannotAcceptRightNow;
            }
        }
    }
    
    // Вызвать хук CanAcceptItem, чтобы получить результат проверки
    object obj = Interface.CallHook("CanAcceptItem", container, item);
    if (obj is CanAcceptResult)
    {
        return (CanAcceptResult)obj;
    }
    return CanAcceptResult.CanAccept;
}
```

## InitLogging(unknown)

```csharp
/// <summary>
/// Вызывается при инициализации логирования.
/// </summary>
/// <param name="unknown">Неизвестный параметр.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void InitLogging(object unknown)
{
    Puts("InitLogging вызван!");
}
```

## OnCropGather(PlantEntity,Item,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок собирает плоды растения.
/// </summary>
/// <param name="plantEntity">Сущность растения.</param>
/// <param name="item">Предмет, который был собран.</param>
/// <param name="player">Игрок, который собрал плоды.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnCropGather(PlantEntity plantEntity, Item item, BasePlayer player)
{
    Puts("OnCropGather работает!");
    return null;
}
```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда пользователь включает или выключает печь.
/// </summary>
/// <param name="oven">Печь.</param>
/// <param name="player">Игрок, который включил или выключил печь.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts("OnOvenToggle работает!");
    return null;
}
```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается открыть защищенную сущность.
/// </summary>
/// <param name="player">Игрок, пытающийся открыть сущность.</param>
/// <param name="entity">Защищенная сущность.</param>
/// <returns>Возвращает true, если игрок может использовать сущность, и false в противном случае.</returns>
bool CanUseLockedEntity(BasePlayer player, CodeLock entity)
{
    Puts("CanUseLockedEntity работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnItemAction(Item,string)

```csharp
/// <summary>
/// Вызывается при выполнении действия с предметом.
/// </summary>
/// <param name="item">Предмет.</param>
/// <param name="action">Действие, выполняемое с предметом.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemAction(Item item, string action)
{
    Puts("OnItemAction работает!");
    return null;
}
```

## OnServerMessage(string,string,string,ulong)

```csharp
/// <summary>
/// Вызывается при отправке серверного сообщения.
/// </summary>
/// <param name="message">Сообщение от сервера.</param>
/// <param name="username">Имя пользователя, отправившего сообщение.</param>
/// <param name="color">Цвет текста сообщения.</param>
/// <param name="userid">ID пользователя, отправившего сообщение.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnServerMessage(string message, string username, string color, ulong userid)
{
    Puts($"Серверское сообщение: {message} от {username}");
}
```

## IOnServerUsersRemove(ulong)

```csharp
/// <summary>
/// Вызывается, когда пользователь удаляется из сервера.
/// </summary>
/// <param name="steamId">ИД пользователя.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void IOnServerUsersRemove(ulong steamId)
{
    Puts($"Пользователь с ID {steamId} удален из сервера.");
}
</promt>
```

## CanUseVending(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается использовать автомат для продажи товаров.
/// </summary>
/// <param name="vendingMachine">Автомат для продажи товаров.</param>
/// <param name="player">Игрок, пытаясь использовать автомат.</param>
/// <returns>Возвращает true, если игрок может использовать автомат, и false в противном случае.</returns>
bool CanUseVending(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("CanUseVending работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnPlayerKicked(BasePlayer,string)

```csharp
/// <summary>
/// Вызывается при выкисте игрока из сервера.
/// </summary>
/// <param name="player">Выкинутый игрок.</param>
/// <param name="reason">Причина выкиста.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerKicked(BasePlayer player, string reason)
{
    Puts($"Игрок {player.Name} выкинут из сервера за причину: {reason}");
    return null;
}
```

## CanSeeStash(StashContainer,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается увидеть содержимое ящика.
/// </summary>
/// <param name="stashContainer">Ящик, который игрок хочет увидеть.</param>
/// <param name="player">Игрок, который пытается увидеть ящик.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object CanSeeStash(StashContainer stashContainer, BasePlayer player)
{
    Puts("CanSeeStash работает!");
    return null;
}
```

## OnPlayerSpawn(BasePlayer)

```csharp
/// <summary>
/// Вызывается при спавне нового игрока.
/// </summary>
/// <param name="player">Новый игрок.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerSpawn(BasePlayer player)
{
    Puts("OnPlayerSpawn работает!");
    return null;
}
```

## CanRecycle(Recycler,Item)

```csharp
/// <summary>
/// Вызывается, чтобы определить, может ли предмет быть переработан.
/// </summary>
/// <param name="recycler">Объект, который пытается переработать предмет.</param>
/// <param name="item">Предмет, который нужно проверить на возможность переработки.</param>
/// <returns>Возвращает true, если предмет может быть переработан, и false в противном случае.</returns>
bool CanRecycle(Recycler recycler, Item item)
{
    Puts("CanRecycle работает!");
    // Код для демонстрации функциональности
    return true;
}
```

## IOnPlayerRevive(MedicalTool,BasePlayer)

```csharp
/// <summary>
/// Вызывается при попытке возродить игрока.
/// </summary>
/// <param name="medicalTool">Медицинское инструмент, используемое для возродения.</param>
/// <param name="player">Игрок, которого пытаются возродить.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object IOnPlayerRevive(MedicalTool medicalTool, BasePlayer player)
{
    Puts("IOnPlayerRevive работает!");
    return null;
}
```

## OnPlayerInit(BasePlayer)

```csharp
/// <summary>
/// Вызывается при инициализации игрока.
/// </summary>
/// <param name="player">Игрок, который был инициализирован.</param>
void OnPlayerInit(BasePlayer player)
{
    Puts("OnPlayerInit вызван!");
}
</promt>
```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
/// <summary>
/// Вызывается при деавторизации туррета.
/// </summary>
/// <param name="turret">Туррет, который был деавторизован.</param>
/// <param name="player">Игрок, который был деавторизован.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Туррет {turret} деавторизован игроком {player}");
}
</promt>
```

## OnSignUpdated(Signage,BasePlayer)

```csharp
/// <summary>
/// Вызывается при обновлении знака.
/// </summary>
/// <param name="signage">Объект знака.</param>
/// <param name="player">Игрок, который обновил знак.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnSignUpdated(Signage signage, BasePlayer player)
{
    Puts("OnSignUpdated работает!");
    return null;
}
```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
/// <summary>
/// Вызывается для проверки возможности выстрела по целевой сущности.
/// </summary>
/// <param name="entity">Целевая сущность.</param>
/// <param name="turret">Турель, из которой будет произведено выстрел.</param>
/// <returns>Возвращает true, если цель может быть поражена, и false в противном случае.</returns>
bool CanBeTargeted(BaseCombatEntity entity, HelicopterTurret turret)
{
    Puts("CanBeTargeted вызван!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
Документация для OnMeleeAttack(BasePlayer, HitInfo)

**Описание**

Функция OnMeleeAttack вызывается при выполнении атаки игрока с помощью оружия. Эта функция позволяет модулю или скрипту изменить поведение атаки или предотвратить ее.

**Параметры**

* `BasePlayer`: Игрок, который совершает атаку.
* `HitInfo`: Информация об атаке, включая позицию и скорость оружия, а также информацию о цели.

**Возвращаемые значения**

Функция возвращает null, если атака не была предотвращена или изменена. В противном случае функция возвращает значение, которое будет использовано вместо стандартного поведения атаки.

**Пример использования**

```csharp
public void OnMeleeAttack(BasePlayer player, HitInfo hitInfo)
{
    // Проверьте, является ли цель игроком
    if (hitInfo.HitEntity == player)
    {
        // Предотвратите атаку, если цель - игрок
        return;
    }

    // Измените поведение атаки, если необходимо
    hitInfo.damageProperties = new DamageProperties { Amount = 10 };
}
```

**Примечания**

* Функция OnMeleeAttack вызывается после проверки атаки на предмет нарушения правил игры.
* Если функция возвращает значение, оно будет использовано вместо стандартного поведения атаки.
* Функция не должна изменять внутренние данные или состояние игры.
```

## OnMeleeThrown(BasePlayer,Item)

```csharp
/// <summary>
/// Вызывается при броске предмета игроком.
/// </summary>
/// <param name="player">Игрок, бросивший предмет.</param>
/// <param name="item">Брошенный предмет.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnMeleeThrown(BasePlayer player, Item item)
{
    Puts($"Предмет {item.info.shortPrefabName} бросил игрок {player.UserIDString}");
}
</return_type_instructions></method_structure>

В этом методе нет оператора return, поскольку тип возвращаемого значения void.
```

## OnPlayerLand(BasePlayer,float)

```csharp
/// <summary>
/// Вызывается при приземлении игрока.
/// </summary>
/// <param name="player">Игрок, приземлившийся.</param>
/// <param name="height">Высота приземления в метрах.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerLand(BasePlayer player, float height)
{
    Puts("OnPlayerLand работает!");
    return null;
}
```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
/// <summary>
/// Вызывается, когда сущность умирает.
/// </summary>
/// <param name="entity">Умирающая сущность.</param>
/// <param name="info">Информация о смерти.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnEntityDeath(BaseCombatEntity entity, HitInfo info)
{
    Puts("OnEntityDeath работает!");
    return null;
}
```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Вызывается при открытии административного меню для автомата.
/// </summary>
/// <param name="vendingMachine">Автомат.</param>
/// <param name="player">Игрок, открывающий административное меню.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnOpenVendingAdmin работает!");
}
```

## CanBypassQueue(Network.Connection)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается пропустить очередь.
/// </summary>
/// <param name="connection">Соединение игрока.</param>
/// <returns>Возвращает <c>true</c>, если игрок может пропустить очередь, и <c>false</c> в противном случае.</returns>
bool CanBypassQueue(Network.Connection connection)
{
    Puts("CanBypassQueue вызван!");
    object obj = Interface.CallHook("CanBypassQueue", connection);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // Если игрок в списке разработчиков, он может пропустить очередь
    if (DeveloperList.Contains(connection.userid))
    {
        return true;
    }
    ServerUsers.User user = ServerUsers.Get(connection.userid);
    // Если игрок является модератором или владельцем сервера, он может пропустить очередь
    if (user != null && user.group == ServerUsers.UserGroup.Moderator)
    {
        return true;
    }
    if (user != null && user.group == ServerUsers.UserGroup.Owner)
    {
        return true;
    }
    return false;
}
```

## OnSpinWheel(BasePlayer,SpinnerWheel)

```csharp
/// <summary>
/// Вызывается при вращении колеса fortune.
/// </summary>
/// <param name="player">Игрок, который вращает колесо.</param>
/// <param name="wheel">Колесо fortune.</param>
/// <returns>Возвращает значение, которое будет использовано для определения результата вращения колеса.</returns>
object OnSpinWheel(BasePlayer player, SpinnerWheel wheel)
{
    Puts("OnSpinWheel вызван!");
    // Здесь можно добавить логику для обработки вращения колеса
    return null;
}
```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
/// <summary>
/// Вызывается при инициализации Bradley APC.
/// </summary>
/// <param name="apc">Bradley APC.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts("OnBradleyApcInitialize работает!");
}
```

## IOnServerUsersSet(ulong,ServerUsers.UserGroup,string,string)

```csharp
/// <summary>
/// Вызывается, когда пользователь добавлен или изменен в базе данных серверных пользователей.
/// </summary>
/// <param name="steamId">Идентификатор Steam пользователя.</param>
/// <param name="group">Группа пользователя.</param>
/// <param name="username">Нickname пользователя.</param>
/// <param name="notes">Примечание к пользователю.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолччанию переопределено.</returns>
object IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string username, string notes)
{
    Puts($"Пользователь {username} добавлен в группу {group} с примечанием: {notes}");
    return null;
}
```

## OnConsumeFuel(BaseOven,Item,ItemModBurnable)

```csharp
/// <summary>
/// Вызывается, когда топливо сожжено в печи.
/// </summary>
/// <param name="oven">Печь, в которой сожжено топливо.</param>
/// <param name="fuel">Топливо, сожженное в печи.</param>
/// <param name="burnable">Объект, который можно сжечь.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts("OnConsumeFuel вызван!");
}
</return_type_instructions>

<interface_callhook_analysis>
Когда вы видите код типа:
private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
{
    Interface.CallHook("OnConsumeFuel", this, fuel, burnable);
...
Обратите внимание, что `Interface.CallHook` представляет метод `OnConsumeFuel` в этом контексте. Посмотрите, как используется 'this', 'fuel' и 'burnable', чтобы определить тип возвращаемого значения. Примеры:

- Нет оператора return после Interface.CallHook -> ReturnType: void

Также учитывайте случаи типа "Interface.CallHook('OnConsumeFuel', Parameters...) == null"
</interface_callhook_analysis>

<examples>
<example1>
User: OnConsumeFuel(BaseOven,Item,ItemModBurnable)
private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
{
    Interface.CallHook("OnConsumeFuel", this, fuel, burnable);
...
RustGpt:
void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts("OnConsumeFuel вызван!");
}
</example1>
</examples>

<instructions>
1. Проанализируйте контекст на наличие использования <interface_callhook_analysis>.
2. Определите соответствующий тип возвращаемого значения на основе использования возвращаемого значения (<return_type_rules>).
3. Включите информацию о возвращаемом значении и его использовании в ваш ответ.
4. Предоставьте детализированную структуру метода с минимальным кодом для демонстрации функциональности (1-3 строки).
5. Для методов с типом возвращаемого значения void, пропустите оператор return.
6. Используйте раздел <examples> в качестве справки для понимания структуры метода и минимального кода, необходимого для демонстрации функциональности.
</instructions>
```

## IOnRconInitialize(unknown)

```csharp
/// <summary>
/// Вызывается при инициализации RCON.
/// </summary>
void IOnRconInitialize()
{
    Puts("IOnRconInitialize вызван!");
}
```

## OnQuarryEnabled(MiningQuarry)

```csharp
/// <summary>
/// Вызывается при включении или выключении шахты.
/// </summary>
/// <param name="quarry">Шахта, которая была включена или выключена.</param>
void OnQuarryEnabled(MiningQuarry quarry)
{
    Puts("OnQuarryEnabled вызван!");
}
```

## OnMessagePlayer(string,BasePlayer)

```csharp
/// <summary>
/// Вызывается при отправке игроком сообщения в чат.
/// </summary>
/// <param name="message">Отправленное сообщение.</param>
/// <param name="player">Игрок, отправивший сообщение.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Игрок {player.UserIDString} отправил в чат: {message}");
    return null;
}
```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
/// <summary>
/// Вызывается при успешном обновлении предмета.
/// </summary>
/// <param name="oldItem">Старый предмет.</param>
/// <param name="newItem">Новый обновлённый предмет.</param>
/// <param name="player">Игрок, выполнивший обновление.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemUpgrade(Item oldItem, Item newItem, BasePlayer player)
{
    Puts("OnItemUpgrade вызван!");
    // Здесь можно добавить дополнительное поведение при обновлении предмета
    return null;
}
```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject)

```csharp
/// <summary>
/// Вызывается, когда игрок попадает в ловушку.
/// </summary>
/// <param name="trigger">Триггер ловушки.</param>
/// <param name="obj">Объект, на который попал игрок.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnTrapSnapped(BaseTrapTrigger trigger, GameObject obj)
{
    Puts("Игрок попал в ловушку!");
}
```

## OnPlayerSpectate(BasePlayer,string)

```csharp
/// <summary>
/// Вызывается, когда игрок начинает наблюдать за другим игроком.
/// </summary>
/// <param name="player">Игрок, который начинает наблюдать.</param>
/// <param name="targetPlayerId">ID игрока, которого наблюдает игрок.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnPlayerSpectate(BasePlayer player, string targetPlayerId)
{
    Puts($"Игрок {player.UserIDString} начинает наблюдать за игроком {targetPlayerId}");
}
</summary>

<return_type_instructions> void </return_type_instructions>

<examples>
<example1>
Предположим, что в методе StartSpectating() вызывается OnPlayerSpectate(), а затем UpdateSpectateTarget(spectateFilter) обновляет значение spectateFilter.
В этом случае OnPlayerSpectate() будет вызван каждый раз, когда игрок начинает наблюдать за другим игроком, и spectateFilter будет обновляться в методе UpdateSpectateTarget().
</example1>
</examples>
```

## OnPlayerRespawn(BasePlayer)

```csharp
/// <summary>
/// Вызывается при возобновлении игрока.
/// </summary>
/// <param name="player">Игрок, возобновляющийся.</param>
/// <returns>Возвращает сущность SpawnPoint, если поведение по умолчанию переопределено.</returns>
object OnPlayerRespawn(BasePlayer player)
{
    Puts("OnPlayerRespawn работает!");
    return null;
}
```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
Документация для OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

**Описание хука**

Хук `OnResourceDepositCreated` вызывается после создания нового ресурсного депозита на позиции, указанной в методе `CreateFromPosition(Vector3 pos)`.

**Параметры хука**

* `resourceDeposit`: объект типа `ResourceDeposit`, представляющий новый ресурсный депозит.

**События и действия**

Когда этот хук вызывается, он уведомляет о создании нового ресурсного депозита. Этот событие может быть использовано для различных целей, таких как:

* Обновление интерфейса или графики.
* Выполнение дополнительных действий или проверок.
* Уведомление других компонентов или систем.

**Пример использования**

Например, вы можете использовать этот хук для обновления интерфейса и отображения информации о новом ресурсном депозите:

```csharp
public void OnResourceDepositCreated(ResourceDeposit resourceDeposit)
{
    // Обновить интерфейс и отобразить информацию о новом ресурсном депозите.
    Interface.Update(resourceDeposit);
}
```

**Примечания**

* Этот хук вызывается только один раз после создания нового ресурсного депозита.
* Вы можете использовать этот хук для различных целей, но убедитесь, что он не влияет на нормальное функционирование системы.
```

## OnEntityKill(BaseNetworkable)

```csharp
/// <summary>
/// Вызывается, когда сущность убита.
/// </summary>
/// <param name="entity">Убиваемая сущность.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnEntityKill(BaseNetworkable entity)
{
    Puts("OnEntityKill работает!");
    return null;
}
```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
/// <summary>
/// Вызывается, когда Брэдли APC находится в патрульном режиме.
/// </summary>
/// <param name="apc">Брэдли APC.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts("OnBradleyApcPatrol работает!");
}
```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
/// <summary>
/// Вызывается, когда патрульный вертолет пытается использовать зажигательную смесь.
/// </summary>
/// <param name="ai">Объект-патрульного вертолета.</param>
/// <returns>Возвращает true, если вертолет может использовать зажигательную смесь, и false в противном случае.</returns>
bool CanHelicopterUseNapalm(PatrolHelicopterAI ai)
{
    Puts("CanHelicopterUseNapalm работает!");
    // Если ReturnType - bool, возвращайте значение
    return true; // Или другое значение в зависимости от функциональности метода
}
```

## OnNpcPlayerTarget(NPCPlayerApex,BaseEntity)

```csharp
/// <summary>
/// Вызывается, когда NPC пытается атаковать игрока.
/// </summary>
/// <param name="npc">НПС, пытающийся атаковать.</param>
/// <param name="target">Цель атаки.</param>
/// <returns>Возвращает значение, указывающее на желание НПС атаковать игрока. Если возвращаемое значение равно 0f, НПС не будет атаковать игрока.</returns>
float OnNpcPlayerTarget(NPCPlayerApex npc, BaseEntity target)
{
    Puts("OnNpcPlayerTarget работает!");
    return 1f;
}
```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается обновить строительный блок.
/// </summary>
/// <param name="player">Игрок, пытающийся обновить строительный блок.</param>
/// <param name="block">Строительный блок, который нужно обновить.</param>
/// <param name="grade">Новая степень строительного блока.</param>
/// <returns>Возвращает true, если игрок может afford обновление, и false в противном случае.</returns>
bool CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
{
    Puts("CanAffordUpgrade работает!");
    // Если ReturnType - bool, вернуть результат вызова Interface.CallHook
    return (bool)Interface.CallHook("CanAffordUpgrade", player, block, grade);
}
```

## CanStackItem(Item,Item)

```csharp
/// <summary>
/// Вызывается, когда проверяется возможность стекаивания предмета.
/// </summary>
/// <param name="item">Предмет, который необходимо стекаить.</param>
/// <returns>Возвращает <c>true</c>, если предмет можно стекаить, и <c>false</c> в противном случае.</returns>
bool CanStackItem(Item item)
{
    Puts("CanStackItem работает!");
    return true;
}
```

## CanDemolish(BasePlayer,BuildingBlock)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается разрушить объект.
/// </summary>
/// <param name="player">Игрок, пытающийся разрушить объект.</param>
/// <param name="block">Блок, который будет разрушен.</param>
/// <returns>Возвращает true, если демонтаж возможен, и false в противном случае.</returns>
bool CanDemolish(BasePlayer player, BuildingBlock block)
{
    Puts("CanDemolish работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnFindBurnable(BaseOven)

```csharp
/// <summary>
/// Вызывается, когда необходимо найти сгораемый предмет в инвентаре.
/// </summary>
/// <param name="oven">Пекарь, который ищет сгораемый предмет.</param>
/// <returns>Возвращает найденный сгораемый предмет или null, если не найдено.</returns>
Item OnFindBurnable(BaseOven oven)
{
    Puts("OnFindBurnable вызван!");
    // Если возвращаемое значение равно Item, то вернуть его
    return (Item)obj;
}
```

## CanLock(KeyLock,BasePlayer)

```csharp
/// <summary>
/// Вызывается для проверки возможности блокировки объекта.
/// </summary>
/// <param name="lock">Объект ключевого блока.</param>
/// <param name="player">Игрок, пытаясь заблокировать объект.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object CanLock(KeyLock lock, BasePlayer player)
{
    Puts("CanLock работает!");
    return null;
}
```

## OnAirdrop(CargoPlane,UnityEngine.Vector3)

```csharp
/// <summary>
/// Вызывается при посадке грузового самолета.
/// </summary>
/// <param name="cargoPlane">Объект грузового самолета.</param>
/// <param name="dropPosition">Позиция посадки.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnAirdrop(CargoPlane cargoPlane, Vector3 dropPosition)
{
    Puts($"Грузовой самолет приземлился на позицию {dropPosition}");
}
```

## OnDoorClosed(Door,BasePlayer)

```csharp
/// <summary>
/// Вызывается после закрытия двери.
/// </summary>
/// <param name="door">Объект двери.</param>
/// <param name="player">Игрок, который закрыл дверь.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnDoorClosed(BaseDoor door, BasePlayer player)
{
    Puts("OnDoorClosed работает!");
    return null;
}
```

## OnTurretStartup(AutoTurret)

```csharp
/// <summary>
/// Вызывается при старте автотюра.
/// </summary>
/// <param name="turret">Автотюррет.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts("OnTurretStartup работает!");
    return null;
}
```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
/// <summary>
/// Вызывается при каждом тике игрока.
/// </summary>
/// <param name="player">Игрок.</param>
/// <param name="tick">Информация о тике.</param>
/// <param name="wasPlayerStalled">Было ли игрок заморожен.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerTick(BasePlayer player, PlayerTick tick, bool wasPlayerStalled)
{
    Puts("OnPlayerTick работает!");
    return null;
}
```

## CanVendingAcceptItem(VendingMachine,Item)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается положить предмет в автомат.
/// </summary>
/// <param name="vendingMachine">Автомат.</param>
/// <param name="item">Предмет, который нужно положить в автомат.</param>
/// <returns>Возвращает true, если предмет можно положить в автомат, и false в противном случае.</returns>
bool CanVendingAcceptItem(VendingMachine vendingMachine, Item item)
{
    Puts("CanVendingAcceptItem работает!");
    // Если ReturnType - bool, верните значение
    return true;
}
```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
/// <summary>
/// Вызывается, когда игрок вводит код в CodeLock.
/// </summary>
/// <param name="codeLock">Объект CodeLock.</param>
/// <param name="player">Игрок, который ввел код.</param>
/// <param name="enteredCode">Введенный код.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnCodeEntered(CodeLock codeLock, BasePlayer player, string enteredCode)
{
    Puts($"Код '{enteredCode}' введен игроком {player.UserIDString} в CodeLock {codeLock}");
}
</promt>
```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
/// <summary>
/// Вызывается, когда проверяется возможность выстрелить по игроку.
/// </summary>
/// <param name="player">Игрок.</param>
/// <param name="turret">Танкетта.</param>
/// <returns>Возвращает true, если игрок может быть целью, и false в противном случае.</returns>
bool CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts("CanBeTargeted работает!");
    // Здесь можно добавить дополнительную логику для проверки возможности выстрелить по игроку
    return true;
}
```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
/// <summary>
/// Вызывается, когда NPC пытается съесть сущность.
/// </summary>
/// <param name="npc">НПЦ, пытающийся съесть сущность.</param>
/// <param name="entity">Сущность, которую НПЦ хочет съесть.</param>
/// <returns>Возвращает true, если НПЦ может съесть сущность, и false в противном случае.</returns>
bool CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts("CanNpcEat работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
Документация для хука `OnPlayerAttack(BasePlayer, HitInfo)`:

**Описание**

Этот хук вызывается при атаке игрока на объект в мире. Он позволяет модифицировать поведение атаки и получать информацию о ней.

**Параметры**

* `BasePlayer`: Игрок, который совершает атаку.
* `HitInfo`: Информация об атаке, включая позицию и скорость объекта, на который была совершена атака.

**Возвращаемые значения**

Нет возвращаемых значений. Хук выполняется синхронно с сервером.

**Пример использования**

```csharp
public class MyPlugin : MonoBehaviour
{
    public void OnPlayerAttack(BasePlayer player, HitInfo hitInfo)
    {
        // Получить информацию об атаке
        Debug.Log("Игрок " + player.name + " атаковал объект в позиции " + hitInfo.position);

        // Модифицировать поведение атаки (например, изменить скорость или силу атаки)
        hitInfo.speed *= 2;
    }
}
```

**События**

Этот хук вызывается при следующих событиях:

* Атака игрока на объект в мире.
* Вызов функции `OnPlayerAttack` через интерфейс `Interface.CallHook`.

**Примечания**

* Этот хук выполняется синхронно с сервером, поэтому он не может вызывать асинхронные операции или изменять состояние игры напрямую.
* Если возвращаемое значение функции `OnPlayerAttack` равно null, атака будет выполнена по умолчанию.
```

## IOnEnableServerConsole(ServerConsole)

```csharp
/// <summary>
/// Вызывается при включении серверной консоли.
/// </summary>
/// <param name="console">Серверная консоль.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void IOnEnableServerConsole(ServerConsole console)
{
    Puts("IOnEnableServerConsole работает!");
}
```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
/// <summary>
/// Вызывается при отключении игрока.
/// </summary>
/// <param name="player">Игрок, который отключился.</param>
/// <param name="reason">Причина отключения.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Игрок {player.UserIDString} отключился с причиной: {reason}");
    return null;
}
```

## OnContainerDropItems(ItemContainer)

```csharp
/// <summary>
/// Вызывается при выпадении предметов из контейнера.
/// </summary>
/// <param name="container">Контейнер, из которого выпадают предметы.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnContainerDropItems(ItemContainer container)
{
    Puts("OnContainerDropItems работает!");
}
```

## OnCupboardAuthorize(BuildingPrivlidge,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игроку предоставляется доступ к шкафу.
/// </summary>
/// <param name="privilege">Права доступа к шкафу.</param>
/// <param name="player">Игрок, получивший доступ.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnCupboardAuthorize(BuildingPrivilege privilege, BasePlayer player)
{
    Puts("OnCupboardAuthorize работает!");
    return null;
}
```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда структура ремонтируется.
/// </summary>
/// <param name="entity">Объект, который ремонтируется.</param>
/// <param name="player">Игрок, который производит ремонт.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
{
    Puts("OnStructureRepair работает!");
    return null;
}
```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
/// <summary>
/// Вызывается, когда NPC атакует сущность.
/// </summary>
/// <param name="npc">НПЦ, который атакует.</param>
/// <param name="target">Сущность, которую атакует НПЦ.</param>
/// <returns>Возвращает значение, указывающее, хочет ли НПЦ атаковать сущность. Если возвращаемое значение равно 0, то НПЦ не хочет атаковать.</returns>
float OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts("OnNpcTarget вызван!");
    return 1; // Возвращает ненулевое значение, если поведение по умолчанию переопределено
}
```

## OnPlayerLanded(BasePlayer,float)

```csharp
/// <summary>
/// Вызывается, когда игрок приземляется.
/// </summary>
/// <param name="player">Игрок, приземлившийся.</param>
/// <param name="height">Высота приземления в метрах.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerLanded(BasePlayer player, float height)
{
    Puts("OnPlayerLanded работает!");
    return null;
}
```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
/// <summary>
/// Вызывается, когда патрульный вертолет пытается стрелять.
/// </summary>
/// <param name="ai">Объект-вертолет.</param>
/// <returns>Возвращает true, если стрельба разрешена, и false в противном случае.</returns>
bool CanHelicopterStrafe(PatrolHelicopterAI ai)
{
    Puts("CanHelicopterStrafe работает!");
    return true; // или другое значение в зависимости от функциональности
}
```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
/// <summary>
/// Вызывается для проверки возможности сетевого доступа к сущности.
/// </summary>
/// <param name="entity">Сущность, для которой проверяется сетевой доступ.</param>
/// <param name="player">Игрок, который пытается получить доступ.</param>
/// <returns>Возвращает true, если сетевой доступ разрешен, и false в противном случае.</returns>
bool CanNetworkTo(BaseNetworkable entity, BasePlayer player)
{
    Puts("CanNetworkTo работает!");
    return true;
}
```

## OnAddVendingOffer(VendingMachine,BasePlayer,ProtoBuf.VendingMachine.SellOrder)

```csharp
/// <summary>
/// Вызывается при добавлении предложения для автомата.
/// </summary>
/// <param name="vendingMachine">Автомат.</param>
/// <param name="player">Игрок, добавляющий предложение.</param>
/// <param name="sellOrder">Предложение.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnAddVendingOffer(VendingMachine vendingMachine, BasePlayer player, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"Предложение добавлено для автомата {vendingMachine} игроком {player}");
}
</promt>
```

## CanAssignBed(SleepingBag,BasePlayer,ulong)

```csharp
/// <summary>
/// Вызывается для проверки возможности присвоения кровати игроку.
/// </summary>
/// <param name="sleepingBag">Кровать, которую необходимо присвоить.</param>
/// <param name="player">Игрок, которому необходимо присвоить кровать.</param>
/// <param name="bedID">ИД кровати.</param>
/// <returns>Возвращает true, если присвоение возможно, и false в противном случае.</returns>
bool CanAssignBed(SleepingBag sleepingBag, BasePlayer player, ulong bedID)
{
    // Минимальный код для демонстрации функциональности
    Puts("CanAssignBed работает!");
    
    // Здесь можно добавить логика проверки возможности присвоения кровати игроку
    return true; // Возвращаем true по умолчанию
}
```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
/// <summary>
/// Вызывается после создания сущности.
/// </summary>
/// <param name="planner">Планировщик.</param>
/// <param name="gameObject">Созданная сущность.</param>
void OnEntityBuilt(Planner planner, GameObject gameObject)
{
    Puts("OnEntityBuilt вызван!");
}
```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
/// <summary>
/// Вызывается при создании предмета.
/// </summary>
/// <param name="task">Задача по созданию предмета.</param>
/// <param name="owner">Владелец, который создает предмет.</param>
/// <param name="item">Предмет, который будет создан.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnItemCraft(ItemCraftTask task, BasePlayer owner, Item item)
{
    Puts($"Игрок {owner.UserIDString} начал создавать предмет {item.info.name}");
}
</promt>
```

## OnExplosiveThrown(BasePlayer,BaseEntity)

```csharp
/// <summary>
/// Вызывается при броске взрывного устройства.
/// </summary>
/// <param name="player">Игрок, бросивший взрывное устройство.</param>
/// <param name="entity">Взрывное устройство.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
{
    Puts($"Взрывное устройство бросено игроком {player.UserIDString}.");
}
</promt>
```

## OnCreateWorldProjectile(HitInfo,Item)

```csharp
/// <summary>
/// Вызывается после создания в мире проектиля.
/// </summary>
/// <param name="info">Информация о выстреле.</param>
/// <param name="item">Проектиль.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnCreateWorldProjectile(HitInfo info, Item item)
{
    Puts("OnCreateWorldProjectile работает!");
    return null;
}
```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается изменить степень здания.
/// </summary>
/// <param name="player">Игрок, пытающийся изменить степень.</param>
/// <param name="block">Блок здания.</param>
/// <param name="grade">Новая степень здания.</param>
/// <returns>Возвращает true, если игрок имеет право на изменение степени, и false в противном случае.</returns>
bool CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
{
    Puts("CanChangeGrade вызван!");
    return true; // Или другое значение в зависимости от функциональности
}
```

## OnExplosiveDropped(BasePlayer,BaseEntity)

```csharp
/// <summary>
/// Вызывается при броске взрывного устройства.
/// </summary>
/// <param name="player">Игрок, бросивший взрывное устройство.</param>
/// <param name="explosive">Брошенное взрывное устройство.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnExplosiveDropped(BasePlayer player, BaseEntity explosive)
{
    Puts($"Взрывное устройство бросено игроком {player.displayName}.");
}
</promt>
```

## OnSurveyGather(SurveyCharge,Item)

```csharp
/// <summary>
/// Вызывается при сборе сведений о ресурсах.
/// </summary>
/// <param name="surveyCharge">Заряд для сбора сведений.</param>
/// <param name="item">Объект, который собирает сведения.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts($"Собираем сведения о ресурсах с зарядом {surveyCharge} и объектом {item}");
}
```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
/// <summary>
/// Вызывается при покупке предмета из автомата.
/// </summary>
/// <param name="vendingMachine">Автомат, из которого был куплен предмет.</param>
/// <param name="player">Игрок, который купил предмет.</param>
/// <param name="itemIndex">Индекс предмета в автомате.</param>
/// <param name="quantity">Количество купленных предметов.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer player, int itemIndex, int quantity)
{
    Puts($"Игрок {player.UserID} купил из автомата {vendingMachine.Name} предмет с индексом {itemIndex} в количестве {quantity}");
    // Добавьте сюда свой код для обработки покупки
    return null;
}
```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
/// <summary>
/// Вызывается, чтобы определить, может ли объект быть целью для таргета.
/// </summary>
/// <param name="entity">Объект, который проверяется.</param>
/// <param name="turret">Таргет, который проверяет.</param>
/// <returns>Возвращает true, если объект может быть целью, и false в противном случае.</returns>
bool CanBeTargeted(BaseCombatEntity entity, AutoTurret turret)
{
    Puts("CanBeTargeted вызван!");
    return (bool)Interface.CallHook("CanBeTargeted", entity, turret);
}
```

## CanBuild(Planner,Construction,UnityEngine.Vector3)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается построить объект.
/// </summary>
/// <param name="planner">Планировщик.</param>
/// <param name="construction">Объект для постройки.</param>
/// <param name="position">Позиция, где будет построен объект.</param>
/// <returns>Возвращает true, если постройка разрешена, и false в противном случае.</returns>
bool CanBuild(Planner planner, Construction construction, UnityEngine.Vector3 position)
{
    // Минимальный код для демонстрации функциональности
    return true;
}
```

## OnEntitySpawned(BaseNetworkable)

```csharp
/// <summary>
/// Вызывается, когда сущность спавнивается.
/// </summary>
/// <param name="entity">Сущность, которая была спавнена.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnEntitySpawned(BaseNetworkable entity)
{
    Puts("OnEntitySpawned вызван!");
    return null;
}
```

## OnItemPickup(Item,BasePlayer)

```csharp
/// <summary>
/// Вызывается при подхвате предмета игроком.
/// </summary>
/// <param name="item">Подхваченный предмет.</param>
/// <param name="player">Игрок, который подхватил предмет.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemPickup(Item item, BasePlayer player)
{
    Puts("OnItemPickup работает!");
    return null;
}
```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
/// <summary>
/// Вызывается для проверки возможности целигования патрульного вертолета по игроку.
/// </summary>
/// <param name="helicopterAI">Объект AI вертолета.</param>
/// <param name="player">Игрок, который может быть целью.</param>
/// <returns>Возвращает true, если игрок может быть целью для патрульного вертолета, иначе false.</returns>
bool CanHelicopterTarget(PatrolHelicopterAI helicopterAI, BasePlayer player)
{
    Puts("CanHelicopterTarget работает!");
    // Здесь можно добавить дополнительную логику для проверки возможности целигования
    return true; // Возвращаем значение по умолчанию
}
```

## OnPlayerConnected(Network.Message)

```csharp
/// <summary>
/// Вызывается, когда игрок подключается к серверу.
/// </summary>
/// <param name="message">Информация о подключении игрока.</param>
/// <returns>Возвращает информацию о подключении игрока.</returns>
object OnPlayerConnected(Network.Message message)
{
    Puts("Игрок подключился!");
    return message;
}
```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Вызывается при повороте автомата для продажи.
/// </summary>
/// <param name="vendingMachine">Автомат для продажи.</param>
/// <param name="player">Игрок, который пытается повернуть автомат.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnRotateVendingMachine работает!");
    return null;
}
```

## CanChangeCode(CodeLock,BasePlayer,string,bool)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается изменить код.
/// </summary>
/// <param name="lock">Кодовый замок.</param>
/// <param name="player">Игрок, пытающийся изменить код.</param>
/// <param name="newCode">Новый код.</param>
/// <param name="isGuest">Флаг, указывающий, что это гостевой код.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object CanChangeCode(CodeLock lock, BasePlayer player, string newCode, bool isGuest)
{
    Puts("CanChangeCode работает!");
    return null;
}
```

## CanUnlock(KeyLock,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается открыть замок.
/// </summary>
/// <param name="lock">Замок, который нужно открыть.</param>
/// <param name="player">Игрок, пытающийся открыть замок.</param>
/// <returns>Возвращает true, если замок можно открыть, и false в противном случае.</returns>
bool CanUnlock(KeyLock lock, BasePlayer player)
{
    Puts("CanUnlock работает!");
    return true;
}
```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
/// <summary>
/// Вызывается, когда игрок закончил лутить сущность.
/// </summary>
/// <param name="player">Игрок, который закончил лутить.</param>
/// <param name="storageContainer">Хранилище контейнеров, в котором хранятся предметы.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnLootEntityEnd(BasePlayer player, StorageContainer storageContainer)
{
    Puts("OnLootEntityEnd работает!");
    return null;
}
```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
/// <summary>
/// Вызывается, когда игрок наносит удар молотом.
/// </summary>
/// <param name="player">Игрок, наносящий удар.</param>
/// <param name="hitInfo">Информация о точке удара.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnHammerHit(BasePlayer player, HitInfo hitInfo)
{
    Puts("OnHammerHit работает!");
    return null;
}
```

## OnEntityGroundMissing(BaseEntity)

```csharp
/// <summary>
/// Вызывается, когда сущность теряет связь с землей.
/// </summary>
/// <param name="entity">Сущность, потерявшая связь с землей.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnEntityGroundMissing(BaseEntity entity)
{
    Puts("OnEntityGroundMissing работает!");
    return null;
}
```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
/// <summary>
/// Вызывается при изменении здоровья игрока.
/// </summary>
/// <param name="player">Игрок, у которого изменился здоровье.</param>
/// <param name="oldHealth">Старое значение здоровья игрока.</param>
/// <param name="newHealth">Новое значение здоровья игрока.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Здоровье игрока {player.UserIDString} изменилось с {oldHealth} до {newHealth}");
    return null;
}
```

## OnClientAuth(Network.Connection)

```csharp
/// <summary>
/// Вызывается при авторизации клиента.
/// </summary>
/// <param name="connection">Информация о подключении.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnClientAuth(Network.Connection connection)
{
    Puts("OnClientAuth вызван!");
}
```

## IOnStructureDemolish(BuildingBlock,BasePlayer)

```csharp
/// <summary>
/// Вызывается при демонтаже структуры.
/// </summary>
/// <param name="block">Блок, который будет разрушен.</param>
/// <param name="player">Игрок, выполняющий демонтаж.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object IOnStructureDemolish(BuildingBlock block, BasePlayer player)
{
    Puts("IOnStructureDemolish работает!");
    return null;
}
```

## IOnLootPlayer(PlayerLoot,BasePlayer)

```csharp
/// <summary>
/// Вызывается при начале поиска лута у игрока.
/// </summary>
/// <param name="loot">Объект с информацией о луте.</param>
/// <param name="player">Игрок, у которого происходит поиск лута.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object IOnLootPlayer(PlayerLoot loot, BasePlayer player)
{
    Puts("IOnLootPlayer работает!");
    return null;
}
```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда патрульный вертолет проверяет возможность стрелять по цели.
/// </summary>
/// <param name="ai">Объект AI патрульного вертолета.</param>
/// <param name="target">Цель для стрельбы.</param>
/// <returns>Возвращает true, если цель доступна для стрельбы, и false в противном случае.</returns>
bool CanHelicopterStrafeTarget(PatrolHelicopterAI ai, BasePlayer target)
{
    Puts("CanHelicopterStrafeTarget работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnItemDeployed(Deployer,BaseEntity)

```csharp
/// <summary>
/// Вызывается после успешного развертывания предмета на сущности.
/// </summary>
/// <param name="deployer">Объект, который выполнил действие.</param>
/// <param name="entity">Сущность, на которую был развернут предмет.</param>
/// <returns>Возвращает объект, если поведение по умолчанию переопределено.</returns>
object OnItemDeployed(Deployer deployer, BaseEntity entity)
{
    Puts("OnItemDeployed работает!");
    return null;
}
```

## OnSignLocked(Signage,BasePlayer)

```csharp
/// <summary>
/// Вызывается при блокировке знака.
/// </summary>
/// <param name="sign">Знак, который был заблокирован.</param>
/// <param name="player">Игрок, который заблокировал знак.</param>
object OnSignLocked(Signage sign, BasePlayer player)
{
    Puts("OnSignLocked работает!");
    return null;
}
```

## CanUnlock(CodeLock,BasePlayer)

```csharp
/// <summary>
/// Вызывается для проверки возможности разблокировать кодовый замок.
/// </summary>
/// <param name="lock">Кодовый замок.</param>
/// <param name="player">Игрок, пытаясь разблокировать замок.</param>
/// <returns>Возвращает true, если игрок может разблокировать замок, и false в противном случае.</returns>
bool CanUnlock(CodeLock lock, BasePlayer player)
{
    Puts("CanUnlock вызван!");
    // Здесь можно добавить дополнительную логику для проверки возможности разблокирования
    return true; // или false в зависимости от условий
}
```

## CanUpdateSign(BasePlayer,Signage)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается обновить знак.
/// </summary>
/// <param name="player">Игрок, пытающийся обновить знак.</param>
/// <param name="signage">Знак, который нужно обновить.</param>
/// <returns>Возвращает true, если игрок может обновить знак, и false в противном случае.</returns>
bool CanUpdateSign(BasePlayer player, Signage signage)
{
    Puts("CanUpdateSign вызван!");
    // Если ReturnType - bool, верните значение
    return true;
}
```

## OnPlayerLootEnd(PlayerLoot)

```csharp
/// <summary>
/// Вызывается, когда игрок завершает процесс поиска и сбора предметов.
/// </summary>
/// <param name="loot">Объект PlayerLoot, представляющий процесс поиска и сбора предметов.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnPlayerLootEnd(PlayerLoot loot)
{
    Puts("Процесс поиска и сбора предметов завершен!");
}
```

## OnDeleteVendingOffer(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Вызывается при удалении предложения продажи из vending machine.
/// </summary>
/// <param name="vendingMachine">ВENDING MACHINE, с которого удаляется предложение.</param>
/// <param name="player">Игрок, который удаляет предложение.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnDeleteVendingOffer работает!");
}
```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
/// <summary>
/// Вызывается для проверки возможности использования ящика игроком.
/// </summary>
/// <param name="player">Игрок, пытаясь использовать ящик.</param>
/// <param name="mailbox">Ящик, который должен быть использован.</param>
/// <returns>Возвращает true, если игрок может использовать ящик, и false в противном случае.</returns>
bool CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts("CanUseMailbox работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnPlayerRespawned(BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок возобновляет свою деятельность после смерти.
/// </summary>
/// <param name="player">Игрок, возобновляющий свою деятельность.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts("Игрок возобновил свою деятельность!");
}
```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
/// <summary>
/// Вызывается при использовании предмета для лечения.
/// </summary>
/// <param name="tool">Предмет для лечения.</param>
/// <param name="player">Игрок, получающий лечение.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnHealingItemUse(MedicalTool tool, BasePlayer player)
{
    Puts("OnHealingItemUse работает!");
    return null;
}
```

## OnItemRepair(BasePlayer,Item)

```csharp
/// <summary>
/// Вызывается при попытке отремонтировать предмет.
/// </summary>
/// <param name="player">Игрок, пытается отремонтировать предмет.</param>
/// <param name="item">Предмет, который нужно отремонтировать.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemRepair(BasePlayer player, Item item)
{
    Puts("OnItemRepair работает!");
    return null;
}
```

## IOnLootItem(PlayerLoot,Item)

```csharp
/// <summary>
/// Вызывается при начале поиска предметов в контейнере.
/// </summary>
/// <param name="loot">Объект с информацией о контейнере.</param>
/// <param name="item">Предмет, который находится в контейнере.</param>
object IOnLootItem(PlayerLoot loot, Item item)
{
    Puts("IOnLootItem вызван!");
    // Добавьте здесь код для реализации логики хука
}
</promt>
```

## OnRecycleItem(Recycler,Item)

```csharp
Документация для метода `OnRecycleItem`:

```rust
/// <summary>
/// Вызывается, когда игрок пытается разобрать предмет.
/// </summary>
/// <param name="recycler">Объект, который разбирает предмет.</param>
/// <param name="item">Предмет, который нужно разобрать.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnRecycleItem(Recycler recycler, Item item)
{
    // Минимальный код для демонстрации функциональности
}
```

Тип возвращаемого значения: `void` (предполагается, что метод не возвращает никаких данных).

Использование: Этот хук вызывается в методе `RecycleThink`, когда игрок пытается разобрать предмет. Если этот хук возвращает значение, которое отлично от null, то процесс разбора будет остановлен.

Примечание: В документации указано, что тип возвращаемого значения равен void, но на самом деле метод не имеет оператора return, поэтому он фактически возвращает значение по умолчанию (null).
```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
/// <summary>
/// Вызывается, когда сущность покидает область.
/// </summary>
/// <param name="entity">Сущность, покидающая область.</param>
/// <param name="leavingEntity">Сущность, покидающая область.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnEntityLeave(TriggerBase entity, BaseEntity leavingEntity)
{
    Puts("OnEntityLeave работает!");
    return null;
}
```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается открыть защищенную сущность.
/// </summary>
/// <param name="player">Игрок, пытающийся открыть сущность.</param>
/// <param name="lock">Замок, который необходимо проверить.</param>
/// <returns>Возвращает true, если игрок может использовать защищенную сущность, и false в противном случае.</returns>
bool CanUseLockedEntity(BasePlayer player, KeyLock lock)
{
    Puts("CanUseLockedEntity работает!");
    // Если HasLockPermission(player) == true или IsLocked() == false, вернуть true
    return HasLockPermission(player) || !IsLocked();
}
```

## OnTick(unknown)

```csharp
/// <summary>
/// Вызывается каждый тик (цикл обновления игры).
/// </summary>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnTick()
{
    Puts("OnTick вызван!");
}
```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
/// <summary>
/// Вызывается, когда предмет добавляется в контейнер.
/// </summary>
/// <param name="container">Контейнер, в который был добавлен предмет.</param>
/// <param name="item">Добавленный предмет.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts("OnItemAddedToContainer работает!");
    return null;
}
```

## OnTerrainInitialized(unknown)

```csharp
/// <summary>
/// Вызывается после инициализации террена.
/// </summary>
/// <param name="unknown">Неизвестный параметр.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnTerrainInitialized(object unknown)
{
    Puts("OnTerrainInitialized вызван!");
}
```

## OnPlayerSleepEnded(BasePlayer)

```csharp
/// <summary>
/// Вызывается после того, как игрок закончил спать.
/// </summary>
/// <param name="player">Игрок, который закончил спать.</param>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts("OnPlayerSleepEnded вызван!");
}
</return_type_instructions>
```

## OnMaxStackable(Item)

```csharp
/// <summary>
/// Вызывается при определении максимального количества предметов, которые можно хранить в стоке.
/// </summary>
/// <param name="item">Предмет, для которого определяется максимальное количество.</param>
/// <returns>Возвращает максимальное количество предметов, которое можно хранить в стоке. Если поведение по умолчанию переопределено, возвращается ненулевое значение.</returns>
object OnMaxStackable(Item item)
{
    Puts("OnMaxStackable работает!");
    return null;
}
```

## CanWearItem(PlayerInventory,Item)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается надеть предмет.
/// </summary>
/// <param name="inventory">Инвентарь игрока.</param>
/// <param name="item">Предмет, который хочет надеть игрок.</param>
/// <returns>Возвращает true, если предмет можно надеть, и false в противном случае.</returns>
object CanWearItem(PlayerInventory inventory, Item item)
{
    Puts("CanWearItem вызван!");
    
    // Если возвращаемое значение не равно null, то метод переопределен
    object obj = Interface.CallHook("CanWearItem", this, item);
    if (obj is bool)
    {
        return (bool)obj;
    }
    
    // Если предмет можно надеть, то возвращаем true
    return true;
}
```

## IOnUserApprove(Network.Connection)

```csharp
/// <summary>
/// Вызывается, когда пользователь подтверждается после проверки соединения.
/// </summary>
/// <param name="connection">Соединение пользователя.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object IOnUserApprove(Network.Connection connection)
{
    Puts("IOnUserApprove работает!");
    return null;
}
```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
/// <summary>
/// Вызывается при выдаче бонуса из ресурсного диспенсера.
/// </summary>
/// <param name="dispenser">Ресурсный диспенсер, из которого был получен бонус.</param>
/// <param name="player">Игрок, которому был выдан бонус.</param>
/// <param name="item">Выданное бонусное предмет.</param>
/// <returns>Возвращает выданное бонусное предмет или null, если поведение по умолчанию не переопределено.</returns>
Item OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts("OnDispenserBonus вызван!");
    return item;
}
```

## OnRconConnection(System.Net.IPEndPoint)

```csharp
/// <summary>
/// Вызывается, когда клиент подключается к серверу по RCON.
/// </summary>
/// <param name="endpoint">Адрес и порт клиента.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnRconConnection(System.Net.IPEndPoint endpoint)
{
    Puts("OnRconConnection вызван!");
    return null;
}
```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
/// <summary>
/// Вызывается, когда сущность входит в зону действия триггера.
/// </summary>
/// <param name="trigger">Триггер, на который вшла сущность.</param>
/// <param name="entity">Вошедшая сущность.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Сущность {entity} вошла в зону действия триггера {trigger}");
}
</summary>

<return_type_instructions> void </return_type_instructions>
```

## OnItemCraftCancelled(ItemCraftTask)

```csharp
/// <summary>
/// Вызывается при отмене задачи по изготовлению предмета.
/// </summary>
/// <param name="task">Задача по изготовлению предмета.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnItemCraftCancelled(ItemCraftTask task)
{
    Puts($"Задача по изготовлению '{task.blueprint.targetItem}' отменена.");
}
```

## OnTurretShutdown(AutoTurret)

```csharp
/// <summary>
/// Вызывается при завершении работы туррета.
/// </summary>
/// <param name="turret">Туррет, который завершил работу.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTurretShutdown(AutoTurret turret)
{
    Puts("OnTurretShutdown работает!");
    return null;
}
```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
/// <summary>
/// Вызывается при включении или выключении ретайлера.
/// </summary>
/// <param name="recycler">Ретайлер.</param>
/// <param name="player">Игрок, который выполнил действие.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts("OnRecyclerToggle работает!");
    return null;
}
```

## OnPlayerChat(ConsoleSystem.Arg)

```csharp
Документация для OnPlayerChat(ConsoleSystem.Arg)

**Описание**

Функция вызывается при отправке игроком сообщения в чат.

**Параметры**

* `arg`: Объект ConsoleSystem.Arg, содержащий информацию о сообщении.

**Возвращаемые значения**

Нет.

**Событие**

Этот хук вызывается в методе `say` класса `ServerUserVar`.

**Описание логики**

Функция проверяет, можно ли игроку отправлять сообщение. Если чат отключен или игрок мутован, функция возвращает и не выполняет никаких действий.

Если игрок не администратор и не разработчик, функция проверяет, сколько времени прошло с последнего сообщения игрока. Если это время меньше 30 секунд, функция добавляет время ожидания до следующего сообщения игрока.

Если сообщение содержит запрещенные символы или начинается с символов "/", "\", функция возвращает и не выполняет никаких действий.

Если все проверки пройдены, функция отправляет сообщение в чат и записывает его в лог файл.

**Использование**

Этот хук можно использовать для расширения функционала чата или добавления новых правил для отправки сообщений.
```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
/// <summary>
/// Вызывается, когда игрок перестает смотреть на другого игрока.
/// </summary>
/// <param name="player">Игрок, который перестал смотреть.</param>
/// <param name="spectateFilter">Фильтр смотрения.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
{
    Puts($"Игрок {player.UserIDString} перестал смотреть на другого игрока.");
}
</summary>

<return_type_instructions> void </return_type_instructions>
```

## IOnLootEntity(PlayerLoot,BaseEntity)

```csharp
/// <summary>
/// Вызывается при начале поиска лута на сущности.
/// </summary>
/// <param name="looter">Игрок, который начинает поиск лута.</param>
/// <param name="entity">Сущность, на которой начинается поиск лута.</param>
object IOnLootEntity(PlayerLoot looter, BaseEntity entity)
{
    Puts("IOnLootEntity вызван!");
    // Здесь можно добавить дополнительную логическую или физическую обработку при начале поиска лута
    return null;
}
```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается активировать ловушку.
/// </summary>
/// <param name="trap">Ловушка.</param>
/// <param name="player">Игрок, пытающийся активировать ловушку.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts("OnTrapArm работает!");
    return null;
}
```

## OnItemSplit(Item,int)

```csharp
/// <summary>
/// Вызывается при разделении предмета.
/// </summary>
/// <param name="item">Объект, который будет разделен.</param>
/// <param name="splitAmount">Количество предметов, которое будет разделено.</param>
/// <returns>Возвращает разделенный предмет, если поведение по умолчанию переопределено.</returns>
object OnItemSplit(Item item, int splitAmount)
{
    Puts("OnItemSplit работает!");
    return null;
}
```

## IOnLoseCondition(Item,float)

```csharp
/// <summary>
/// Вызывается, когда условие теряется.
/// </summary>
/// <param name="item">Объект, у которого теряется условие.</param>
/// <param name="amount">Количество потерянного условия.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts("IOnLoseCondition работает!");
    return null;
}
```

## IOnStructureImmediateDemolish(BuildingBlock,BasePlayer)

```csharp
/// <summary>
/// Вызывается при немедленном разрушении структуры.
/// </summary>
/// <param name="block">Блок структуры.</param>
/// <param name="player">Игрок, выполнивший демонтаж.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object IOnStructureImmediateDemolish(BuildingBlock block, BasePlayer player)
{
    Puts("IOnStructureImmediateDemolish работает!");
    return null;
}
```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
/// <summary>
/// Вызывается при попытке снять мины.
/// </summary>
/// <param name="landmine">Мина.</param>
/// <param name="player">Игрок, пытаясь снять мину.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts("OnTrapDisarm работает!");
    return null;
}
```

## CanNpcAttack(BaseNpc,BaseEntity)

```csharp
/// <summary>
/// Вызывается, когда NPC готовится атаковать сущность.
/// </summary>
/// <param name="npc">НПС, который готовится атаковать.</param>
/// <param name="target">Сущность, которую НПС готовится атаковать.</param>
/// <returns>Возвращает true, если атака разрешена, и false в противном случае.</returns>
bool CanNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts("CanNpcAttack работает!");
    // Здесь можно добавить логическую логику для определения возможности атаки
    return true;
}
```

## OnReloadWeapon(BasePlayer,BaseProjectile)

```csharp
/// <summary>
/// Вызывается при перезарядке оружия.
/// </summary>
/// <param name="player">Игрок, который перезарядает оружие.</param>
/// <param name="projectile">Производимый снаряд.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
{
    Puts("OnReloadWeapon работает!");
    return null;
}
```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int)

```csharp
/// <summary>
/// Вызывается при совершении транзакции с автоматом.
/// </summary>
/// <param name="vendingMachine">Автомат.</param>
/// <param name="buyer">Купивший игрок.</param>
/// <param name="sellOrderId">Идентификатор продажи.</param>
/// <param name="numberOfTransactions">Количество транзакций.</param>
/// <returns>Возвращает true, если транзакция прошла успешно, и false в противном случае.</returns>
bool OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions)
{
    // Минимальный код для демонстрации функциональности
    return true;
}
```

## OnPlayerWound(BasePlayer)

```csharp
/// <summary>
/// Вызывается при получении игроком ранения.
/// </summary>
/// <param name="player">Игрок, получивший ранение.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnPlayerWound(BasePlayer player)
{
    Puts("OnPlayerWound работает!");
    return null;
}
```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
/// <summary>
/// Вызывается, когда игрок закончил лутить сущность.
/// </summary>
/// <param name="player">Игрок, который закончил лутить.</param>
/// <param name="lootableCorpse">Сущность, которую лутил игрок.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts("OnLootEntityEnd работает!");
}
```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
/// <summary>
/// Вызывается, когда таргет для туррета изменяется.
/// </summary>
/// <param name="turret">Туррет, чей таргет изменился.</param>
/// <param name="entity">Новый таргет туррета.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
{
    Puts("OnTurretTarget работает!");
    return null;
}
```

## OnQuarryGather(MiningQuarry,Item)

```csharp
/// <summary>
/// Вызывается, когда ресурс собран из шахты.
/// </summary>
/// <param name="quarry">Шахта, из которой был собран ресурс.</param>
/// <param name="item">Собранный ресурс.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts("OnQuarryGather работает!");
    return null;
}
```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
Документация для IOnBasePlayerAttacked(BasePlayer, HitInfo)

**Описание**

Этот хук вызывается при атаке игрока BasePlayer. Он позволяет модификаторам или плагинам изменить поведение игрока в момент атаки.

**Параметры**

* `BasePlayer`: Игрок, который был атакован.
* `HitInfo`: Информация о хите, включая точку начала и конца хита, тип повреждения и т. д.

**Возвращаемые значения**

Хук не возвращает никаких значений.

**Пример использования**

Чтобы использовать этот хук, необходимо вызвать его из метода OnAttacked(HitInfo info) игрока BasePlayer:
```csharp
public override void OnAttacked(HitInfo info)
{
    if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
    {
        return;
    }
    // код атаки игрока...
}
```
**Примечания**

* Этот хук вызывается только на сервере.
* Если в методе OnAttacked(HitInfo info) не будет вызвана эта функция, то она будет вызвана автоматически.
```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
/// <summary>
/// Вызывается при повороте структуры.
/// </summary>
/// <param name="block">Блок, который был использован для поворота.</param>
/// <param name="player">Игрок, который выполнил поворот.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnStructureRotate(BuildingBlock block, BasePlayer player)
{
    Puts("OnStructureRotate вызван!");
}
</promt>
```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
/// <summary>
/// Вызывается, когда игрок трогает ловушку.
/// </summary>
/// <param name="trap">Ловушка, которую тронул игрок.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTrapTrigger(BearTrap trap, UnityEngine.GameObject obj)
{
    Puts("OnTrapTrigger работает!");
    return null;
}
```

## OnItemCraftFinished(ItemCraftTask,Item)

```csharp
/// <summary>
/// Вызывается после завершения процесса создания предмета.
/// </summary>
/// <param name="task">Задача создания предмета.</param>
/// <param name="item">Созданный предмет.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnItemCraftFinished(ItemCraftTask task, Item item)
{
    Puts($"Процесс создания предмета завершен: {item.info.itemid}");
}
```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
/// <summary>
/// Вызывается при активации ловушки.
/// </summary>
/// <param name="landmine">Объект-ловушка.</param>
/// <param name="gameObject">Игрок, который активировал ловушку.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnTrapTrigger(Landmine landmine, UnityEngine.GameObject gameObject)
{
    Puts("OnTrapTrigger работает!");
    return null;
}
```

## OnLiftUse(Lift,BasePlayer)

```csharp
/// <summary>
/// Вызывается при использовании лифта игроком.
/// </summary>
/// <param name="lift">Объект лифта.</param>
/// <param name="player">Игрок, использующий лифт.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnLiftUse(Lift lift, BasePlayer player)
{
    Puts("OnLiftUse работает!");
    return null;
}
```

## CanCraft(ItemCrafter,ItemBlueprint,int)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается создать предмет.
/// </summary>
/// <param name="craftTask">Задача создания.</param>
/// <param name="blueprint">Схема создаваемого предмета.</param>
/// <param name="amount">Количество создаваемых предметов.</param>
/// <returns>Возвращает true, если создание возможно, и false в противном случае.</returns>
bool CanCraft(ItemCrafter craftTask, ItemBlueprint blueprint, int amount)
{
    Puts("CanCraft вызван!");
    
    // Если количество создаваемых предметов не находится в диапазоне от 1 до 9000, вернуть false
    if (amount < 1 || amount > 9000)
    {
        return false;
    }
    
    // Вызвать хук CanCraft и получить результат
    object result = Interface.CallHook("CanCraft", craftTask, blueprint, amount);
    
    // Если результат является bool, вернуть его значение
    if (result is bool)
    {
        return (bool)result;
    }
    
    // Проверить наличие необходимых ингредиентов для создания предмета
    foreach (ItemAmount ingredient in blueprint.ingredients)
    {
        if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
        {
            return false;
        }
    }
    
    // Если все проверки пройдены, вернуть true
    return true;
}
```

## OnItemResearch(Item,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок начинает исследовать предмет.
/// </summary>
/// <param name="item">Исследуемый предмет.</param>
/// <param name="player">Игрок, который проводит исследование.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnItemResearch(Item item, BasePlayer player)
{
    Puts("OnItemResearch работает!");
    return null;
}
```

## IOnDisableServerConsole(unknown)

```csharp
/// <summary>
/// Вызывается при отключении сервера.
/// </summary>
/// <param name="unknown">Неизвестный параметр.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void IOnDisableServerConsole(object unknown)
{
    Puts("IOnDisableServerConsole вызван!");
}
```

## CanHideStash(StashContainer,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается спрятать контейнер.
/// </summary>
/// <param name="stash">Контейнер, который нужно спрятать.</param>
/// <param name="player">Игрок, пытающийся спрятать контейнер.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object CanHideStash(StashContainer stash, BasePlayer player)
{
    Puts("CanHideStash работает!");
    return null;
}
```

## OnRunPlayerMetabolism(PlayerMetabolism,BaseCombatEntity,float)

```csharp
Документация для хука `OnRunPlayerMetabolism`

**Описание**

Хук `OnRunPlayerMetabolism` вызывается в методе `RunMetabolism` и позволяет модифицировать метаболизм игрока.

**Сигнатура**

`void OnRunPlayerMetabolism(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)`

**Параметры**

* `playerMetabolism`: Объект `PlayerMetabolism`, который содержит информацию о метаболизме игрока.
* `ownerEntity`: Объект `BaseCombatEntity`, который представляет собой игрока.
* `delta`: Плавающая точка, которая представляет собой время между последним и текущим кадрами.

**Возвращаемые значения**

Нет возвращаемых значений.

**Описание хука**

Хук `OnRunPlayerMetabolism` позволяет модифицировать метаболизм игрока. Он вызывается в методе `RunMetabolism` и может быть использован для изменения различных параметров, таких как температура, комфорт, голодание, отравление и т.д.

**Пример использования**

Например, вы можете использовать хук для увеличения температуры игрока на 10 градусов:
```csharp
void OnRunPlayerMetabolism(PlayerMetabolism playerMetabolism, BaseCombatEntity ownerEntity, float delta)
{
    playerMetabolism.temperature.value += 10f;
}
```
**Примечания**

Хук `OnRunPlayerMetabolism` вызывается в методе `RunMetabolism`, который является частью системы метаболизма игрока. Поэтому, если вы хотите модифицировать метаболизм игрока, вам необходимо использовать этот хук.

Также обратите внимание, что хук `OnRunPlayerMetabolism` не возвращает никаких значений, поэтому вы не можете использовать его для изменения состояния игрока.
```

## OnBradleyApcHunt(BradleyAPC)

```csharp
/// <summary>
/// Вызывается, когда Bradley APC находится в охотничьем режиме.
/// </summary>
/// <param name="bradleyApc">Bradley APC.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnBradleyApcHunt(BradleyAPC bradleyApc)
{
    Puts("OnBradleyApcHunt работает!");
}
```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
/// <summary>
/// Вызывается, когда игрок пытается открыть лут для другого игрока.
/// </summary>
/// <param name="looter">Игрок, пытающийся открыть лут.</param>
/// <param name="targetPlayer">Игрок, для которого открывается лут.</param>
/// <returns>Возвращает true, если лут можно открыть, и false в противном случае.</returns>
bool CanLootPlayer(BasePlayer looter, BasePlayer targetPlayer)
{
    Puts("CanLootPlayer работает!");
    // Если тип возвращаемого значения не bool, вернуть значение по умолчанию
    return true;
}
```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
/// <summary>
/// Вызывается для проверки возможности цели Bradley APC.
/// </summary>
/// <param name="apc">Bradley APC.</param>
/// <param name="target">Цель.</param>
/// <returns>Возвращает true, если цель доступна для атаки, и false в противном случае.</returns>
bool CanBradleyApcTarget(BradleyAPC apc, BaseEntity target)
{
    Puts("CanBradleyApcTarget работает!");
    return true; // Возвращаемое значение по умолчанию
}
```

## OnMapImageUpdated(unknown)

```csharp
/// <summary>
/// Вызывается, когда картинка на карте обновлена.
/// </summary>
/// <param name="imageData">Данные картинки.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnMapImageUpdated(object imageData)
{
    Puts("Картинка на карте обновлена!");
}
```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
/// <summary>
/// Вызывается для проверки возможности объединения двух предметов на земле.
/// </summary>
/// <param name="item1">Первый предмет.</param>
/// <param name="item2">Второй предмет.</param>
/// <returns>Возвращает true, если предметы можно объединить, иначе false.</returns>
bool CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts("CanCombineDroppedItem работает!");
    // Здесь вы можете добавить дополнительную логику для проверки возможности объединения предметов
    return true; // Возвращаем true, если предметы можно объединить
}
```

## OnOpenVendingShop(VendingMachine,BasePlayer)

```csharp
/// <summary>
/// Вызывается при открытии автомата.
/// </summary>
/// <param name="vendingMachine">Автомат.</param>
/// <param name="player">Игрок, открывающий автомат.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnOpenVendingShop(VendingMachine vendingMachine, BasePlayer player)
{
    Puts("OnOpenVendingShop работает!");
    return null;
}
```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
/// <summary>
/// Вызывается, когда игрок вводит команду в консоли.
/// </summary>
/// <param name="arg">Аргументы команды.</param>
/// <returns>Возвращает <c>true</c>, если команда была успешно выполнена, и <c>false</c> в противном случае.</returns>
bool IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts("IOnServerCommand вызван!");
    
    // Если возвращаемое значение не равно null, то возвращаем его
    return (bool)Interface.CallHook("IOnServerCommand", arg);
}
```

## IOnRunCommandLine(unknown)

```csharp
/// <summary>
/// Вызывается перед обновлением значений из командной строки.
/// </summary>
/// <param name="args">Аргументы командной строки.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object IOnRunCommandLine(object args)
{
    Puts("IOnRunCommandLine работает!");
    return null;
}
```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
/// <summary>
/// Вызывается, когда игрок kicked.
/// </summary>
/// <param name="player">Игрок, которого kickнули.</param>
/// <param name="reason">Причина kickа.</param>
/// <returns>Возвращает ненулевое значение, если поведение по умолчанию переопределено.</returns>
object OnUserKicked(IPlayer player, string reason)
{
    Puts($"Игрок {player.Name} kicked за причину: {reason}");
    return null;
}
```

## OnPlayerUnbanned(string,ulong,string)

```csharp
/// <summary>
/// Вызывается, когда игрок снят из списка забаненных пользователей.
/// </summary>
/// <param name="name">Имя игрока.</param>
/// <param name="steamId">Steam ID игрока.</param>
/// <param name="address">Адрес IP игрока.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnPlayerUnbanned(string name, ulong steamId, string address)
{
    Puts($"Игрок {name} снят из списка забаненных пользователей.");
}
</assistant
```

## OnUserBanned(string,string,string,string)

```csharp
/// <summary>
/// Вызывается, когда пользователь заблокирован.
/// </summary>
/// <param name="name">Имя пользователя.</param>
/// <param name="steamId">ID Steam пользователя.</param>
/// <param name="address">Адрес IP пользователя.</param>
/// <param name="reason">Причина блокировки.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnUserBanned(string name, string steamId, string address, string reason)
{
    Puts($"Пользователь '{name}' заблокирован по причине: {reason} с ID Steam {steamId} и адресом IP {address}");
}
```

## OnPlayerBanned(string,ulong,string,string)

```csharp
/// <summary>
/// Вызывается, когда игрок заблокирован.
/// </summary>
/// <param name="name">Имя игрока.</param>
/// <param name="steamId">Steam ID игрока.</param>
/// <param name="address">Адрес IP игрока.</param>
/// <param name="reason">Причина блокировки.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnPlayerBanned(string name, ulong steamId, string address, string reason)
{
    Puts($"Игрок {name} заблокирован по причине: {reason}");
}
```

## OnUserUnbanned(string,string,string)

```csharp
/// <summary>
/// Вызывается, когда игрок из списка забаненных пользователей был разблокирован.
/// </summary>
/// <param name="name">Имя игрока.</param>
/// <param name="steamId">Steam ID игрока.</param>
/// <param name="address">Адрес IP игрока.</param>
/// <returns>Нет поведения возвращаемого значения.</returns>
void OnUserUnbanned(string name, string steamId, string address)
{
    Puts($"Игрок '{name}' разблокирован из списка забаненных пользователей с Steam ID {steamId} и адресом {address}");
}
```

