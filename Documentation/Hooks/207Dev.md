# Hook Definitions

## OnPlayerRecover(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecover(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered from being wounded.");
}
```
```

### Source Code from the Library

```csharp

	public void StopWounded()
	{
		if (IsDead() || Interface.CallHook("OnPlayerRecover", this) == null)
		{
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			CancelInvoke(WoundingTick);
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is finished.
/// </summary>
/// <param name="task">The ItemCraftTask that was completed.</param>
/// <param name="item">The crafted item.</param>
object OnItemCraftFinished(ItemCraftTask task, Item item)
{
    Puts($"Item crafting task {task.taskUID} has been completed.");
    if (task.blueprint.targetItem.shortname == "crafting_test")
    {
        Puts($"Item crafting test has been completed with result {item.info.itemid}.");
        return item;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item.amount = task.blueprint.amountToCreate;
		if (item.hasCondition && task.conditionScale != 1f)
		{
			item.maxCondition *= task.conditionScale;
			item.condition = item.maxCondition;
		}
		item.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int amount = takenItem.amount;
					int num2 = Mathf.Min(amount, num);
					takenItem.UseItem(num);
					num -= num2;
				}
				if (num > 0)
				{
				}
			}
		}
		Facepunch.Rust.Analytics.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		task.owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item);
		item.instanceData = task.instanceData;
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			task.owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		if (task.owner.inventory.GiveItem(item))
		{
			task.owner.Command("note.inv", item.info.itemid, item.amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		task.owner.Command("note.inv", item.info.itemid, item.amount);
		task.owner.Command("note.inv", item.info.itemid, -item.amount);
		item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## IOnNpcPlayerTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC player target is set.
/// </summary>
/// <param name="npcPlayer">The NPC player apex.</param>
/// <param name="target">The base entity being targeted.</param>
/// <returns>
/// Returns a float value indicating the NPC's desire to attack the target, on a scale of 0 (no interest) to 1 (high interest). 
/// If `null` is returned, the default behavior will be used.
/// </returns>
float IOnNpcPlayerTarget(NPCPlayerApex npcPlayer, BaseEntity target)
{
    Puts($"NPC {npcPlayer.UserIDString} has set its target to {target.UserIDString}");
    if (target == null || !target.IsValid())
    {
        return 0f;
    }
    if (target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
    {
        return 1f;
    }
    return 0.5f;
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		if (target == null)
		{
			return 0f;
		}
		object obj = Interface.CallHook("IOnNpcPlayerTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
		{
			return 0f;
		}
		if (target.GetType() == GetType())
		{
			return 0f;
		}
		if (target.Health() <= 0f)
		{
			return 0f;
		}
		return 1f;
	}

```

## OnSignUpdated(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign's image is updated.
/// </summary>
/// <param name="sign">The signage that was updated.</param>
/// <param name="player">The player who performed the update.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.signID} has been updated by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				textureID = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				Interface.CallHook("OnSignUpdated", this, msg.player);
				SendNetworkUpdate();
			}
		}
	}

```

## OnFlameExplosion(FlameExplosive,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a flame explosion occurs.
/// </summary>
/// <param name="explosive">The explosive that caused the flame explosion.</param>
/// <param name="entity">The entity affected by the flame explosion.</param>
/// <returns>No return behavior.</returns>
void OnFlameExplosion(FlameExplosive explosive, BaseEntity entity)
{
    Puts($"Flame explosion occurred at position {entity.transform.position} with velocity {explosive.maxVelocity}");
    if (explosive.isHighIntensity)
    {
        Puts($"High-intensity flame explosion detected. Taking additional damage.");
        // Take additional damage or apply other effects
    }
}
```
```

### Source Code from the Library

```csharp

	public void Explode(Vector3 surfaceNormal)
	{
		if (!base.isServer)
		{
			return;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, base.transform.position);
			if ((bool)baseEntity)
			{
				baseEntity.transform.position = base.transform.position;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle, surfaceNormal);
				baseEntity.transform.rotation = Quaternion.LookRotation(modifiedAimConeDirection);
				baseEntity.creatorEntity = ((!(creatorEntity == null)) ? creatorEntity : baseEntity);
				Interface.CallHook("OnFlameExplosion", this, baseEntity);
				baseEntity.Spawn();
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(minVelocity, maxVelocity));
			}
		}
		base.Explode();
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to check if a target can be targeted by the turret.
/// </summary>
/// <param name="target">The target entity.</param>
/// <param name="turret">The auto turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BaseCombatEntity target, AutoTurret turret)
{
    Puts($"Checking if {target} can be targeted by {turret}.");
    if (target == null || !target.IsValid())
    {
        return false;
    }
    // Additional checks or overrides can go here
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.GetList<RaycastHit>();
		Vector3 position = eyePos.transform.position;
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 normalized = (vector - position).normalized;
		Vector3 vector2 = Vector3.Cross(normalized, Vector3.up);
		for (int i = 0; (float)i < ((!CheckPeekers()) ? 1f : 3f); i++)
		{
			Vector3 vector3 = vector + vector2 * visibilityOffsets[i];
			Vector3 normalized2 = (vector3 - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized2), 0f, obj3, num * 1.1f, 1218652417);
			for (int j = 0; j < obj3.Count; j++)
			{
				RaycastHit hit = obj3[j];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if ((!(entity != null) || !entity.isClient) && (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) && (!(entity != null) || !entity.EqualNetID(this)))
				{
					if (entity != null && (entity == obj || entity.EqualNetID(obj)))
					{
						Facepunch.Pool.FreeList(ref obj3);
						return true;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj3);
		return false;
	}

```

## IOnNpcPlayerSenseClose(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses a player in close range.
/// </summary>
/// <param name="npc">The NPC sensing the player.</param>
/// <returns>
/// Returns `null` to allow the NPC to sense the player, or any non-null value to prevent the NPC from sensing the player.
/// </returns>
object IOnNpcPlayerSenseClose(NPCPlayerApex npc)
{
    Puts($"NPC {npc.name} senses a player in close range.");
    if (npc.IsInCombat)
    {
        Puts($"NPC {npc.name} is already in combat and cannot sense the player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void _FindEntitiesInCloseRange()
	{
		if (Interface.CallHook("IOnNpcPlayerSenseClose", this) != null)
		{
			return;
		}
		EntityQueryResultCount = Query.Server.GetInSphere(base.transform.position, Stats.CloseRange, EntityQueryResults, delegate(BaseEntity entity)
		{
			if (entity == null || !entity.isServer || entity.IsDestroyed)
			{
				return false;
			}
			return (entity is BaseNpc || entity is TimedExplosive) ? true : false;
		});
	}

```

## OnReloadWeapon(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player starts reloading their weapon.
/// </summary>
/// <param name="player">The player starting to reload.</param>
/// <param name="projectile">The projectile being reloaded, if applicable.</param>
/// <returns>
/// Returns `null` to allow the player to start reloading, or any non-null value to prevent them from reloading.
/// </returns>
object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} started reloading their weapon.");
    if (projectile != null && projectile.ammoType == "rare")
    {
        Puts($"Player {player.displayName} is trying to reload a rare ammo type.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnReloadWeapon", player, this) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			StartReloadCooldown(reloadTime);
		}
	}

```

## OnItemDeployed(Deployer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is deployed on a base entity.
/// </summary>
/// <param name="deployer">The deployer of the item.</param>
/// <param name="baseEntity">The base entity where the item was deployed.</param>
object OnItemDeployed(Deployable deployer, BaseEntity baseEntity)
{
    Puts($"Item {deployer.name} has been deployed on {baseEntity.displayName}");
    if (baseEntity is BaseBuilding && ((BaseBuilding)baseEntity).IsLocked)
    {
        Puts($"Deployment of item {deployer.name} on {baseEntity.displayName} has been blocked due to locked building.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, uint entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || !ownerPlayer.CanBuild())
		{
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity);
		UseItemAmount(1);
	}

```

## IOnPlayerChat(ConsoleSystem.Arg)

```csharp
Here is the method structure for `IOnPlayerChat(ConsoleSystem.Arg)`:

```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="arg">The console argument containing the chat message.</param>
/// <returns>
/// Returns null to allow the default chat behavior. 
/// If a string is returned, the player will be kicked with the provided message as the reason. 
/// If `null` is returned, the player's chat message is processed normally.
/// </returns>
object IOnPlayerChat(ConsoleSystem.Arg arg)
{
    // Minimal code to demonstrate functionality
    Puts("IOnPlayerChat called!");
    
    // Return null to allow default chat behavior
    return null;
}
```

Note that this method structure assumes that the `Interface.CallHook` function is used to determine whether the player's chat message should be processed normally or not. If the hook returns a non-null value, it means that the chat message should be blocked and the player will be kicked with the provided reason.
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!basePlayer || basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper)
		{
			if (basePlayer.NextChatTime == 0f)
			{
				basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup - 30f;
			}
			if (basePlayer.NextChatTime > UnityEngine.Time.realtimeSinceStartup)
			{
				basePlayer.NextChatTime += 2f;
				float num = basePlayer.NextChatTime - UnityEngine.Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(basePlayer.net.connection, "chat.add", 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					basePlayer.Kick("Chatting too fast");
				}
				return;
			}
		}
		string text = arg.GetString(0, "text").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0)
		{
			return;
		}
		if (text.StartsWith("/") || text.StartsWith("\\"))
		{
			if (Interface.CallHook("IOnPlayerCommand", arg) == null)
			{
			}
		}
		else
		{
			if ((text.Contains("<") && (text.Contains("<size", CompareOptions.IgnoreCase) || text.Contains("<color", CompareOptions.IgnoreCase) || text.Contains("<material", CompareOptions.IgnoreCase) || text.Contains("<quad", CompareOptions.IgnoreCase) || text.Contains("<b>", CompareOptions.IgnoreCase) || text.Contains("<i>", CompareOptions.IgnoreCase))) || Interface.CallHook("IOnPlayerChat", arg) != null)
			{
				return;
			}
			if (serverlog)
			{
				ServerConsole.PrintColoured(ConsoleColor.DarkYellow, basePlayer.displayName + ": ", ConsoleColor.DarkGreen, text);
				DebugEx.Log($"[CHAT] {basePlayer.ToString()} : {text}", StackTraceLogType.None);
			}
			string text2 = "#5af";
			if (basePlayer.IsAdmin)
			{
				text2 = "#af5";
			}
			if (basePlayer.IsDeveloper)
			{
				text2 = "#fa5";
			}
			string displayName = basePlayer.displayName;
			displayName = displayName.Replace('<', '[').Replace('>', ']');
			basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup + 1.5f;
			ChatEntry chatEntry = default(ChatEntry);
			chatEntry.Message = text;
			chatEntry.UserId = basePlayer.userID;
			chatEntry.Username = basePlayer.displayName;
			chatEntry.Color = text2;
			chatEntry.Time = Epoch.Current;
			ChatEntry chatEntry2 = chatEntry;
			History.Add(chatEntry2);
			RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
			if (Server.globalchat)
			{
				ConsoleNetwork.BroadcastToAllClients("chat.add2", basePlayer.userID, text, displayName, text2, 1f);
				arg.ReplyWith(string.Empty);
				return;
			}
			float num2 = 2500f;
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				float sqrMagnitude = (activePlayer.transform.position - basePlayer.transform.position).sqrMagnitude;
				if (!(sqrMagnitude > num2))
				{
					ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", basePlayer.userID, text, displayName, text2, Mathf.Clamp01(num2 - sqrMagnitude + 0.2f));
				}
			}
			arg.ReplyWith(string.Empty);
		}
	}

```

## OnEntityMarkHostile(BaseCombatEntity,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile.
/// </summary>
/// <param name="entity">The entity being marked as hostile.</param>
/// <param name="duration">The duration for which the entity should be considered hostile, in seconds. Defaults to 60 seconds.</param>
/// <returns>
/// Returns `null` to allow the entity to be marked as hostile, or any non-null value to prevent it from being marked.
/// </returns>
object OnEntityMarkHostile(BaseCombatEntity entity, float duration)
{
    Puts($"Entity {entity.EntityID} has been marked as hostile for {duration} seconds.");
    if (entity.EntityID == 12345)
    {
        Puts($"Entity {entity.EntityID} is already considered hostile and should not be marked again.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			float b = UnityEngine.Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, b);
		}
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a BasePlayer is hurt.
/// </summary>
/// <param name="basePlayer">The BasePlayer that was hurt.</param>
/// <param name="hitInfo">Information about the hit, including the initiator and damage types.</param>
void IOnBasePlayerHurt(BasePlayer basePlayer, HitInfo hitInfo)
{
    Puts($"BasePlayer {basePlayer.displayName} has been hurt.");
    // Add custom logic here to handle the BasePlayer being hurt.
    // For example, you could send a message to all players in the area, or apply additional damage effects.
    
    // If you want to override the default behavior of the BasePlayer being hurt,
    // return a non-null value from this method. Otherwise, return null.
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || IsImmortal() || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			basePlayer.Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		if (info.damageTypes.Get(DamageType.Drowned) > 5f && drownEffect.isValid)
		{
			Effect.server.Run(drownEffect.resourcePath, this, StringPool.Get("head"), UnityEngine.Vector3.zero, UnityEngine.Vector3.zero);
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((bool)initiatorPlayer && initiatorPlayer != this)
		{
			if (initiatorPlayer.InSafeZone() || InSafeZone())
			{
				initiatorPlayer.MarkHostileFor(1800f);
			}
			if (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(DamageType.Explosion) > 0f)
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);
			}
		}
		base.Hurt(info);
		if (EACServer.playerTracker != null && info.Initiator != null && info.Initiator is BasePlayer)
		{
			BasePlayer basePlayer2 = info.Initiator.ToPlayer();
			if (net.connection != null && basePlayer2.net.connection != null)
			{
				EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
				EasyAntiCheat.Server.Hydra.Client client2 = EACServer.GetClient(basePlayer2.net.connection);
				PlayerTakeDamage eventParams = default(PlayerTakeDamage);
				eventParams.DamageTaken = (int)info.damageTypes.Total();
				eventParams.HitBoneID = (int)info.HitBone;
				eventParams.WeaponID = 0;
				if (info.Weapon != null)
				{
					Item item = info.Weapon.GetItem();
					if (item != null)
					{
						eventParams.WeaponID = item.info.itemid;
					}
				}
				UnityEngine.Vector3 position = basePlayer2.eyes.position;
				UnityEngine.Vector3 eulerAngles = basePlayer2.eyes.rotation.eulerAngles;
				UnityEngine.Vector3 position2 = eyes.position;
				UnityEngine.Vector3 eulerAngles2 = eyes.rotation.eulerAngles;
				eventParams.AttackerPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position.x, position.y, position.z);
				eventParams.AttackerViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(eulerAngles.x, eulerAngles.y, eulerAngles.z);
				eventParams.VictimPosition = new EasyAntiCheat.Server.Cerberus.Vector3(position2.x, position2.y, position2.z);
				eventParams.VictimViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(eulerAngles2.x, eulerAngles2.y, eulerAngles2.z);
				EACServer.playerTracker.LogPlayerTakeDamage(client, client2, eventParams);
			}
		}
		metabolism.SendChangesToClient();
		if (info.PointStart != UnityEngine.Vector3.zero)
		{
			ClientRPCPlayer(null, this, "DirectionalDamage", info.PointStart, (int)info.damageTypes.GetMajorityDamageType());
		}
	}

```

## OnCreateWorldProjectile(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="hitInfo">Information about the hit that triggered the projectile creation.</param>
/// <param name="itemDef">The definition of the item being used to create the projectile.</param>
/// <returns>
/// Returns `null` to allow the projectile to be created as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for rejecting the projectile creation.
/// </returns>
object OnCreateWorldProjectile(HitInfo hitInfo, ItemDefinition itemDef)
{
    Puts($"Creating world projectile at {hitInfo.HitPositionWorld} with item definition {itemDef.name}");
    if (hitInfo.HitEntity != null && hitInfo.HitEntity.GetComponent<Rigidbody>() != null)
    {
        Puts("Rejecting projectile creation due to existing rigidbody");
        return "Existing Rigidbody";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem == null) ? ItemManager.Create(itemDef, 1, 0uL) : recycleItem);
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		Rigidbody rigidbody = null;
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			rigidbody = baseEntity.GetComponent<Rigidbody>();
			rigidbody.isKinematic = true;
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			rigidbody = baseEntity.GetComponent<Rigidbody>();
			rigidbody.AddForce(projectileVelocity.normalized * 200f);
			rigidbody.WakeUp();
		}
	}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine admin menu is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <param name="player">The player opening the admin menu.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} opened admin menu for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			SendSellOrders(player);
			PlayerOpenLoot(player);
			ClientRPCPlayer(null, player, "CLIENT_OpenAdminMenu");
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## OnPlayerInput(BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player's input is received.
/// </summary>
/// <param name="player">The player whose input is being processed.</param>
/// <param name="inputState">The current state of the player's input.</param>
/// <returns>
/// Returns `null` to allow the default behavior to occur. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnPlayerInput(BasePlayer player, InputState inputState)
{
    Puts($"Player {player.UserIDString} has received new input.");
    // Add custom logic here if needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can use napalm.
/// </summary>
/// <param name="helicopter">The helicopter in question.</param>
/// <returns>
/// Returns `true` if the helicopter can use napalm, and `false` otherwise.
/// If `null` is returned, the default behavior will be to allow the helicopter to use napalm after a 30-second cooldown period.
/// </returns>
bool CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter {helicopter.GetReference().name} can use napalm.");
    object obj = Interface.CallHook("CanHelicopterUseNapalm", helicopter);
    if (obj is bool)
    {
        return (bool)obj;
    }
    else if (obj == null)
    {
        Puts($"Helicopter {helicopter.GetReference().name} cannot use napalm at this time.");
        return false;
    }
    else
    {
        Puts($"Helicopter {helicopter.GetReference().name} is not allowed to use napalm by default.");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when a item loses condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>
/// Returns `null` to allow the item to lose condition, or any non-null value to prevent it from losing condition.
/// If a string is returned, the item will be destroyed with the provided message as the reason.
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Item {item.info.shortname} lost {amount} condition.");
    if (amount > 0.5f)
    {
        Puts($"Item {item.info.shortname} has been severely damaged.");
        return "Destroyed: Excessive damage.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to disarm a trap.
/// </summary>
/// <param name="landmine">The landmine being disarmed.</param>
/// <param name="player">The player attempting to disarm the landmine.</param>
/// <returns>
/// Returns `null` to allow the player to disarm the landmine, or any non-null value to prevent them from disarming it.
/// </returns>
object OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to disarm landmine at location {landmine.transform.position}");
    if (player.HasFlag(Flags.Admin))
    {
        Puts($"Player {player.displayName} is an admin and can't be prevented from disarming the landmine.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if (rpc.player.net.ID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			int num = UnityEngine.Random.Range(0, 100);
			if (num < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after falling.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallDistance">The distance the player fell.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLand(BasePlayer player, float fallDistance)
{
    Puts($"Player {player.UserIDString} landed after falling {fallDistance} units.");
    if (fallDistance > 50f)
    {
        Puts($"Player {player.displayName} suffered severe injuries from the fall.");
        // Apply additional damage or effects here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (float.IsNaN(num) || float.IsInfinity(num))
		{
			return;
		}
		float num2 = Mathf.InverseLerp(-15f, -100f, num);
		if (num2 != 0f && Interface.CallHook("OnPlayerLand", this, num2) == null)
		{
			metabolism.bleeding.Add(num2 * 0.5f);
			float num3 = num2 * 500f;
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num2);
		}
	}

```

## CanRenameBed(BasePlayer,SleepingBag,string)

```csharp
```csharp
/// <summary>
/// Called to check if a player can rename a bed.
/// </summary>
/// <param name="player">The player attempting to rename the bed.</param>
/// <param name="bed">The bed being renamed.</param>
/// <param name="newName">The proposed new name for the bed.</param>
/// <returns>
/// Returns `null` if the player can rename the bed, or any non-null value to prevent renaming.
/// </returns>
object CanRenameBed(BasePlayer player, SleepingBag bed, string newName)
{
    Puts($"Player {player.UserIDString} is trying to rename a sleeping bag with name: {newName}");
    if (newName == "Admin Only")
    {
        Puts($"Player {player.displayName} cannot rename the sleeping bag to '{newName}'");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("CanRenameBed", msg.player, this, text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
		}
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an item.
/// </summary>
/// <param name="player">The player starting to loot the item.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} started looting item: {item.name}");
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			MarkDirty();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
		}
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player's looting session ends.
/// </summary>
/// <param name="playerLoot">The PlayerLoot object associated with the ended looting session.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot playerLoot)
{
    Puts($"Player {playerLoot.Player.UserIDString} has finished looting.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		containers.Clear();
		entitySource = null;
		itemSource = null;
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a rocket is launched.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="projectile">The projectile that was launched.</param>
void OnRocketLaunched(BasePlayer player, BaseEntity projectile)
{
    Puts($"Rocket launched by {player.displayName} at position {projectile.transform.position}");
    Interface.CallHook("OnRocketLaunched", player, projectile);
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "magazine_empty");
			return;
		}
		primaryMagazine.contents--;
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		bool flag = msg.read.Bit();
		BaseEntity mounted = player.GetParentEntity();
		if (mounted == null)
		{
			mounted = player.GetMounted();
		}
		if (flag)
		{
			if (mounted != null)
			{
				vector = mounted.transform.TransformPoint(vector);
				vector2 = mounted.transform.TransformDirection(vector2);
			}
			else
			{
				vector = player.eyes.position;
				vector2 = player.eyes.BodyForward();
			}
		}
		if (!ValidateEyePos(player, vector))
		{
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		float num = GetAimCone() + component.projectileSpread;
		if (num > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num, vector2);
		}
		float num2 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num2, 1236478737))
		{
			num2 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num2);
		if (!(baseEntity == null))
		{
			baseEntity.creatorEntity = player;
			ServerProjectile component2 = baseEntity.GetComponent<ServerProjectile>();
			if ((bool)component2)
			{
				component2.InitializeVelocity(player.GetInheritedProjectileVelocity() + vector2 * component2.speed);
			}
			baseEntity.Spawn();
			StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
			Interface.CallHook("OnRocketLaunched", player, baseEntity);
			GetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));
		}
	}

```

## IOnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets another entity.
/// </summary>
/// <param name="npc">The NPC that targeted the entity.</param>
/// <param name="target">The entity that was targeted by the NPC.</param>
/// <returns>
/// Returns a float value indicating how much the NPC wants to attack the target, on a scale of 0 to 1.
/// If `null` is returned, the default behavior will be used.
/// </returns>
float IOnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} targeted entity {target.UserIDString}");
    if (target is Player player && player.IsSpectator)
    {
        Puts($"NPC {npc.name} does not want to attack spectator {player.UserIDString}");
        return 0;
    }
    return WantsToAttack(target);
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret authorizes a player.
/// </summary>
/// <param name="turret">The AutoTurret that authorized the player.</param>
/// <param name="player">The BasePlayer who was authorized by the turret.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent the authorization.
/// </returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.name} has authorized player {player.displayName}");
    if (player.UserIDString == "admin")
    {
        Puts($"Player {player.displayName} is already authorized by the turret.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!IsOnline() && Interface.CallHook("OnTurretAuthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = rpc2.player.userID;
			playerNameID.username = rpc2.player.displayName;
			authorizedPlayers.Add(playerNameID);
			SendNetworkUpdate();
		}
	}

```

## OnItemSplit(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is being split into smaller quantities.
/// </summary>
/// <param name="item">The item being split.</param>
/// <param name="splitAmount">The amount to split the item by.</param>
/// <returns>
/// Returns a new `Item` object if the split should be overridden, or `null` to allow the default splitting behavior.
/// </returns>
object OnItemSplit(Item item, int splitAmount)
{
    Puts($"Item {item.info.itemid} is being split into {splitAmount} pieces.");
    // If you want to override the default splitting behavior and return a new item
    Item new_item = ItemManager.CreateByItemID(item.info.itemid, 1, 0uL);
    new_item.amount = splitAmount;
    return new_item;
}
```
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		MarkDirty();
		return item;
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player ends spectating.
/// </summary>
/// <param name="player">The player ending spectation.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to end spectating normally. 
/// If any non-null value is returned, it will override the default behavior and prevent the player from ending spectation.
/// </returns>
object OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} ended spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to end spectation with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## OnItemScrap(ResearchTable,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is scrapped for research.
/// </summary>
/// <param name="researchTable">The research table used to scrap the item.</param>
/// <param name="item">The item being scrapped.</param>
/// <returns>
/// Returns a non-negative integer representing the amount of research points gained from scrapping the item. 
/// If `null` is returned, the default research point value will be used.
/// </returns>
object OnItemScrap(ResearchTable researchTable, Item item)
{
    Puts($"Item {item.info.name} has been scrapped for research.");
    if (item.info.rarity == Rarity.VeryRare)
    {
        Puts($"Item {item.info.name} is a Very Rare item. Scrapping will yield 1000 research points.");
        return 1000;
    }
    int result = ScrapForResearchDefault(item);
    return result;
}

// Default research point value for scrapping an item
int ScrapForResearchDefault(Item item)
{
    switch (item.info.rarity)
    {
        case Rarity.Common:
            return 20;
        case Rarity.Uncommon:
            return 75;
        case Rarity.Rare:
            return 250;
        case Rarity.VeryRare:
            return 1000;
        default:
            return 750;
    }
}
```
```

### Source Code from the Library

```csharp

	public int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnItemScrap", this, item);
		if (obj is int)
		{
			return (int)obj;
		}
		int result = 0;
		if (item.info.rarity == Rarity.Common)
		{
			result = 20;
		}
		if (item.info.rarity == Rarity.Uncommon)
		{
			result = 75;
		}
		if (item.info.rarity == Rarity.Rare)
		{
			result = 250;
		}
		if (item.info.rarity == Rarity.VeryRare || item.info.rarity == Rarity.None)
		{
			result = 750;
		}
		return result;
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity being killed.</param>
/// <returns>No return behavior.</returns>
void OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity.ShortName} has been killed.");
    if (entity is BasePlayer player && player.UserIDString == "admin")
    {
        Puts($"Admin player {player.displayName} was killed.");
        // Additional logic for admin players
    }
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
			return;
		}
		Interface.CallHook("OnEntityKill", this);
		OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
		DoEntityDestroy();
		TerminateOnClient(mode);
		TerminateOnServer();
		EntityDestroy();
	}

```

## IOnServerUsersRemove(ulong)

```csharp
```csharp
/// <summary>
/// Called when a user is removed from the server.
/// </summary>
/// <param name="uid">The ID of the user being removed.</param>
/// <returns>No return behavior.</returns>
void IOnServerUsersRemove(ulong uid)
{
    Puts($"User with ID {uid} has been removed from the server.");
}
```
```

### Source Code from the Library

```csharp

	public static void Remove(ulong uid)
	{
		Interface.CallHook("IOnServerUsersRemove", uid);
		if (users.ContainsKey(uid))
		{
			users.Remove(uid);
		}
	}

```

## OnItemResearched(ResearchTable,int)

```csharp
```csharp
/// <summary>
/// Called when an item is researched.
/// </summary>
/// <param name="researchTable">The research table used to research the item.</param>
/// <param name="amountOfScrapUsed">The amount of scrap used in the research process.</param>
object OnItemResearched(ResearchTable researchTable, int amountOfScrapUsed)
{
    Puts($"Item {researchTable.GetItemName()} has been researched using {amountOfScrapUsed} units of scrap.");
    if (amountOfScrapUsed > 1000)
    {
        Puts($"Warning: Item {researchTable.GetItemName()} was researched with excessive amount of scrap ({amountOfScrapUsed}).");
        return "Excessive Scrap Used";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", this, num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount <= num)
				{
					inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
				item.blueprintTarget = targetItem.info.itemid;
				if (!item.MoveToContainer(inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the mailbox, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Player {player.UserIDString} attempting to access mailbox {mailbox.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnTurretClearList(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the turret clear list is triggered.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <param name="player">The player who triggered the clear list.</param>
/// <returns>
/// Returns `null` to allow the clear list to proceed, or any non-null value to prevent it from clearing.
/// </returns>
object OnTurretClearList(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.GetID()} has been cleared by player {player.UserIDString}.");
    if (player.UserID == 123456) // Example: Prevent a specific user from clearing the list
    {
        Puts($"Player {player.UserIDString} is not allowed to clear the turret list.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			SendNetworkUpdate();
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="entity">The locked entity being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the locked entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
bool CanUseLockedEntity(BasePlayer player, CodeLock entity)
{
    Puts($"Player {player.UserIDString} attempted to access locked entity {entity.EntityID}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.UserIDString} is an admin and can access the locked entity");
        return true;
    }
    else if (player.HasPermission(entity.GetPermissionName()))
    {
        Puts($"Player {player.UserIDString} has permission to access the locked entity");
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to access the locked entity");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## IOnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a new user connects to the server.
/// </summary>
/// <param name="connection">The connection object for the new user.</param>
/// <returns>
/// Returns `null` if the user is approved as normal, or a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object IOnUserApprove(Network.Connection connection)
{
    Puts($"New connection from {connection.userid} with token {connection.token}");
    if (connection.token == null || connection.token.Length < 32)
    {
        Reject(connection, "Invalid Token");
        return true;
    }
    // Additional approval logic can be added here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2137)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)", StackTraceLogType.None);
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			Reject(connection, "You are banned from this server");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log(connection.ToString() + " has auth level 1", StackTraceLogType.None);
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log(connection.ToString() + " has auth level 2", StackTraceLogType.None);
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log(connection.ToString() + " is a developer", StackTraceLogType.None);
			connection.authLevel = 3u;
		}
		if (IsConnected(connection.userid))
		{
			Reject(connection, "You are already connected!");
		}
		else if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnQuarryEnabled(MiningQuarry)

```csharp
```csharp
/// <summary>
/// Called when a quarry is enabled.
/// </summary>
/// <param name="quarry">The mining quarry that has been enabled.</param>
/// <returns>No return behavior.</returns>
void OnQuarryEnabled(MiningQuarry quarry)
{
    Puts($"Quarry {quarry.name} has been enabled.");
    if (quarry.isHighPriority)
    {
        Puts($"Quarry {quarry.name} is a high priority quarry.");
        // Perform additional actions for high-priority quarries
    }
}
```
```

### Source Code from the Library

```csharp

	public void SetOn(bool isOn)
	{
		SetFlag(Flags.On, isOn);
		engineSwitchPrefab.instance.SetFlag(Flags.On, isOn);
		SendNetworkUpdate();
		engineSwitchPrefab.instance.SendNetworkUpdate();
		if (isOn)
		{
			InvokeRepeating(ProcessResources, processRate, processRate);
			Interface.CallHook("OnQuarryEnabled", this);
		}
		else
		{
			CancelInvoke(ProcessResources);
		}
	}

```

## OnPlayerInit(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's initialization process begins.
/// </summary>
/// <param name="player">The player being initialized.</param>
/// <returns>
/// Returns a non-null value to override the default initialization behavior. 
/// If `null` is returned, the player is initialized as normal.
/// </returns>
object OnPlayerInit(BasePlayer player)
{
    Puts($"Initializing player {player.UserIDString}.");
    if (player.UserIDString == "admin")
    {
        Puts($"Player {player.UserIDString} has been blocked from initializing.");
        return "Blocked: Unauthorized player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PlayerInit(Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10L))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			userID = c.userid;
			UserIDString = userID.ToString();
			_displayName = c.username.ToPrintable(32);
			c.player = this;
			tickInterpolator.Reset(base.transform.position);
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			ClientRPCPlayer(null, this, "StartLoading");
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			SendGlobalSnapshot();
			SendFullSnapshot();
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
			}
			Interface.CallHook("OnPlayerInit", this);
		}
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted (in this case, a corpse).</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, LootableCorpse entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot corpse {entity.GetGlobalID()}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Not enough permissions";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if ((bool)player && player.CanInteract() && CanLoot() && containers != null && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
		{
			SetFlag(Flags.Open, b: true);
			ItemContainer[] array = containers;
			foreach (ItemContainer container in array)
			{
				player.inventory.loot.AddContainer(container);
			}
			player.inventory.loot.SendImmediate();
			ClientRPCPlayer(null, player, "RPC_ClientLootCorpse");
			SendNetworkUpdate();
		}
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a hammer hits an entity.
/// </summary>
/// <param name="owner">The player who hit the entity.</param>
/// <param name="info">Information about the hit, including the entity and damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default behavior of repairing the entity. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnHammerHit(BasePlayer owner, HitInfo info)
{
    Puts($"Player {owner.UserIDString} hit an entity with their hammer.");
    if (info.HitEntity is BaseBuilding)
    {
        Puts($"The entity hit was a building.");
        return "Building cannot be repaired.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			if (ownerPlayer != null && base.isServer)
			{
				using (TimeWarning.New("DoRepair", 50L))
				{
					baseCombatEntity.DoRepair(ownerPlayer);
				}
			}
		}
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that was locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.EntityID} has been locked by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container that the item was added to.</param>
/// <param name="item">The item that was added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been added to container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## OnMapImageUpdated()

```csharp
```csharp
/// <summary>
/// Called when a map image is updated.
/// </summary>
void OnMapImageUpdated()
{
    Puts("Map image has been updated.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void ImageUpdate(RPCMessage msg)
	{
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}

```

## CanUseVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the vending machine.
/// </summary>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the vending machine, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} attempted to use vending machine {vendingMachine.name}");
    if (player.IsAdmin)
    {
        return true;
    }
    // Check if the player has a valid ticket
    if (!player.HasValidTicket())
    {
        return false;
    }
    // Allow players with a certain permission level to use the vending machine
    if (player.GetPermissionLevel() >= 3)
    {
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName = "")
	{
		object obj = Interface.CallHook("CanUseVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		return base.CanOpenLootPanel(player, panelName) && CanPlayerAdmin(player);
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the recycler is toggled on or off.
/// </summary>
/// <param name="recycler">The recycler being toggled.</param>
/// <param name="player">The player who toggled the recycler.</param>
/// <returns>
/// Returns `null` to allow the recycler to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts($"Recycler {recycler.name} has been toggled by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot toggle the recycler.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || msg.player == null || Interface.CallHook("OnRecyclerToggle", this, msg.player) != null || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

```

## OnPlayerKicked(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="player">The player being kicked.</param>
/// <param name="reason">The reason for kicking the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void Kick(string reason)
	{
		if (IsConnected)
		{
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason);
		}
	}

```

## OnCrateDropped(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a crate is dropped.
/// </summary>
/// <param name="crate">The crate that was dropped.</param>
/// <returns>No return behavior.</returns>
void OnCrateDropped(HackableLockedCrate crate)
{
    Puts($"Crate {crate.CrateID} has been dropped.");
}
```
```

### Source Code from the Library

```csharp

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", this);
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford an upgrade.
/// </summary>
/// <param name="player">The player attempting the upgrade.</param>
/// <param name="buildingBlock">The building block being upgraded.</param>
/// <param name="grade">The grade of the upgrade.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the return value.
/// </returns>
bool CanAffordUpgrade(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum grade)
{
    Puts($"Player {player.UserIDString} attempting to upgrade {buildingBlock.name} to grade {grade}");
    object obj = Interface.CallHook("CanAffordUpgrade", player, buildingBlock, grade);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // Default implementation
    ConstructionGrade constructionGrade = GetGrade(grade);
    foreach (ItemAmount item in constructionGrade.costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
        {
            Puts($"Player {player.UserIDString} does not have enough resources to upgrade {buildingBlock.name} to grade {grade}");
            return false;
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool CanAffordUpgrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ConstructionGrade constructionGrade = GetGrade(iGrade);
		foreach (ItemAmount item in constructionGrade.costToBuild)
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallDistance">The distance the player fell.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanded(BasePlayer player, float fallDistance)
{
    Puts($"Player {player.UserIDString} has landed after falling {fallDistance} units.");
    if (fallDistance > 50f)
    {
        Puts($"Player {player.displayName} suffered severe injuries from the fall.");
        // Apply additional damage or effects here
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void OnPlayerLanded(RPCMessage msg)
	{
		float num = msg.read.Float();
		if (float.IsNaN(num) || float.IsInfinity(num))
		{
			return;
		}
		float num2 = Mathf.InverseLerp(-15f, -100f, num);
		if (num2 != 0f && Interface.CallHook("OnPlayerLand", this, num2) == null)
		{
			metabolism.bleeding.Add(num2 * 0.5f);
			float num3 = num2 * 500f;
			Hurt(num3, DamageType.Fall);
			if (num3 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, UnityEngine.Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num2);
		}
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if a target can be targeted by the helicopter turret.
/// </summary>
/// <param name="potentialTarget">The potential target entity.</param>
/// <param name="turret">The helicopter turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBeTargeted(BaseCombatEntity potentialTarget, HelicopterTurret turret)
{
    Puts($"Checking if {potentialTarget.displayName} can be targeted by the helicopter turret.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the network should be allowed to connect to a BasePlayer.
/// </summary>
/// <param name="player">The player to check.</param>
/// <returns>
/// Returns `true` to allow the network to connect, or `false` to deny it.
/// If any other value is returned (e.g. a string), it will be treated as an error message and used to kick the player.
/// </returns>
object CanNetworkTo(BasePlayer player)
{
    Puts($"Checking if network can connect to {player.UserIDString}...");
    if (player.IsBanned)
    {
        Puts($"Network denied: Player is banned.");
        return "You are banned from this server.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## CanDemolish(BasePlayer,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Determines whether a player can demolish the current building.
/// </summary>
/// <param name="player">The player attempting to demolish.</param>
/// <param name="buildingBlock">The block being demolished, if applicable.</param>
/// <returns>
/// Returns `true` if the player can demolish, and `false` otherwise.
/// If a non-bool value is returned by the hook, it will be used as the result.
/// </returns>
object CanDemolish(BasePlayer player, BuildingBlock buildingBlock)
{
    Puts($"Player {player.UserIDString} attempting to demolish {buildingBlock.GetType().Name}.");
    if (IsAdmin(player))
    {
        return true;
    }
    object obj = Interface.CallHook("CanDemolish", player, buildingBlock);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return IsDemolishable() && HasDemolishPrivilege(player);
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <param name="target">The object that entered the trap's trigger area.</param>
/// <returns>No return behavior.</returns>
void OnTrapTrigger(BearTrap trap, GameObject target)
{
    Puts($"Trap {trap.name} triggered by {target.name}");
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can bypass the queue.
/// </summary>
/// <param name="connection">The player's connection.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue, or `false` otherwise.
/// If this method returns `null`, it will be treated as returning `false`.
/// </returns>
bool CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if {connection.UserIDString} can bypass queue...");
    bool result = (bool)Interface.CallHook("CanBypassQueue", connection);
    if (result)
    {
        return true;
    }
    if (DeveloperList.Contains(connection.userid))
    {
        return true;
    }
    ServerUsers.User user = ServerUsers.Get(connection.userid);
    if (user != null && user.group == ServerUsers.UserGroup.Moderator)
    {
        return true;
    }
    if (user != null && user.group == ServerUsers.UserGroup.Owner)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		return false;
	}

```

## OnFireBallDamage(FireBall,BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a fireball deals damage to an entity.
/// </summary>
/// <param name="fireBall">The fireball that dealt the damage.</param>
/// <param name="entity">The entity that was damaged.</param>
/// <param name="hitInfo">Information about the hit, including the damage type and amount.</param>
/// <returns>
/// Returns a non-null value to override the default damage behavior. 
/// If `null` is returned, the entity will be damaged as normal.
/// </returns>
object OnFireBallDamage(FireBall fireBall, BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Fireball dealt {hitInfo.damageTypes.Get(DamageType.Heat)} damage to {entity}.");
    if (entity is BasePlayer player && player.IsOnFire())
    {
        Puts($"Player {player} was already on fire, so no additional damage was applied.");
        return null;
    }
    // Add custom logic here to handle the fireball damage
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoRadialDamage()
	{
		List<Collider> obj = Pool.GetList<Collider>();
		Vector3 position = base.transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Colliders(position, radius, obj, AttackLayers);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = ((!(creatorEntity == null)) ? creatorEntity : GameObjectEx.ToBaseEntity(base.gameObject));
		hitInfo.PointStart = base.transform.position;
		foreach (Collider item in obj)
		{
			if (item.isTrigger && (item.gameObject.layer == 29 || item.gameObject.layer == 18))
			{
				continue;
			}
			BaseCombatEntity baseCombatEntity = GameObjectEx.ToBaseEntity(item.gameObject) as BaseCombatEntity;
			if (!(baseCombatEntity == null) && baseCombatEntity.isServer && baseCombatEntity.IsAlive() && baseCombatEntity.IsVisible(position))
			{
				if (baseCombatEntity is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", baseCombatEntity, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = baseCombatEntity.transform.position;
				hitInfo.HitPositionWorld = baseCombatEntity.transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", this, baseCombatEntity, hitInfo);
				baseCombatEntity.OnAttacked(hitInfo);
			}
		}
		Pool.FreeList(ref obj);
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is hunting.
/// </summary>
/// <param name="bradleyApc">The Bradley APC instance.</param>
/// <returns>
/// Returns a non-null value to override the default hunting behavior. 
/// If `null` is returned, the Bradley APC will continue with its normal hunting routine.
/// </returns>
object OnBradleyApcHunt(BradleyAPC bradleyApc)
{
    Puts($"The Bradley APC {bradleyApc.GetId()} has started hunting.");
    if (bradleyApc.GetCurrentTarget().GetDistance() > 100f)
    {
        Puts($"The Bradley APC {bradleyApc.GetId()} is too far away from its target to engage.");
        return "Too Far Away";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			BasePathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			BasePathNode basePathNode = null;
			List<BasePathNode> nearNodes = Facepunch.Pool.GetList<BasePathNode>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<BasePathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (BasePathNode item2 in nearNodes)
			{
				Stack<BasePathNode> path = new Stack<BasePathNode>();
				if (targetInfo.entity.IsVisible(item2.transform.position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					basePathNode = item2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].transform.position);
					}
				}
				foreach (BasePathNode item3 in stack)
				{
					currentPath.Add(item3.transform.position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = basePathNode.transform.position;
			}
			Facepunch.Pool.FreeList(ref nearNodes);
			Facepunch.Pool.FreeList(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## CanLootEntity(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `true` to allow the player to loot the entity, or `false` to prevent them from doing so.
/// If a non-bool value is returned, it will be treated as a custom reason for denying access.
/// </returns>
object CanLootEntity(BasePlayer player, StorageContainer entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot {entity.name}.");
    if (entity.IsLocked())
    {
        return "Locked: Entity is currently locked.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen)
	{
		object obj = Interface.CallHook("CanLootEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsLocked())
		{
			player.ChatMessage("Can't loot right now");
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnTick()

```csharp
```csharp
/// <summary>
/// Called every tick.
/// </summary>
void OnTick()
{
    Puts("Server is ticking...");
    // Perform any necessary server-side tasks here
    // For example, you could update the server's state or perform some calculations
}
```
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		if (Rust.Global.SteamServer != null)
		{
			Interface.CallHook("OnTick");
			Rust.Global.SteamServer.Update();
		}
		RCon.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## CanChangeCode(BasePlayer,CodeLock,string,bool)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to change the code on a CodeLock.
/// </summary>
/// <param name="player">The player attempting to change the code.</param>
/// <param name="codeLock">The CodeLock being modified.</param>
/// <param name="newCode">The new code being set.</param>
/// <param name="isGuest">Whether the code is for a guest or not.</param>
/// <returns>
/// Returns `null` to allow the code change, or any non-null value to prevent it.
/// If a string is returned, the player will be notified with that message as the reason.
/// </returns>
object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuest)
{
    Puts($"Player {player.UserIDString} attempted to change the code on {codeLock.name} to '{newCode}' as a guest: {isGuest}");
    if (newCode.Length != 4)
    {
        Puts($"Invalid code length. Code must be exactly 4 characters long.");
        return "Error: Invalid code length.";
    }
    // Additional validation or logic can go here
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (IsLocked() || text.Length != 4 || (!hasCode && flag))
		{
			return;
		}
		if (!hasCode && !flag)
		{
			SetFlag(Flags.Locked, b: true);
		}
		if (Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## CanMountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when an entity is mounted by a player.
/// </summary>
/// <param name="player">The player mounting the entity.</param>
/// <param name="entity">The entity being mounted.</param>
/// <returns>
/// Returns `null` to allow the entity to be mounted, or any non-null value to prevent it from being mounted.
/// </returns>
object CanMountEntity(BasePlayer player, BaseMountable entity)
{
    Puts($"Player {player.UserIDString} is trying to mount {entity.name}.");
    if (entity.isBroken)
    {
        Puts($"Cannot mount {entity.name} because it's broken.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			TriggerParent triggerParent = player.FindTrigger<TriggerParent>();
			if ((bool)triggerParent)
			{
				triggerParent.OnTriggerExit(player.GetComponent<Collider>());
			}
			player.MountObject(this);
			player.MovePosition(mountAnchor.transform.position);
			player.transform.rotation = mountAnchor.transform.rotation;
			player.ServerRotation = mountAnchor.transform.rotation;
			player.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			SetFlag(Flags.Busy, b: true);
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnCrateHack(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to hack a locked crate.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>
/// Returns `null` to allow the hacking process to proceed, or any non-null value to prevent the hacking attempt.
/// </returns>
object OnCrateHack(HackableLockedCrate crate)
{
    Puts($"Player attempted to hack crate {crate.crateName} with hack time: {crate.hackTime} seconds");
    if (crate.hackTime < 10)
    {
        Puts($"Player's hacking attempt on crate {crate.crateName} was blocked due to insufficient hack time.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", this);
		SetFlag(Flags.Reserved1, b: true);
		InvokeRepeating(HackProgress, 1f, 1f);
		ClientRPC(null, "UpdateHackProgress", 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

```

## OnReloadMagazine(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player reloads their magazine.
/// </summary>
/// <param name="player">The player reloading the magazine.</param>
/// <param name="projectile">The projectile being reloaded.</param>
/// <returns>
/// Returns `null` to allow the magazine to be reloaded, or any non-null value to prevent it from being reloaded.
/// </returns>
object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} is reloading their magazine.");
    if (projectile.ammoType == "rare")
    {
        Puts($"Player {player.displayName} cannot reload rare ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected void ReloadMagazine()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((bool)ownerPlayer && Interface.CallHook("OnReloadMagazine", ownerPlayer, this) == null)
		{
			primaryMagazine.Reload(ownerPlayer);
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped.
/// </summary>
/// <param name="item">The item being dropped.</param>
/// <param name="baseEntity">The BaseEntity representing the dropped item, or null if the item cannot be dropped.</param>
/// <returns>No return behavior.</returns>
void OnItemDropped(Item item, BaseEntity baseEntity)
{
    Puts($"Item {item.info.name} has been dropped.");
    if (baseEntity != null && baseEntity is BasePlayer)
    {
        Puts($"The item was dropped by player {((BasePlayer)baseEntity).displayName}");
    }
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		RemoveFromWorld();
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## CanBuild(Planner,Construction,Construction.Target)

```csharp
```csharp
/// <summary>
/// Determines whether a player can build at the specified position.
/// </summary>
/// <param name="planner">The planner instance.</param>
/// <param name="construction">The construction instance.</param>
/// <param name="target">The target instance.</param>
/// <returns>
/// Returns a non-null value to override the default building behavior. 
/// If `null` is returned, the player can build as normal.
/// </returns>
object CanBuild(Planner planner, Construction construction, Construction.Target target)
{
    Puts($"Player {planner.GetOwnerPlayer().Username} is attempting to build at position {target.Position}");
    if (construction.CanBypassBuildingPermission && !planner.GetOwnerPlayer().CanBuild())
    {
        return "Building is blocked!";
    }
    if (!planner.GetOwnerPlayer().CanAffordToPlace(construction))
    {
        return "Can't afford to place!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ChatMessage("Couldn't find Construction " + msg.blockID);
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			ownerPlayer.ChatMessage("Can't afford to place!");
			return;
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ChatMessage("Building is blocked!");
			return;
		}
		Deployable deployable = GetDeployable();
		Construction.Target target = default(Construction.Target);
		BaseEntity baseEntity = null;
		if (msg.entity != 0)
		{
			baseEntity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if (!baseEntity)
			{
				ownerPlayer.ChatMessage("Couldn't find entity " + msg.entity);
				return;
			}
			msg.position = baseEntity.transform.TransformPoint(msg.position);
			msg.normal = baseEntity.transform.TransformDirection(msg.normal);
			msg.rotation = baseEntity.transform.rotation * msg.rotation;
			if (msg.socket == 0)
			{
				if ((bool)deployable && deployable.setSocketParent && baseEntity.Distance(msg.position) > 1f)
				{
					ownerPlayer.ChatMessage("Parent too far away: " + baseEntity.Distance(msg.position));
					return;
				}
				if (baseEntity is Door)
				{
					ownerPlayer.ChatMessage("Can't deploy on door");
					return;
				}
			}
			target.entity = baseEntity;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != string.Empty && target.entity != null)
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				else
				{
					ownerPlayer.ChatMessage("Invalid Socket!");
				}
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.valid = true;
		if (Interface.CallHook("CanBuild", this, construction, target) != null)
		{
			return;
		}
		if ((bool)deployable && deployable.placeEffect.isValid)
		{
			if ((bool)baseEntity && msg.socket != 0)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.TransformPoint(target.socket.worldPosition), baseEntity.transform.up);
			}
			else
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, msg.position, msg.normal);
			}
		}
		DoBuild(target, construction);
	}

```

## CanResearchItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to research an item.
/// </summary>
/// <param name="player">The player attempting to research the item.</param>
/// <param name="item">The item being researched.</param>
/// <returns>
/// Returns `null` to allow the player to research the item, or any non-null value to prevent them from researching it.
/// </returns>
object CanResearchItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} is attempting to research item {item.info.name}.");
    if (item.info.category == "Forbidden")
    {
        Puts($"Player {player.displayName} does not have permission to research the forbidden item {item.info.name}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## CanAssignBed(BasePlayer,SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called to check if a bed can be assigned to a player.
/// </summary>
/// <param name="player">The player who is trying to assign the bed.</param>
/// <param name="sleepingBag">The sleeping bag that is being assigned.</param>
/// <param name="bedId">The ID of the bed that is being assigned.</param>
/// <returns>
/// Returns `null` if the bed can be assigned, or any non-null value to prevent assignment.
/// </returns>
object CanAssignBed(BasePlayer player, SleepingBag sleepingBag, ulong bedId)
{
    Puts($"Player {player.UserIDString} is trying to assign bed {bedId} with sleeping bag {sleepingBag.name}");
    if (bedId == 1234567890)
    {
        Puts($"Bed {bedId} is reserved and cannot be assigned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (msg.player.CanInteract() && deployerUserID == msg.player.userID)
		{
			ulong num = msg.read.UInt64();
			if (num != 0 && Interface.CallHook("CanAssignBed", msg.player, this, num) == null)
			{
				deployerUserID = num;
				SendNetworkUpdate();
			}
		}
	}

```

## IOnPlayerCommand(ConsoleSystem.Arg)

```csharp
Here is the method structure for `IOnPlayerCommand(ConsoleSystem.Arg)`:

```csharp
/// <summary>
/// Called when a player issues a command.
/// </summary>
/// <param name="arg">The argument passed to the command.</param>
/// <returns>
/// Returns null if the command was handled successfully, or a non-null value to override the default behavior.
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object IOnPlayerCommand(ConsoleSystem.Arg arg)
{
    // Minimal code to demonstrate functionality
    Puts("IOnPlayerCommand called!");
    
    // Return null if the command was handled successfully
    return null;
}
```

Note that this method structure assumes that `Interface.CallHook` is used in the context, and analyzes how the return value (`obj`) is used to determine the correct return type. In this case, since no specific return type is mentioned, we use 'object' as the return type.
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!basePlayer || basePlayer.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper)
		{
			if (basePlayer.NextChatTime == 0f)
			{
				basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup - 30f;
			}
			if (basePlayer.NextChatTime > UnityEngine.Time.realtimeSinceStartup)
			{
				basePlayer.NextChatTime += 2f;
				float num = basePlayer.NextChatTime - UnityEngine.Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(basePlayer.net.connection, "chat.add", 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					basePlayer.Kick("Chatting too fast");
				}
				return;
			}
		}
		string text = arg.GetString(0, "text").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0)
		{
			return;
		}
		if (text.StartsWith("/") || text.StartsWith("\\"))
		{
			if (Interface.CallHook("IOnPlayerCommand", arg) == null)
			{
			}
		}
		else
		{
			if ((text.Contains("<") && (text.Contains("<size", CompareOptions.IgnoreCase) || text.Contains("<color", CompareOptions.IgnoreCase) || text.Contains("<material", CompareOptions.IgnoreCase) || text.Contains("<quad", CompareOptions.IgnoreCase) || text.Contains("<b>", CompareOptions.IgnoreCase) || text.Contains("<i>", CompareOptions.IgnoreCase))) || Interface.CallHook("IOnPlayerChat", arg) != null)
			{
				return;
			}
			if (serverlog)
			{
				ServerConsole.PrintColoured(ConsoleColor.DarkYellow, basePlayer.displayName + ": ", ConsoleColor.DarkGreen, text);
				DebugEx.Log($"[CHAT] {basePlayer.ToString()} : {text}", StackTraceLogType.None);
			}
			string text2 = "#5af";
			if (basePlayer.IsAdmin)
			{
				text2 = "#af5";
			}
			if (basePlayer.IsDeveloper)
			{
				text2 = "#fa5";
			}
			string displayName = basePlayer.displayName;
			displayName = displayName.Replace('<', '[').Replace('>', ']');
			basePlayer.NextChatTime = UnityEngine.Time.realtimeSinceStartup + 1.5f;
			ChatEntry chatEntry = default(ChatEntry);
			chatEntry.Message = text;
			chatEntry.UserId = basePlayer.userID;
			chatEntry.Username = basePlayer.displayName;
			chatEntry.Color = text2;
			chatEntry.Time = Epoch.Current;
			ChatEntry chatEntry2 = chatEntry;
			History.Add(chatEntry2);
			RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
			if (Server.globalchat)
			{
				ConsoleNetwork.BroadcastToAllClients("chat.add2", basePlayer.userID, text, displayName, text2, 1f);
				arg.ReplyWith(string.Empty);
				return;
			}
			float num2 = 2500f;
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				float sqrMagnitude = (activePlayer.transform.position - basePlayer.transform.position).sqrMagnitude;
				if (!(sqrMagnitude > num2))
				{
					ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", basePlayer.userID, text, displayName, text2, Mathf.Clamp01(num2 - sqrMagnitude + 0.2f));
				}
			}
			arg.ReplyWith(string.Empty);
		}
	}

```

## OnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
void OnServerShutdown()
{
    Puts("Server shutdown initiated.");
    // No return value expected
}
```
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("OnServerShutdown");
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		foreach (BasePlayer basePlayer in array)
		{
			basePlayer.Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## OnTurretModeToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the turret mode is toggled.
/// </summary>
/// <param name="turret">The AutoTurret instance whose mode was toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretModeToggle(AutoTurret turret)
{
    Puts($"Turret {turret.GetReference().ToString()} mode has been toggled.");
}
```
```

### Source Code from the Library

```csharp

	public void SetPeacekeepermode(bool isOn)
	{
		bool flag = PeacekeeperMode();
		if (flag != isOn)
		{
			SetFlag(Flags.Reserved1, isOn);
			Effect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnTurretModeToggle", this);
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be targeted for helicopter strafing.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <param name="target">The potential target player.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanHelicopterStrafeTarget(PatrolHelicopterAI ai, BasePlayer target)
{
    Puts($"Checking if {target.displayName} can be targeted for helicopter strafing.");
    if (target.IsAdmin())
    {
        Puts($"Cannot target admin {target.displayName} for helicopter strafing.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidStrafeTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return !ply.IsNearEnemyBase();
	}

```

## OnLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting another player's inventory.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="targetPlayer">The player being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootPlayer(BasePlayer looter, BasePlayer targetPlayer)
{
    Puts($"Player {looter.UserIDString} is looting player {targetPlayer.UserIDString}");
    if (looter == targetPlayer)
    {
        Puts($"Player {looter.UserIDString} cannot loot themselves.");
        return;
    }
    // Additional logic can be added here to handle specific cases or modify the behavior of the OnLootPlayer hook.
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_LootPlayer(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))
		{
			player.inventory.loot.AddContainer(inventory.containerMain);
			player.inventory.loot.AddContainer(inventory.containerWear);
			player.inventory.loot.AddContainer(inventory.containerBelt);
			Interface.CallHook("OnLootPlayer", this, player);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "player_corpse");
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the gun trap.
/// </summary>
/// <param name="player">The player being checked.</param>
/// <param name="gunTrap">The gun trap doing the checking.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, GunTrap gunTrap)
{
    Puts($"Checking if {player.Name} can be targeted by {gunTrap.GetType().Name}...");
    // Custom logic to determine if the player can be targeted
    // For example:
    if (player.IsAdmin())
    {
        return false;
    }
    else if (player.IsSleeping() || !player.IsAlive())
    {
        return false;
    }
    else
    {
        return true;
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger(float offset, float radius)
	{
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		List<BasePlayer> obj2 = Pool.GetList<BasePlayer>();
		Vis.Entities(GetEyePosition() + base.transform.forward * offset, radius, obj2, 131072);
		bool flag = false;
		foreach (BasePlayer item in obj2)
		{
			if (item.IsSleeping() || !item.IsAlive() || item.IsBuildingAuthed())
			{
				continue;
			}
			object obj3 = Interface.CallHook("CanBeTargeted", item, this);
			if (obj3 is bool)
			{
				Pool.FreeList(ref obj);
				Pool.FreeList(ref obj2);
				return (bool)obj3;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1218519297);
			for (int i = 0; i < obj.Count; i++)
			{
				RaycastHit hit = obj[i];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (flag)
			{
				break;
			}
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		return flag;
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when the BasePlayer is attacked.
/// </summary>
/// <param name="info">The HitInfo object containing information about the attack.</param>
void IOnBasePlayerAttacked(BasePlayer player, HitInfo info)
{
    // Custom logic can be implemented here to override the default behavior
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float health_old = base.health;
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.GetList<Item>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortal())
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			if (isMounted)
			{
				GetMounted().MounteeTookDamage(this, info);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				Effect effect = new Effect();
				effect.Init(Effect.Type.Generic, base.transform.position, base.transform.forward);
				effect.pooledString = "assets/bundled/prefabs/fx/takedamage_hit.prefab";
				EffectNetwork.Send(effect, net.connection);
			}
			string text = StringPool.Get(info.HitBone);
			UnityEngine.Vector3 normalized = (info.PointEnd - info.PointStart).normalized;
			bool flag = UnityEngine.Vector3.Dot(normalized, eyes.BodyForward()) > 0.4f;
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new UnityEngine.Vector3(0f, 2f, 0f), UnityEngine.Vector3.zero, (!(initiatorPlayer != null)) ? null : initiatorPlayer.net.connection);
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1);
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.Log(info, health_old, base.health, "wounded");
			}
			else if (IsDead())
			{
				stats.combat.Log(info, health_old, base.health, "killed");
			}
			else
			{
				stats.combat.Log(info, health_old, base.health);
			}
		}
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the player's active item should be dropped.
/// </summary>
/// <param name="player">The player whose active item is being considered for dropping.</param>
/// <returns>
/// Returns `true` to allow the player's active item to be dropped, or `false` to prevent it from being dropped.
/// If a non-bool value is returned, the default behavior will be used (i.e., the item will not be dropped).
/// </returns>
bool CanDropActiveItem(BasePlayer player)
{
    Puts($"Considering dropping active item for player {player.UserIDString}");
    if (player.IsAdmin)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnItemRepair(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to repair an item.
/// </summary>
/// <param name="player">The player attempting to repair the item.</param>
/// <param name="item">The item being repaired.</param>
/// <returns>
/// Returns `null` if the repair is allowed, or any non-null value to prevent the repair from occurring.
/// </returns>
object OnItemRepair(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} is attempting to repair item {item.info.shortname}.");
    if (item.info.condition.repairable && !item.info.condition.maxConditionReached)
    {
        return null;
    }
    else
    {
        Puts($"Repair of item {item.info.shortname} denied. Item condition is not repairable or has reached maximum condition.");
        return "Item condition is not repairable or has reached maximum condition.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RepairItem(RPCMessage msg)
	{
		Item slot = inventory.GetSlot(0);
		if (slot == null)
		{
			return;
		}
		ItemDefinition info = slot.info;
		ItemBlueprint component = info.GetComponent<ItemBlueprint>();
		if (!component || !info.condition.repairable || slot.condition == slot.maxCondition)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (Interface.CallHook("OnItemRepair", player, slot) != null || (!player.blueprints.HasUnlocked(info) && (!(info.Blueprint != null) || info.Blueprint.isResearchable)))
		{
			return;
		}
		float num = RepairCostFraction(slot);
		bool flag = false;
		List<ItemAmount> obj = GetRepairCostList(component);
		foreach (ItemAmount item in obj)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				int num2 = Mathf.CeilToInt(item.amount * num);
				if (num2 > amount)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Facepunch.Pool.Free(ref obj);
			return;
		}
		foreach (ItemAmount item2 in obj)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
			}
		}
		Facepunch.Pool.Free(ref obj);
		slot.DoRepair(maxConditionLostOnRepair);
		if (Global.developer > 0)
		{
			Debug.Log("Item repaired! condition : " + slot.condition + "/" + slot.maxCondition);
		}
		Effect.server.Run("assets/bundled/prefabs/fx/repairbench/itemrepair.prefab", this, 0u, Vector3.zero, Vector3.zero);
	}

```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when the stock level of a vending machine is refreshed.
/// </summary>
/// <param name="vendingMachine">The vending machine whose stock level is being refreshed.</param>
/// <param name="itemDefinition">The item definition for which the stock level is being refreshed. If null, all items are refreshed.</param>
object OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDefinition)
{
    Puts($"Refreshing stock level of vending machine {vendingMachine.name}.");
    if (itemDefinition != null)
    {
        Puts($"Refreshing stock level for item {itemDefinition.itemid}.");
    }
    else
    {
        Puts("Refreshing stock levels for all items.");
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		foreach (ProtoBuf.VendingMachine.SellOrder so in sellOrders.sellOrders)
		{
			if (!(itemDef == null) && itemDef.itemid != so.itemToSellID)
			{
				continue;
			}
			if (so.itemToSellIsBP)
			{
				List<Item> source = inventory.FindItemsByItemID(blueprintBaseDef.itemid);
				List<Item> list = source.Where((Item x) => x.blueprintTarget == so.itemToSellID).ToList();
				ProtoBuf.VendingMachine.SellOrder sellOrder = so;
				int inStock;
				if (list != null && list.Count() >= 0)
				{
					Interface.CallHook("OnRefreshVendingStock", this, itemDef);
					inStock = list.Sum((Item x) => x.amount) / so.itemToSellAmount;
				}
				else
				{
					inStock = 0;
				}
				sellOrder.inStock = inStock;
				continue;
			}
			List<Item> list2 = inventory.FindItemsByItemID(so.itemToSellID);
			ProtoBuf.VendingMachine.SellOrder sellOrder2 = so;
			int inStock2;
			if (list2 != null && list2.Count >= 0)
			{
				Interface.CallHook("OnRefreshVendingStock", this, itemDef);
				inStock2 = list2.Sum((Item x) => x.amount) / so.itemToSellAmount;
			}
			else
			{
				inStock2 = 0;
			}
			sellOrder2.inStock = inStock2;
		}
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a craft can be performed.
/// </summary>
/// <param name="craftTask">The item crafter performing the craft.</param>
/// <param name="blueprint">The blueprint for the item being crafted.</param>
/// <param name="amount">The amount of items being crafted.</param>
/// <returns>
/// Returns `true` if the craft can be performed, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object CanCraft(ItemCrafter craftTask, ItemBlueprint blueprint, int amount)
{
    Puts($"Checking if craft of {amount}x {blueprint.targetItem.name} can be performed.");
    if (amount < 1 || amount > blueprint.targetItem.craftingStackable)
    {
        Puts($"Cannot craft {amount}x {blueprint.targetItem.name}, invalid amount.");
        return false;
    }
    object result = Interface.CallHook("CanCraft", craftTask, blueprint, amount);
    if (result is bool)
    {
        return result;
    }
    foreach (ItemAmount ingredient in blueprint.ingredients)
    {
        if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
        {
            Puts($"Cannot craft {amount}x {blueprint.targetItem.name}, missing ingredients.");
            return false;
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1)
	{
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## OnHelicopterAttacked(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter is attacked.
/// </summary>
/// <param name="helicopter">The helicopter being attacked.</param>
/// <returns>
/// Returns `null` to allow the helicopter to be damaged normally, or any non-null value to prevent it from taking damage.
/// </returns>
object OnHelicopterAttacked(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetDisplayName()} is being attacked.");
    if (helicopter.IsUnderwater())
    {
        Puts($"Helicopter {helicopter.GetDisplayName()} cannot be damaged while underwater.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttacked", this) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved7, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

```

## CanRecycle(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled.
/// </summary>
/// <param name="recycler">The recycler checking the item.</param>
/// <param name="item">The item being checked for recyclability.</param>
/// <returns>
/// Returns `true` if the item can be recycled, or `false` otherwise.
/// If a non-null value is returned, it will override the default recyclability behavior.
/// </returns>
object CanRecycle(Recycler recycler, Item item)
{
    Puts($"Checking if {item.info.Blueprint.name} can be recycled by {recycler.UserIDString}");
    if (item.info.Blueprint == null || item.info.Blueprint.category != "Materials")
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## OnServerMessage(string,string,string,ulong)

```csharp
```csharp
/// <summary>
/// Called when a server message is broadcasted.
/// </summary>
/// <param name="message">The message being broadcasted.</param>
/// <param name="username">The username of the user who sent the message, defaults to "SERVER" if not provided.</param>
/// <param name="color">The color of the message, defaults to "#eee" if not provided.</param>
/// <param name="userid">The ID of the user who sent the message, defaults to 0 if not provided.</param>
/// <returns>
/// Returns `null` to allow the message to be broadcasted as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the message from being broadcasted.
/// </returns>
object OnServerMessage(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
{
    Puts($"Server message: {message} from {username} (ID: {userid})");
    if (message == "This is a test")
    {
        Puts("Ignoring server message as it's just a test.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", message, username, color, userid) == null)
		{
			ConsoleNetwork.BroadcastToAllClients("chat.add", 0, "<color=" + color + ">" + username + "</color> " + message);
			ChatEntry chatEntry = default(ChatEntry);
			chatEntry.Message = message;
			chatEntry.UserId = userid;
			chatEntry.Username = username;
			chatEntry.Color = color;
			chatEntry.Time = Epoch.Current;
			ChatEntry chatEntry2 = chatEntry;
			History.Add(chatEntry2);
			RCon.Broadcast(RCon.LogType.Chat, chatEntry2);
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="signage">The signage being updated (not used in this implementation).</param>
/// <returns>
/// Returns `true` if the player is allowed to update the sign, or `false` otherwise.
/// </returns>
bool CanUpdateSign(BasePlayer player, Signage signage)
{
    Puts($"Player {player.UserIDString} attempted to update a sign.");
    if (signage.IsLocked && player.userID != signage.OwnerID)
    {
        Puts($"Player {player.UserIDString} does not own the locked sign.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## CanUnlock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock the object.
/// </summary>
/// <param name="player">The player attempting to unlock.</param>
/// <param name="lock">The lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to unlock, or any non-null value to prevent them from unlocking.
/// </returns>
object CanUnlock(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} is attempting to unlock {lock.name}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Access denied: Only admins can unlock";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnAddVendingOffer(VendingMachine,ProtoBuf.VendingMachine.SellOrder)

```csharp
```csharp
/// <summary>
/// Called when a new vending offer is added.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was added to.</param>
/// <param name="sellOrder">The details of the sell order being added.</param>
object OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"Sell order added to vending machine {vendingMachine.name} for item ID {sellOrder.itemToSellID} and currency ID {sellOrder.currencyID}");
    if (sellOrder.itemToSellID == 123 && sellOrder.currencyID == 456)
    {
        Puts($"Warning: Sell order for rare item and high-value currency has been added.");
        return "Warning: Rare item and high-value currency sale";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = itemToSellID;
			sellOrder.itemToSellAmount = itemToSellAmount;
			sellOrder.currencyID = currencyToUseID;
			sellOrder.currencyAmountPerItem = currencyAmount;
			sellOrder.currencyIsBP = bpState == 3 || bpState == 2;
			sellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", this, sellOrder);
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## CanHackCrate(BasePlayer,HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called to determine if a crate can be hacked.
/// </summary>
/// <param name="player">The player attempting to hack the crate.</param>
/// <param name="crate">The crate being attempted to be hacked.</param>
/// <returns>
/// Returns `null` to allow the crate to be hacked, or any non-null value to prevent it from being hacked.
/// </returns>
object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
{
    Puts($"Player {player.UserIDString} is attempting to hack crate {crate.CrateID}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} has admin privileges and can hack the crate.");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} does not have admin privileges and cannot hack the crate.");
        return "Access denied: Not an administrator.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", msg.player, this) == null)
		{
			StartHacking();
		}
	}

```

## OnCrateHackEnd(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable crate has been successfully hacked.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateHackEnd(HackableLockedCrate crate)
{
    Puts($"Crate {crate.crateName} has been successfully hacked.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", this);
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			CancelInvoke(HackProgress);
		}
		ClientRPC(null, "UpdateHackProgress", (int)hackSeconds, (int)requiredHackSeconds);
	}

```

## OnPlayerRespawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player respawning.</param>
/// <returns>
/// Returns a non-null value to override the default respawn behavior. 
/// If a `SpawnPoint` object is returned, the player will respawn at that location and rotation.
/// If `null` is returned, the player will respawn at the default spawn point.
/// </returns>
object OnPlayerRespawn(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.IsAdmin)
    {
        SpawnPoint adminSpawn = new SpawnPoint(player.transform.position + Vector3.forward * 10, Quaternion.identity);
        return adminSpawn;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint();
		object obj = Interface.CallHook("OnPlayerRespawn", this);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnPlayerActiveItemChanged(BasePlayer,Item,Item)

```csharp
```csharp
/// <summary>
/// Called when a player's active item changes.
/// </summary>
/// <param name="player">The player whose active item has changed.</param>
/// <param name="oldItem">The old active item.</param>
/// <param name="newItem">The new active item.</param>
object OnPlayerActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
{
    Puts($"Player {player.UserIDString} changed their active item from {oldItem?.name ?? "null"} to {newItem?.name ?? "null"}.");
    if (newItem != null && newItem.name == "Medkit")
    {
        Puts($"Player {player.UserIDString} equipped a medkit.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal void UpdateActiveItem(uint itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = 0u;
		}
		Item activeItem = GetActiveItem();
		svActiveItemID = 0u;
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnPlayerActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnPlayerConnected(Network.Message)

```csharp
```csharp
/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="packet">The message packet containing information about the connected player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(Network.Message packet)
{
    Puts($"Player {packet.connection.info.Get("username")} has connected to the server.");
    if (packet.connection.info.Get("isModerator") == "true")
    {
        Puts($"Player {packet.connection.info.Get("username")} is a moderator.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void ClientReady(Message packet)
	{
		packet.connection.decryptIncoming = true;
		using ClientReady clientReady = ProtoBuf.ClientReady.Deserialize(packet.read);
		foreach (ClientReady.ClientInfo item in clientReady.clientInfo)
		{
			packet.connection.info.Set(item.name, item.value);
		}
		connectionQueue.JoinedGame(packet.connection);
		Interface.CallHook("OnPlayerConnected", packet);
		using (TimeWarning.New("ClientReady"))
		{
			using (TimeWarning.New("SpawnPlayerSleeping"))
			{
				if (SpawnPlayerSleeping(packet.connection))
				{
					return;
				}
			}
			using (TimeWarning.New("SpawnNewPlayer"))
			{
				SpawnNewPlayer(packet.connection);
			}
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player disconnects from the server.
/// </summary>
/// <param name="player">The disconnected player.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} disconnected with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void OnDisconnected(string strReason, Connection connection)
	{
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		Rust.Global.SteamServer.Auth.EndSession(connection.userid);
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((bool)basePlayer)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the oven is toggled on or off.
/// </summary>
/// <param name="oven">The oven being toggled.</param>
/// <param name="player">The player who toggled the oven.</param>
/// <returns>
/// Returns `null` to allow the oven to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts($"Oven {oven.GetGlobalName()} was toggled by player {player.UserIDString}.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot toggle the oven.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag != IsOn() && Interface.CallHook("OnOvenToggle", this, msg.player) == null && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				StartCooking();
			}
			else
			{
				StopCooking();
			}
		}
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="message">The text of the chat message.</param>
/// <param name="player">The player who sent the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be displayed, or any non-null value to prevent it from being displayed.
/// </returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Player {player.UserIDString} said: {message}");
    if (message.ToLower() == "bad word")
    {
        Puts($"Player {player.displayName} used a bad word and was muted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 0, msg);
		}
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player picks up an item.
/// </summary>
/// <param name="item">The item being picked up.</param>
/// <param name="player">The player picking up the item.</param>
/// <returns>
/// Returns `null` to allow the player to pick up the item, or any non-null value to prevent them from picking it up.
/// </returns>
object OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} picked up item: {item.displayName}");
    if (item.isLocked)
    {
        Puts($"Player {player.UserIDString} tried to pick up locked item: {item.displayName}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && item != null && allowPickup && Interface.CallHook("OnItemPickup", item, msg.player) == null)
		{
			ClientRPC(null, "PickupSound");
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable quantity of an item.
/// </summary>
/// <param name="item">The item being checked.</param>
/// <returns>
/// Returns the maximum stackable quantity, or any non-null value to override the default behavior. 
/// If `null` is returned, the default maximum stackable quantity will be used.
/// </returns>
object OnMaxStackable(Item item)
{
    Puts($"Checking max stackable for {item.name}...");
    if (item.category == "Rare")
    {
        Puts($"Item {item.name} has a custom max stackable of 10.");
        return 10;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is being repaired.
/// </summary>
/// <param name="structure">The structure being repaired.</param>
/// <param name="player">The player performing the repair.</param>
/// <returns>
/// Returns `null` to allow the repair to proceed, or any non-null value to cancel the repair.
/// </returns>
object OnStructureRepair(BaseCombatEntity structure, BasePlayer player)
{
    Puts($"Structure {structure.name} is being repaired by player {player.displayName}");
    if (player.inventory.GetAmount(ItemID.None) < 1000f)
    {
        Puts($"Player {player.displayName} does not have enough resources to repair the structure.");
        return "Not enough resources.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		if (SecondsSinceAttacked <= 30f)
		{
			OnRepairFailed();
			return;
		}
		float num = MaxHealth() - health;
		float num2 = num / MaxHealth();
		if (num <= 0f || num2 <= 0f)
		{
			OnRepairFailed();
			return;
		}
		List<ItemAmount> list = RepairCost(num2);
		if (list == null)
		{
			return;
		}
		float num3 = list.Sum((ItemAmount x) => x.amount);
		if (num3 > 0f)
		{
			float a = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			a = Mathf.Min(a, 50f / num);
			if (a <= 0f)
			{
				OnRepairFailed();
				return;
			}
			int num4 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(a * item.amount);
				int num5 = player2.inventory.Take(null, item.itemid, amount);
				if (num5 > 0)
				{
					num4 += num5;
					player2.Command("note.inv", item.itemid, num5 * -1);
				}
			}
			float num6 = (float)num4 / num3;
			health += num * num6;
			SendNetworkUpdate();
		}
		else
		{
			health += num;
			SendNetworkUpdate();
		}
		if (health >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## OnNpcPlayerTarget(NPCPlayerApex,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC player targets a base entity.
/// </summary>
/// <param name="npc">The NPC player apex.</param>
/// <param name="target">The targeted base entity.</param>
/// <returns>
/// Returns `null` to allow the default targeting behavior, or any non-null value to override it.
/// If a non-null value is returned, it will be used as the new target for the NPC player.
/// </returns>
object OnNpcPlayerTarget(NPCPlayerApex npc, BaseEntity target)
{
    Puts($"NPC {npc.UserIDString} has targeted entity {target.EntityId}.");
    if (target == null || target.EntityId == 12345)
    {
        Puts($"Entity {target.EntityId} is not a valid target for NPC {npc.UserIDString}.");
        return "Invalid Target";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public Memory.SeenInfo UpdateTargetMemory(BaseEntity target, float dmg, Vector3 lastKnownPosition, out Memory.ExtendedInfo extendedInfo)
	{
		if (target == null || Interface.CallHook("OnNpcPlayerTarget", this, target) != null)
		{
			extendedInfo = default(Memory.ExtendedInfo);
			return default(Memory.SeenInfo);
		}
		Vector3 dir;
		float dot;
		if (base.isMounted)
		{
			BestMountedPlayerDirection.Evaluate(this, lastKnownPosition, out dir, out dot);
		}
		else
		{
			BestPlayerDirection.Evaluate(this, lastKnownPosition, out dir, out dot);
		}
		BestPlayerDistance.Evaluate(this, lastKnownPosition, out var distanceSqr, out var _);
		BasePlayer basePlayer = target.ToPlayer();
		int standing;
		int crouched;
		byte b = (byte)((!basePlayer) ? 1 : ((!base.isMounted) ? BestLineOfSight.Evaluate(this, basePlayer, out standing, out crouched) : BestMountedLineOfSight.Evaluate(this, basePlayer)));
		SetFact(Facts.HasLineOfSight, b);
		return AiContext.Memory.Update(target, lastKnownPosition, dmg, dir, dot, distanceSqr, b, lastAttacker == target, lastAttackedTime, out extendedInfo);
	}

```

## IOnServerUsersSet(ulong,ServerUsers.UserGroup,string,string)

```csharp
```csharp
/// <summary>
/// Called when a server user's information is set.
/// </summary>
/// <param name="steamId">The Steam ID of the user.</param>
/// <param name="group">The group the user belongs to.</param>
/// <param name="username">The username of the user.</param>
/// <param name="notes">Any additional notes about the user.</param>
/// <returns>No return behavior.</returns>
void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string username, string notes)
{
    Puts($"User {username} with SteamID {steamId} has been set to group {group} with notes: {notes}");
}
```
```

### Source Code from the Library

```csharp

	public static void Set(ulong uid, UserGroup group, string username, string notes)
	{
		Interface.CallHook("IOnServerUsersSet", uid, group, username, notes);
		Remove(uid);
		User user = new User();
		user.steamid = uid;
		user.group = group;
		user.username = username;
		user.notes = notes;
		User value = user;
		users.Add(uid, value);
	}

```

## OnDispenserGather(ResourceDispenser,BaseEntity,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser gathers an item.
/// </summary>
/// <param name="dispenser">The dispenser that gathered the item.</param>
/// <param name="entity">The entity from which the item was gathered.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the item will be given to the entity as normal.
/// </returns>
object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
{
    Puts($"Dispenser {dispenser} gathered item {item} from entity {entity}.");
    if (item == null || item.amount <= 0)
    {
        Puts($"No items were gathered by dispenser {dispenser} from entity {entity}.");
        return null;
    }
    // Additional logic can be added here to handle the gathering of the item.
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BaseEntity entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float value = itemAmt.startAmount * num / num2;
		float num3 = Mathf.Clamp(value, 0f, itemAmt.amount);
		float num4 = num3 * destroyFraction * 2f;
		if (itemAmt.amount <= num3 + num4)
		{
			float num5 = (num3 + num4) / itemAmt.amount;
			num3 /= num5;
			num4 /= num5;
		}
		itemAmt.amount -= Mathf.Floor(num3);
		itemAmt.amount -= Mathf.Floor(num4);
		if (num3 < 1f)
		{
			num3 = ((!(UnityEngine.Random.Range(0f, 1f) <= num3)) ? 0f : 1f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (num3 >= 1f)
		{
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, Mathf.FloorToInt(num3), 0uL);
			if (item != null && Interface.CallHook("OnDispenserGather", this, entity, item) == null)
			{
				OverrideOwnership(item, attackWeapon);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a healing item is used on a player.
/// </summary>
/// <param name="medicalTool">The medical tool being used.</param>
/// <param name="player">The player receiving the healing effect.</param>
/// <returns>
/// Returns `null` to allow the healing effect to be applied, or any non-null value to override the default behavior.
/// </returns>
object OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)
{
    Puts($"Medical tool {medicalTool.name} used on player {player.displayName}");
    if (player.IsWounded())
    {
        Puts($"Player {player.displayName} is already wounded.");
        return true;
    }
    // Additional logic can be added here to override the default healing effect
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			if (player != GetOwnerPlayer() && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				player.StopWounded();
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when an entity is built.
/// </summary>
/// <param name="planner">The planner that built the entity.</param>
/// <param name="gameObject">The built entity's game object.</param>
void OnEntityBuilt(Planner planner, UnityEngine.GameObject gameObject)
{
    Puts($"Entity {gameObject.name} has been built by {planner.name}.");
    // Add custom logic here if needed
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())
		{
			return;
		}
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ChatMessage("Target socket is not female. (" + target.socket.socketName + ")");
				return;
			}
			if (target.entity != null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ChatMessage("Target socket is occupied. (" + target.socket.socketName + ")");
				return;
			}
		}
		else if (ConVar.AntiHack.eye_protection >= 2)
		{
			Vector3 center = ownerPlayer.eyes.center;
			Vector3 position = ownerPlayer.eyes.position;
			Vector3 origin = target.ray.origin;
			Vector3 position2 = target.position;
			if (!GamePhysics.LineOfSight(center, position, origin, position2, 2162688, 0.01f))
			{
				ownerPlayer.ChatMessage("Line of sight blocked.");
				return;
			}
		}
		Construction.lastPlacementError = "No Error";
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			ownerPlayer.ChatMessage("Can't place: " + Construction.lastPlacementError);
		}
		if (!(gameObject != null))
		{
			return;
		}
		Interface.CallHook("OnEntityBuilt", this, gameObject);
		Deployable deployable = GetDeployable();
		if (deployable != null)
		{
			BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
			if (deployable.setSocketParent && target.entity != null && target.entity.SupportsChildDeployables() && (bool)baseEntity)
			{
				baseEntity.SetParent(target.entity, worldPositionStays: true);
			}
			if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
			{
				(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
			}
			if (deployable.copyInventoryFromItem)
			{
				StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
				if ((bool)component2)
				{
					component2.ReceiveInventoryFromItem(GetOwnerItem());
				}
			}
			ItemModDeployable modDeployable = GetModDeployable();
			if (modDeployable != null)
			{
				modDeployable.OnDeployed(baseEntity, ownerPlayer);
			}
		}
		PayForPlacement(ownerPlayer, component);
	}

```

## OnSurveyGather(SurveyCharge,Item)

```csharp
```csharp
/// <summary>
/// Called when a survey charge is gathered.
/// </summary>
/// <param name="surveyCharge">The survey charge being gathered.</param>
/// <param name="item">The item being dropped as a result of the survey charge gathering.</param>
void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts($"Survey charge {surveyCharge} has been gathered and an item {item} is being dropped.");
    // You can add custom logic here to handle the survey charge gathering and item dropping.
    // For example, you could modify the item's properties or spawn additional entities based on the survey charge.
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		base.Explode();
		if (WaterLevel.Test(base.transform.position))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))
		{
			return;
		}
		Vector3 point = hitOut.point;
		Vector3 normal = hitOut.normal;
		List<SurveyCrater> obj = Pool.GetList<SurveyCrater>();
		Vis.Entities(base.transform.position, 10f, obj, 1);
		bool flag = obj.Count > 0;
		Pool.FreeList(ref obj);
		if (flag)
		{
			return;
		}
		bool flag2 = false;
		bool flag3 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag2 = true;
				if (resource.isLiquid)
				{
					flag3 = true;
				}
				for (int i = 0; i < num; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", this, item);
					float aimCone = 20f;
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, Vector3.up);
					BaseEntity baseEntity = item.Drop(base.transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation);
					baseEntity.SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
				}
			}
		}
		if (flag2)
		{
			string strPrefab = ((!flag3) ? craterPrefab.resourcePath : craterPrefab_Oil.resourcePath);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if ((bool)baseEntity2)
			{
				baseEntity2.Spawn();
			}
		}
	}

```

## OnSwitchAmmo(BasePlayer,BaseProjectile)

```csharp
```csharp
/// <summary>
/// Called when a player switches ammo.
/// </summary>
/// <param name="player">The player switching ammo.</param>
/// <param name="projectile">The projectile being switched to.</param>
/// <returns>
/// Returns a non-null value to override the default ammo switch behavior. 
/// If `null` is returned, the ammo switch will proceed as normal.
/// </returns>
object OnSwitchAmmo(BasePlayer player, BaseProjectile projectile)
{
    Puts($"Player {player.UserIDString} switched ammo to {projectile.definition.displayName}.");
    if (projectile.definition.ammoType == "restricted")
    {
        Puts($"Player {player.UserIDString} cannot switch to restricted ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnSwitchAmmo", ownerPlayer, this) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				primaryMagazine.contents = 0;
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that died.</param>
/// <param name="info">Information about the hit that killed the entity, if any.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity.name} has died.");
    if (info != null && info.Attacker != null)
    {
        Puts($"Entity was killed by {info.Attacker.name} with damage: {info.Damage}");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		Interface.CallHook("OnEntityDeath", this, info);
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
		}
		health = 0f;
		lifestate = LifeState.Dead;
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The container from which the items were dropped.</param>
/// <returns>
/// Returns `true` to override the default drop behavior, or `false` to allow the items to be dropped normally.
/// If `null` is returned, the default drop behavior will be used.
/// </returns>
bool OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping items from container {container}.");
    if (container.itemList.Count > 10)
    {
        Puts($"Not dropping items from container {container}, as it contains too many items.");
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position, float chance = 1f)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			if (!(UnityEngine.Random.Range(0f, 1f) > chance))
			{
				float num2 = UnityEngine.Random.Range(0f, 2f);
				item.RemoveFromContainer();
				BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
				if (baseEntity == null)
				{
					item.Remove();
				}
				else if (num2 > 0f)
				{
					baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
					baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
				}
			}
		}
	}

```

## OnFlameThrowerBurn(FlameThrower,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a flame thrower burns an entity.
/// </summary>
/// <param name="flameThrower">The flame thrower that caused the burn.</param>
/// <param name="burnedEntity">The entity that was burned.</param>
public void OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity burnedEntity)
{
    Puts($"Entity {burnedEntity} has been burned by flame thrower {flameThrower}.");
    // Add custom logic here if needed
}
```
```

### Source Code from the Library

```csharp

	public void FlameTick()
	{
		float num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;
		lastFlameTick = UnityEngine.Time.realtimeSinceStartup;
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		ReduceAmmo(num);
		SendNetworkUpdate();
		Ray ray = ownerPlayer.eyes.BodyRay();
		Vector3 origin = ray.origin;
		RaycastHit hitInfo;
		bool flag = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);
		if (!flag)
		{
			hitInfo.point = origin + ray.direction * flameRange;
		}
		float amount = damagePerSec[0].amount;
		damagePerSec[0].amount = amount * num;
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, 2246913, useLineOfSight: true);
		damagePerSec[0].amount = amount;
		if (flag && UnityEngine.Time.realtimeSinceStartup >= nextFlameTime && hitInfo.distance > 1.1f)
		{
			nextFlameTime = UnityEngine.Time.realtimeSinceStartup + 0.45f;
			Vector3 point = hitInfo.point;
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, point - ray.direction * 0.25f);
			if ((bool)baseEntity)
			{
				baseEntity.creatorEntity = ownerPlayer;
				Interface.CallHook("OnFlameThrowerBurn", this, baseEntity);
				baseEntity.Spawn();
			}
		}
		if (ammo == 0)
		{
			SetFlameState(wantsOn: false);
		}
		GetOwnerItem()?.LoseCondition(num);
	}

```

## OnHelicopterKilled(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter is killed.
/// </summary>
/// <param name="helicopter">The helicopter that was killed.</param>
/// <returns>
/// Returns `null` to allow the helicopter's death to be handled normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display when the helicopter is killed.
/// </returns>
object OnHelicopterKilled(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetDisplayName()} has been destroyed.");
    if (helicopter.GetDisplayName() == "Enemy Helicopter")
    {
        Puts($"Enemy helicopter {helicopter.GetDisplayName()} has been eliminated.");
        return "Enemy helicopter eliminated.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterKilled", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret is shutting down.
/// </summary>
/// <param name="turret">The AutoTurret instance being shut down.</param>
/// <returns>
/// Returns `null` to allow the turret to shut down normally, or any non-null value to prevent it from shutting down.
/// </returns>
object OnTurretShutdown(AutoTurret turret)
{
    Puts($"Turret {turret.name} is shutting down.");
    if (turret.isMalfunctioning())
    {
        Puts($"Turret {turret.name} has malfunctioned and will not shut down.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if (!IsOffline() && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## OnConsumeFuel(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when fuel is consumed by an oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The item being consumed as fuel.</param>
/// <param name="burnable">The burnable item that determines how the fuel is used.</param>
/// <returns>No return behavior.</returns>
void OnConsumeFuel(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Fuel {fuel.info.name} consumed by oven {oven.info.name}.");
    if (burnable.fuelAmount <= 0)
    {
        Puts($"Error: Burnable item has no fuel amount set.");
        return;
    }
    // Additional logic can be added here to handle the consumption of fuel.
}
```
```

### Source Code from the Library

```csharp

	private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		Interface.CallHook("OnConsumeFuel", this, fuel, burnable);
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount, 0uL);
			if (!item.MoveToContainer(inventory))
			{
				OvenFull();
				item.Drop(inventory.dropPosition, inventory.dropVelocity);
			}
		}
		if (fuel.amount <= 1)
		{
			fuel.Remove();
			return;
		}
		fuel.amount--;
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
	}

```

## IOnServerInitialized()

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
void IOnServerInitialized()
{
    Puts("Server initialization complete.");
    // Add any additional logic or setup required after server initialization here.
}
```
```

### Source Code from the Library

```csharp

	public void OpenConnection()
	{
		useQueryPort = ConVar.Server.queryport > 0 && ConVar.Server.queryport != ConVar.Server.port;
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		if (!Network.Net.sv.Start())
		{
			UnityEngine.Debug.LogWarning("Couldn't Start Server.");
			return;
		}
		StartSteamServer();
		Network.Net.sv.callbackHandler = this;
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		EACServer.DoStartup();
		InvokeRepeating("EACUpdate", 1f, 1f);
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		Interface.CallHook("IOnServerInitialized");
	}

```

## OnItemRemove(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from the game.
/// </summary>
/// <param name="item">The item being removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemove(Item item)
{
    Puts($"Item {item.info.name} has been removed.");
    if (item.info.category == "Forbidden")
    {
        Puts($"Item {item.info.name} is a forbidden item and cannot be removed.");
        // Add any additional logic to handle the removal of forbidden items
    }
}
```
```

### Source Code from the Library

```csharp

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			foreach (ItemMod itemMod in itemMods)
			{
				itemMod.OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = UnityEngine.Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		if (isServer)
		{
			ItemManager.RemoveItem(this, fTime);
		}
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
```csharp
/// <summary>
/// Called to determine if two dropped items can be combined.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>
/// Returns `null` to allow the combination, or any non-null value to prevent it.
/// </returns>
object CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts($"Checking if items {item1.info.name} and {item2.info.name} can be combined.");
    if (item1.info.stackable <= 1 || item2.item.info != item1.info || (item2.IsBlueprint() && item2.blueprintTarget != item1.blueprintTarget))
    {
        Puts($"Items cannot be combined due to stackability or blueprint target mismatch.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || item.info.stackable <= 1 || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget))
		{
			return;
		}
		int num = di.item.amount + item.amount;
		if (num <= item.info.stackable && num != 0)
		{
			di.DestroyItem();
			di.Kill();
			item.amount = num;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
		}
	}

```

## OnHelicopterOutOfCrates(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter runs out of crates.
/// </summary>
/// <param name="controller">The AI controller for the helicopter.</param>
/// <returns>
/// Returns `true` if the helicopter has run out of crates, and `false` otherwise.
/// If this method returns `null`, it will be assumed that the helicopter has run out of crates.
/// </returns>
bool OnHelicopterOutOfCrates(CH47HelicopterAIController controller)
{
    Puts("Helicopter is running low on crates!");
    if (controller.numCrates <= 0)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

```

## CanExperiment(BasePlayer,Workbench)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to start an experiment.
/// </summary>
/// <param name="player">The player attempting to start the experiment.</param>
/// <param name="workbench">The workbench being used for the experiment.</param>
/// <returns>
/// Returns `null` to allow the experiment to proceed, or any non-null value to prevent the experiment from starting.
/// </returns>
object CanExperiment(BasePlayer player, Workbench workbench)
{
    Puts($"Player {player.UserID} is attempting to start an experiment on workbench {workbench.name}.");
    if (player.GetRole() == "Admin")
    {
        return null;
    }
    else
    {
        return "You do not have permission to perform this action.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !playerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("CanExperiment", player, this) != null)
			{
				return;
			}
			Item slot = inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
		}
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret sets its target.
/// </summary>
/// <param name="turret">The helicopter turret setting the target.</param>
/// <param name="target">The entity being targeted by the helicopter turret.</param>
/// <returns>
/// Returns `null` to allow the helicopter turret to set its target, or any non-null value to prevent it from setting its target.
/// </returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts($"Helicopter turret {turret.GetReference()} is targeting entity {target.UserIDString}.");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"Player {player.UserIDString} is being targeted by helicopter turret {turret.GetReference()}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="block">The building block being modified.</param>
/// <param name="grade">The new grade to be applied.</param>
/// <returns>
/// Returns `true` if the player can change the grade, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
{
    Puts($"Player {player.UserIDString} attempted to change the grade of {block.BlockName} to {grade}.");
    if (grade == BuildingGrade.Enum.Premium && !player.HasPremiumSubscription())
    {
        Puts($"Player {player.displayName} does not have a premium subscription and cannot upgrade to Premium grade.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanChangeToGrade(BuildingGrade.Enum iGrade, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return HasUpgradePrivilege(iGrade, player) && !IsUpgradeBlocked();
	}

```

## OnStructureDemolish(BuildingBlock,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a structure is demolished.
/// </summary>
/// <param name="structure">The structure being demolished.</param>
/// <param name="player">The player demolishing the structure.</param>
/// <param name="isForced">Whether the demolition was forced or not.</param>
/// <returns>
/// Returns `null` to allow the structure to be demolished, or any non-null value to prevent it from being demolished.
/// </returns>
object OnStructureDemolish(BuildingBlock structure, BasePlayer player, bool isForced)
{
    Puts($"Structure {structure.name} has been demolished by player {player.UserIDString}.");
    if (isForced && structure.isImportant)
    {
        Puts($"Demolition of important structure {structure.name} was forced.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Kill(DestroyMode.Gib);
		}
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded to a new grade.
/// </summary>
/// <param name="structure">The structure being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="grade">The new grade of the structure.</param>
/// <returns>
/// Returns a non-null value to override the default upgrade behavior. 
/// If `null` is returned, the structure is upgraded as normal.
/// </returns>
object OnStructureUpgrade(BuildingBlock structure, BasePlayer player, BuildingGrade.Enum grade)
{
    Puts($"Structure {structure.name} has been upgraded by player {player.UserIDString} to grade {grade}.");
    if (grade == BuildingGrade.Enum.Premium && !player.HasPermission("premium_upgrade"))
    {
        Puts($"Player {player.UserIDString} does not have permission to upgrade to premium grade.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoUpgradeToGrade(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
			ConstructionGrade constructionGrade = GetGrade(@enum);
			if (!(constructionGrade == null) && CanChangeToGrade(@enum, msg.player) && CanAffordUpgrade(@enum, msg.player) && !(base.SecondsSinceAttacked < 30f) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum) == null)
			{
				PayForUpgrade(constructionGrade, msg.player);
				SetGrade(@enum);
				SetHealthToMax();
				StartBeingRotatable();
				SendNetworkUpdate();
				UpdateSkin();
				ResetUpkeepTime();
				BuildingManager.server.GetBuilding(buildingID)?.Dirty();
				Effect.server.Run("assets/bundled/prefabs/fx/build/promote_" + @enum.ToString().ToLower() + ".prefab", this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item was removed.</param>
/// <param name="item">The item that was removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been removed from container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		if (onPreItemRemove != null)
		{
			onPreItemRemove(item);
		}
		itemList.Remove(item);
		item.parent = null;
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: false);
		}
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed.
/// </summary>
/// <param name="trap">The bear trap being armed.</param>
/// <param name="player">The player who triggered the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to be armed, or any non-null value to prevent it from arming.
/// </returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Bear trap {trap.name} has been armed by player {player.displayName}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot trigger traps.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## IOnNpcPlayerSenseVision(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses a player in its vision range.
/// </summary>
/// <param name="npc">The NPC sensing the player.</param>
/// <returns>
/// Returns `null` to allow the NPC to sense the player, or any non-null value to prevent it from sensing the player.
/// </returns>
object IOnNpcPlayerSenseVision(NPCPlayerApex npc)
{
    Puts($"NPC {npc.name} senses a player in its vision range.");
    if (npc.target == null || npc.target.IsDead())
    {
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void _FindPlayersInVisionRange()
	{
		if (AI.ignoreplayers || base.transform == null || Interface.CallHook("IOnNpcPlayerSenseVision", this) != null)
		{
			return;
		}
		PlayerQueryResultCount = Query.Server.GetPlayersInSphere(base.transform.position, Stats.VisionRange, PlayerQueryResults, delegate(BasePlayer player)
		{
			if (player == null || !player.isServer || player.IsDead())
			{
				return false;
			}
			if (player.IsSleeping() && player.secondsSleeping < NPCAutoTurret.sleeperhostiledelay)
			{
				return false;
			}
			float num = Stats.VisionRange * Stats.VisionRange;
			float sqrMagnitude = (player.ServerPosition - ServerPosition).sqrMagnitude;
			return !(sqrMagnitude > num);
		});
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The Bradley APC instance.</param>
/// <returns>
/// Returns `null` to allow the APC to initialize normally, or any non-null value to override the default initialization behavior.
/// </returns>
object OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Bradley APC initialized at position: {apc.transform.position}");
    // If you want to change the destination of the APC, do it here
    apc.destination = new Vector3(10.0f, 5.0f, 2.0f);
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="lootableCorpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts($"Player {player.UserIDString} stopped looting the lootable corpse.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is patrolling.
/// </summary>
/// <param name="apc">The Bradley APC performing the patrol.</param>
/// <returns>
/// Returns `null` to allow the APC to continue patrolling, or any non-null value to override the default patrol behavior.
/// If a string is returned, it will be used as a message to display in the console.
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC {apc.GetId()} is patrolling.");
    if (apc.GetPosition() == Vector3.zero)
    {
        Puts("Bradley APC has reached its final destination.");
        return "Bradley APC has reached its final destination.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		PathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		BasePathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.transform.position);
		BasePathNode basePathNode = null;
		bool flag = false;
		List<BasePathNode> nodes = Facepunch.Pool.GetList<BasePathNode>();
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			basePathNode = nodes[nodes.Count - 1];
		}
		else
		{
			basePathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.transform.position) > 2f))
		{
			return;
		}
		if (closestToPoint == basePathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.transform.position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
		else
		{
			if (!AStarPath.FindPath(basePathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].transform.position);
				}
			}
			foreach (BasePathNode item in path)
			{
				currentPath.Add(item.transform.position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.transform.position;
		}
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
```csharp
/// <summary>
/// Called when a new resource deposit is created.
/// </summary>
/// <param name="resourceDeposit">The newly created resource deposit.</param>
void OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit resourceDeposit)
{
    Puts($"New resource deposit created at position {resourceDeposit.origin}.");
}
```
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		uint seed = new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt);
		UnityEngine.Random.InitState((int)seed);
		ResourceDeposit resourceDeposit = new ResourceDeposit();
		resourceDeposit.origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20);
		float num = UnityEngine.Random.Range(0f, 1f);
		if (num < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else if (0 == 0)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
			float num2 = 0f;
			if (World.Procedural)
			{
				float num3 = ((!(TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f)) ? 0f : 1f);
				num2 = num3 * 0.25f;
			}
			else
			{
				num2 = 0.1f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num4 = 0f;
			if (World.Procedural)
			{
				float num5 = ((!(TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)) ? 0f : 1f);
				num4 = num5 * (0.25f + 0.25f * ((!TerrainMeta.TopologyMap.GetTopology(pos, 8)) ? 0f : 1f) + 0.25f * ((!TerrainMeta.TopologyMap.GetTopology(pos, 1)) ? 0f : 1f));
			}
			else
			{
				num4 = 0.1f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num4)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num6 = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
				{
					num6 += 0.25f;
				}
			}
			else
			{
				num6 += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num6)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret starts up.
/// </summary>
/// <param name="turret">The AutoTurret instance starting up.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally, or any non-null value to prevent it from starting up.
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"Turret {turret.name} has started up.");
    if (turret.isMalfunctioning)
    {
        Puts($"Turret {turret.name} is malfunctioning and cannot start up.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnCrateLanded(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate lands on the ground.
/// </summary>
/// <param name="crate">The landed crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateLanded(HackableLockedCrate crate)
{
    Puts($"Hackable locked crate landed at position {crate.transform.position}.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void LandCheck()
	{
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", this);
			return;
		}
		Ray ray = new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down);
		if (UnityEngine.Physics.Raycast(ray, out var hitInfo, 1f, 1218511105))
		{
			Effect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);
			hasLanded = true;
			CancelInvoke(LandCheck);
		}
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is upgraded.
/// </summary>
/// <param name="oldItem">The original item being upgraded.</param>
/// <param name="newItem">The upgraded item.</param>
/// <param name="player">The player who performed the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnItemUpgrade(Item oldItem, Item newItem, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has upgraded their {oldItem.info.name} to a {newItem.info.name}.");
    if (newItem.info.category == "rare")
    {
        Puts($"The upgraded item is rare! Player {player.UserIDString} will receive a bonus reward.");
        // Add code here to give the player a bonus reward
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		float num = UnityEngine.Random.Range(0f, 1f);
		if (num <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is deauthorized.
/// </summary>
/// <param name="turret">The AutoTurret instance that was deauthorized.</param>
/// <param name="player">The player who deauthorized the turret.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.name} has been deauthorized by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			SendNetworkUpdate();
		}
	}

```

## OnRconConnection(System.Net.IPEndPoint)

```csharp
```csharp
/// <summary>
/// Called when an RCON connection is established.
/// </summary>
/// <param name="remoteEndPoint">The remote endpoint of the RCON connection.</param>
/// <returns>
/// Returns a non-null value to override the default behavior and close the socket. 
/// If `null` is returned, the RCON client will be processed as normal.
/// </returns>
object OnRconConnection(System.Net.IPEndPoint remoteEndPoint)
{
    Puts($"RCON connection established from {remoteEndPoint}");
    if (remoteEndPoint.Address.ToString() == "192.168.1.1")
    {
        Puts("Ignoring RCON connection - banned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", iPEndPoint) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnLootSpawn(LootContainer)

```csharp
```csharp
/// <summary>
/// Called when loot is spawned.
/// </summary>
/// <param name="lootContainer">The LootContainer that was spawned.</param>
/// <returns>
/// Returns `null` to allow the loot container to spawn normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be logged as a message.
/// </returns>
object OnLootSpawn(LootContainer lootContainer)
{
    Puts($"Loot has been spawned in {lootContainer.GetPosition()}");
    if (lootContainer.GetWeight() > 1000)
    {
        Puts($"Warning: Loot container is overweight! Weight: {lootContainer.GetWeight()}");
        return "Overweight";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void SpawnLoot()
	{
		if (inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				Invoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

```

## IOnEnableServerConsole(ServerConsole)

```csharp
```csharp
/// <summary>
/// Called when the server console is enabled.
/// </summary>
/// <param name="console">The server console instance.</param>
/// <returns>No return behavior.</returns>
void IOnEnableServerConsole(ServerConsole console)
{
    Puts("Server console has been enabled.");
}
```
```

### Source Code from the Library

```csharp

	public void OnEnable()
	{
		if (Interface.CallHook("IOnEnableServerConsole", this) == null)
		{
		}
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
Here is the method structure for `OnMeleeAttack(BasePlayer, HitInfo)`:

/// <summary>
/// Called when a melee attack occurs.
/// </summary>
/// <param name="player">The player who performed the attack.</param>
/// <param name="hitInfo">Information about the hit.</param>
/// <returns>Returns true if the attack is valid, false otherwise.</returns>
bool OnMeleeAttack(BasePlayer player, HitInfo hitInfo)
{
    // Minimal code to demonstrate functionality
    Puts("OnMeleeAttack called!");
    
    // Return true if the attack is valid, false otherwise
    return true;
}
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50L))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo hitInfo = Facepunch.Pool.Get<HitInfo>();
			hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
			hitInfo.Initiator = player;
			hitInfo.Weapon = this;
			hitInfo.WeaponPrefab = this;
			hitInfo.Predicted = msg.connection;
			hitInfo.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, hitInfo) != null)
			{
				return;
			}
			if (hitInfo.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.Log(hitInfo, "melee_nan");
				return;
			}
			if (ConVar.AntiHack.melee_protection > 0 && (bool)hitInfo.HitEntity)
			{
				bool flag = true;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTime + num2 + num3) * num;
				if (ConVar.AntiHack.projectile_protection >= 2)
				{
					float num5 = hitInfo.HitEntity.MaxVelocity() + hitInfo.HitEntity.GetParentVelocity().magnitude;
					float num6 = hitInfo.HitEntity.BoundsPadding() + num4 * num5;
					float num7 = hitInfo.HitEntity.Distance(hitInfo.HitPositionWorld);
					if (num7 > num6)
					{
						string shortPrefabName2 = base.ShortPrefabName;
						string shortPrefabName3 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName2 + " on " + shortPrefabName3 + " with " + num7 + "m > " + num6 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_distance");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					float num8 = hitInfo.Initiator.MaxVelocity() + hitInfo.Initiator.GetParentVelocity().magnitude;
					float num9 = hitInfo.Initiator.BoundsPadding() + num4 * num8 + num * maxDistance;
					float num10 = hitInfo.Initiator.Distance(hitInfo.HitPositionWorld);
					if (num10 > num9)
					{
						string shortPrefabName4 = base.ShortPrefabName;
						string shortPrefabName5 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num10 + "m > " + num9 + "m in " + num4 + "s)");
						player.stats.combat.Log(hitInfo, "melee_distance");
						flag = false;
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					Vector3 pointStart = hitInfo.PointStart;
					Vector3 vector = hitInfo.HitPositionWorld + hitInfo.HitNormalWorld.normalized * 0.001f;
					Vector3 center = player.eyes.center;
					Vector3 position = player.eyes.position;
					Vector3 vector2 = pointStart;
					Vector3 vector3 = hitInfo.PositionOnRay(vector);
					Vector3 vector4 = vector;
					bool flag2 = GamePhysics.LineOfSight(center, position, vector2, vector3, vector4, 2162688);
					if (!flag2)
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
					}
					else
					{
						player.stats.Add("hit_" + hitInfo.HitEntity.Categorize() + "_direct_los", 1, Stats.Server);
					}
					if (!flag2)
					{
						string shortPrefabName6 = base.ShortPrefabName;
						string shortPrefabName7 = hitInfo.HitEntity.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat("Line of sight (", shortPrefabName6, " on ", shortPrefabName7, ") ", center, " ", position, " ", vector2, " ", vector3, " ", vector4));
						player.stats.combat.Log(hitInfo, "melee_los");
						flag = false;
					}
				}
				if (!flag)
				{
					AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
					return;
				}
			}
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50L))
			{
				DoAttackShared(hitInfo);
			}
		}
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when a projectile is created in the world.
/// </summary>
/// <param name="info">The hit info of the projectile.</param>
/// <param name="itemDef">The definition of the item being used to create the projectile.</param>
/// <returns>
/// Returns `null` if the projectile should be created normally, or a non-null value to override the default behavior.
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object CanCreateWorldProjectile(HitInfo info, ItemDefinition itemDef)
{
    Puts($"Player {info.Attacker} tried to create a projectile in world at position {info.HitPositionWorld}.");
    if (itemDef.name == "Forbidden Projectile")
    {
        Puts($"Player {info.Attacker} tried to use the forbidden projectile {itemDef.name}.");
        return "You are not allowed to use that projectile.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		UnityEngine.Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem == null) ? ItemManager.Create(itemDef, 1, 0uL) : recycleItem);
		if (Interface.CallHook("OnCreateWorldProjectile", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		Rigidbody rigidbody = null;
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			rigidbody = baseEntity.GetComponent<Rigidbody>();
			rigidbody.isKinematic = true;
		}
		else
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			rigidbody = baseEntity.GetComponent<Rigidbody>();
			rigidbody.AddForce(projectileVelocity.normalized * 200f);
			rigidbody.WakeUp();
		}
	}

```

## OnNpcStopMoving(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC stops moving.
/// </summary>
/// <param name="npc">The NPC that stopped moving.</param>
/// <returns>No return behavior.</returns>
void OnNpcStopMoving(NPCPlayerApex npc)
{
    Puts($"NPC {npc.name} has stopped moving.");
}
```
```

### Source Code from the Library

```csharp

	public void StopMoving()
	{
		if (Interface.CallHook("OnNpcStopMoving", this) == null)
		{
			IsStopped = true;
			finalDestination = GetPosition();
		}
	}

```

## OnRecycleItem(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled.
/// </summary>
/// <param name="recycler">The recycler that is recycling the item.</param>
/// <param name="item">The item being recycled.</param>
/// <returns>
/// Returns a non-null value to override the default recycling behavior. 
/// If `null` is returned, the item is recycled as normal.
/// </returns>
object OnRecycleItem(Recycler recycler, Item item)
{
    Puts($"Item {item.info.shortname} has been recycled.");
    if (item.info.shortname == "scrap")
    {
        Puts($"Item {item.info.shortname} cannot be recycled because it is already scrap.");
        return null;
    }
    // Add custom recycling logic here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = recycleEfficiency;
		for (int i = 0; i < 6; i++)
		{
			Item slot = inventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			if (Interface.CallHook("OnRecycleItem", this, slot) != null)
			{
				if (!HasRecyclable())
				{
					StopRecycling();
				}
				return;
			}
			if (!(slot.info.Blueprint != null))
			{
				continue;
			}
			if (slot.hasCondition)
			{
				num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
			}
			int num2 = 1;
			if (slot.amount > 1)
			{
				num2 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.info.stackable * 0.1f));
			}
			if (slot.info.Blueprint.scrapFromRecycle > 0)
			{
				int num3 = slot.info.Blueprint.scrapFromRecycle * num2;
				if (slot.info.stackable == 1 && slot.hasCondition)
				{
					num3 = Mathf.CeilToInt((float)num3 * slot.conditionNormalized);
				}
				if (num3 >= 1)
				{
					Item newItem = ItemManager.CreateByName("scrap", num3, 0uL);
					MoveItemToOutput(newItem);
				}
			}
			slot.UseItem(num2);
			foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
			{
				if (ingredient.itemDef.shortname == "scrap")
				{
					continue;
				}
				float num4 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
				int num5 = 0;
				if (num4 <= 1f)
				{
					for (int j = 0; j < num2; j++)
					{
						if (UnityEngine.Random.Range(0f, 1f) <= num4 * num)
						{
							num5++;
						}
					}
				}
				else
				{
					num5 = Mathf.CeilToInt(Mathf.Clamp(num4 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount) * (float)num2);
				}
				if (num5 <= 0)
				{
					continue;
				}
				int num6 = Mathf.CeilToInt((float)num5 / (float)ingredient.itemDef.stackable);
				for (int k = 0; k < num6; k++)
				{
					int num7 = ((num5 <= ingredient.itemDef.stackable) ? num5 : ingredient.itemDef.stackable);
					Item newItem2 = ItemManager.Create(ingredient.itemDef, num7, 0uL);
					if (!MoveItemToOutput(newItem2))
					{
						flag = true;
					}
					num5 -= num7;
					if (num5 <= 0)
					{
						break;
					}
				}
			}
			break;
		}
		if (flag || !HasRecyclable())
		{
			StopRecycling();
		}
	}

```

## OnPlayerRevive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is revived.
/// </summary>
/// <param name="reviver">The player who performed the revive.</param>
/// <param name="victim">The player being revived.</param>
/// <returns>
/// Returns `null` to allow the victim to be revived, or any non-null value to prevent them from being revived.
/// </returns>
object OnPlayerRevive(BasePlayer reviver, BasePlayer victim)
{
    Puts($"Player {reviver.UserIDString} has revived player {victim.UserIDString}");
    if (reviver.IsWounded())
    {
        Puts($"Player {reviver.UserIDString} cannot revive themselves.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemModConsumable component = GetOwnerItemDefinition().GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			if (player != GetOwnerPlayer() && player.IsWounded() && canRevive)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				player.StopWounded();
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
		}
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be wounded.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="hitInfo">Information about the hit that caused this call.</param>
/// <returns>
/// Returns `true` if the player can be wounded, or `false` otherwise. 
/// If a non-boolean value is returned, it will override the default behavior.
/// </returns>
object CanBeWounded(BasePlayer player, HitInfo hitInfo)
{
    Puts($"Checking if {player.UserIDString} can be wounded by {hitInfo.WeaponPrefab.name}.");
    if (hitInfo.WeaponPrefab.name == "Melee")
    {
        Puts($"Player {player.UserIDString} cannot be wounded by melee attacks.");
        return false;
    }
    if (hitInfo.isHeadshot)
    {
        Puts($"Player {player.UserIDString} cannot be wounded by headshots.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastWoundedTime < 60f)
		{
			return false;
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the vending broadcast toggle is changed.
/// </summary>
/// <param name="vendingMachine">The vending machine that was toggled.</param>
/// <param name="player">The player who performed the action.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending broadcast toggle changed by {player.displayName} for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="lock">The lock on the entity, which could be a key or other type of lock.</param>
/// <returns>
/// Returns `true` if the player can use the locked entity, and `false` otherwise.
/// If `null` is returned, the default behavior will be used (i.e., the player cannot use the locked entity unless they have permission).
/// </returns>
bool CanUseLockedEntity(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} attempted to use locked entity with key {lock.KeyID}");
    if (lock.IsMasterKey())
    {
        return true;
    }
    // Check if the player has permission to use the locked entity
    if (HasPermission(player, Permission.UseLockedEntity))
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the turret.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="turret">The turret doing the targeting.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts($"Checking if {player.Name} can be targeted by {turret.name}.");
    if (player.IsSleeping() || !player.IsAlive() || player.IsBuildingAuthed())
    {
        return false;
    }
    object obj = Interface.CallHook("CanBeTargeted", player, turret);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // Additional checks can be added here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		List<BasePlayer> obj2 = Pool.GetList<BasePlayer>();
		Vis.Entities(GetEyePosition() + base.transform.forward * 3f, 2.5f, obj2, 131072);
		bool flag = false;
		foreach (BasePlayer item in obj2)
		{
			if (item.IsSleeping() || !item.IsAlive() || item.IsBuildingAuthed())
			{
				continue;
			}
			object obj3 = Interface.CallHook("CanBeTargeted", item, this);
			if (obj3 is bool)
			{
				Pool.FreeList(ref obj);
				Pool.FreeList(ref obj2);
				return (bool)obj3;
			}
			if (item.transform.position.y > GetEyePosition().y + 0.5f)
			{
				continue;
			}
			obj.Clear();
			GamePhysics.TraceAll(new Ray(item.eyes.position, (GetEyePosition() - item.eyes.position).normalized), 0f, obj, 9f, 1218519297);
			for (int i = 0; i < obj.Count; i++)
			{
				RaycastHit hit = obj[i];
				BaseEntity entity = RaycastHitEx.GetEntity(hit);
				if (entity != null && (entity == this || entity.EqualNetID(this)))
				{
					flag = true;
					break;
				}
				if (!(entity != null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			break;
		}
		Pool.FreeList(ref obj);
		Pool.FreeList(ref obj2);
		return flag;
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is being accepted into the container.
/// </summary>
/// <param name="item">The item being accepted.</param>
/// <param name="targetPos">The position in the container where the item will be placed.</param>
/// <returns>
/// Returns a non-null value to override the default acceptance behavior. 
/// If `CanAcceptResult.CannotAccept` is returned, the item cannot be accepted into the container.
/// If `CanAcceptResult.CannotAcceptRightNow` is returned, the item can be accepted into the container, but there are not enough available slots to accommodate it.
/// </returns>
object CanAcceptItem(ItemContainer container, Item item, int targetPos)
{
    Puts($"Item {item.info.name} is being accepted into container {container.info.name} at position {targetPos}.");
    if (item.info.itemType == ItemType.Key && !container.info.hasLock)
    {
        Puts($"Item {item.info.name} cannot be accepted into container {container.info.name} because it does not have a lock.");
        return CanAcceptResult.CannotAccept;
    }
    object obj = Interface.CallHook("CanAcceptItem", container, item, targetPos);
    if (obj is CanAcceptResult)
    {
        return obj;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (onlyAllowedItem != null && onlyAllowedItem != item.info)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			int[] array = new int[32];
			foreach (ItemSlot availableSlot in availableSlots)
			{
				array[(int)Mathf.Log((float)availableSlot, 2f)]++;
			}
			foreach (Item item2 in itemList)
			{
				for (int i = 0; i < 32; i++)
				{
					if (((uint)item2.info.occupySlots & (uint)(1 << i)) != 0)
					{
						array[i]--;
					}
				}
			}
			for (int j = 0; j < 32; j++)
			{
				if (((uint)item.info.occupySlots & (uint)(1 << j)) != 0 && array[j] <= 0)
				{
					return CanAcceptResult.CannotAcceptRightNow;
				}
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		return CanAcceptResult.CanAccept;
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.GetPlayerFlag(PlayerFlags.IsAdmin))
    {
        Puts($"Player {player.displayName} is an admin and will receive a special spawn reward.");
        // Reward the admin with something
    }
    else
    {
        Puts($"Player {player.displayName} is not an admin and will respawn normally.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RespawnAt(UnityEngine.Vector3 position, Quaternion rotation)
	{
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		ServerPerformance.spawns++;
		SetParent(null, worldPositionStays: true);
		base.transform.position = position;
		base.transform.rotation = rotation;
		tickInterpolator.Reset(position);
		lastTickTime = 0f;
		StopWounded();
		StopSpectating();
		UpdateNetworkGroup();
		UpdatePlayerCollider(state: true);
		UpdatePlayerRigidbody(state: false);
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		InitializeHealth(StartHealth(), StartMaxHealth());
		inventory.GiveDefaultItems();
		SendNetworkUpdateImmediate();
		ClearEntityQueue();
		ClientRPCPlayer(null, this, "StartLoading");
		if (net != null)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", this);
		SendFullSnapshot();
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's sleep has ended.
/// </summary>
/// <param name="player">The player whose sleep has ended.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has woken up from sleep.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and will not be affected by the wake-up event.");
        return;
    }
    // Additional logic can be added here to handle the player's wake-up event.
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (!IsSleeping())
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.Sleeping, b: false);
		sleepStartTime = -1f;
		sleepingPlayerList.Remove(this);
		InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
		if (RelationshipManager.TeamsEnabled())
		{
			InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
		}
		UpdatePlayerCollider(state: true);
		UpdatePlayerRigidbody(state: true);
		Interface.CallHook("OnPlayerSleepEnded", this);
		if (EACServer.playerTracker == null || net.connection == null)
		{
			return;
		}
		using (TimeWarning.New("playerTracker.LogPlayerSpawn"))
		{
			EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(net.connection);
			EACServer.playerTracker.LogPlayerSpawn(client, 0, 0);
		}
	}

```

## CanPickupEntity(BasePlayer,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pick up an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
{
    Puts($"Player {player.UserIDString} attempting to pick up entity {entity.EntityID}");
    if (entity.IsLocked)
    {
        Puts($"Entity {entity.EntityID} is locked and cannot be picked up.");
        return false;
    }
    // Additional logic can go here, such as checking the player's permissions or inventory space
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return pickup.enabled && (!pickup.requireBuildingPrivilege || (player.CanBuild() && (!pickup.requireHammer || player.IsHoldingEntity<Hammer>())));
	}

```

## OnPlayerVoice(BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a player sends voice data.
/// </summary>
/// <param name="player">The player sending the voice data.</param>
/// <param name="data">The voice data sent by the player.</param>
/// <returns>
/// Returns `null` to allow the voice data to be broadcasted, or any non-null value to prevent it from being broadcasted.
/// </returns>
object OnPlayerVoice(BasePlayer player, byte[] data)
{
    Puts($"Player {player.UserIDString} sent voice data.");
    if (data.Length > 1024)
    {
        Puts($"Player {player.UserIDString} tried to send too much voice data.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnReceivedVoice(byte[] data)
	{
		if (Interface.CallHook("OnPlayerVoice", this, data) == null && Network.Net.sv.write.Start())
		{
			Network.Net.sv.write.PacketID(Message.Type.VoiceData);
			Network.Net.sv.write.UInt32(net.ID);
			Network.Net.sv.write.BytesWithSize(data);
			Network.Net.sv.write.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f))
			{
				priority = Priority.Immediate
			});
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned.
/// </summary>
/// <param name="entity">The entity that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity {entity.EntityID} has been spawned.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## CanAdministerVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} attempting to administer vending machine {vendingMachine.name}");
    if (player.IsSuperAdmin)
    {
        return true;
    }
    // Additional checks can be added here
    return false;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return PlayerBehind(player) && OccupiedCheck(player);
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amountToConsume">The amount of the item to consume. Defaults to 1.</param>
/// <returns>No return behavior.</returns>
void OnItemUse(Item item, int amountToConsume)
{
    Puts($"Item {item.name} has been used.");
    if (amountToConsume > item.maxStackSize)
    {
        Puts($"Warning: Attempted to consume more than the maximum stack size of {item.maxStackSize} for item {item.name}.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			Interface.CallHook("OnItemUse", this, amountToConsume);
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a vending transaction is attempted.
/// </summary>
/// <param name="vendingMachine">The vending machine that initiated the transaction.</param>
/// <param name="buyer">The player attempting to buy an item from the vending machine.</param>
/// <param name="sellOrderId">The ID of the sell order being executed.</param>
/// <param name="numberOfTransactions">The number of transactions being performed (default is 1).</param>
/// <returns>
/// Returns a non-null value to override the default transaction behavior. 
/// If `true` is returned, the transaction will be allowed as normal.
/// If `false` is returned, the transaction will be cancelled and no items will be dispensed or currency taken.
/// </returns>
object OnVendingTransaction(VendingMachine vendingMachine, BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
{
    Puts($"Vending machine {vendingMachine.name} has been used by player {buyer.displayName}.");
    if (sellOrderId < 0 || sellOrderId > vendingMachine.sellOrders.Count)
    {
        return false;
    }
    ProtoBuf.VendingMachine.SellOrder sellOrder = vendingMachine.sellOrders[sellOrderId];
    List<Item> list = buyer.inventory.FindItemsByItemID(sellOrder.itemToSellID);
    if (sellOrder.itemToSellIsBP)
    {
        list = (from x in buyer.inventory.FindItemsByItemID(blueprintBaseDef.itemid)
            where x.blueprintTarget == sellOrder.itemToSellID
            select x).ToList();
    }
    if (list == null || list.Count == 0)
    {
        return false;
    }
    numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
    int num = sellOrder.itemToSellAmount * numberOfTransactions;
    int num2 = list.Sum((Item x) => x.amount);
    if (num > num2)
    {
        return false;
    }
    List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
    if (sellOrder.currencyIsBP)
    {
        source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
            where x.blueprintTarget == sellOrder.currencyID
            select x).ToList();
    }
    source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
    if (source.Count == 0)
    {
        return false;
    }
    int num3 = source.Sum((Item x) => x.amount);
    int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
    if (num3 < num4)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1)
	{
		if (sellOrderId < 0 || sellOrderId > sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> list = inventory.FindItemsByItemID(sellOrder.itemToSellID);
		if (sellOrder.itemToSellIsBP)
		{
			list = (from x in inventory.FindItemsByItemID(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.itemToSellID
				select x).ToList();
		}
		if (list == null || list.Count == 0)
		{
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, list[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = list.Sum((Item x) => x.amount);
		if (num > num2)
		{
			return false;
		}
		List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
		if (source.Count == 0)
		{
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
		if (num3 < num4)
		{
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item2 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item2.amount);
			Item takenCurrencyItem = ((item2.amount > num6) ? item2.SplitItem(num6) : item2);
			TakeCurrencyItem(takenCurrencyItem);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		int num7 = 0;
		foreach (Item item3 in list)
		{
			int num8 = num - num7;
			Item item = ((item3.amount > num8) ? item3.SplitItem(num8) : item3);
			if (item == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item.amount;
				GiveSoldItem(item, buyer);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## CanEntityBeHostile(BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether an entity can be hostile.
/// </summary>
/// <param name="entity">The entity to check.</param>
/// <returns>
/// Returns `true` if the entity can be hostile, and `false` otherwise.
/// If a non-bool value is returned by the hook, it will be treated as `true`.
/// </returns>
bool CanEntityBeHostile(BaseCombatEntity entity)
{
    object obj = Interface.CallHook("CanEntityBeHostile", entity);
    if (obj is bool)
    {
        return (bool)obj;
    }
    Puts($"Entity {entity.UserIDString} can be hostile because {obj}");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a turret targets an entity.
/// </summary>
/// <param name="turret">The AutoTurret that has targeted the entity.</param>
/// <param name="entity">The BaseCombatEntity that is being targeted by the turret.</param>
/// <returns>
/// Returns `null` to allow the turret to target the entity, or any non-null value to prevent the turret from targeting the entity.
/// </returns>
object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
{
    Puts($"Turret {turret.name} has targeted entity {entity.displayName}.");
    if (entity is Player player && player.IsSpectator())
    {
        Puts($"Player {player.displayName} is a spectator and cannot be targeted by the turret.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((!(targ == null)) ? targetAcquiredEffect.resourcePath : targetLostEffect.resourcePath, base.transform.position, Vector3.up);
			}
			target = targ;
		}
	}

```

## CanLootEntity(BasePlayer,ResourceContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.EntityID}");
    if (entity.IsLocked)
    {
        Puts($"Entity {entity.EntityID} is locked and cannot be looted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.IsVisible(3f)]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is rotated.
/// </summary>
/// <param name="block">The building block being rotated.</param>
/// <param name="player">The player who initiated the rotation.</param>
/// <returns>
/// Returns `null` to allow the structure to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnStructureRotate(BuildingBlock block, BasePlayer player)
{
    Puts($"Structure {block.name} has been rotated by player {player.UserIDString}");
    if (block.name == "Forbidden Structure")
    {
        Puts($"Rotation of structure {block.name} is not allowed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotate && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			UpdateSkin(force: true);
			SendNetworkUpdateImmediate();
			ClientRPC(null, "RefreshSkin");
		}
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger.
/// </summary>
/// <param name="trigger">The trigger that was entered.</param>
/// <param name="entity">The entity that entered the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has entered trigger {trigger.name}");
    
    // If ReturnType is void, do not include the return statement
    // In this case, we're just logging a message, so no return statement needed
}
```
```

### Source Code from the Library

```csharp

	internal virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			Interface.CallHook("OnEntityEnter", this, ent);
			entityContents.Add(ent);
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
```csharp
/// <summary>
/// Called when a player's tick is processed.
/// </summary>
/// <param name="player">The player whose tick is being processed.</param>
/// <param name="tick">The player's tick data.</param>
/// <param name="wasPlayerStalled">Whether the player was stalled during this tick.</param>
/// <returns>
/// Returns a non-null value to override the default tick processing behavior. 
/// If `null` is returned, the tick is processed as normal.
/// </returns>
object OnPlayerTick(BasePlayer player, PlayerTick tick, bool wasPlayerStalled)
{
    Puts($"Processing tick for player {player.displayName}.");
    if (wasPlayerStalled)
    {
        Puts($"Player {player.displayName} was stalled during this tick.");
        // Add custom logic here to handle stalled players
    }
    else
    {
        // Add custom logic here to handle non-stalled players
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			lastInputTime = UnityEngine.Time.time;
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(0u);
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsWounded())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if the helicopter can strafe.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanHelicopterStrafe(PatrolHelicopterAI ai)
{
    Puts($"Helicopter {ai.GetHelicopterName()} is checking if it can strafe.");
    if (ai.IsInDanger())
    {
        Puts($"Helicopter {ai.GetHelicopterName()} cannot strafe because it's in danger.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= 20f && CanInterruptState();
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
Based on the provided code snippet, I will attempt to create a method structure for the `OnWeaponFired` method.

**Method Structure:**

```csharp
/// <summary>
/// Called when a weapon is fired.
/// </summary>
/// <param name="baseProjectile">The base projectile.</param>
/// <param name="basePlayer">The player who fired the weapon.</param>
/// <param name="itemModProjectile">The item mod projectile component.</param>
/// <param name="projectileShoot">The projectile shoot data.</param>
public void OnWeaponFired(BaseProjectile baseProjectile, BasePlayer basePlayer, ItemModProjectile itemModProjectile, ProjectileShoot projectileShoot)
{
    // Code to handle the weapon firing event
}
```

**Method Parameters:**

* `baseProjectile`: The base projectile associated with the fired weapon.
* `basePlayer`: The player who fired the weapon.
* `itemModProjectile`: The item mod projectile component associated with the fired weapon.
* `projectileShoot`: The projectile shoot data, including the number of projectiles and their properties.

**Method Body:**

The method body will contain the code to handle the weapon firing event. This may include:

* Validating the player's action
* Updating the player's stats and inventory
* Creating a new projectile effect on clientside
* Broadcasting a signal to other players in the area

Note that this is just an example method structure, and you may need to modify it based on your specific game logic and requirements.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_missing");
			return;
		}
		ItemDefinition ammoType = primaryMagazine.ammoType;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (ammoType.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "ammo_mismatch");
			return;
		}
		if (!UsingInfiniteAmmoCheat)
		{
			primaryMagazine.contents--;
		}
		ItemModProjectile component = ammoType.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.Log(this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection);
		player.CleanupExpiredProjectiles();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.Log(this, "duplicate_id");
			}
			else if (ValidateEyePos(player, projectile.startPos))
			{
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, ammoType);
				CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
			}
		}
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count());
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);
		player.MarkHostileFor();
		UpdateItemCondition();
		DidAttackServerside();
		float num = 0f;
		if (component.projectileObject != null)
		{
			GameObject gameObject = component.projectileObject.Get();
			if (gameObject != null)
			{
				Projectile component2 = gameObject.GetComponent<Projectile>();
				if (component2 != null)
				{
					foreach (DamageTypeEntry damageType in component2.damageTypes)
					{
						num += damageType.amount;
					}
				}
			}
		}
		float num2 = NoiseRadius;
		if (IsSilenced())
		{
			num2 *= AI.npc_gun_noise_silencer_modifier;
		}
		Sensation sensation = default(Sensation);
		sensation.Type = SensationType.Gunshot;
		sensation.Position = player.transform.position;
		sensation.Radius = num2;
		sensation.DamagePotential = num;
		sensation.InitiatorPlayer = player;
		sensation.Initiator = player;
		Sense.Stimulate(sensation);
		if (EACServer.playerTracker == null)
		{
			return;
		}
		using (TimeWarning.New("LogPlayerShooting"))
		{
			UnityEngine.Vector3 networkPosition = player.GetNetworkPosition();
			UnityEngine.Vector3 eulerAngles = player.GetNetworkRotation().eulerAngles;
			int weaponID = GetItem()?.info.itemid ?? 0;
			EasyAntiCheat.Server.Hydra.Client client = EACServer.GetClient(player.net.connection);
			PlayerUseWeapon eventParams = default(PlayerUseWeapon);
			eventParams.Position = new EasyAntiCheat.Server.Cerberus.Vector3(networkPosition.x, networkPosition.y, networkPosition.z);
			eventParams.ViewAngles = new EasyAntiCheat.Server.Cerberus.Vector3(eulerAngles.x, eulerAngles.y, eulerAngles.z);
			eventParams.WeaponID = weaponID;
			EACServer.playerTracker.LogPlayerUseWeapon(client, eventParams);
		}
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an entity.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntity(BasePlayer looter, BaseEntity entity)
{
    Puts($"Player {looter.UserIDString} started looting entity {entity.baseEntityID}");
    if (entity is BaseCorpse corpse && corpse.IsBoss)
    {
        Puts($"Player {looter.UserIDString} cannot loot the boss entity {entity.baseEntityID}");
    }
}
```
```

### Source Code from the Library

```csharp

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!targetEntity)
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		MarkDirty();
		return true;
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a code is entered into the lock.
/// </summary>
/// <param name="lock">The CodeLock instance.</param>
/// <param name="player">The BasePlayer who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>
/// Returns `null` to allow the player to enter the code, or any non-null value to override the default behavior.
/// If a string is returned, the player will be notified with the provided message as the reason.
/// </returns>
object OnCodeEntered(CodeLock lock, BasePlayer player, string code)
{
    Puts($"Player {player.displayName} entered code '{code}' into lock {lock.name}.");
    if (code == "1234" && !player.IsAdmin())
    {
        return "Access denied: Only admins can use this code.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 10f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
			}
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
		}
	}

```

## CanDismountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when an entity is being dismounted.
/// </summary>
/// <param name="entity">The entity being dismounted.</param>
/// <param name="player">The player who is dismounting the entity.</param>
/// <returns>
/// Returns `null` to allow the entity to be dismounted, or any non-null value to prevent it from being dismounted.
/// </returns>
object CanDismountEntity(BasePlayer player, BaseMountable entity)
{
    Puts($"Player {player.displayName} is attempting to dismount entity {entity.name}.");
    if (player.userID == 123456789) // Example: Prevent a specific user from dismounting the entity
    {
        return "Access denied.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		if (lite)
		{
			_mounted.DismountObject();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			return;
		}
		Vector3 dismountPosition = GetDismountPosition(player);
		if (dismountPosition == DISMOUNT_POS_INVALID)
		{
			dismountPosition = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(dismountPosition);
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", dismountPosition);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			SetFlag(Flags.Busy, b: false);
		}
		else
		{
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(dismountPosition);
			_mounted.SendNetworkUpdateImmediate();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPCPlayer(null, player, "ForcePositionToParentOffset", baseEntity.transform.InverseTransformPoint(dismountPosition), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPCPlayer(null, player, "ForcePositionTo", dismountPosition);
			}
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## CanHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can drop a crate.
/// </summary>
/// <param name="helicopter">The helicopter attempting to drop the crate.</param>
/// <returns>
/// Returns `true` if the helicopter is allowed to drop the crate, and `false` otherwise.
/// If any other type of object is returned, it will be treated as a custom reason for not dropping the crate.
/// </returns>
object CanHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityId()} attempting to drop crate.");
    if (helicopter.IsLowOnFuel())
    {
        Puts($"Helicopter {helicopter.GetReference().GetEntityId()} is low on fuel and cannot drop crate.");
        return "Not enough fuel.";
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

```

## OnTurretToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret's online status is toggled.
/// </summary>
/// <param name="turret">The AutoTurret whose online status has been toggled.</param>
/// <returns>
/// Returns `null` to allow the turret's online status to be toggled, or any non-null value to prevent the toggle.
/// </returns>
object OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret.name} has been {(turret.IsOnline ? "enabled" : "disabled")}.");
    if (turret.IsOnline && !BasePlayer.LocalPlayer.CanSee(turret))
    {
        Puts($"Turret {turret.name} is not visible to the player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != HasFlag(Flags.On) && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			booting = false;
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
			}
		}
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger.
/// </summary>
/// <param name="trigger">The trigger that the entity left.</param>
/// <param name="entity">The entity that left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.ClassName} has left trigger {trigger.EntityId}");
}
```
```

### Source Code from the Library

```csharp

	internal virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null)
		{
			Interface.CallHook("OnEntityLeave", this, ent);
			entityContents.Remove(ent);
		}
	}

```

## CanUseHelicopter(BasePlayer,CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the helicopter.
/// </summary>
/// <param name="player">The player attempting to use the helicopter.</param>
/// <param name="helicopterController">The AI controller for the helicopter.</param>
/// <returns>
/// Returns `null` to allow the player to use the helicopter, or any non-null value to prevent them from using it.
/// </returns>
object CanUseHelicopter(BasePlayer player, CH47HelicopterAIController helicopterController)
{
    Puts($"Player {player.UserIDString} is attempting to use the helicopter.");
    if (helicopterController.IsUnderMaintenance())
    {
        Puts($"The helicopter is currently under maintenance and cannot be used by {player.displayName}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void AttemptMount(BasePlayer player)
	{
		if (Interface.CallHook("CanUseHelicopter", player, this) == null)
		{
			base.AttemptMount(player);
		}
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player who is starting to sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has started sleeping.");
    if (player.GetPlayerFlag(PlayerFlags.Admin))
    {
        Puts($"Admin player {player.UserIDString} has started sleeping. Allowing them to sleep without restrictions.");
    }
    else
    {
        Puts($"Non-admin player {player.UserIDString} has started sleeping. Disabling their inventory and crafting while they sleep.");
        // Disable inventory and crafting for non-admin players who are sleeping
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping())
		{
			EnsureDismounted();
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			sleepStartTime = UnityEngine.Time.time;
			if (!sleepingPlayerList.Contains(this))
			{
				sleepingPlayerList.Add(this);
			}
			CancelInvoke(InventoryUpdate);
			CancelInvoke(TeamUpdate);
			inventory.loot.Clear();
			inventory.crafting.CancelAll(returnItems: true);
			UpdatePlayerCollider(state: true);
			UpdatePlayerRigidbody(state: false);
			Interface.CallHook("OnPlayerSleep", this);
		}
	}

```

## OnPlayerSpawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a new player spawns.
/// </summary>
/// <param name="player">The newly spawned player.</param>
/// <returns>
/// Returns `null` to allow the player to spawn normally, or any non-null value to override the default spawning behavior. 
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object OnPlayerSpawn(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has spawned.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is a VIP and gets special treatment.");
        return "Welcome, VIP!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void SpawnNewPlayer(Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot);
		BasePlayer basePlayer = baseEntity.ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer) == null)
		{
			basePlayer.health = 0f;
			basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
			basePlayer.ResetLifeStateOnSpawn = false;
			basePlayer.limitNetworking = true;
			basePlayer.Spawn();
			basePlayer.limitNetworking = false;
			basePlayer.PlayerInit(connection);
			if (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife)
			{
				basePlayer.Respawn();
			}
			else
			{
				basePlayer.SendRespawnOptions();
			}
			DebugEx.Log(basePlayer.net.connection.ToString() + " joined [" + basePlayer.net.connection.os + "/" + basePlayer.net.connection.ownerid + "]", StackTraceLogType.None);
		}
	}

```

## OnOpenVendingShop(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player opens a vending shop.
/// </summary>
/// <param name="vendingMachine">The vending machine being opened.</param>
/// <param name="player">The player opening the vending shop.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingShop(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has opened a vending shop with ID {vendingMachine.id}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player))
		{
			SendSellOrders(msg.player);
			PlayerOpenLoot(msg.player, customerPanel);
			Interface.CallHook("OnOpenVendingShop", this, msg.player);
		}
	}

```

## CanUnlock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock the code lock.
/// </summary>
/// <param name="player">The player attempting to unlock.</param>
/// <param name="codeLock">The code lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to unlock, or any non-null value to prevent them from unlocking.
/// </returns>
object CanUnlock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.UserIDString} is attempting to unlock code lock {codeLock.name}");
    if (player.userID == 123456) // hardcoded admin ID
    {
        Puts($"Player {player.displayName} is an administrator and can unlock the code lock");
        return null;
    }
    return "Access denied: Unauthorized player";
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null)
		{
			if (whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectUnlocked.resourcePath);
				SetFlag(Flags.Locked, b: false);
				SendNetworkUpdate();
			}
			else
			{
				ClientRPCPlayer(null, rpc.player, "EnterUnlockCode");
			}
		}
	}

```

## IOnDisableServerConsole()

```csharp
```csharp
/// <summary>
/// Called when the server console is disabled.
/// </summary>
void IOnDisableServerConsole()
{
    Puts("Server console has been disabled.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	private void OnDisable()
	{
		if (Interface.CallHook("IOnDisableServerConsole") == null)
		{
			Output.OnMessage -= HandleLog;
		}
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, DroppedItemContainer entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.GetDisplayName()}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Not allowed: Only admins can loot this entity.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base combat entity is hurt.
/// </summary>
/// <param name="entity">The base combat entity that was hurt.</param>
/// <param name="hitInfo">Information about the hit, including the initiator and damage types.</param>
object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity} has been hurt by {hitInfo.Initiator} with damage type {hitInfo.damageTypes.GetMajorityDamageType()}.");
    // You can add custom logic here to handle the hurt event
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50L))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			health = num - info.damageTypes.Total();
			SendNetworkUpdate();
			if (ConVar.Global.developer > 1)
			{
				Debug.Log(string.Concat("[Combat]".PadRight(10), base.gameObject.name, " hurt ", info.damageTypes.GetMajorityDamageType(), "/", info.damageTypes.Total(), " - ", health.ToString("0"), " health left"));
			}
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (markAttackerHostile && baseCombatEntity2 != null && baseCombatEntity2 != this)
			{
				baseCombatEntity2.MarkHostileFor();
			}
			if (lastDamage != DamageType.Decay)
			{
				lastAttackedTime = UnityEngine.Time.time;
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;
				}
			}
			if (health <= 0f)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.Log(info, num, health, "killed");
				}
				else
				{
					initiatorPlayer.stats.combat.Log(info, num, health);
				}
			}
		}
	}

```

## OnItemResearch(ResearchTable,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player researches an item.
/// </summary>
/// <param name="researchTable">The research table being used.</param>
/// <param name="item">The item being researched.</param>
/// <param name="player">The player performing the research.</param>
/// <returns>No return behavior.</returns>
void OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has started researching item {item.info.name}.");
    if (item.info.category == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to research restricted items.");
        return;
    }
    // Additional logic can be added here based on the requirements.
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			inventory.SetLocked(isLocked: true);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client authenticates with the server.
/// </summary>
/// <param name="connection">The client connection.</param>
/// <returns>
/// Returns `null` to allow the client to authenticate normally, or any non-null value to override the default authentication behavior. 
/// If a string is returned, the client will be kicked with the provided message as the reason.
/// </returns>
object OnClientAuth(Network.Connection connection)
{
    Puts($"Client {connection} has authenticated with the server.");
    if (connection.userid == 1234567890)
    {
        Puts($"Client {connection} has been blocked from authenticating.");
        return "Blocked: Unauthorized client.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Connection.State.Connecting;
		byte b = packet.read.UInt8();
		if (b != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String();
		packet.connection.username = packet.read.String();
		Interface.CallHook("OnClientAuth", packet.connection);
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.unread >= 4)
		{
			text = packet.read.String();
		}
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their branch is '", text, "' not '", branch, "'"), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2137)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2137), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2137)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2137), StackTraceLogType.None);
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize();
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
			}
			else
			{
				auth.OnNewConnection(packet.connection);
			}
		}
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="landmine">The landmine that was triggered.</param>
/// <param name="victim">The player who triggered the landmine.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(Landmine landmine, BasePlayer victim)
{
    Puts($"Landmine {landmine.name} triggered by player {victim.displayName}");
    if (victim.isSuperAdmin)
    {
        Puts($"Player {victim.displayName} is a super admin and cannot trigger the landmine.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## CanNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC can attack a target.
/// </summary>
/// <param name="npc">The NPC attempting to attack.</param>
/// <param name="target">The entity the NPC is trying to attack.</param>
/// <returns>
/// Returns `null` to allow the NPC to attack, or any non-null value to prevent them from attacking.
/// </returns>
object CanNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} attempting to attack {target.displayName}");
    if (target is Player player && player.IsSpectating)
    {
        Puts($"NPC {npc.name} cannot attack spectating player {player.displayName}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if (!AttackTarget || !AttackReady() || Interface.CallHook("CanNpcAttack", this, AttackTarget) != null)
		{
			return;
		}
		float magnitude = (AttackTarget.ServerPosition - ServerPosition).magnitude;
		if (!(magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(null, "Attack", AttackTarget.ServerPosition);
			}
		}
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a melee item is thrown.
/// </summary>
/// <param name="basePlayer">The BasePlayer who threw the item.</param>
/// <param name="item">The Item that was thrown.</param>
void OnMeleeThrown(BasePlayer basePlayer, Item item)
{
    Puts($"BasePlayer {basePlayer.displayName} threw an item.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (player == null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsProjectile)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "item_missing");
				return;
			}
			ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
			if (component == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "mod_missing");
				return;
			}
			ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
			if (projectileShoot.projectiles.Count != 1)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.Log(this, "count_mismatch");
				return;
			}
			player.CleanupExpiredProjectiles();
			foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.Log(this, "duplicate_id");
				}
				else if (ValidateEyePos(player, projectile.startPos))
				{
					player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, item);
					Effect effect = new Effect();
					effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
					effect.scale = 1f;
					effect.pooledString = component.projectileObject.resourcePath;
					effect.number = projectile.seed;
					EffectNetwork.Send(effect);
				}
			}
			item.SetParent(null);
			Interface.CallHook("OnMeleeThrown", player, item);
			if (!canAiHearIt)
			{
				return;
			}
			float num = 0f;
			if (component.projectileObject != null)
			{
				GameObject gameObject = component.projectileObject.Get();
				if (gameObject != null)
				{
					Projectile component2 = gameObject.GetComponent<Projectile>();
					if (component2 != null)
					{
						foreach (DamageTypeEntry damageType in component2.damageTypes)
						{
							num += damageType.amount;
						}
					}
				}
			}
			if (player != null)
			{
				Sensation sensation = default(Sensation);
				sensation.Type = SensationType.ThrownWeapon;
				sensation.Position = player.transform.position;
				sensation.Radius = 50f;
				sensation.DamagePotential = num;
				sensation.InitiatorPlayer = player;
				sensation.Initiator = player;
				Sense.Stimulate(sensation);
			}
		}
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when a resource is gathered from a quarry.
/// </summary>
/// <param name="quarry">The mining quarry that gathered the resource.</param>
/// <param name="item">The item that was gathered, which can be a resource such as coal or iron ore.</param>
void OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts($"Resource {item.GetDefinition().name} has been gathered from quarry {quarry.name}.");
    if (item.GetDefinition().name == "rare_ore")
    {
        Puts($"Rare ore has been found in the quarry! Adding it to the player's inventory.");
        // Add the rare ore to the player's inventory or perform some other action
    }
    else if (item.GetDefinition().name == "depleted_resource")
    {
        Puts($"The resource {item.GetDefinition().name} is depleted. The quarry will need to be refilled before it can gather more.");
        // Perform some action when the resource is depleted, such as refilling the quarry
    }
}
```
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			resource.workDone += workToAdd;
			if (!(resource.workDone < resource.workNeeded))
			{
				int num = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
				resource.workDone -= (float)num * resource.workNeeded;
				Item item = ItemManager.Create(resource.type, num, 0uL);
				Interface.CallHook("OnQuarryGather", this, item);
				if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a player buys an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine the item was purchased from.</param>
/// <param name="player">The player who made the purchase.</param>
/// <param name="itemIndex">The index of the item purchased.</param>
/// <param name="quantity">The quantity of the item purchased.</param>
/// <returns>
/// Returns `null` to allow the purchase to complete normally, or any non-null value to cancel the purchase.
/// </returns>
object OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer player, int itemIndex, int quantity)
{
    Puts($"Player {player.UserIDString} bought {quantity} x {itemIndex} from vending machine {vendingMachine.name}");
    if (itemIndex == 5 && quantity > 10)
    {
        Puts($"Player {player.displayName} attempted to buy more than 10 of item {itemIndex}, purchase cancelled.");
        return "Purchase cancelled: Exceeded maximum quantity.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void BuyItem(RPCMessage rpc)
	{
		if (OccupiedCheck(rpc.player))
		{
			int num = rpc.read.Int32();
			int num2 = rpc.read.Int32();
			if (Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2) == null)
			{
				SetPendingOrder(rpc.player, num, num2);
				Invoke(CompletePendingOrder, GetBuyDuration());
			}
		}
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser bonus is assigned to a player.
/// </summary>
/// <param name="dispenser">The dispenser that triggered the bonus.</param>
/// <param name="player">The player who received the bonus.</param>
/// <param name="item">The item that was given as a bonus.</param>
/// <returns>
/// Returns `null` to allow the player to receive the bonus, or any non-null value to override the default behavior.
/// If an `Item` is returned, it will be used instead of the original item.
/// </returns>
object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} received a bonus from dispenser {dispenser.displayName}.");
    if (item.name == "Golden Coin")
    {
        Puts($"Player {player.displayName} already has the Golden Coin!");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction)
	{
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			Item item = ItemManager.Create(finishBonu.itemDef, Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction)), 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## IOnRconInitialize()

```csharp
```csharp
/// <summary>
/// Called when the RCON system is initialized.
/// </summary>
void IOnRconInitialize()
{
    Puts("RCon initialization complete.");
}
```
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", string.Empty));
		if (Password == "password" || Password == string.Empty)
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPEndPoint ip, string id, string msg)
			{
				lock (Commands)
				{
					Command item = JsonConvert.DeserializeObject<Command>(msg);
					item.Ip = ip;
					item.ConnectionId = id;
					Commands.Enqueue(item);
				}
			};
			listenerNew.Start();
			Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			Debug.Log("RCon Started on " + Port);
			Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## OnHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter drops a crate.
/// </summary>
/// <param name="helicopter">The helicopter that dropped the crate.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityID()} has dropped a crate.");
}
```
```

### Source Code from the Library

```csharp

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

```

## OnFindBurnable(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when an oven is searching for a burnable item.
/// </summary>
/// <param name="oven">The oven searching for a burnable item.</param>
/// <returns>
/// Returns the first burnable item found in the inventory, or null if no burnable item is found.
/// If `null` is returned, the oven will continue to search without a burnable item.
/// </returns>
Item OnFindBurnable(BaseOven oven)
{
    Puts($"Oven {oven.GetInventory().GetSlot(0).info.name} is searching for a burnable item.");
    if (oven.inventory.itemList.Count == 0)
    {
        return null;
    }
    foreach (Item item in oven.inventory.itemList)
    {
        ItemModBurnable component = item.info.GetComponent<ItemModBurnable>();
        if ((bool)component)
        {
            return item;
        }
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (inventory == null)
		{
			return null;
		}
		foreach (Item item in inventory.itemList)
		{
			ItemModBurnable component = item.info.GetComponent<ItemModBurnable>();
			if ((bool)component && (fuelType == null || item.info == fuelType))
			{
				return item;
			}
		}
		return null;
	}

```

## OnNpcPlayerResume(NPCPlayerApex)

```csharp
```csharp
/// <summary>
/// Called when an NPC player resumes their activity.
/// </summary>
/// <param name="npcPlayer">The NPC player resuming their activity.</param>
/// <returns>
/// Returns `null` to allow the NPC player to resume as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for the NPC player's radio chatter.
/// </returns>
object OnNpcPlayerResume(NPCPlayerApex npcPlayer)
{
    Puts($"NPC Player {npcPlayer.EntityId} has resumed their activity.");
    if (npcPlayer.GetNavAgent.isOnNavMesh)
    {
        // Do nothing, as the NPC is already on the nav mesh
        return null;
    }
    else if (Interface.CallHook("OnNpcPlayerResume", npcPlayer) != null)
    {
        // If a hook returns a non-null value, we should not try to force the NPC onto the nav mesh
        return null;
    }
    else
    {
        // Try to force the NPC onto the nav mesh
        StartCoroutine(npcPlayer.TryForceToNavmesh());
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Resume()
	{
		if (base.isMounted)
		{
			if (utilityAiComponent == null)
			{
				utilityAiComponent = Entity.GetComponent<UtilityAIComponent>();
			}
			if (utilityAiComponent != null)
			{
				utilityAiComponent.enabled = true;
				utilityAiComponent.Resume();
			}
			SendNetworkUpdateImmediate();
			return;
		}
		if (!GetNavAgent.isOnNavMesh)
		{
			if (Interface.CallHook("OnNpcPlayerResume", this) == null)
			{
				StartCoroutine(TryForceToNavmesh());
			}
			return;
		}
		GetNavAgent.enabled = true;
		StoppingDistance = 1f;
		if (utilityAiComponent == null)
		{
			utilityAiComponent = Entity.GetComponent<UtilityAIComponent>();
		}
		if (utilityAiComponent != null)
		{
			utilityAiComponent.enabled = true;
			utilityAiComponent.Resume();
		}
		InvokeRandomized(RadioChatter, RadioEffectRepeatRange.x, RadioEffectRepeatRange.x, RadioEffectRepeatRange.y - RadioEffectRepeatRange.x);
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing its ground.
/// </summary>
/// <param name="entity">The BaseEntity that is missing its ground.</param>
/// <returns>
/// Returns `null` to allow the entity to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has lost contact with the ground.");
    if (entity is BaseCombatEntity combatEntity && combatEntity.IsPlayerControlled)
    {
        Puts($"Player-controlled entity {entity.UserIDString} has been destroyed due to losing ground contact.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (baseEntity != null && Interface.CallHook("OnEntityGroundMissing", baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is crafted.
/// </summary>
/// <param name="itemCraftTask">The task associated with the crafting process.</param>
/// <param name="owner">The player who initiated the crafting process.</param>
/// <param name="fromTempBlueprint">The blueprint used for crafting, if any.</param>
/// <returns>
/// Returns a non-null value to override the default crafting behavior. 
/// If `true` is returned, the crafting process will be allowed as normal.
/// If `false` is returned, the crafting process will be cancelled.
/// </returns>
object OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)
{
    Puts($"Player {owner.displayName} has initiated an item craft task.");
    if (itemCraftTask.blueprint.targetItem.itemid == 12345)
    {
        Puts($"Player {owner.displayName} is attempting to craft a restricted item.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null)
	{
		if (!CanCraft(bp, amount))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		CollectIngredients(bp, itemCraftTask, amount, owner);
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.owner = owner;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			return (bool)obj;
		}
		queue.Enqueue(itemCraftTask);
		if (itemCraftTask.owner != null)
		{
			itemCraftTask.owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a Bradley APC can target the given entity.
/// </summary>
/// <param name="apc">The Bradley APC attempting to target.</param>
/// <param name="entity">The entity being targeted.</param>
/// <returns>
/// Returns `true` if the Bradley APC can target the entity, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBradleyApcTarget(BradleyAPC apc, BaseEntity entity)
{
    Puts($"Bradley APC {apc.transform.position} attempting to target {entity.displayName} at {entity.transform.position}");
    if (entity == null || !entity.IsValid())
    {
        return true;
    }
    Vector3 distance = Vector3.Distance(apc.transform.position, entity.transform.position);
    if (distance > apc.maxTargetDistance)
    {
        Puts($"Bradley APC {apc.transform.position} cannot target {entity.displayName} at {entity.transform.position} due to range.");
        return true;
    }
    object result = Interface.CallHook("CanBradleyApcTarget", apc, entity);
    if (result is bool)
    {
        return (bool)result;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.transform.position, base.transform.position) < viewDistance))
		{
			return false;
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			return IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position, position);
		}
		Debug.LogWarning("Standard vis test!");
		return IsVisible(ent.CenterPoint());
	}

```

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating.
/// </summary>
/// <param name="player">The player starting to spectate.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} started spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to spectate with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnPlayerDie(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player dies.
/// </summary>
/// <param name="player">The player who died.</param>
/// <param name="info">Information about the hit that caused the death, if any.</param>
/// <returns>
/// Returns `null` to allow the player to die normally. If a non-null value is returned, it will override the default dying behavior.
/// </returns>
object OnPlayerDie(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} has died.");
    if (info != null && info.Attacker != null)
    {
        Puts($"Player was killed by {info.Attacker.UserIDString} with a {info.Weapon}.");
        return "Killed by another player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead())
			{
				if (Belt != null && ShouldDropActiveItem())
				{
					UnityEngine.Vector3 vector = new UnityEngine.Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + vector.normalized * 3f);
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDie", this, info) == null)
				{
					base.Die(info);
				}
			}
		}
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player attacks another entity.
/// </summary>
/// <param name="player">The player performing the attack.</param>
/// <param name="info">Information about the attack, including the hit entity and any damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default attack behavior to occur. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnPlayerAttack(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} attacked entity {info.HitEntity?.ToString()} with damage {info.Damage}.");
    if (info.HitEntity == "tank")
    {
        Puts($"Player {player.displayName} is not allowed to attack the tank.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", GetOwnerPlayer(), info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50L))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (info.DoHitEffects)
		{
			if (base.isServer)
			{
				using (TimeWarning.New("ImpactEffect", 20L))
				{
					Effect.server.ImpactEffect(info);
				}
			}
			else
			{
				using (TimeWarning.New("ImpactEffect", 20L))
				{
					Effect.client.ImpactEffect(info);
				}
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50L))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay);
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The storage container being used for looting.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.UserIDString} has stopped looting the entity.");
    if (container.GetContents().Count > 0)
    {
        Puts($"The storage container still contains {container.GetContents().Count} items.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnNpcPlayerTarget(Rust.Ai.HTN.BaseNpcMemory,BaseNpc)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npcMemory">The memory of the NPC that targeted the player.</param>
/// <param name="baseNpc">The base NPC that targeted the player.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the player, or any non-null value to prevent them from targeting the player.
/// </returns>
object OnNpcPlayerTarget(Rust.Ai.HTN.BaseNpcMemory npcMemory, BaseNpc baseNpc)
{
    Puts($"NPC {baseNpc.Name} has targeted a player.");
    if (npcMemory.GetAggroTarget() == null)
    {
        Puts($"NPC {baseNpc.Name} does not have an aggro target.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RememberPrimaryAnimal(BaseNpc animal)
	{
		if (Interface.CallHook("OnNpcPlayerTarget", this, animal) != null)
		{
			return;
		}
		for (int i = 0; i < NpcContext.AnimalsInRange.Count; i++)
		{
			AnimalInfo primaryKnownAnimal = NpcContext.AnimalsInRange[i];
			if (primaryKnownAnimal.Animal == animal)
			{
				PrimaryKnownAnimal = primaryKnownAnimal;
				break;
			}
		}
	}

```

## CanLock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called when a player tries to lock the object.
/// </summary>
/// <param name="player">The player trying to lock the object.</param>
/// <param name="lockObject">The CodeLock object being locked.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(BasePlayer player, CodeLock lockObject)
{
    Puts($"Player {player.UserIDString} tried to lock the code lock.");
    if (lockObject.IsLocked())
    {
        Puts($"Code lock is already locked by another player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", rpc.player, this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the target player can be looted, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is trying to loot player {target.UserIDString}");
    if (looter == target)
    {
        return false;
    }
    object obj = Interface.CallHook("CanLootPlayer", looter, target);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If no specific rule is set, allow looting by default
    return true;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		return IsWounded() || IsSleeping();
	}

```

## OnEntityDismounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is dismounted.
/// </summary>
/// <param name="entity">The entity that was dismounted.</param>
/// <param name="player">The player who dismounted the entity.</param>
object OnEntityDismounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Entity {entity.name} has been dismounted by player {player.displayName}");
    // You can add custom logic here to handle the dismounting of the entity
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		if (lite)
		{
			_mounted.DismountObject();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			return;
		}
		Vector3 dismountPosition = GetDismountPosition(player);
		if (dismountPosition == DISMOUNT_POS_INVALID)
		{
			dismountPosition = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(dismountPosition);
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", dismountPosition);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			SetFlag(Flags.Busy, b: false);
		}
		else
		{
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(dismountPosition);
			_mounted.SendNetworkUpdateImmediate();
			_mounted = null;
			SetFlag(Flags.Busy, b: false);
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPCPlayer(null, player, "ForcePositionToParentOffset", baseEntity.transform.InverseTransformPoint(dismountPosition), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPCPlayer(null, player, "ForcePositionTo", dismountPosition);
			}
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can target a player.
/// </summary>
/// <param name="helicopter">The helicopter attempting to target the player.</param>
/// <param name="player">The player being targeted.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player, and `false` otherwise.
/// If this method is not implemented or returns a non-boolean value, the default behavior will be used.
/// </returns>
bool CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Helicopter {helicopter.GetReference()} attempting to target player {player.UserIDString}.");
    if (player.IsDead || player.IsInvisible)
    {
        return false;
    }
    // Additional logic can be added here to determine if the helicopter can target the player
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## OnTerrainInitialized()

```csharp
```csharp
/// <summary>
/// Called after the terrain has been initialized.
/// </summary>
void OnTerrainInitialized()
{
    Puts("Terrain initialization complete.");
    
    // Minimal code to demonstrate functionality
    // You can add any necessary setup or initialization here
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		foreach (TerrainExtension terrainExtension in components)
		{
			terrainExtension.PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap trigger is snapped to an object.
/// </summary>
/// <param name="trapTrigger">The trap trigger that was snapped.</param>
/// <param name="object">The object that the trap trigger was snapped to.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trapTrigger, GameObject obj)
{
    Puts($"Trap {trapTrigger.name} snapped to object {obj.name}");
}
```
```

### Source Code from the Library

```csharp

	internal override void OnObjectAdded(GameObject obj)
	{
		Interface.CallHook("OnTrapSnapped", this, obj);
		base.OnObjectAdded(obj);
		_trap.ObjectEntered(obj);
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC wants to eat a given entity.
/// </summary>
/// <param name="npc">The NPC in question.</param>
/// <param name="entity">The entity the NPC is considering eating.</param>
/// <returns>
/// Returns `true` if the NPC wants to eat the entity, and `false` otherwise.
/// If a non-null value other than `bool` is returned, it will be used as the return value instead of this default behavior.
/// </returns>
object CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc.name} wants to eat {entity.name}");
    if (entity.HasTrait(TraitFlag.Poisoned))
    {
        Puts($"NPC {npc.name} does not want to eat {entity.name} because it is poisoned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## InitLogging()

```csharp
```csharp
/// <summary>
/// Called to initialize logging.
/// </summary>
void InitLogging()
{
    Puts("Initializing logging...");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

```

## OnPlayerWound(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is wounded.
/// </summary>
/// <param name="player">The player who was wounded.</param>
/// <returns>
/// Returns `null` to allow the player to be wounded, or any non-null value to prevent them from being wounded.
/// </returns>
object OnPlayerWound(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been wounded.");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot be wounded.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartWounded()
	{
		if (!IsWounded() && Interface.CallHook("OnPlayerWound", this) == null)
		{
			stats.Add("wounded", 1);
			woundedDuration = UnityEngine.Random.Range(40f, 50f);
			woundedStartTime = UnityEngine.Time.realtimeSinceStartup;
			SetPlayerFlag(PlayerFlags.Wounded, b: true);
			SendNetworkUpdateImmediate();
			Invoke(WoundingTick, 1f);
		}
	}

```

## OnDeleteVendingOffer(VendingMachine,int)

```csharp
```csharp
/// <summary>
/// Called when a vending offer is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was on.</param>
/// <param name="offerIndex">The index of the offer being deleted.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, int offerIndex)
{
    Puts($"Deleted vending offer {offerIndex} from vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", this, num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## OnEntityMounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is mounted by a player.
/// </summary>
/// <param name="entity">The entity being mounted.</param>
/// <param name="player">The player mounting the entity.</param>
/// <returns>
/// Returns `null` to allow the entity to be mounted, or any non-null value to prevent it from being mounted.
/// </returns>
object OnEntityMounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Entity {entity.name} has been mounted by player {player.displayName}");
    if (entity.name == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to mount entity {entity.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			TriggerParent triggerParent = player.FindTrigger<TriggerParent>();
			if ((bool)triggerParent)
			{
				triggerParent.OnTriggerExit(player.GetComponent<Collider>());
			}
			player.MountObject(this);
			player.MovePosition(mountAnchor.transform.position);
			player.transform.rotation = mountAnchor.transform.rotation;
			player.ServerRotation = mountAnchor.transform.rotation;
			player.OverrideViewAngles(mountAnchor.transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(mountAnchor.transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			SetFlag(Flags.Busy, b: true);
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed in the shop.
/// </summary>
/// <param name="shopFront">The shop front where the trade was completed.</param>
/// <returns>
/// Returns `null` to allow the trade completion, or any non-null value to prevent it.
/// If a string is returned, an error message will be displayed to the players involved in the trade.
/// </returns>
object OnShopCompleteTrade(ShopFront shopFront)
{
    Puts($"Trade completed at shop front {shopFront.name}.");
    if (shopFront.inventory.Count == 0)
    {
        Puts($"Error: Shop inventory is empty.");
        return "Error: Shop inventory is empty.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			for (int num = vendorInventory.capacity - 1; num >= 0; num--)
			{
				Item slot = vendorInventory.GetSlot(num);
				Item slot2 = customerInventory.GetSlot(num);
				if ((bool)customerPlayer && slot != null)
				{
					customerPlayer.GiveItem(slot);
				}
				if ((bool)vendorPlayer && slot2 != null)
				{
					vendorPlayer.GiveItem(slot2);
				}
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine is rotated.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="player">The player who initiated the rotation.</param>
/// <returns>
/// Returns `null` to allow the vending machine to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending Machine {vendingMachine.name} has been rotated by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot rotate the vending machine");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RotateVM(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (Interface.CallHook("OnRotateVendingMachine", this, player) == null && player.CanBuild() && IsInventoryEmpty())
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnItemCraftCancelled(ItemCraftTask)

```csharp
```csharp
/// <summary>
/// Called when an item craft task is cancelled.
/// </summary>
/// <param name="task">The cancelled item craft task.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task)
{
    Puts($"Item craft task {task.taskUID} has been cancelled.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID, bool ReturnItems)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (itemCraftTask.owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask);
		itemCraftTask.owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0 && ReturnItems)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))
					{
						takenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition + UnityEngine.Random.value * Vector3.down + UnityEngine.Random.insideUnitSphere, itemCraftTask.owner.inventory.containerMain.dropVelocity);
						itemCraftTask.owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
		}
		return true;
	}

```

## CanSetBedPublic(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called when a player tries to set their bed public or private.
/// </summary>
/// <param name="player">The player attempting to set the bed's visibility.</param>
/// <param name="bed">The sleeping bag being modified.</param>
/// <returns>
/// Returns `null` if the player is allowed to change the bed's visibility, or any non-null value to prevent them from doing so.
/// </returns>
object CanSetBedPublic(BasePlayer player, SleepingBag bed)
{
    Puts($"Player {player.UserIDString} tried to set their bed public or private.");
    if (bed.IsInUseBy(player))
    {
        Puts($"Player {player.displayName} is already using the bed and cannot change its visibility.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag != IsPublic() && Interface.CallHook("CanSetBedPublic", msg.player, this) == null)
		{
			SetPublic(flag);
			if (!IsPublic())
			{
				deployerUserID = msg.player.userID;
			}
			SendNetworkUpdate();
		}
	}

```

## CanVendingAcceptItem(VendingMachine,Item,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a vending machine can accept an item.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being attempted to be accepted.</param>
/// <param name="targetSlot">The slot on the vending machine where the item is being placed.</param>
/// <returns>
/// Returns `true` if the vending machine can accept the item, or `false` otherwise.
/// If a non-null value other than `bool` is returned, it will override the default behavior.
/// </returns>
object CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)
{
    Puts($"Vending Machine {vendingMachine.name} attempting to accept item {item.displayName} into slot {targetSlot}");
    if (item.isAdminOnly && !CanPlayerAdmin(vendingMachine.owner))
    {
        Puts($"Vending Machine {vendingMachine.name} cannot accept admin-only item {item.displayName} because the owner is not an administrator.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if (transactionActive)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (inventory.itemList.Contains(item))
		{
			return true;
		}
		if (ownerPlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(ownerPlayer);
	}

```

## CanStackItem(Item,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if two items can be stacked together.
/// </summary>
/// <param name="item1">The first item.</param>
/// <param name="item2">The second item.</param>
/// <returns>
/// Returns `true` if the items can be stacked, or any non-null value to override the default stacking behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the items cannot be stacked.
/// </returns>
object CanStackItem(Item item1, Item item2)
{
    Puts($"Checking if {item1.info.itemid} and {item2.info.itemid} can be stacked.");
    if (item1 == item2)
    {
        return true;
    }
    if (item1.info.stackable <= 1 || item2.info.stackable <= 1)
    {
        return null;
    }
    if (item1.info.itemid != item2.info.itemid)
    {
        return null;
    }
    if ((item1.hasCondition && item1.condition != item1.maxCondition) ||
        (item2.hasCondition && item2.condition != item2.maxCondition))
    {
        return null;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (info.stackable <= 1)
		{
			return false;
		}
		if (item.info.stackable <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != maxCondition)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.maxCondition)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		return true;
	}

```

## CanLock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to lock the object.
/// </summary>
/// <param name="player">The player attempting to lock the object.</param>
/// <param name="lock">The KeyLock instance being locked.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} attempted to lock {lock.name}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Access denied: Only admins can lock this object.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Lock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			LockLock(rpc.player);
			SendNetworkUpdate();
		}
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldHealth">The player's old health value.</param>
/// <param name="newHealth">The player's new health value.</param>
/// <returns>No return behavior.</returns>
void OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Player {player.UserIDString}'s health changed from {oldHealth} to {newHealth}");
}
```
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) == null)
		{
			base.OnHealthChanged(oldvalue, newvalue);
			metabolism.isDirty = true;
		}
	}

```

## OnFireBallSpread(FireBall,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a fireball spreads.
/// </summary>
/// <param name="fireBall">The fireball that is spreading.</param>
/// <param name="newFireBall">The new fireball entity created by the spread.</param>
/// <returns>No return behavior.</returns>
void OnFireBallSpread(FireBall fireBall, BaseEntity newFireBall)
{
    Puts($"Fireball {fireBall.id} has spawned a new fireball at position: {newFireBall.transform.position}");
    if (newFireBall.transform.position.x > 10f)
    {
        Puts($"New fireball {newFireBall.id} is being blocked by an obstacle.");
        return;
    }
    // Additional logic can be added here to handle the spread of the fireball
}
```
```

### Source Code from the Library

```csharp

	public void TryToSpread()
	{
		float num = 0.9f - generation * 0.1f;
		if (UnityEngine.Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				float aimCone = 45f;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, Vector3.up);
				baseEntity.creatorEntity = ((!(creatorEntity == null)) ? creatorEntity : baseEntity);
				Interface.CallHook("OnFireBallSpread", this, baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));
				baseEntity.SendMessage("SetGeneration", generation + 1f);
			}
		}
	}

```

## OnNpcDestinationSet(NPCPlayerApex,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an NPC's destination is set.
/// </summary>
/// <param name="npc">The NPC whose destination is being set.</param>
/// <param name="newDestination">The new destination for the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC's destination to be set, or any non-null value to prevent it from being set.
/// </returns>
object OnNpcDestinationSet(NPCPlayerApex npc, Vector3 newDestination)
{
    Puts($"NPC {npc.name} is being moved to destination: {newDestination}");
    if (newDestination == Vector3.zero)
    {
        Puts($"NPC {npc.name} cannot be moved to the origin.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void SetDestination(Vector3 newDestination)
	{
		if (Interface.CallHook("OnNpcDestinationSet", this, newDestination) == null)
		{
			base.SetDestination(newDestination);
			Destination = newDestination;
		}
	}

```

## OnPlayerRecovered(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecovered(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered from being wounded.");
}
```
```

### Source Code from the Library

```csharp

	private void WoundingTick()
	{
		using (TimeWarning.New("WoundingTick"))
		{
			if (IsDead())
			{
				return;
			}
			if (secondsSinceWoundedStarted >= woundedDuration)
			{
				if (UnityEngine.Random.Range(0, 100) < 20)
				{
					SetPlayerFlag(PlayerFlags.Wounded, b: false);
					Interface.CallHook("OnPlayerRecovered", this);
				}
				else
				{
					Die();
				}
			}
			else
			{
				Invoke(WoundingTick, 1f);
			}
		}
	}

```

## OnHelicopterDropDoorOpen(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the helicopter's drop door is opened or closed.
/// </summary>
/// <param name="controller">The AI controller of the CH-47 helicopter.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropDoorOpen(CH47HelicopterAIController controller)
{
    Puts($"Drop door on {controller.GetDisplayName()} is {(controller.GetFlag(Flags.Reserved8)) ? "open" : "closed"}}");
}
```
```

### Source Code from the Library

```csharp

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

```

## IOnRunCommandLine()

```csharp
```csharp
/// <summary>
/// Called when the command line is run.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRunCommandLine()
{
    Puts("Command line has been executed.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		Dictionary<string, string> switches = Facepunch.CommandLine.GetSwitches();
		foreach (KeyValuePair<string, string> item in switches)
		{
			string text = item.Value;
			if (text == string.Empty)
			{
				text = "1";
			}
			string strCommand = item.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
Here's the code with a hook method added:

```csharp
[HookMethod("IOnServerCommand")]
private static bool IOnServerCommand(ConsoleSystem.Arg arg)
{
    // Existing logic remains the same...
}
```

This will allow plugins to override the default behavior of the `Internal` method by implementing their own version of `IOnServerCommand`.
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null)
		{
			string @string = arg.cmd.String;
			string text = ((!arg.cmd.Variable) ? string.Empty : arg.cmd.String);
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## OnGroupCreated(string,string,int)

```csharp
```csharp
/// <summary>
/// Called when a new group is created.
/// </summary>
/// <param name="groupName">The name of the newly created group.</param>
/// <param name="title">The title of the newly created group.</param>
/// <param name="rank">The rank associated with the newly created group.</param>
/// <returns>No return behavior.</returns>
void OnGroupCreated(string groupName, string title, int rank)
{
    Puts($"Group {groupName} with title '{title}' and rank {rank} has been created.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string group, string title, int rank)
	{
		if (GroupExists(group) || string.IsNullOrEmpty(group))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = title,
			Rank = rank
		};
		group = group.ToLower();
		groupdata.Add(group, value);
		Interface.CallHook("OnGroupCreated", group, title, rank);
		return true;
	}

```

## OnUserNameUpdated(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's saved nickname is updated.
/// </summary>
/// <param name="id">The player's ID.</param>
/// <param name="oldName">The player's old nickname.</param>
/// <param name="newName">The player's new nickname.</param>
/// <returns>No return behavior.</returns>
void OnUserNameUpdated(string id, string oldName, string newName)
{
    Puts($"Player's name changed from {oldName} to {newName} for ID {id}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string id, string nickname)
	{
		if (UserExists(id))
		{
			UserData userData = GetUserData(id);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = nickname.Sanitize();
			userData.LastSeenNickname = nickname.Sanitize();
			Interface.CallHook("OnUserNameUpdated", id, lastSeenNickname, obj);
		}
	}

```

## OnGroupRankSet(string,int)

```csharp
```csharp
/// <summary>
/// Called when a group's rank is set.
/// </summary>
/// <param name="group">The name of the group.</param>
/// <param name="rank">The new rank for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupRankSet(string group, int rank)
{
    Puts($"Group {group} has been set to rank {rank}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string group, int rank)
	{
		if (!GroupExists(group))
		{
			return false;
		}
		group = group.ToLower();
		if (!groupdata.TryGetValue(group, out var value))
		{
			return false;
		}
		if (value.Rank == rank)
		{
			return true;
		}
		value.Rank = rank;
		Interface.CallHook("OnGroupRankSet", group, rank);
		return true;
	}

```

## OnGroupTitleSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's title is set.
/// </summary>
/// <param name="group">The name of the group.</param>
/// <param name="title">The new title for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupTitleSet(string group, string title)
{
    Puts($"Group {group} has been renamed to {title}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string group, string title)
	{
		if (!GroupExists(group))
		{
			return false;
		}
		group = group.ToLower();
		if (!groupdata.TryGetValue(group, out var value))
		{
			return false;
		}
		if (value.Title == title)
		{
			return true;
		}
		value.Title = title;
		Interface.CallHook("OnGroupTitleSet", group, title);
		return true;
	}

```

## OnPermissionRegistered(string,Oxide.Core.Plugins.Plugin)

```csharp
```csharp
/// <summary>
/// Called when a new permission is registered.
/// </summary>
/// <param name="name">The name of the registered permission.</param>
/// <param name="owner">The plugin that registered the permission.</param>
/// <returns>No return behavior.</returns>
void OnPermissionRegistered(string name, Plugin owner)
{
    Puts($"Permission '{name}' has been registered by plugin {owner.Title}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string name, Plugin owner)
	{
		if (string.IsNullOrEmpty(name))
		{
			return;
		}
		name = name.ToLower();
		if (PermissionExists(name))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", name, owner.Title);
			return;
		}
		if (!permset.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>();
			permset.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(name);
		Interface.CallHook("OnPermissionRegistered", name, owner);
		string text = owner.Name.ToLower() + ".";
		if (!name.StartsWith(text) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", text, name, owner.Title);
		}
	}

```

## OnGroupParentSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's parent is set.
/// </summary>
/// <param name="group">The ID of the group whose parent is being set.</param>
/// <param name="parent">The ID of the new parent group.</param>
/// <returns>No return behavior.</returns>
void OnGroupParentSet(string group, string parent)
{
    Puts($"Group {group} has been assigned a new parent: {parent}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string group, string parent)
	{
		if (!GroupExists(group))
		{
			return false;
		}
		group = group.ToLower();
		if (!groupdata.TryGetValue(group, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parent))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parent) || group.Equals(parent.ToLower()))
		{
			return false;
		}
		parent = parent.ToLower();
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parent))
		{
			return true;
		}
		if (HasCircularParent(group, parent))
		{
			return false;
		}
		value.ParentGroup = parent;
		Interface.CallHook("OnGroupParentSet", group, parent);
		return true;
	}

```

## OnGroupDeleted(string)

```csharp
```csharp
/// <summary>
/// Called when a group is deleted.
/// </summary>
/// <param name="groupName">The name of the deleted group.</param>
/// <returns>No return behavior.</returns>
void OnGroupDeleted(string groupName)
{
    Puts($"Group {groupName} has been deleted.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string group)
	{
		if (!GroupExists(group))
		{
			return false;
		}
		group = group.ToLower();
		bool flag = groupdata.Remove(group);
		if (flag)
		{
			foreach (GroupData item in groupdata.Values.Where((GroupData x) => x.ParentGroup == group))
			{
				item.ParentGroup = string.Empty;
			}
		}
		if (userdata.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(group)))
		{
			SaveUsers();
		}
		if (flag)
		{
			Interface.CallHook("OnGroupDeleted", group);
		}
		return true;
	}

```

## OnRconCommand(System.Net.IPEndPoint,string,string[])

```csharp
```csharp
/// <summary>
/// Called when an RCON command is received.
/// </summary>
/// <param name="sender">The IP endpoint of the sender.</param>
/// <param name="commandName">The name of the RCON command being executed.</param>
/// <param name="args">The arguments passed with the RCON command.</param>
/// <returns>
/// Returns `true` to override the default behavior and prevent the command from executing.
/// If `null` is returned, the command will be executed as normal.
/// </returns>
object OnRconCommand(IPEndPoint sender, string commandName, string[] args)
{
    Puts($"Received RCON command '{commandName}' from {sender} with arguments: [{string.Join(", ", args)}]");
    if (args.Length > 0 && args[0].ToLower() == "shutdown")
    {
        Puts($"RCON command 'shutdown' received, shutting down the server.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconCommand")]
	private object IOnRconCommand(IPEndPoint sender, string command)
	{
		if (sender != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (!string.IsNullOrEmpty(message?.Message))
			{
				string[] array = Oxide.Core.CommandLine.Split(message.Message);
				if (array.Length >= 1)
				{
					string obj = array[0].ToLower();
					string[] obj2 = array.Skip(1).ToArray();
					if (Interface.CallHook("OnRconCommand", sender, obj, obj2) != null)
					{
						return true;
					}
				}
			}
		}
		return null;
	}

```

## OnDestroyUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a UI element is destroyed.
/// </summary>
/// <param name="player">The player whose UI was destroyed.</param>
/// <param name="elem">The ID of the destroyed UI element.</param>
/// <returns>No return behavior.</returns>
void OnDestroyUI(BasePlayer player, string elem)
{
    Puts($"UI for player {player.UserIDString} with ID {elem} has been destroyed.");
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		if (player?.net != null)
		{
			Interface.CallHook("OnDestroyUI", player, elem);
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "DestroyUI", elem);
			return true;
		}
		return false;
	}

```

## OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a user issues a command.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The actual command being executed (e.g. /help, /kick).</param>
/// <param name="args">Any arguments passed with the command (e.g. /kick Player1).</param>
/// <returns>
/// Returns a non-null value to override the default command handling behavior.
/// If `null` is returned, the command will be handled as normal.
/// </returns>
object OnUserCommand(IPlayer player, string command, string[] args)
{
    Puts($"Player {player.Id} issued command: /{command} {string.Join(" ", args)}");
    if (command == "admin" && !player.HasPermission(Permissions.Admin))
    {
        Puts($"Player {player.Id} does not have permission to use the admin command.");
        return "Access denied: You do not have permission to use this command.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(ConsoleSystem.Arg arg)
	{
		string text = arg.GetString(0).Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command == null)
		{
			return;
		}
		BasePlayer basePlayer = arg.Connection.player as BasePlayer;
		IPlayer player = basePlayer?.IPlayer;
		if (player != null)
		{
			object obj = Interface.CallHook("OnPlayerCommand", arg);
			object obj2 = Interface.CallHook("OnUserCommand", player, command, args);
			if (obj == null && obj2 == null && !Covalence.CommandSystem.HandleChatMessage(player, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				player.Reply(string.Format(lang.GetMessage("UnknownCommand", this, player.Id), command));
			}
		}
	}

```

## OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The IPlayer instance of the user who respawned.</param>
/// <returns>
/// Returns `null` to allow the player to respawn normally, or any non-null value to override the default respawn behavior.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnUserRespawn(IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
    if (player.Name == "Admin")
    {
        Puts($"Player {player.Name} has been granted admin privileges upon respawning.");
        return "You have been granted admin privileges.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer player)
	{
		IPlayer iPlayer = player.IPlayer;
		return (iPlayer != null) ? Interface.CallHook("OnUserRespawn", iPlayer) : null;
	}

```

## OnEntityTakeDamage(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that took the damage.</param>
/// <param name="info">Information about the hit, including the attacker and damage dealt.</param>
/// <returns>No return behavior.</returns>
void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity.ClassName} took {info.Damage} damage from {info.Attacker?.ClassName ?? "unknown"}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo info)
	{
		return (entity is BasePlayer) ? null : Interface.CallHook("OnEntityTakeDamage", entity, info);
	}

```

## OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user disconnects from the server.
/// </summary>
/// <param name="iPlayer">The IPlayer object representing the disconnected user.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnUserDisconnected(IPlayer iPlayer, string reason)
{
    Puts($"User {iPlayer.Name} has disconnected from the server with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer player, string reason)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(player);
	}

```

## OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnUserRespawned(IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer player)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", iPlayer);
		}
	}

```

## OnServerInitialized(bool)

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
/// <param name="initialized">Whether the server has been initialized.</param>
/// <returns>No return behavior.</returns>
void OnServerInitialized(bool initialized)
{
    Puts($"Server initialization complete: {initialized}");
    if (!initialized)
    {
        Puts("Server initialization failed.");
        // Add any error handling or logging here
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			if (Interface.Oxide.CheckConsole() && SingletonComponent<ServerConsole>.Instance != null)
			{
				SingletonComponent<ServerConsole>.Instance.enabled = false;
				UnityEngine.Object.Destroy(SingletonComponent<ServerConsole>.Instance);
				typeof(SingletonComponent<ServerConsole>).GetField("instance", BindingFlags.Static | BindingFlags.NonPublic)?.SetValue(null, null);
			}
			Oxide.Core.Analytics.Collect();
			RustExtension.ServerConsole();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools(that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", serverInitialized);
		}
	}

```

## OnNpcPlayerTarget(BaseEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC that targeted the player.</param>
/// <param name="target">The player who was targeted by the NPC.</param>
/// <returns>
/// Returns `true` to override the default behavior and prevent the NPC from targeting the player, or `null` to allow the NPC to target the player as normal.
/// </returns>
object OnNpcPlayerTarget(BaseEntity npc, BasePlayer target)
{
    Puts($"NPC {npc.UserIDString} has targeted player {target.UserIDString}");
    if (target.IsSpectator())
    {
        Puts($"NPC {npc.UserIDString} cannot target spectator {target.UserIDString}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnHtnNpcPlayerTarget")]
	private object IOnHtnNpcPlayerTarget(IHTNAgent npc, BasePlayer target)
	{
		if (npc != null && Interface.CallHook("OnNpcPlayerTarget", npc.Body, target) != null)
		{
			npc.AiDomain.NpcContext.BaseMemory.Forget(0f);
			npc.AiDomain.NpcContext.BaseMemory.PrimaryKnownEnemyPlayer.PlayerInfo.Player = null;
			return true;
		}
		return null;
	}

```

## OnPlayerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a player issues a command.
/// </summary>
/// <param name="arg">The argument containing the command and its parameters.</param>
/// <returns>
/// Returns `null` to allow the command to be handled normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the response to the player's command.
/// </returns>
object OnPlayerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Player {arg.Connection.player.UserIDString} issued the command: {arg.GetString(0)}");
    if (arg.GetString(0).ToLower() == "/test")
    {
        return "This is a test response.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(ConsoleSystem.Arg arg)
	{
		string text = arg.GetString(0).Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command == null)
		{
			return;
		}
		BasePlayer basePlayer = arg.Connection.player as BasePlayer;
		IPlayer player = basePlayer?.IPlayer;
		if (player != null)
		{
			object obj = Interface.CallHook("OnPlayerCommand", arg);
			object obj2 = Interface.CallHook("OnUserCommand", player, command, args);
			if (obj == null && obj2 == null && !Covalence.CommandSystem.HandleChatMessage(player, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				player.Reply(string.Format(lang.GetMessage("UnknownCommand", this, player.Id), command));
			}
		}
	}

```

## CanUserLogin(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user attempts to login.
/// </summary>
/// <param name="username">The username of the user attempting to login.</param>
/// <param name="steamId">The Steam ID of the user attempting to login.</param>
/// <param name="ipAddress">The IP address of the user attempting to login.</param>
/// <returns>
/// Returns a non-null value to override the default login behavior. 
/// If `true` is returned, the user will be allowed to login.
/// If `false` or a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object CanUserLogin(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} is attempting to login.");
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from logging in.");
        return false;
    }
    // Additional logic can be added here to check for other conditions
    return true;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = obj2 ?? obj3;
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object obj6 = Interface.CallHook("OnUserApproved", username, text, obj);
		return obj5 ?? obj6;
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

```

## CanClientLogin(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client attempts to login.
/// </summary>
/// <param name="connection">The client's connection details.</param>
/// <returns>
/// Returns `true` if the client should be rejected, or any non-null value to override the default behavior. 
/// If `null` is returned, the client will be allowed to login as normal.
/// </returns>
object CanClientLogin(Connection connection)
{
    Puts($"Client {connection.username} with IP {connection.ipaddress} has attempted to login.");
    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"Client {connection.username} with IP {connection.ipaddress} has been blocked from logging in.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = obj2 ?? obj3;
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object obj6 = Interface.CallHook("OnUserApproved", username, text, obj);
		return obj5 ?? obj6;
	}

```

## OnUserBanned(string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is banned from the server.
/// </summary>
/// <param name="name">The username of the banned user.</param>
/// <param name="steamId">The Steam ID of the banned user.</param>
/// <param name="ipAddress">The IP address of the banned user.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string name, string steamId, string ipAddress, string reason)
{
    Puts($"User {name} with SteamID {steamId}, IP {ipAddress} has been banned: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

```

## OnPlayerChat(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="arg">The argument containing the chat message and other information.</param>
/// <returns>
/// Returns `null` to allow the chat message to be sent as normal, or any non-null value to prevent the chat message from being sent.
/// If a string is returned, it will be displayed in the chat instead of the original message.
/// </returns>
object OnPlayerChat(ConsoleSystem.Arg arg)
{
    Puts($"Player {arg.Connection.player.UserIDString} sent chat message: {arg.GetString(0).Trim()}");
    if (arg.GetString(0).Trim() == "/mute")
    {
        Puts($"Player {arg.Connection.player.UserIDString} has been muted.");
        return "You have been muted.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ConsoleSystem.Arg arg)
	{
		string text = arg.GetString(0).Trim();
		if (string.IsNullOrEmpty(text))
		{
			return true;
		}
		IPlayer player = ((arg.Connection.player is BasePlayer basePlayer) ? basePlayer.IPlayer : null);
		if (player == null)
		{
			return null;
		}
		object obj = Interface.CallHook("OnPlayerChat", arg);
		object obj2 = Interface.CallHook("OnUserChat", player, text);
		return obj ?? obj2;
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a base entity.
/// </summary>
/// <param name="npc">The NPC that is targeting.</param>
/// <param name="target">The entity being targeted by the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the entity normally, or any non-null value to override the default behavior.
/// If a float value is returned, it will be used as the range for the NPC's fear and enemy behaviors.
/// </returns>
float OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} has targeted entity {target.displayName}");
    if (target is Player player && player.IsSpectating())
    {
        Puts($"NPC {npc.name} will not attack spectating player {player.displayName}");
        return 10f;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		object obj = Interface.CallHook("OnNpcTarget", npc, target);
		if (obj != null)
		{
			npc.SetFact(BaseNpc.Facts.HasEnemy, 0);
			npc.SetFact(BaseNpc.Facts.EnemyRange, 3);
			npc.SetFact(BaseNpc.Facts.AfraidRange, 1);
			return 0f;
		}
		return null;
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The IPlayer object representing the kicked user.</param>
/// <param name="reason">The reason for kicking the user.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(IPlayer player, string reason)
{
    Puts($"User {player.Name} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer player, string reason)
	{
		IPlayer iPlayer = player.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserKicked", player.IPlayer, reason);
		}
	}

```

## OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user connects to the server.
/// </summary>
/// <param name="player">The IPlayer object representing the connected user.</param>
/// <returns>No return behavior.</returns>
void OnUserConnected(IPlayer player)
{
    Puts($"User {player.Name} has connected to the server.");
    if (player.IsAdmin())
    {
        Puts($"User {player.Name} is an administrator.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerInit")]
	private void OnPlayerInit(BasePlayer player)
	{
		lang.SetLanguage(player.net.connection.info.GetString("global.language", "en"), player.UserIDString);
		Covalence.PlayerManager.PlayerConnected(player);
		IPlayer player2 = Covalence.PlayerManager.FindPlayerById(player.UserIDString);
		if (player2 != null)
		{
			player.IPlayer = player2;
			Interface.CallHook("OnUserConnected", player2);
		}
	}

```

## OnNpcPlayerTarget(NPCPlayerApex,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a player.
/// </summary>
/// <param name="npc">The NPC that is targeting the player.</param>
/// <param name="player">The player being targeted by the NPC.</param>
/// <returns>
/// Returns `true` to override the default behavior and prevent the NPC from targeting the player, or any non-boolean value to override the default behavior with a custom reason.
/// </returns>
bool OnNpcPlayerTarget(NPCPlayerApex npc, BasePlayer player)
{
    Puts($"NPC {npc.UserIDString} is targeting player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"NPC {npc.UserIDString} cannot target admin player {player.UserIDString}");
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	private int GetPlayersSensed(NPCPlayerApex npc, Vector3 position, float distance, BaseEntity[] targetList)
	{
		return BaseEntity.Query.Server.GetInSphere(position, distance, targetList, delegate(BaseEntity entity)
		{
			BasePlayer basePlayer = entity as BasePlayer;
			object obj = ((basePlayer != null && npc != null && basePlayer != npc) ? Interface.CallHook("OnNpcPlayerTarget", npc, basePlayer) : null);
			if (obj != null)
			{
				foreach (Memory.SeenInfo item in npc.AiContext.Memory.All)
				{
					if (item.Entity == basePlayer)
					{
						npc.AiContext.Memory.All.Remove(item);
						break;
					}
				}
				foreach (Memory.ExtendedInfo item2 in npc.AiContext.Memory.AllExtended)
				{
					if (item2.Entity == basePlayer)
					{
						npc.AiContext.Memory.AllExtended.Remove(item2);
						break;
					}
				}
			}
			return basePlayer != null && obj == null && basePlayer.isServer && !basePlayer.IsSleeping() && !basePlayer.IsDead() && basePlayer.Family != npc.Family;
		});
	}

```

## OnLoseCondition(object[])

```csharp
```csharp
/// <summary>
/// Called when an item loses a certain amount of condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>No return behavior.</returns>
void OnLoseCondition(object[] args)
{
    Item item = (Item)args[0];
    float amount = (float)args[1];
    Puts($"Item {item.name} has lost {amount} condition.");
    if (item.condition <= 0f && item.condition < ((Item)item).condition)
    {
        Puts($"Item {item.name} is now broken.");
        item.OnBroken();
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

```

## OnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The argument containing information about the command.</param>
/// <returns>
/// Returns `null` to allow the command to execute normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Server command {arg.cmd.FullName} executed by {arg.Player().displayName}");
    if (arg.cmd.FullName == "admin.kick")
    {
        Puts($"Player {arg.Player().displayName} is not allowed to use the admin.kick command.");
        return "You do not have permission to use this command.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		return (arg.cmd.FullName != "chat.say") ? Interface.CallHook("OnServerCommand", arg) : null;
	}

```

## OnPlayerBanned(string,ulong,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="name">The name of the banned player.</param>
/// <param name="steamId">The Steam ID of the banned player.</param>
/// <param name="ipAddress">The IP address of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string name, ulong steamId, string ipAddress, string reason)
{
    Puts($"Player {name} with SteamID {steamId} and IP {ipAddress} has been banned: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersSet")]
	private void IOnServerUsersSet(ulong steamId, ServerUsers.UserGroup group, string name, string reason)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (group == ServerUsers.UserGroup.Banned)
			{
				Interface.CallHook("OnPlayerBanned", name, steamId, player?.Address ?? "0", reason);
				Interface.CallHook("OnUserBanned", name, text, player?.Address ?? "0", reason);
			}
		}
	}

```

## OnEntityTakeDamage(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity (in this case, a player) takes damage.
/// </summary>
/// <param name="entity">The entity taking the damage.</param>
/// <param name="info">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns `true` to allow the entity to take the damage, or any non-null value to prevent them from taking the damage.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnEntityTakeDamage(BasePlayer entity, HitInfo info)
{
    Puts($"Entity {entity.UserIDString} took {info.damageType} damage from {info.attacker.UserIDString}");
    if (info.damageType == "explosive")
    {
        Puts($"Entity {entity.UserIDString} was damaged by an explosive.");
        return "You were hit by an explosive!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer player, HitInfo info)
	{
		if (!serverInitialized || player == null || info == null || player.IsDead() || isPlayerTakingDamage || player is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", player, info) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			player.OnAttacked(info);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

```

## OnUserApproved(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="username">The username of the approved user.</param>
/// <param name="steamId">The Steam ID of the approved user.</param>
/// <param name="ipAddress">The IP address of the approved user.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object OnUserApproved(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been approved to join the server.");
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    // Additional logic can be added here
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = obj2 ?? obj3;
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object obj6 = Interface.CallHook("OnUserApproved", username, text, obj);
		return obj5 ?? obj6;
	}

```

## OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The actual chat message sent by the player.</param>
/// <returns>
/// Returns `null` to allow the chat message to be processed as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for rejecting the chat message.
/// </returns>
object OnUserChat(IPlayer player, string message)
{
    Puts($"Player {player.Name} sent chat message: {message}");
    if (message.ToLower() == "badword")
    {
        Puts($"Player {player.Name} tried to send a bad word in chat.");
        return "Bad word detected.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ConsoleSystem.Arg arg)
	{
		string text = arg.GetString(0).Trim();
		if (string.IsNullOrEmpty(text))
		{
			return true;
		}
		IPlayer player = ((arg.Connection.player is BasePlayer basePlayer) ? basePlayer.IPlayer : null);
		if (player == null)
		{
			return null;
		}
		object obj = Interface.CallHook("OnPlayerChat", arg);
		object obj2 = Interface.CallHook("OnUserChat", player, text);
		return obj ?? obj2;
	}

```

## CanUseUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the UI.
/// </summary>
/// <param name="player">The player attempting to use the UI.</param>
/// <param name="json">The JSON data related to the UI.</param>
/// <returns>
/// Returns `null` to allow the player to use the UI, or any non-null value to prevent them from using it.
/// </returns>
object CanUseUI(BasePlayer player, string json)
{
    Puts($"Player {player.UserIDString} is attempting to use the UI with JSON: {json}");
    if (json == "restricted")
    {
        Puts($"Player {player.displayName} does not have permission to use the restricted UI.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AddUi(BasePlayer player, string json)
	{
		if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
		{
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "AddUI", json);
			return true;
		}
		return false;
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned player.</param>
/// <param name="steamId">The Steam ID of the unbanned player.</param>
/// <param name="ipAddress">The IP address of the unbanned player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} with SteamID {steamId} and IP {ipAddress} has been unbanned.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerUsersRemove")]
	private void IOnServerUsersRemove(ulong steamId)
	{
		if (serverInitialized)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			if (ServerUsers.Is(steamId, ServerUsers.UserGroup.Banned))
			{
				Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
				Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
			}
		}
	}

```

## OnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="connection">The network connection of the user being approved.</param>
/// <returns>
/// Returns `null` to allow the user to join, or any non-null value to prevent them from joining.
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object OnUserApprove(Connection connection)
{
    Puts($"User {connection.username} has been approved to join the server.");
    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"User {connection.username} with IP {connection.ipaddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel == 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = obj2 ?? obj3;
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object obj6 = Interface.CallHook("OnUserApproved", username, text, obj);
		return obj5 ?? obj6;
	}

```

## CanPickupEntity(BasePlayer,DoorCloser)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pickup an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or `null` if they cannot.
/// If a non-null value other than `true` is returned, it will override the default behavior and prevent the player from picking up the entity.
/// </returns>
object CanPickupEntity(BasePlayer player, DoorCloser entity)
{
    Puts($"Player {player.UserIDString} attempting to pick up {entity.GetType().Name}");
    if (entity.IsLocked)
    {
        Puts($"Player {player.displayName} cannot pick up locked {entity.GetType().Name}");
        return "Cannot pick up: Locked";
    }
    object result = Interface.CallHook("CanPickupEntity", player, entity);
    return result;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer player, DoorCloser entity)
	{
		object obj = Interface.CallHook("CanPickupEntity", player, entity);
		bool flag = default(bool);
		int num;
		if (obj is bool)
		{
			flag = (bool)obj;
			num = 1;
		}
		else
		{
			num = 0;
		}
		return (((uint)num & (flag ? 1u : 0u)) != 0) ? ((object)true) : null;
	}

```

