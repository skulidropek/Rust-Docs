# Hook Definitions

## OnPlayerSpectate(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player starts spectating.
/// </summary>
/// <param name="player">The player starting to spectate.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to start spectating, or any non-null value to prevent them from spectating.
/// </returns>
object OnPlayerSpectate(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} started spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to spectate with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartSpectating()
	{
		if (!IsSpectating() && Interface.CallHook("OnPlayerSpectate", this, spectateFilter) == null)
		{
			SetPlayerFlag(PlayerFlags.Spectating, b: true);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 10);
			CancelInvoke(InventoryUpdate);
			ChatMessage("Becoming Spectator");
			UpdateSpectateTarget(spectateFilter);
		}
	}

```

## OnFuelConsumed(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when a base oven consumes fuel.
/// </summary>
/// <param name="oven">The base oven consuming the fuel.</param>
/// <param name="fuel">The item being consumed as fuel.</param>
/// <param name="burnable">The burnable item associated with the fuel consumption.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the fuel will be consumed normally.
/// </returns>
object OnFuelConsumed(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Base oven {oven.info.shortname} has consumed {fuel.amount} units of fuel.");
    if (burnable.fuelAmount > 1000 && fuel.amount < 500)
    {
        Puts($"Fuel consumption rate is too high for base oven {oven.info.shortname}.");
        return "Error: Fuel consumption rate exceeded.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Facepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## OnNpcConversationStart(NPCTalking,BasePlayer,ConversationData)

```csharp
```csharp
/// <summary>
/// Called when an NPC conversation starts with a player.
/// </summary>
/// <param name="npc">The talking NPC.</param>
/// <param name="player">The player starting the conversation.</param>
/// <param name="conversationData">The data for the conversation being started.</param>
/// <returns>
/// Returns `null` to allow the conversation to start normally, or any non-null value to prevent the conversation from starting.
/// </returns>
object OnNpcConversationStart(NPCTalking npc, BasePlayer player, ConversationData conversationData)
{
    Puts($"NPC {npc.name} is starting a conversation with player {player.UserIDString}.");
    if (conversationData.topic == "sensitive")
    {
        Puts($"NPC {npc.name} is trying to start a sensitive conversation with player {player.UserIDString}, but it has been blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server]
	public void Server_BeginTalking(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		CleanupConversingPlayers();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor != null)
		{
			if (conversingPlayers.Contains(player))
			{
				OnConversationEnded(player);
			}
			if (Interface.CallHook("OnNpcConversationStart", this, player, conversationFor) == null)
			{
				conversingPlayers.Add(player);
				UpdateFlags();
				OnConversationStarted(player);
				ClientRPCPlayer(null, player, "Client_StartConversation", GetConversationIndex(conversationFor.shortname), GetConversationStartSpeech(player));
			}
		}
	}

```

## OnCrateHack(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to hack a locked crate.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>
/// Returns `null` to allow the hacking process to proceed, or any non-null value to prevent the hacking attempt.
/// </returns>
object OnCrateHack(HackableLockedCrate crate)
{
    Puts($"Player attempted to hack crate {crate.crateName} with hack time: {crate.hackTime} seconds");
    if (crate.hackTime < 10f)
    {
        Puts($"Player's hacking attempt on crate {crate.crateName} was blocked due to insufficient hack time.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartHacking()
	{
		Interface.CallHook("OnCrateHack", this);
		BroadcastEntityMessage("HackingStarted", 20f, 256);
		SetFlag(Flags.Reserved1, b: true);
		InvokeRepeating(HackProgress, 1f, 1f);
		ClientRPC(null, "UpdateHackProgress", 0, (int)requiredHackSeconds);
		RefreshDecay();
	}

```

## CanAffordToPlace(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford to place a construction component.
/// </summary>
/// <param name="player">The player attempting to place the component.</param>
/// <param name="component">The construction component being placed.</param>
/// <returns>
/// Returns `true` if the player can afford to place the component, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the return value.
/// </returns>
object CanAffordToPlace(BasePlayer player, Construction component)
{
    Puts($"Checking if {player.UserIDString} can afford to place {component.name}");
    // Check if the player has enough funds
    if (player.money < component.cost)
    {
        Puts($"Insufficient funds: {player.money} < {component.cost}");
        return false;
    }
    
    // Check if the player has all required items in their inventory
    foreach (ItemAmount item in component.defaultGrade.costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemDef.itemid) < item.amount)
        {
            Puts($"Missing item: {item.itemDef.name} ({item.amount})");
            return false;
        }
    }
    
    // If all checks pass, the player can afford to place the component
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordToPlace(Construction component)
	{
		if (isTypeDeployable)
		{
			return true;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return false;
		}
		object obj = Interface.CallHook("CanAffordToPlace", ownerPlayer, this, component);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount item in component.defaultGrade.costToBuild)
		{
			if ((float)ownerPlayer.inventory.GetAmount(item.itemDef.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## OnDoorKnocked(DoorKnocker,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a door is knocked.
/// </summary>
/// <param name="door">The door that was knocked.</param>
/// <param name="knocker">The player who knocked on the door.</param>
/// <returns>No return behavior.</returns>
void OnDoorKnocked(BaseDoor door, BasePlayer knocker)
{
    Puts($"Door {door.name} has been knocked by player {knocker.displayName}");
}
```
```

### Source Code from the Library

```csharp

	public void Knock(BasePlayer player)
	{
		ClientRPC(null, "ClientKnock", player.transform.position);
		Interface.CallHook("OnDoorKnocked", this, player);
	}

```

## OnGrowableGather(GrowableEntity,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a player gathers from a growable entity.
/// </summary>
/// <param name="growableEntity">The growable entity being gathered from.</param>
/// <param name="player">The player gathering the item.</param>
/// <param name="eat">Whether the player is eating the item or not.</param>
/// <returns>
/// Returns a non-null value to override the default gather behavior. 
/// If `null` is returned, the player can gather as normal.
/// </returns>
object OnGrowableGather(GrowableEntity growableEntity, BasePlayer player, bool eat)
{
    Puts($"Player {player.UserIDString} gathered from {growableEntity.GetDisplayName()}");
    if (eat && growableEntity.GetProperties().isPoisonous)
    {
        Puts($"Player {player.UserIDString} was poisoned by {growableEntity.GetDisplayName()}");
        return "You were poisoned!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PickFruit(BasePlayer player, bool eat = false)
	{
		if (!CanPick() || Interface.CallHook("OnGrowableGather", this, player, eat) != null)
		{
			return;
		}
		harvests++;
		GiveFruit(player, CurrentPickAmount, eat);
		RandomItemDispenser randomItemDispenser = PrefabAttribute.server.Find<RandomItemDispenser>(prefabID);
		if (randomItemDispenser != null)
		{
			randomItemDispenser.DistributeItems(player, base.transform.position);
		}
		ResetSeason();
		if (Properties.pickEffect.isValid)
		{
			Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
		}
		if (harvests >= Properties.maxHarvests)
		{
			if (Properties.disappearAfterHarvest)
			{
				Die();
			}
			else
			{
				ChangeState(PlantProperties.State.Dying, resetAge: true);
			}
		}
		else
		{
			ChangeState(PlantProperties.State.Mature, resetAge: true);
		}
	}

```

## OnItemUnlock(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is unlocked.
/// </summary>
/// <param name="item">The item that was unlocked.</param>
/// <returns>
/// Returns `null` to allow the item to be unlocked, or any non-null value to prevent it from being unlocked.
/// </returns>
object OnItemUnlock(Item item)
{
    Puts($"Item {item.name} has been unlocked.");
    if (item.name == "restricted_item")
    {
        Puts($"Item {item.name} cannot be unlocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## CanUseHelicopter(BasePlayer,CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the helicopter.
/// </summary>
/// <param name="player">The player attempting to use the helicopter.</param>
/// <param name="helicopterController">The AI controller for the helicopter.</param>
/// <returns>
/// Returns `null` to allow the player to use the helicopter, or any non-null value to prevent them from using it.
/// </returns>
object CanUseHelicopter(BasePlayer player, CH47HelicopterAIController helicopterController)
{
    Puts($"Player {player.UserIDString} is attempting to use the helicopter.");
    if (helicopterController.IsUnderMaintenance())
    {
        Puts($"The helicopter is currently under maintenance and cannot be used by {player.displayName}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", player, this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

```

## OnTrapSnapped(BaseTrapTrigger,UnityEngine.GameObject,UnityEngine.Collider)

```csharp
```csharp
/// <summary>
/// Called when a trap is snapped to an object.
/// </summary>
/// <param name="trap">The trap that was snapped.</param>
/// <param name="obj">The object the trap was snapped to.</param>
/// <param name="col">The collider of the object the trap was snapped to.</param>
/// <returns>No return behavior.</returns>
void OnTrapSnapped(BaseTrapTrigger trap, GameObject obj, Collider col)
{
    Puts($"Trap {trap.name} has been snapped to object {obj.name} with collider {col.gameObject.name}");
}
```
```

### Source Code from the Library

```csharp

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		Interface.CallHook("OnTrapSnapped", this, obj, col);
		base.OnObjectAdded(obj, col);
		_trap.ObjectEntered(obj);
	}

```

## OnDemoRecordingStopped(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is stopped.
/// </summary>
/// <param name="filename">The filename of the recorded demo.</param>
/// <param name="player">The player who was being recorded.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStopped(string filename, BasePlayer player)
{
    Puts($"Demo recording stopped for {player.UserIDString} with filename: {filename}");
}
```
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnCodeEntered(CodeLock,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a code is entered into the lock.
/// </summary>
/// <param name="lock">The lock that was entered.</param>
/// <param name="player">The player who entered the code.</param>
/// <param name="code">The code that was entered.</param>
/// <returns>
/// Returns `null` to allow the default behavior of checking if the code is correct. 
/// If a non-null value is returned, it will override the default behavior and be used as the result.
/// </returns>
object OnCodeEntered(CodeLock lock, BasePlayer player, string code)
{
    Puts($"Player {player.UserID} entered code '{code}' into lock {lock}.");
    if (code == "123456")
    {
        return "Invalid code. Access denied.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void UnlockWithCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract() || !IsLocked() || IsCodeEntryBlocked())
		{
			return;
		}
		string text = rpc.read.String();
		if (Interface.CallHook("OnCodeEntered", this, rpc.player, text) != null)
		{
			return;
		}
		bool flag = text == guestCode;
		bool flag2 = text == code;
		if (!(text == code) && (!hasGuestCode || !(text == guestCode)))
		{
			if (UnityEngine.Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			DoEffect(effectDenied.resourcePath);
			DoEffect(effectShock.resourcePath);
			rpc.player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, this, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, blockwarning);
			}
			if ((float)wrongCodes >= maxFailedAttempts)
			{
				SetFlag(Flags.Reserved11, b: true);
				Invoke(ClearCodeEntryBlocked, lockoutCooldown);
			}
			lastWrongTime = UnityEngine.Time.realtimeSinceStartup;
			return;
		}
		SendNetworkUpdate();
		if (flag2)
		{
			if (!whitelistPlayers.Contains(rpc.player.userID))
			{
				DoEffect(effectCodeChanged.resourcePath);
				whitelistPlayers.Add(rpc.player.userID);
				wrongCodes = 0;
			}
			Facepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: false);
		}
		else if (flag && !guestPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectCodeChanged.resourcePath);
			guestPlayers.Add(rpc.player.userID);
			Facepunch.Rust.Analytics.Azure.OnCodeLockEntered(rpc.player, this, isGuest: true);
		}
	}

```

## CanUnlock(BasePlayer,ModularCarCodeLock,string)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to unlock the car with a code.
/// </summary>
/// <param name="player">The player attempting to unlock the car.</param>
/// <param name="carCodeLock">The car's code lock.</param>
/// <param name="codeEntered">The code entered by the player.</param>
/// <returns>
/// Returns `true` if the code is valid and the player should be allowed to unlock the car, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanUnlock(BasePlayer player, ModularCarCodeLock carCodeLock, string codeEntered)
{
    Puts($"Player {player.UserIDString} attempted to unlock the car with code: {codeEntered}");
    if (carCodeLock.IsLocked && !carCodeLock.IsWhitelisted(player))
    {
        return false;
    }
    if (carCodeLock.Code == codeEntered)
    {
        return true;
    }
    player.Hurt((float)(5 - carCodeLock.WrongCodes) * 5f, DamageType.ElectricShock, carCodeLock.Owner, useProtection: false);
    carCodeLock.WrongCodes++;
    if (carCodeLock.WrongCodes >= carCodeLock.MaxFailedAttempts)
    {
        carCodeLock.Owner.SetFlag(BaseEntity.Flags.Reserved10, b: true);
        carCodeLock.Owner.Invoke(ClearCodeEntryBlocked, carCodeLock.LockoutCooldown);
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public bool TryOpenWithCode(BasePlayer player, string codeEntered)
	{
		object obj = Interface.CallHook("CanUnlock", player, this, codeEntered);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (CodeEntryBlocked(player))
		{
			return false;
		}
		if (!(codeEntered == Code))
		{
			if (Time.realtimeSinceStartup > lastWrongTime + 60f)
			{
				wrongCodes = 0;
			}
			player.Hurt((float)(wrongCodes + 1) * 5f, DamageType.ElectricShock, owner, useProtection: false);
			wrongCodes++;
			if (wrongCodes > 5)
			{
				player.ShowToast(GameTip.Styles.Red_Normal, CodeLock.blockwarning);
			}
			if ((float)wrongCodes >= CodeLock.maxFailedAttempts)
			{
				owner.SetFlag(BaseEntity.Flags.Reserved10, b: true);
				owner.Invoke(ClearCodeEntryBlocked, CodeLock.lockoutCooldown);
			}
			lastWrongTime = Time.realtimeSinceStartup;
			return false;
		}
		if (!WhitelistPlayers.Contains(player.userID))
		{
			WhitelistPlayers.Add(player.userID);
			wrongCodes = 0;
		}
		owner.SendNetworkUpdate();
		return true;
	}

```

## OnSignalBroadcast(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a signal is broadcasted to all connected clients.
/// </summary>
/// <param name="entity">The entity that triggered the signal.</param>
/// <returns>No return behavior.</returns>
void OnSignalBroadcast(BaseEntity entity)
{
    Puts($"Signal broadcasted from {entity.name}.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", this) == null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers)
			{
				method = SendMethod.Unreliable,
				priority = Priority.Immediate
			}, sourceConnection, "SignalFromServerEx", (int)signal, arg);
		}
	}

```

## OnAdventGiftAward(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a gift is awarded to a player.
/// </summary>
/// <param name="calendar">The Advent Calendar instance.</param>
/// <param name="player">The BasePlayer who received the gift.</param>
object OnAdventGiftAward(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Gift awarded to {player.displayName} on {calendar.Name}");
    if (player.UserIDString == "123456")
    {
        Puts($"Gift denied for {player.displayName}. Only players with ID 987654 are eligible.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AwardGift(BasePlayer player)
	{
		if (Interface.CallHook("OnAdventGiftAward", this, player) != null)
		{
			return;
		}
		DateTime now = DateTime.Now;
		int num = now.Day - startDay;
		if (now.Month == startMonth && num >= 0 && num < days.Length)
		{
			if (!playerRewardHistory.ContainsKey(player.userID))
			{
				playerRewardHistory.Add(player.userID, new List<int>());
			}
			playerRewardHistory[player.userID].Add(num);
			Effect.server.Run(giftEffect.resourcePath, player.transform.position);
			if (num >= 0 && num < crosses.Length)
			{
				Effect.server.Run(boxCloseEffect.resourcePath, base.transform.position + Vector3.up * 1.5f);
			}
			DayReward dayReward = days[num];
			for (int i = 0; i < dayReward.rewards.Length; i++)
			{
				ItemAmount itemAmount = dayReward.rewards[i];
				player.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);
			}
			Interface.CallHook("OnAdventGiftAwarded", this, player);
		}
	}

```

## CanUnlock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock the object.
/// </summary>
/// <param name="player">The player attempting to unlock.</param>
/// <param name="lock">The lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to unlock, or any non-null value to prevent them from unlocking.
/// </returns>
object CanUnlock(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} is attempting to unlock {lock.name}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Access denied: Only admins can unlock";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Unlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && HasLockPermission(rpc.player))
		{
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## OnEntityDestroy(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when an entity is destroyed.
/// </summary>
/// <param name="entity">The entity being destroyed.</param>
/// <returns>
/// Returns `null` to allow the entity to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnEntityDestroy(CH47HelicopterAIController entity)
{
    Puts($"Entity {entity.GetType().Name} has been destroyed.");
    if (entity is CH47HelicopterAIController && ((CH47HelicopterAIController)entity).IsCritical)
    {
        Puts($"Entity {entity.GetType().Name} was critical and could not be destroyed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnKilled(info);
		}
	}

```

## OnExperimentEnded(Workbench)

```csharp
```csharp
/// <summary>
/// Called when an experiment has ended.
/// </summary>
/// <param name="workbench">The workbench where the experiment was conducted.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the experiment will be considered successful and the blueprint will be created.
/// </returns>
object OnExperimentEnded(Workbench workbench)
{
    Puts($"Experiment on {workbench.GetDisplayName()} has ended.");
    if (workbench.GetPendingBlueprint() == null)
    {
        Puts("No pending blueprint found!");
        return true;
    }
    // Additional logic can be added here to modify the experiment outcome
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnFishCatch(Item,BaseFishingRod,BasePlayer)

```csharp
This is a C# code snippet that appears to be part of a fishing game mechanic in the Rust game. It's a server-side script that handles the process of catching a fish. Here's a breakdown of what it does:

1. **Input Handling**: The script checks for various input flags (e.g., `HasReelInInput`, `AllowPullInDirection`) to determine if the player is trying to catch a fish.
2. **State Management**: It updates the current state of the fishing process, which can be one of three states: Waiting, Catching, or Caught.
3. **Fish State Updates**: The script updates the fish's state based on the input flags and the current state of the fishing process.
4. **Strain Timer**: It increments a strain timer that affects the fish's behavior and ultimately determines whether it will be caught or not.
5. **Catch Logic**: If the fish is caught, the script:
	* Cancels any ongoing catch process.
	* Updates the player's inventory with the caught fish.
	* Triggers various hooks (e.g., `CanCatchFish`, `OnFishCatch`) to allow for custom behavior.
	* Resets the fishing line after a short delay.

Some notable aspects of this code include:

* The use of flags and state management to handle complex game logic.
* The incorporation of hooks to allow for customization by other scripts or plugins.
* The use of timers and delays to create a sense of realism and anticipation in the game.
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1218511105))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(null, "Client_HookedSomething");
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(null, "Client_UpdateFishState", (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else
		{
			if (!(num2 <= FishCatchDistance) && !ForceSuccess)
			{
				return;
			}
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					fishLookup.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(null, "Client_OnCaughtFish", currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## OnWildlifeTrap(WildlifeTrap,TrappableWildlife)

```csharp
```csharp
/// <summary>
/// Called when a wildlife trap is triggered.
/// </summary>
/// <param name="trap">The wildlife trap that was triggered.</param>
/// <param name="wildlife">The trappable wildlife caught by the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to function normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display when the trap is triggered.
/// </returns>
object OnWildlifeTrap(WildlifeTrap trap, TrappableWildlife wildlife)
{
    Puts($"Wildlife trap {trap.name} caught {wildlife.speciesName}.");
    if (wildlife.speciesName == "rare species")
    {
        Puts($"Rare species caught by {trap.name}. Rewarding player with bonus experience.");
        return "Caught rare species! +1000 XP";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TrapWildlife(TrappableWildlife trapped)
	{
		if (Interface.CallHook("OnWildlifeTrap", this, trapped) == null)
		{
			Item item = ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Remove();
			}
			else
			{
				SetFlag(Flags.Reserved1, b: true);
			}
			SetTrapActive(trapOn: false);
			Hurt(StartMaxHealth() * 0.1f, DamageType.Decay, null, useProtection: false);
		}
	}

```

## OnNpcEquipWeapon(ScientistNPC,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon.
/// </summary>
/// <param name="npc">The NPC equipping the weapon.</param>
/// <param name="item">The item being equipped.</param>
/// <returns>
/// Returns `null` to allow the NPC to equip the weapon normally, or any non-null value to prevent the NPC from equipping the weapon.
/// </returns>
object OnNpcEquipWeapon(ScientistNPC npc, Item item)
{
    Puts($"NPC {npc.name} is attempting to equip {item.displayName}.");
    if (item.contents == null || item.contents.Count > 5)
    {
        Puts($"NPC {npc.name} cannot equip {item.displayName} due to inventory constraints.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void EquipWeapon(bool skipDeployDelay = false)
	{
		base.EquipWeapon(skipDeployDelay);
		HeldEntity heldEntity = GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		Item item = heldEntity.GetItem();
		if (item == null || item.contents == null || Interface.CallHook("OnNpcEquipWeapon", this, item) != null)
		{
			return;
		}
		if (UnityEngine.Random.Range(0, 3) == 0)
		{
			Item item2 = ItemManager.CreateByName("weapon.mod.flashlight", 1, 0uL);
			if (!item2.MoveToContainer(item.contents))
			{
				item2.Remove();
				return;
			}
			lightsOn = false;
			InvokeRandomized(base.LightCheck, 0f, 30f, 5f);
			LightCheck();
		}
		else
		{
			Item item3 = ItemManager.CreateByName("weapon.mod.lasersight", 1, 0uL);
			if (!item3.MoveToContainer(item.contents))
			{
				item3.Remove();
			}
			LightToggle();
			lightsOn = true;
		}
	}

```

## CanBeRecycled(Item,Recycler)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled.
/// </summary>
/// <param name="item">The item being checked for recyclability.</param>
/// <param name="recycler">The recycler performing the check (not used in this example).</param>
/// <returns>
/// Returns `true` if the item can be recycled, and `false` otherwise.
/// If a non-null value is returned that is not a boolean, it will override the default recyclability behavior.
/// </returns>
bool CanBeRecycled(Item item, Recycler recycler)
{
    Puts($"Checking if item {item.info.name} can be recycled.");
    object obj = Interface.CallHook("CanBeRecycled", item, this);
    if (obj is bool)
    {
        return (bool)obj;
    }
    if (item != null && item.info.Blueprint != null)
    {
        Puts($"Item {item.info.name} has a valid blueprint and can be recycled.");
        return true;
    }
    Puts($"Item {item.info.name} cannot be recycled.");
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanBeRecycled(Item item)
	{
		object obj = Interface.CallHook("CanBeRecycled", item, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item != null)
		{
			return item.info.Blueprint != null;
		}
		return false;
	}

```

## OnQuarryConsumeFuel(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when a quarry consumes fuel.
/// </summary>
/// <param name="quarry">The mining quarry consuming fuel.</param>
/// <param name="item">The item being consumed as fuel.</param>
/// <returns>
/// Returns `true` if the fuel consumption was successful, or any non-null value to override the default behavior. 
/// If `null` is returned, the fuel consumption will be cancelled.
/// </returns>
object OnQuarryConsumeFuel(MiningQuarry quarry, Item item)
{
    Puts($"Quarry {quarry.name} is consuming fuel.");
    if (item.info.shortname == "diesel_barrel")
    {
        Puts($"Quarry {quarry.name} has been refueled with diesel barrels.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool FuelCheck()
	{
		if (pendingWork > 0f)
		{
			return true;
		}
		Item item = fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemsByItemName("diesel_barrel");
		object obj = Interface.CallHook("OnQuarryConsumeFuel", this, item);
		if (obj is Item)
		{
			item = (Item)obj;
		}
		if (item != null && item.amount >= 1)
		{
			pendingWork += workPerFuel;
			Facepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);
			item.UseItem();
			return true;
		}
		return false;
	}

```

## OnOpenVendingAdmin(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine admin menu is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <param name="player">The player opening the admin menu.</param>
/// <returns>No return behavior.</returns>
void OnOpenVendingAdmin(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} opened admin menu for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenAdmin(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			SendSellOrders(player);
			PlayerOpenLoot(player);
			ClientRPCPlayer(null, player, "CLIENT_OpenAdminMenu");
			Interface.CallHook("OnOpenVendingAdmin", this, player);
		}
	}

```

## CanReceiveCall(PhoneController)

```csharp
```csharp
/// <summary>
/// Determines whether the phone can receive a call.
/// </summary>
/// <param name="phoneController">The phone controller.</param>
/// <returns>
/// Returns `true` if the phone can receive a call, and `false` otherwise.
/// If `null` is returned by the hook, it will default to returning `true`.
/// </returns>
bool CanReceiveCall(PhoneController phoneController)
{
    object obj = Interface.CallHook("CanReceiveCall", phoneController);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If no value is returned by the hook, default to returning true
    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool CanReceiveCall()
	{
		object obj = Interface.CallHook("CanReceiveCall", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequirePower && !IsPowered())
		{
			return false;
		}
		if (RequireParent && !base.baseEntity.HasParent())
		{
			return false;
		}
		return true;
	}

```

## OnTurretTarget(AutoTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a turret's target is set.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <param name="targetEntity">The BaseCombatEntity being targeted by the turret.</param>
/// <returns>
/// Returns `null` to allow the turret to target the entity, or any non-null value to prevent the turret from targeting the entity.
/// </returns>
object OnTurretTarget(AutoTurret turret, BaseCombatEntity targetEntity)
{
    Puts($"Turret {turret.name} is now targeting {targetEntity.displayName}");
    if (targetEntity == null || targetEntity.IsDead)
    {
        Puts($"Turret {turret.name} has lost its target.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity targ)
	{
		if (Interface.CallHook("OnTurretTarget", this, targ) == null)
		{
			if (targ != target)
			{
				Effect.server.Run((targ == null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, base.transform.position, Vector3.up);
				MarkDirtyForceUpdateOutputs();
				nextShotTime += 0.1f;
			}
			target = targ;
		}
	}

```

## OnEntityActiveCheck(BaseEntity,BasePlayer,uint,string)

```csharp
```csharp
/// <summary>
/// Called when checking if an entity is active.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <param name="player">The player performing the check.</param>
/// <param name="id">A unique identifier for the check.</param>
/// <param name="debugName">A debug-friendly name for the entity or check.</param>
/// <returns>
/// Returns `true` if the entity is active, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object OnEntityActiveCheck(BaseEntity entity, BasePlayer player, uint id, string debugName)
{
    Puts($"Checking if entity {debugName} ({entity.net.ID}) is active for player {player.displayName} ({player.net.ID}).");
    // Perform custom logic here to determine if the entity is active
    return true; // Replace with actual logic
}
```
```

### Source Code from the Library

```csharp
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityActiveCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				Item activeItem = player.GetActiveItem();
				if (activeItem == null)
				{
					return false;
				}
				if (activeItem.GetHeldEntity() != ent)
				{
					return false;
				}
				return true;
			}

```

## CanHelicopterUseNapalm(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can use napalm.
/// </summary>
/// <param name="helicopter">The helicopter in question.</param>
/// <returns>
/// Returns `true` if the helicopter is allowed to use napalm, and `false` otherwise.
/// If no return value is specified, returns whether 30 seconds have passed since the last time napalm was used.
/// </returns>
bool CanHelicopterUseNapalm(PatrolHelicopterAI helicopter)
{
    Puts($"Checking if helicopter can use napalm...");
    if (helicopter.IsOnFire())
    {
        Puts("Helicopter is on fire, cannot use napalm.");
        return false;
    }
    object obj = Interface.CallHook("CanHelicopterUseNapalm", helicopter);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return UnityEngine.Time.realtimeSinceStartup - lastNapalmTime >= 30f;
	}

```

## OnPhoneCallStarted(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone call is started.
/// </summary>
/// <param name="caller">The player making the call.</param>
/// <param name="receiver">The player receiving the call.</param>
/// <param name="currentPlayer">The current player, which could be either the caller or receiver.</param>
/// <returns>
/// Returns `null` to allow the phone call to start normally. 
/// If a non-null value is returned, it will override the default behavior and prevent the call from starting.
/// </returns>
object OnPhoneCallStarted(PhoneController caller, PhoneController receiver, BasePlayer currentPlayer)
{
    Puts($"Phone call started between {caller.UserIDString} and {receiver.UserIDString}");
    if (currentPlayer == null)
    {
        Puts("Error: Current player is null");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", this, activeCallTo, currentPlayer) == null)
		{
			if (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)
			{
				_ = currentPlayer != null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			Invoke(TimeOutCall, TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", this, activeCallTo, currentPlayer);
		}
	}

```

## OnSignUpdated(CarvablePumpkin,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated.
/// </summary>
/// <param name="pumpkin">The CarvablePumpkin instance.</param>
/// <param name="player">The player who updated the sign.</param>
/// <returns>No return behavior, this method only logs and updates the network.</returns>
void OnSignUpdated(CarvablePumpkin pumpkin, BasePlayer player)
{
    Puts($"Sign on {pumpkin} has been updated by {player}.");
    // You can add custom logic here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			UnityEngine.Debug.LogWarning($"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", this, msg.player);
	}

```

## OnVendingShopOpen(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine that was opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>
/// Returns `null` to allow the shop to open normally, or any non-null value to prevent the shop from opening.
/// </returns>
object OnVendingShopOpen(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} opened a vending shop with machine ID: {vendingMachine.machineId}");
    if (player.HasFlag("VIP"))
    {
        Puts($"Player {player.displayName} is a VIP and has been granted access to the shop.");
        return null;
    }
    return "Access denied: You are not authorized to open this shop.";
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", this, msg.player) == null)
		{
			SendSellOrders(msg.player);
			PlayerOpenLoot(msg.player, customerPanel);
			Interface.CallHook("OnVendingShopOpened", this, msg.player);
		}
	}

```

## OnExcavatorMiningToggled(ExcavatorArm)

```csharp
```csharp
/// <summary>
/// Called when the excavator's mining state is toggled.
/// </summary>
/// <param name="excavatorArm">The ExcavatorArm instance that triggered the toggle.</param>
/// <returns>No return behavior.</returns>
void OnExcavatorMiningToggled(ExcavatorArm excavatorArm)
{
    Puts($"Excavator mining state toggled: {excavatorArm.IsMining}");
    if (excavatorArm.IsMining)
    {
        Puts("Excavator is now mining.");
    }
    else
    {
        Puts("Excavator has stopped mining.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void BeginMining()
	{
		if (!IsPowered())
		{
			return;
		}
		SetFlag(Flags.On, b: true);
		InvokeRepeating(ProduceResources, resourceProductionTickRate, resourceProductionTickRate);
		if (UnityEngine.Time.time > nextNotificationTime)
		{
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				if (!activePlayer.IsNpc && activePlayer.IsConnected)
				{
					activePlayer.ShowToast(GameTip.Styles.Server_Event, excavatorPhrase);
				}
			}
			nextNotificationTime = UnityEngine.Time.time + 60f;
		}
		ExcavatorServerEffects.SetMining(isMining: true);
		Facepunch.Rust.Analytics.Server.ExcavatorStarted();
		excavatorStartTime = GetNetworkTime();
		Interface.CallHook("OnExcavatorMiningToggled", this);
	}

```

## OnClientProjectileEffectCreate(Network.Connection,BaseProjectile,string)

```csharp
```csharp
/// <summary>
/// Called when a client-side projectile effect is created.
/// </summary>
/// <param name="connection">The connection of the player who created the effect.</param>
/// <param name="projectile">The projectile that was fired.</param>
/// <param name="prefabName">The name of the prefab used to create the effect.</param>
/// <returns>
/// Returns `null` to allow the effect to be created as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for overriding the default behavior.
/// </returns>
object OnClientProjectileEffectCreate(Network.Connection connection, BaseProjectile projectile, string prefabName)
{
    Puts($"Client-side projectile effect created by {connection.UserIDString} with prefab {prefabName}");
    if (prefabName == "SilencedBullet")
    {
        Puts($"Client-side projectile effect creation overridden for silenced bullet");
        return "Silenced bullet effects are not allowed.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false)
	{
		if (Interface.CallHook("OnClientProjectileEffectCreate", sourceConnection, this, prefabName) == null)
		{
			Effect effect = reusableInstance;
			effect.Clear();
			effect.Init(Effect.Type.Projectile, pos, velocity, sourceConnection);
			effect.scale = (silenced ? 0f : 1f);
			if (forceClientsideEffects)
			{
				effect.scale = 2f;
			}
			effect.pooledString = prefabName;
			effect.number = seed;
			EffectNetwork.Send(effect);
		}
	}

```

## OnHorseLead(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a horse is led by a player.
/// </summary>
/// <param name="animal">The horse being led.</param>
/// <param name="player">The player leading the horse.</param>
/// <returns>
/// Returns `null` to allow the horse to be led, or any non-null value to prevent it from being led.
/// </returns>
object OnHorseLead(BaseRidableAnimal animal, BasePlayer player)
{
    Puts($"Horse {animal.GetDisplayName()} is being led by player {player.UserIDString}.");
    if (player == null || !player.IsConnected)
    {
        Puts($"Player {player.UserIDString} is not connected to the server.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Lead(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && !AnyMounted() && !IsForSale())
		{
			bool num = IsLeading();
			bool flag = msg.read.Bit();
			if (num != flag && Interface.CallHook("OnHorseLead", this, player) == null)
			{
				SetLeading(flag ? player : null);
				LeadingChanged();
			}
		}
	}

```

## IOnBaseCombatEntityHurt(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a base combat entity is hurt.
/// </summary>
/// <param name="entity">The entity that was hurt.</param>
/// <param name="info">Information about the hit.</param>
/// <returns>
/// Returns a non-null value to override the default hurt behavior. 
/// If `null` is returned, the entity will be hurt as normal.
/// </returns>
object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity} was hurt by {info.Initiator} with damage type {info.damageTypes.GetMajorityDamageType()}.");
    if (info.damageTypes.GetMajorityDamageType() == DamageType.Arrow && entity is BasePlayer player)
    {
        Puts($"Player {player} was hit by an arrow.");
        return "Arrow hit";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void Hurt(HitInfo info)
	{
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead())
		{
			return;
		}
		using (TimeWarning.New("Hurt( HitInfo )", 50))
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!(propDirection[i].extraProtection == null) && !propDirection[i].IsWeakspot(base.transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (!(this is BasePlayer))
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
			if (Interface.CallHook("IOnBaseCombatEntityHurt", this, info) != null)
			{
				return;
			}
			DebugHurt(info);
			health = num - info.damageTypes.Total();
			SendNetworkUpdate();
			if (ConVar.Global.developer > 1)
			{
				Debug.Log(string.Concat("[Combat]".PadRight(10), base.gameObject.name, " hurt ", info.damageTypes.GetMajorityDamageType(), "/", info.damageTypes.Total(), " - ", health.ToString("0"), " health left"));
			}
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if (lastAttacker != null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if (baseCombatEntity != null)
				{
					baseCombatEntity.lastDealtDamageTime = UnityEngine.Time.time;
					baseCombatEntity.lastDealtDamageTo = this;
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (markAttackerHostile && baseCombatEntity2 != null && baseCombatEntity2 != this)
			{
				baseCombatEntity2.MarkHostileFor();
			}
			if (lastDamage.IsConsideredAnAttack())
			{
				lastAttackedTime = UnityEngine.Time.time;
				if (lastAttacker != null)
				{
					LastAttackedDir = (lastAttacker.transform.position - base.transform.position).normalized;
				}
			}
			bool flag = Health() <= 0f;
			Facepunch.Rust.Analytics.Azure.OnEntityTakeDamage(info, flag);
			if (flag)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer)
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.LogAttack(info, "killed", num);
				}
				else
				{
					initiatorPlayer.stats.combat.LogAttack(info, "", num);
				}
			}
		}
	}

```

## OnAddVendingOffer(VendingMachine,ProtoBuf.VendingMachine.SellOrder)

```csharp
```csharp
/// <summary>
/// Called when a new vending offer is added.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was added to.</param>
/// <param name="sellOrder">The sell order details of the new offer.</param>
object OnAddVendingOffer(VendingMachine vendingMachine, ProtoBuf.VendingMachine.SellOrder sellOrder)
{
    Puts($"New vending offer added to {vendingMachine.name} with item ID {sellOrder.itemToSellID}, amount {sellOrder.itemToSellAmount}, currency ID {sellOrder.currencyID}, and amount per item {sellOrder.currencyAmountPerItem}");
    if (sellOrder.currencyID == 123 && sellOrder.itemToSellID == 456)
    {
        Puts($"Vending offer with item ID {sellOrder.itemToSellID} and currency ID {sellOrder.currencyID} has been blocked.");
        return "Blocked: Invalid item or currency.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AddSellOrder(int itemToSellID, int itemToSellAmount, int currencyToUseID, int currencyAmount, byte bpState)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemToSellID);
		ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(currencyToUseID);
		if (!(itemDefinition == null) && !(itemDefinition2 == null))
		{
			currencyAmount = Mathf.Clamp(currencyAmount, 1, 10000);
			itemToSellAmount = Mathf.Clamp(itemToSellAmount, 1, itemDefinition.stackable);
			ProtoBuf.VendingMachine.SellOrder sellOrder = new ProtoBuf.VendingMachine.SellOrder();
			sellOrder.ShouldPool = false;
			sellOrder.itemToSellID = itemToSellID;
			sellOrder.itemToSellAmount = itemToSellAmount;
			sellOrder.currencyID = currencyToUseID;
			sellOrder.currencyAmountPerItem = currencyAmount;
			sellOrder.currencyIsBP = bpState == 3 || bpState == 2;
			sellOrder.itemToSellIsBP = bpState == 3 || bpState == 1;
			Interface.CallHook("OnAddVendingOffer", this, sellOrder);
			sellOrders.sellOrders.Add(sellOrder);
			RefreshSellOrderStockLevel(itemDefinition);
			UpdateMapMarker();
			SendNetworkUpdate();
		}
	}

```

## OnHelicopterRetire(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called when a helicopter is retiring.
/// </summary>
/// <param name="helicopter">The helicopter that is retiring.</param>
/// <returns>
/// Returns `null` to allow the helicopter to retire normally, or any non-null value to prevent it from retiring.
/// </returns>
object OnHelicopterRetire(PatrolHelicopterAI helicopter)
{
    Puts($"Helicopter {helicopter.GetID()} is retiring.");
    if (helicopter.GetFuelLevel() < 10f)
    {
        Puts($"Helicopter {helicopter.GetID()} has low fuel and will not retire.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Retire()
	{
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", this) == null)
		{
			isRetiring = true;
			Invoke(DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 newPos = Vector3Ex.Range(-1f, 1f);
			newPos.y = 0f;
			newPos.Normalize();
			newPos *= x * 20f;
			newPos.y = y;
			ExitCurrentState();
			State_Move_Enter(newPos);
		}
	}

```

## CanElevatorLiftMove(ElevatorLift)

```csharp
```csharp
/// <summary>
/// Called to determine if the elevator lift can move.
/// </summary>
/// <param name="lift">The elevator lift in question.</param>
/// <returns>
/// Returns `true` if the lift can move, and `false` otherwise.
/// If a non-null value is returned that is not a boolean, it will be treated as an error and the lift will not move.
/// </returns>
bool CanElevatorLiftMove(ElevatorLift lift)
{
    Puts($"Checking if elevator lift {lift.name} can move.");
    object result = Interface.CallHook("CanElevatorLiftMove", lift);
    if (result is bool)
    {
        return (bool)result;
    }
    else if (result != null)
    {
        Puts($"Error: Unexpected value returned from CanElevatorLiftMove hook. Lift will not move.");
        return false;
    }
    // If no hook returns a value, check for contents in the vehicle trigger
    if (VehicleTrigger.HasContents && VehicleTrigger.entityContents != null)
    {
        foreach (BaseEntity entityContent in VehicleTrigger.entityContents)
        {
            if (!(entityContent is Drone))
            {
                return false;
            }
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanMove()
	{
		object obj = Interface.CallHook("CanElevatorLiftMove", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (VehicleTrigger.HasContents && VehicleTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in VehicleTrigger.entityContents)
			{
				if (!(entityContent is Drone))
				{
					return false;
				}
			}
		}
		return true;
	}

```

## OnOvenStart(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when an oven starts cooking.
/// </summary>
/// <param name="oven">The oven that started cooking.</param>
/// <returns>
/// Returns `null` to allow the oven to start cooking, or any non-null value to prevent it from starting.
/// </returns>
object OnOvenStart(BaseOven oven)
{
    Puts($"Oven {oven.GetDisplayName()} has started cooking.");
    if (oven.GetFuelLevel() < 0.5f)
    {
        Puts($"Oven {oven.GetDisplayName()} does not have enough fuel to start cooking.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			InvokeRepeating(Cook, 0.5f, 0.5f);
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", this);
		}
	}

```

## OnMapImageUpdated()

```csharp
```csharp
/// <summary>
/// Called when a map image is updated.
/// </summary>
void OnMapImageUpdated()
{
    Puts("Map image has been updated.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.FromOwner]
	public void ImageUpdate(RPCMessage msg)
	{
		if (msg.player == null)
		{
			return;
		}
		byte b = msg.read.UInt8();
		byte b2 = msg.read.UInt8();
		uint num = msg.read.UInt32();
		if ((b == 0 && fogImages[b2] == num) || (b == 1 && paintImages[b2] == num))
		{
			return;
		}
		uint num2 = (uint)(b * 1000 + b2);
		byte[] array = msg.read.BytesWithSize();
		if (array != null)
		{
			FileStorage.server.RemoveEntityNum(net.ID, num2);
			uint num3 = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, num2);
			if (b == 0)
			{
				fogImages[b2] = num3;
			}
			if (b == 1)
			{
				paintImages[b2] = num3;
			}
			InvalidateNetworkCache();
			Interface.CallHook("OnMapImageUpdated");
		}
	}

```

## IOnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets another entity.
/// </summary>
/// <param name="npc">The NPC that targeted the entity.</param>
/// <param name="target">The entity that was targeted by the NPC.</param>
/// <returns>
/// Returns a float value indicating how much the NPC wants to attack the target, on a scale of 0 to 1.
/// If `null` is returned, the default behavior will be used.
/// </returns>
float IOnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} targeted entity {target.UserIDString}");
    if (target is Player player && player.IsSpectator)
    {
        Puts($"NPC {npc.name} does not want to attack spectator {player.UserIDString}");
        return 0;
    }
    return WantsToAttack(target);
}
```
```

### Source Code from the Library

```csharp

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("IOnNpcTarget", this, target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

```

## OnSignLocked(PhotoFrame,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The PhotoFrame instance that was locked.</param>
/// <param name="player">The BasePlayer who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(PhotoFrame sign, BasePlayer player)
{
    Puts($"Sign at {sign.transform.position} has been locked by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## CanLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot another player.
/// </summary>
/// <param name="looter">The player attempting to loot.</param>
/// <param name="target">The player being looted.</param>
/// <returns>
/// Returns `true` if the looter can loot the target, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is attempting to loot player {target.UserIDString}");
    if (looter == target)
    {
        Puts("Cannot loot self");
        return false;
    }
    if (!target.IsWounded())
    {
        Puts("Target is not wounded, cannot loot");
        return true;
    }
    object obj = Interface.CallHook("CanLootPlayer", looter, target);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanBeLooted(BasePlayer player)
	{
		object obj = Interface.CallHook("CanLootPlayer", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player == this)
		{
			return false;
		}
		if (!IsWounded())
		{
			return IsSleeping();
		}
		return true;
	}

```

## CanLootEntity(BasePlayer,BaseRidableAnimal)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, BaseRidableAnimal entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.GetUniqueID()}");
    if (entity.IsLocked())
    {
        Puts($"Entity {entity.GetUniqueID()} is locked and cannot be looted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && CanOpenStorage(player) && (!needsBuildingPrivilegeToUse || player.CanBuild()) && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## OnWorldPrefabSpawned(UnityEngine.GameObject,string)

```csharp
```csharp
/// <summary>
/// Called when a world prefab is spawned.
/// </summary>
/// <param name="gameObject">The spawned game object.</param>
/// <param name="category">The category of the spawned prefab.</param>
/// <returns>No return behavior.</returns>
void OnWorldPrefabSpawned(GameObject gameObject, string category)
{
    Puts($"World prefab {category} has been spawned at position: {gameObject.transform.position}");
}
```
```

### Source Code from the Library

```csharp

	private static void Spawn(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		if (prefab != null && (bool)prefab.Object)
		{
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject gameObject = prefab.Spawn(position, rotation, scale);
			if ((bool)gameObject)
			{
				Interface.CallHook("OnWorldPrefabSpawned", gameObject, category);
				GameObjectEx.SetHierarchyGroup(gameObject, category);
			}
		}
	}

```

## OnInputUpdate(IOEntity,int,int)

```csharp
```csharp
/// <summary>
/// Called when the input of an IOEntity is updated.
/// </summary>
/// <param name="entity">The IOEntity whose input has been updated.</param>
/// <param name="inputAmount">The amount of input provided to the entity.</param>
/// <param name="inputSlot">The slot in which the input was provided.</param>
/// <returns>
/// Returns `null` if the default behavior should be executed, or any non-null value to override the default behavior.
/// </returns>
object OnInputUpdate(IOEntity entity, int inputAmount, int inputSlot)
{
    Puts($"IOEntity {entity.EntityID} has had its input updated with amount {inputAmount} in slot {inputSlot}");
    if (inputAmount < 0 && inputSlot == 1)
    {
        Puts($"IOEntity {entity.EntityID} has been given a negative input in slot {inputSlot}. This is not allowed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (Interface.CallHook("OnInputUpdate", this, inputAmount, inputSlot) != null)
		{
			return;
		}
		if (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)
		{
			IOStateChanged(inputAmount, inputSlot);
			return;
		}
		UpdateHasPower(inputAmount, inputSlot);
		lastEnergy = currentEnergy;
		currentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);
		int passthroughAmount = GetPassthroughAmount();
		bool flag = lastPassthroughEnergy != passthroughAmount;
		lastPassthroughEnergy = passthroughAmount;
		if (currentEnergy != lastEnergy || flag)
		{
			IOStateChanged(inputAmount, inputSlot);
			ensureOutputsUpdated = true;
		}
		_processQueue.Enqueue(this);
	}

```

## OnPayForUpgrade(BasePlayer,BuildingBlock,ConstructionGrade)

```csharp
```csharp
/// <summary>
/// Called when a player pays for an upgrade.
/// </summary>
/// <param name="player">The player paying for the upgrade.</param>
/// <param name="block">The building block being upgraded.</param>
/// <param name="grade">The construction grade of the upgrade.</param>
/// <returns>
/// Returns `null` to allow the player to pay for the upgrade, or any non-null value to prevent them from paying.
/// </returns>
object OnPayForUpgrade(BasePlayer player, BuildingBlock block, ConstructionGrade grade)
{
    Puts($"Player {player.UserIDString} is attempting to pay for an upgrade of {block.name} to grade {grade.name}.");
    if (grade == ConstructionGrade.Platinum && !player.HasPermission("can_upgrade_platinum"))
    {
        Puts($"Player {player.displayName} does not have permission to upgrade to platinum.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PayForUpgrade(ConstructionGrade g, BasePlayer player)
	{
		if (Interface.CallHook("OnPayForUpgrade", player, this, g) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in g.costToBuild)
		{
			player.inventory.Take(list, item.itemid, (int)item.amount);
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.itemid);
			Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "upgrade_block", itemDefinition.shortname, (int)item.amount, this, null, safezone: false, null, player.userID);
			player.Command("note.inv " + item.itemid + " " + item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## OnServerRestart(string,int)

```csharp
```csharp
/// <summary>
/// Called when the server is about to restart.
/// </summary>
/// <param name="notice">A message to display to clients before restarting.</param>
/// <param name="seconds">The number of seconds to wait before restarting.</param>
/// <returns>
/// Returns `null` to allow the server to restart normally, or any non-null value to interrupt the restart.
/// </returns>
object OnServerRestart(string notice, int seconds)
{
    Puts($"Server is about to restart in {seconds} seconds. Notice: {notice}");
    if (seconds < 10)
    {
        Puts("Server restart interrupted due to short delay.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (SingletonComponent<ServerMgr>.Instance == null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
			SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", strNotice, iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

```

## OnPhoneAnswer(PhoneController,PhoneController)

```csharp
```csharp
/// <summary>
/// Called when a phone call is answered.
/// </summary>
/// <param name="caller">The PhoneController of the caller.</param>
/// <param name="callee">The PhoneController of the callee.</param>
/// <returns>
/// Returns `null` to allow the call to be answered, or any non-null value to prevent the call from being answered.
/// </returns>
object OnPhoneAnswer(PhoneController caller, PhoneController callee)
{
    Puts($"Phone call from {caller.GetPlayer().displayName} has been answered.");
    if (callee.GetPlayer().IsAdmin)
    {
        Puts($"Phone call from {caller.GetPlayer().displayName} to admin {callee.GetPlayer().displayName} has been blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (IsInvoking(TimeOutDialing))
		{
			CancelInvoke(TimeOutDialing);
		}
		if (!(activeCallTo == null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", this, activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", this, activeCallTo);
			}
		}
	}

```

## OnOvenTemperature(BaseOven,int)

```csharp
```csharp
/// <summary>
/// Called when the temperature of an oven is requested.
/// </summary>
/// <param name="oven">The oven whose temperature is being requested.</param>
/// <param name="slot">The slot number of the oven (e.g. 0 for the primary oven).</param>
/// <returns>
/// Returns a float representing the current temperature of the oven, or null if no override is provided.
/// If an override is provided and it's not a float, returns that value instead.
/// </returns>
float OnOvenTemperature(BaseOven oven, int slot)
{
    Puts($"Oven {oven.GetSlotName(slot)} temperature requested.");
    // If the return value (obj) is used to determine the correct return type
    if (slot == 0 && oven.IsOnHighHeat())
    {
        return 500f;
    }
    else if (slot == 1)
    {
        return 300f;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public float GetTemperature(int slot)
	{
		object obj = Interface.CallHook("OnOvenTemperature", this, slot);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!HasFlag(Flags.On))
		{
			return 15f;
		}
		return cookingTemperature;
	}

```

## CanHelicopterTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can target a player.
/// </summary>
/// <param name="helicopter">The helicopter attempting to target the player.</param>
/// <param name="player">The player being targeted.</param>
/// <returns>
/// Returns `true` if the helicopter can target the player, and `false` otherwise.
/// If this method is not implemented or returns a non-boolean value, the default behavior will be used.
/// </returns>
bool CanHelicopterTarget(PatrolHelicopterAI helicopter, BasePlayer player)
{
    Puts($"Helicopter attempting to target player {player.UserIDString}.");
    if (helicopter.IsDestroyed || player.IsDead)
    {
        return false;
    }
    // Additional logic can be added here to determine if the helicopter can target the player
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerVisible(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		Vector3 position = ply.eyes.position;
		if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
		{
			return false;
		}
		Vector3 vector = base.transform.position - Vector3.up * 6f;
		float num = Vector3.Distance(position, vector);
		Vector3 normalized = (position - vector).normalized;
		if (GamePhysics.Trace(new Ray(vector + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417) && GameObjectEx.ToBaseEntity(hitInfo.collider.gameObject) == ply)
		{
			return true;
		}
		return false;
	}

```

## OnPlayerHealthChange(BasePlayer,float,float)

```csharp
```csharp
/// <summary>
/// Called when a player's health changes.
/// </summary>
/// <param name="player">The player whose health has changed.</param>
/// <param name="oldHealth">The player's old health value.</param>
/// <param name="newHealth">The player's new health value.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or any non-null value to override it.
/// If a string is returned, it will be logged as a message.
/// </returns>
object OnPlayerHealthChange(BasePlayer player, float oldHealth, float newHealth)
{
    Puts($"Player {player.UserIDString}'s health changed from {oldHealth} to {newHealth}");
    if (newHealth <= 0)
    {
        Puts($"Player {player.displayName} has died!");
        return "Player died.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (Interface.CallHook("OnPlayerHealthChange", this, oldvalue, newvalue) != null)
		{
			return;
		}
		base.OnHealthChanged(oldvalue, newvalue);
		if (base.isServer)
		{
			if (oldvalue > newvalue)
			{
				LifeStoryHurt(oldvalue - newvalue);
			}
			else
			{
				LifeStoryHeal(newvalue - oldvalue);
			}
			metabolism.isDirty = true;
		}
	}

```

## OnDemoRecordingStart(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording starts.
/// </summary>
/// <param name="demoPath">The path where the demo will be saved.</param>
/// <param name="player">The player who started the demo recording.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the demo recording starts as normal.
/// </returns>
object OnDemoRecordingStart(string demoPath, BasePlayer player)
{
    Puts($"Demo recording started by {player.UserIDString} at path: {demoPath}");
    if (demoPath == "/home/user/demos")
    {
        Puts($"Demo recording at path {demoPath} has been blocked.");
        return "Blocked: Demo recording not allowed in this directory.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnItemSubmit(Item,Mailbox,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is submitted.
/// </summary>
/// <param name="item">The item being submitted.</param>
/// <param name="mailbox">The mailbox that received the item.</param>
/// <param name="player">The player who submitted the item, or null if not applicable.</param>
/// <returns>
/// Returns `null` to allow the item to be submitted as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the item from being submitted.
/// </returns>
object OnItemSubmit(Item item, Mailbox mailbox, BasePlayer player)
{
    Puts($"Item {item.name} has been submitted to mailbox {mailbox.name} by player {player?.displayName}.");
    if (item.name == "restricted_item")
    {
        Puts($"Item {item.name} is restricted and cannot be submitted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SubmitInputItems(BasePlayer fromPlayer)
	{
		Item slot = base.inventory.GetSlot(mailInputSlot);
		if (IsFull() || slot == null || Interface.CallHook("OnItemSubmit", slot, this, fromPlayer) != null)
		{
			return;
		}
		if (MoveItemToStorage(slot))
		{
			if (slot.position != mailInputSlot)
			{
				Effect.server.Run(mailDropSound.resourcePath, GetDropPosition());
				if (fromPlayer != null && !PlayerIsOwner(fromPlayer))
				{
					SetFlag(Flags.On, b: true);
				}
			}
		}
		else
		{
			slot.Drop(GetDropPosition(), GetDropVelocity());
		}
	}

```

## OnStructureRepair(BaseCombatEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to repair the structure.
/// </summary>
/// <param name="player">The player attempting to repair.</param>
/// <returns>
/// Returns `null` to allow the repair, or any non-null value to prevent the repair.
/// If a string is returned, the player will be notified with the provided message as the reason for not being able to repair.
/// </returns>
object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
{
    Puts($"Player {player.Name} has attempted to repair structure {entity.EntityId}.");
    if (entity.Health >= entity.MaxHealth())
    {
        Puts("Structure is already fully repaired.");
        return "Already fully repaired.";
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", this, player) != null)
		{
			return;
		}
		float num = 30f;
		if (SecondsSinceAttacked <= num)
		{
			OnRepairFailed(player2, $"Unable to repair: Recently damaged. Repairable in: {num - SecondsSinceAttacked:N0}s.");
			return;
		}
		float num2 = MaxHealth() - Health();
		float num3 = num2 / MaxHealth();
		if (num2 <= 0f || num3 <= 0f)
		{
			OnRepairFailed(player2, "Unable to repair: Not damaged.");
			return;
		}
		List<ItemAmount> list = RepairCost(num3);
		if (list == null)
		{
			return;
		}
		float num4 = list.Sum((ItemAmount x) => x.amount);
		float healthBefore = health;
		if (num4 > 0f)
		{
			float num5 = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			if (float.IsNaN(num5))
			{
				num5 = 0f;
			}
			num5 = Mathf.Min(num5, 50f / num2);
			if (num5 <= 0f)
			{
				OnRepairFailedResources(player2, list);
				return;
			}
			int num6 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(num5 * item.amount);
				int num7 = player2.inventory.Take(null, item.itemid, amount);
				Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "repair_entity", item.itemDef.shortname, num7, this, null, safezone: false, null, player2.userID);
				if (num7 > 0)
				{
					num6 += num7;
					player2.Command("note.inv", item.itemid, num7 * -1);
				}
			}
			float num8 = (float)num6 / num4;
			health += num2 * num8;
			SendNetworkUpdate();
		}
		else
		{
			health += num2;
			SendNetworkUpdate();
		}
		Facepunch.Rust.Analytics.Azure.OnEntityRepaired(player2, this, healthBefore, health);
		if (Health() >= MaxHealth())
		{
			OnRepairFinished();
		}
		else
		{
			OnRepair();
		}
	}

```

## CanHelicopterStrafeTarget(PatrolHelicopterAI,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be targeted for helicopter strafing.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <param name="target">The BasePlayer instance to check.</param>
/// <returns>
/// Returns `true` if the target can be strafed, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanHelicopterStrafeTarget(PatrolHelicopterAI ai, BasePlayer target)
{
    Puts($"Checking if player {target.UserIDString} can be targeted for helicopter strafing...");
    if (target.IsAdmin())
    {
        Puts("Player is an admin, cannot be targeted.");
        return true;
    }
    // Additional checks or logic can go here...
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool ValidStrafeTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", this, ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return !ply.IsNearEnemyBase();
	}

```

## OnStashExposed(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a stash is exposed to a player.
/// </summary>
/// <param name="stash">The stash container that was exposed.</param>
/// <param name="player">The player who can see the stash.</param>
/// <returns>No return behavior.</returns>
void OnStashExposed(StashContainer stash, BasePlayer player)
{
    Puts($"Stash {stash.GetID()} has been exposed to player {player.UserIDString}.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and can see the stash.");
    }
    else
    {
        Puts($"Player {player.displayName} is not an admin, but can still see the stash.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_WantsUnhide(RPCMessage rpc)
	{
		if (IsHidden())
		{
			BasePlayer player = rpc.player;
			if (PlayerInRange(player) && Interface.CallHook("CanSeeStash", player, this) == null)
			{
				Facepunch.Rust.Analytics.Azure.OnStashRevealed(rpc.player, this);
				SetHidden(isHidden: false);
				Interface.CallHook("OnStashExposed", this, player);
			}
		}
	}

```

## CanLootEntity(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from doing so.
/// </returns>
object CanLootEntity(BasePlayer player, Entity entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.name}");
    if (entity.ownerID == player.userID)
    {
        Puts($"Player {player.displayName} owns the entity and can loot it");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} does not own the entity and cannot loot it");
        return "You do not have permission to loot this entity";
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (IsLocked())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, LockedMessage);
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ShowToast(GameTip.Styles.Red_Normal, InUseMessage);
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = panelName;
		}
		if (!CanOpenLootPanel(player, panelToOpen))
		{
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			AddContainers(player.inventory.loot);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", panelToOpen);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnPhoneDialTimeout(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing timeout occurs.
/// </summary>
/// <param name="phoneController">The phone controller that timed out.</param>
/// <param name="caller">The caller who initiated the call.</param>
/// <param name="currentPlayer">The player who is currently using the phone.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialTimeout(PhoneController phoneController, PhoneController caller, BasePlayer currentPlayer)
{
    Puts($"Phone dialing timeout occurred for {caller.displayName} with caller ID {caller.callerId}");
    if (currentPlayer != null && currentPlayer.UserIDString == "admin")
    {
        Puts($"Admin {currentPlayer.displayName} has been notified of the phone dialing timeout.");
        // Notify admin via chat or other means
    }
}
```
```

### Source Code from the Library

```csharp

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", activeCallTo, this, activeCallTo.currentPlayer) == null)
		{
			if (activeCallTo != null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", activeCallTo, this, activeCallTo.currentPlayer);
		}
	}

```

## CanRecycle(Recycler,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be recycled.
/// </summary>
/// <param name="recycler">The recycler checking the item.</param>
/// <param name="item">The item being checked for recyclability.</param>
/// <returns>
/// Returns `true` if the item can be recycled, or `false` otherwise.
/// If a non-null value is returned, it will override the default recyclability behavior.
/// </returns>
object CanRecycle(Recycler recycler, Item item)
{
    Puts($"Checking if {item.info.Blueprint.name} can be recycled by {recycler.UserIDString}");
    if (item.info.Blueprint == null || item.info.Blueprint.category != "Materials")
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool HasRecyclable()
	{
		for (int i = 0; i < 6; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				object obj = Interface.CallHook("CanRecycle", this, slot);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (slot.info.Blueprint != null)
				{
					return true;
				}
			}
		}
		return false;
	}

```

## OnCCTVDirectionChange(CCTV_RC,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the direction of a CCTV camera is changed.
/// </summary>
/// <param name="camera">The CCTV camera whose direction was changed.</param>
/// <param name="player">The player who made the change.</param>
/// <returns>
/// Returns `null` to allow the direction change, or any non-null value to prevent it.
/// </returns>
object OnCCTVDirectionChange(BaseMountable camera, BasePlayer player)
{
    Puts($"Camera {camera.name} direction changed by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and can change the camera direction.");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} does not have permission to change the camera direction.");
        return true;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void Server_SetDir(RPCMessage msg)
	{
		if (!IsStatic())
		{
			BasePlayer player = msg.player;
			if (player.CanBuild() && player.IsBuildingAuthed() && Interface.CallHook("OnCCTVDirectionChange", this, player) == null)
			{
				Vector3 direction = Vector3Ex.Direction(player.eyes.position, yaw.transform.position);
				direction = base.transform.InverseTransformDirection(direction);
				Vector3 vector = BaseMountable.ConvertVector(Quaternion.LookRotation(direction).eulerAngles);
				pitchAmount = Mathf.Clamp(vector.x, pitchClamp.x, pitchClamp.y);
				yawAmount = Mathf.Clamp(vector.y, yawClamp.x, yawClamp.y);
				SendNetworkUpdate();
			}
		}
	}

```

## OnWaterCollect(WaterCatcher)

```csharp
```csharp
/// <summary>
/// Called when water is collected by a WaterCatcher.
/// </summary>
/// <param name="waterCatcher">The WaterCatcher that collected the water.</param>
/// <returns>
/// Returns `null` to allow the water collection, or any non-null value to prevent it.
/// If a string is returned, an error message will be displayed instead of collecting water.
/// </returns>
object OnWaterCollect(WaterCatcher waterCatcher)
{
    Puts($"Water collected by {waterCatcher.name}.");
    if (waterCatcher.isDamaged)
    {
        Puts($"Error: WaterCatcher {waterCatcher.name} is damaged and cannot collect water.");
        return "Error: Damaged WaterCatcher.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CollectWater()
	{
		if (!IsFull() && Interface.CallHook("OnWaterCollect", this) == null)
		{
			float num = 0.25f;
			num += Climate.GetFog(base.transform.position) * 2f;
			if (TestIsOutside())
			{
				num += Climate.GetRain(base.transform.position);
				num += Climate.GetSnow(base.transform.position) * 0.5f;
			}
			AddResource(Mathf.CeilToInt(maxItemToCreate * num));
		}
	}

```

## OnTeamPromote(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a team leader promotes another player to their position.
/// </summary>
/// <param name="team">The team being promoted.</param>
/// <param name="player">The player being promoted.</param>
/// <returns>
/// Returns `null` to allow the promotion, or any non-null value to prevent the promotion.
/// </returns>
object OnTeamPromote(PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been promoted to team leader of {team.teamName}");
    if (team.teamName == "Admins")
    {
        Puts($"Cannot promote player to Admins team");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void promote(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L)
		{
			return;
		}
		BasePlayer lookingAtPlayer = GetLookingAtPlayer(basePlayer);
		if (!(lookingAtPlayer == null) && !lookingAtPlayer.IsDead() && !(lookingAtPlayer == basePlayer) && lookingAtPlayer.currentTeam == basePlayer.currentTeam)
		{
			PlayerTeam playerTeam = ServerInstance.teams[basePlayer.currentTeam];
			if (playerTeam != null && playerTeam.teamLeader == basePlayer.userID && Interface.CallHook("OnTeamPromote", playerTeam, lookingAtPlayer) == null)
			{
				playerTeam.SetTeamLeader(lookingAtPlayer.userID);
			}
		}
	}

```

## OnMapMarkersClear(BasePlayer,System.Collections.Generic.List<ProtoBuf.MapNote>)

```csharp
```csharp
/// <summary>
/// Called when map markers are cleared.
/// </summary>
/// <param name="player">The player who initiated the clear.</param>
/// <param name="markers">A list of map notes to be cleared.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkersClear(BasePlayer player, List<ProtoBuf.MapNote> markers)
{
    Puts($"Map markers cleared for player {player.UserIDString} with {markers.Count} markers.");
    if (markers != null && markers.Count > 0)
    {
        foreach (var marker in markers)
        {
            Puts($"Marker {marker.id} cleared.");
        }
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, State.pointsOfInterest) != null)
		{
			return;
		}
		ServerCurrentDeathNote?.Dispose();
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				item?.Dispose();
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", this);
	}

```

## OnFuelCheck(EntityFuelSystem)

```csharp
```csharp
/// <summary>
/// Called when the fuel level of an entity is checked.
/// </summary>
/// <param name="fuelSystem">The fuel system being checked.</param>
/// <returns>
/// Returns `true` if the fuel system has sufficient fuel, or any non-null value to override the default behavior. 
/// If a string is returned, it will be used as a message for the player.
/// </returns>
object OnFuelCheck(EntityFuelSystem fuelSystem)
{
    Puts($"Checking fuel level of {fuelSystem.entity.name}...");
    if (fuelSystem.fuelLevel < 0.1f)
    {
        return "Low Fuel: Refuel required.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool HasFuel(bool forceCheck = false)
	{
		if (Time.time > nextFuelCheckTime || forceCheck)
		{
			object obj = Interface.CallHook("OnFuelCheck", this);
			if (obj is bool)
			{
				return (bool)obj;
			}
			cachedHasFuel = (float)GetFuelAmount() > 0f;
			nextFuelCheckTime = Time.time + UnityEngine.Random.Range(1f, 2f);
		}
		return cachedHasFuel;
	}

```

## OnMagazineReload(BaseProjectile,int,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a magazine is reloaded.
/// </summary>
/// <param name="projectile">The projectile whose magazine is being reloaded.</param>
/// <param name="desiredAmount">The desired amount of ammunition to reload. If -1, the magazine will be fully reloaded.</param>
/// <param name="ownerPlayer">The player who owns the projectile.</param>
/// <returns>
/// Returns `null` to allow the magazine to be reloaded normally.
/// If a non-null value is returned, it will override the default reload behavior.
/// </returns>
object OnMagazineReload(BaseProjectile projectile, int desiredAmount, BasePlayer ownerPlayer)
{
    Puts($"Magazine for {projectile.GetDisplayName()} has been reloaded by player {ownerPlayer.displayName}.");
    if (desiredAmount > 10)
    {
        Puts($"Player {ownerPlayer.displayName} is trying to reload too much ammo. Stopping reload.");
        return "Too much ammo";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void ReloadMagazine(int desiredAmount = -1)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((bool)ownerPlayer && Interface.CallHook("OnMagazineReload", this, desiredAmount, ownerPlayer) == null)
		{
			primaryMagazine.Reload(ownerPlayer, desiredAmount);
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnSamSiteTargetScan(SamSite,System.Collections.Generic.List<SamSite.ISamSiteTarget>)

```csharp
```csharp
/// <summary>
/// Called when a Sam Site target is scanned.
/// </summary>
/// <param name="samSite">The Sam Site that performed the scan.</param>
/// <param name="targets">A list of potential targets found by the scan.</param>
/// <returns>
/// Returns `null` to allow the default behavior. If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnSamSiteTargetScan(SamSite samSite, List<SamSite.ISamSiteTarget> targets)
{
    Puts($"Sam Site {samSite} has scanned for targets.");
    if (targets.Count == 0)
    {
        Puts("No targets found by Sam Site.");
        return null;
    }
    
    // You can add custom logic here to filter or modify the targets list
    // For example, you could remove any targets that are too far away or not visible
    
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (UnityEngine.Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> obj = Facepunch.Pool.GetList<ISamSiteTarget>();
		if (Interface.CallHook("OnSamSiteTargetScan", this, obj) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(obj, 32768, targetTypeVehicle.scanRadius);
			}
			AddTargetSet(obj, 1048576, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in obj)
		{
			if (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!ObjectEx.IsUnityNull(samSiteTarget) && currentTarget != samSiteTarget)
		{
			lockOnTime = UnityEngine.Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!ObjectEx.IsUnityNull(currentTarget))
		{
			lastTargetVisibleTime = UnityEngine.Time.time;
		}
		Facepunch.Pool.FreeList(ref obj);
		if (ObjectEx.IsUnityNull(currentTarget))
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
		void AddTargetSet(List<ISamSiteTarget> allTargets, int layerMask, float scanRadius)
		{
			List<ISamSiteTarget> obj2 = Facepunch.Pool.GetList<ISamSiteTarget>();
			Vis.Entities(eyePoint.transform.position, scanRadius, obj2, layerMask, QueryTriggerInteraction.Ignore);
			allTargets.AddRange(obj2);
			Facepunch.Pool.FreeList(ref obj2);
		}
	}

```

## OnBookmarkInput(ComputerStation,BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player inputs data into a bookmark.
/// </summary>
/// <param name="computerStation">The computer station where the input is being made.</param>
/// <param name="player">The player making the input.</param>
/// <param name="inputState">The state of the input being made.</param>
/// <returns>
/// Returns `null` to allow the bookmark input, or any non-null value to prevent it.
/// </returns>
object OnBookmarkInput(ComputerStation computerStation, BasePlayer player, InputState inputState)
{
    Puts($"Player {player.UserIDString} is making an input into the bookmark on computer station {computerStation.name}");
    if (inputState == InputState.Cancel)
    {
        Puts($"Player {player.displayName} has cancelled their input into the bookmark.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (HasFlag(Flags.Reserved2) && currentlyControllingEnt.IsValid(serverside: true) && Interface.CallHook("OnBookmarkInput", this, player, inputState) == null)
		{
			currentlyControllingEnt.Get(serverside: true).GetComponent<IRemoteControllable>().UserInput(inputState, new CameraViewerId(player.userID, 0L));
		}
	}

```

## OnItemSkinChange(int,Item,RepairBench,BasePlayer)

```csharp
Here is the method structure for `OnItemSkinChange`:

```csharp
/// <summary>
/// Called when an item's skin is changed.
/// </summary>
/// <param name="itemIndex">The index of the item being skinned.</param>
/// <param name="skinId">The ID of the new skin to apply.</param>
/// <param name="repairBench">The repair bench that initiated the skin change.</param>
/// <param name="player">The player who initiated the skin change.</param>
/// <returns>True if the skin was successfully applied, false otherwise.</returns>
public bool OnItemSkinChange(int itemIndex, ulong skinId, RepairBench repairBench, Player player)
{
    // Implementation of the method goes here
}
```

Note that this is just a skeleton structure and you will need to fill in the implementation details based on your specific requirements.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void ChangeSkin(RPCMessage msg)
	{
		if (UnityEngine.Time.realtimeSinceStartup < nextSkinChangeTime)
		{
			return;
		}
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		Item slot = base.inventory.GetSlot(0);
		if (slot == null || Interface.CallHook("OnItemSkinChange", num, slot, this, msg.player) != null)
		{
			return;
		}
		bool flag = false;
		if (msg.player.UnlockAllSkins)
		{
			flag = true;
		}
		if (num != 0 && !flag && !player.blueprints.CheckSkinOwnership(num, player.userID))
		{
			debugprint("RepairBench.ChangeSkin player does not have item :" + num + ":");
			return;
		}
		ulong Skin = ItemDefinition.FindSkin(slot.info.itemid, num);
		if (Skin == slot.skin && slot.info.isRedirectOf == null)
		{
			debugprint("RepairBench.ChangeSkin cannot apply same skin twice : " + Skin + ": " + slot.skin);
			return;
		}
		nextSkinChangeTime = UnityEngine.Time.realtimeSinceStartup + 0.75f;
		ItemSkinDirectory.Skin skin = slot.info.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		if (slot.info.isRedirectOf != null)
		{
			Skin = ItemDefinition.FindSkin(slot.info.isRedirectOf.itemid, num);
			skin = slot.info.isRedirectOf.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == Skin);
		}
		ItemSkin itemSkin = ((skin.id == 0) ? null : (skin.invItem as ItemSkin));
		if (((bool)itemSkin && (itemSkin.Redirect != null || slot.info.isRedirectOf != null)) || (!itemSkin && slot.info.isRedirectOf != null))
		{
			ItemDefinition template = ((itemSkin != null) ? itemSkin.Redirect : slot.info.isRedirectOf);
			bool flag2 = false;
			if (itemSkin != null && itemSkin.Redirect == null && slot.info.isRedirectOf != null)
			{
				template = slot.info.isRedirectOf;
				flag2 = num != 0;
			}
			float condition = slot.condition;
			float maxCondition = slot.maxCondition;
			int amount = slot.amount;
			int contents = 0;
			ItemDefinition ammoType = null;
			if (slot.GetHeldEntity() != null && slot.GetHeldEntity() is BaseProjectile { primaryMagazine: not null } baseProjectile)
			{
				contents = baseProjectile.primaryMagazine.contents;
				ammoType = baseProjectile.primaryMagazine.ammoType;
			}
			List<Item> obj = Facepunch.Pool.GetList<Item>();
			if (slot.contents != null && slot.contents.itemList != null && slot.contents.itemList.Count > 0)
			{
				foreach (Item item2 in slot.contents.itemList)
				{
					obj.Add(item2);
				}
				foreach (Item item3 in obj)
				{
					item3.RemoveFromContainer();
				}
			}
			slot.Remove();
			ItemManager.DoRemoves();
			Item item = ItemManager.Create(template, 1, 0uL);
			item.MoveToContainer(base.inventory, 0, allowStack: false);
			item.maxCondition = maxCondition;
			item.condition = condition;
			item.amount = amount;
			if (item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile baseProjectile2)
			{
				if (baseProjectile2.primaryMagazine != null)
				{
					baseProjectile2.primaryMagazine.contents = contents;
					baseProjectile2.primaryMagazine.ammoType = ammoType;
				}
				baseProjectile2.ForceModsChanged();
			}
			if (obj.Count > 0 && item.contents != null)
			{
				foreach (Item item4 in obj)
				{
					item4.MoveToContainer(item.contents);
				}
			}
			Facepunch.Pool.FreeList(ref obj);
			if (flag2)
			{
				ApplySkinToItem(item, Skin);
			}
			Facepunch.Rust.Analytics.Server.SkinUsed(item.info.shortname, num);
			Facepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, item, Skin);
		}
		else
		{
			ApplySkinToItem(slot, Skin);
			Facepunch.Rust.Analytics.Server.SkinUsed(slot.info.shortname, num);
			Facepunch.Rust.Analytics.Azure.OnSkinChanged(player, this, slot, Skin);
		}
		if (skinchangeEffect.isValid)
		{
			Effect.server.Run(skinchangeEffect.resourcePath, this, 0u, new Vector3(0f, 1.5f, 0f), Vector3.zero);
		}
	}

```

## OnSupplyDropDropped(BaseEntity,CargoPlane)

```csharp
```csharp
/// <summary>
/// Called when a supply drop is dropped.
/// </summary>
/// <param name="drop">The BaseEntity representing the dropped supply.</param>
/// <param name="plane">The CargoPlane that dropped the supply.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropDropped(BaseEntity drop, CargoPlane plane)
{
    Puts($"Supply drop {drop.UserIDString} has been dropped by cargo plane {plane.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	private void Update()
	{
		if (!base.isServer)
		{
			return;
		}
		secondsTaken += Time.deltaTime;
		float num = Mathf.InverseLerp(0f, secondsToTake, secondsTaken);
		if (!dropped && num >= 0.5f)
		{
			dropped = true;
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabDrop.resourcePath, base.transform.position);
			if ((bool)baseEntity)
			{
				baseEntity.globalBroadcast = true;
				baseEntity.Spawn();
				Interface.CallHook("OnSupplyDropDropped", baseEntity, this);
			}
		}
		base.transform.position = Vector3.Lerp(startPos, endPos, num);
		base.transform.hasChanged = true;
		if (num >= 1f)
		{
			Kill();
		}
	}

```

## OnLootSpawn(LootContainer)

```csharp
```csharp
/// <summary>
/// Called when loot is spawned.
/// </summary>
/// <param name="lootContainer">The LootContainer that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnLootSpawn(LootContainer lootContainer)
{
    Puts($"Loot has been spawned in {lootContainer.GetPosition()}");
    if (lootContainer.GetItemType() == "Rare")
    {
        Puts("Rare item spawned!");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				Invoke(SpawnLoot, UnityEngine.Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

```

## CanUseFuel(EntityFuelSystem,StorageContainer,float,float)

```csharp
```csharp
/// <summary>
/// Called to determine if fuel can be used from a container.
/// </summary>
/// <param name="fuelSystem">The fuel system entity.</param>
/// <param name="container">The storage container containing the fuel.</param>
/// <param name="seconds">The number of seconds to use fuel for.</param>
/// <param name="fuelUsedPerSecond">The amount of fuel used per second.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the fuel can be used as normal.
/// If an integer is returned, it represents the maximum amount of fuel that can be used in the given time period.
/// </returns>
object CanUseFuel(EntityFuelSystem fuelSystem, StorageContainer container, float seconds, float fuelUsedPerSecond)
{
    Puts($"Checking if fuel can be used from container {container?.GetParentEntity()?.name} for {seconds} seconds.");
    // Example: If the container is empty or has less than 1 unit of fuel, return null to prevent fuel usage.
    if (container == null || container.inventory.GetSlot(0) == null || container.inventory.GetSlot(0).amount < 1)
    {
        Puts($"Container {container?.GetParentEntity()?.name} is empty or has insufficient fuel.");
        return null;
    }
    // Example: If the fuel system is damaged, return a negative value to prevent fuel usage.
    if (fuelSystem.health <= 0)
    {
        Puts($"Fuel system {fuelSystem.name} is damaged and cannot use fuel.");
        return -1;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanUseFuel", this, fuelContainer, seconds, fuelUsedPerSecond);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelContainer == null)
		{
			return 0;
		}
		Item slot = fuelContainer.inventory.GetSlot(0);
		if (slot == null || slot.amount < 1)
		{
			return 0;
		}
		pendingFuel += seconds * fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			int num = Mathf.FloorToInt(pendingFuel);
			slot.UseItem(num);
			Facepunch.Rust.Analytics.Azure.AddPendingItems(fuelContainer?.GetParentEntity() ?? fuelContainer, slot.info.shortname, num, "fuel_system");
			pendingFuel -= num;
			return num;
		}
		return 0;
	}

```

## OnPlayerAssist(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player assists another wounded player.
/// </summary>
/// <param name="assister">The player doing the assisting.</param>
/// <param name="assistee">The player being assisted.</param>
/// <returns>
/// Returns `null` to allow the assist, or any non-null value to prevent the assist.
/// </returns>
object OnPlayerAssist(BasePlayer assister, BasePlayer assistee)
{
    Puts($"Player {assister.UserIDString} is assisting wounded player {assistee.UserIDString}");
    if (assistee.IsAdmin())
    {
        Puts($"Player {assistee.displayName} is an admin and cannot be assisted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Assist(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerAssist", this, msg.player) == null)
		{
			StopWounded(msg.player);
			msg.player.stats.Add("wounded_assisted", 1, (Stats)5);
			stats.Add("wounded_healed", 1);
		}
	}

```

## IOnServerInitialized()

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
void IOnServerInitialized()
{
    Puts("Server initialization complete.");
    // Perform any necessary setup or configuration here
}
```
```

### Source Code from the Library

```csharp

	public void OpenConnection()
	{
		if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
		{
			ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
		}
		Network.Net.sv.ip = ConVar.Server.ip;
		Network.Net.sv.port = ConVar.Server.port;
		StartSteamServer();
		if (!Network.Net.sv.Start())
		{
			Debug.LogWarning("Couldn't Start Server.");
			CloseConnection();
			return;
		}
		Network.Net.sv.callbackHandler = this;
		Network.Net.sv.cryptography = new NetworkCryptographyServer();
		EACServer.DoStartup();
		InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
		Interface.CallHook("IOnServerInitialized");
	}

```

## OnDecayDamage(DecayEntity)

```csharp
```csharp
/// <summary>
/// Called when a decay entity is damaged.
/// </summary>
/// <param name="decayEntity">The decay entity being damaged.</param>
/// <returns>
/// Returns `null` to allow the decay damage to occur, or any non-null value to prevent it.
/// If a string is returned, the decay damage will be cancelled with the provided message as the reason.
/// </returns>
object OnDecayDamage(DecayEntity decayEntity)
{
    Puts($"Decay entity {decayEntity} has been damaged.");
    if (decayEntity == "Critical Infrastructure")
    {
        Puts($"Decay entity {decayEntity} has been protected from damage.");
        return "Protected: Critical infrastructure.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DecayTick()
	{
		if (decay == null)
		{
			return;
		}
		float num = UnityEngine.Time.time - lastDecayTick;
		if (num < ConVar.Decay.tick)
		{
			return;
		}
		lastDecayTick = UnityEngine.Time.time;
		if (!decay.ShouldDecay(this))
		{
			return;
		}
		float num2 = num * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num2;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if (buildingPrivilege != null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && ConVar.Decay.upkeep_heal_scale > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", this) == null)
				{
					float num3 = num / decay.GetDecayDuration(this) * ConVar.Decay.upkeep_heal_scale;
					Heal(MaxHealth() * num3);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num2;
		if (decayTimer < decay.GetDecayDelay(this))
		{
			return;
		}
		using (TimeWarning.New("DecayTick"))
		{
			float num4 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num4 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num4 -= decayPoint.protection;
					}
				}
			}
			if (num4 > 0f && Interface.CallHook("OnDecayDamage", this) == null)
			{
				float num5 = num2 / decay.GetDecayDuration(this) * MaxHealth();
				Hurt(num5 * num4 * decayVariance, DamageType.Decay);
			}
		}
	}

```

## OnActiveItemChange(BasePlayer,Item,ItemId)

```csharp
```csharp
/// <summary>
/// Called when the active item of a player changes.
/// </summary>
/// <param name="player">The player whose active item has changed.</param>
/// <param name="oldItem">The old active item.</param>
/// <param name="newItemId">The ID of the new active item.</param>
/// <returns>
/// Returns `null` to allow the default behavior. If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnActiveItemChange(BasePlayer player, Item oldItem, ItemId newItemId)
{
    Puts($"Player {player.displayName}'s active item has changed from {oldItem.info.name} to {newItemId}.");
    // Example: If a specific item is equipped, prevent the player from equipping another item.
    if (newItemId == "item_example" && oldItem != null)
    {
        return "Cannot equip another item while holding this one.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(ItemId itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnOvenStarted(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when an oven is started.
/// </summary>
/// <param name="oven">The oven that was started.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the oven will continue to cook as normal.
/// </returns>
object OnOvenStarted(BaseOven oven)
{
    Puts($"Oven {oven.GetDisplayName()} has been started.");
    if (oven.GetFuelLevel() < 0.5f)
    {
        Puts($"Oven {oven.GetDisplayName()} is running low on fuel.");
        return "Low Fuel: Please refuel the oven.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			InvokeRepeating(Cook, 0.5f, 0.5f);
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", this);
		}
	}

```

## OnSupplyDropLanded(SupplyDrop)

```csharp
```csharp
/// <summary>
/// Called when a supply drop lands.
/// </summary>
/// <param name="supplyDrop">The SupplyDrop object that landed.</param>
/// <returns>No return behavior.</returns>
void OnSupplyDropLanded(SupplyDrop supplyDrop)
{
    Puts($"Supply drop landed at location {supplyDrop.transform.position}");
    
    // Minimal code to demonstrate functionality
    Debug.Log("Supply drop landed!");
}
```
```

### Source Code from the Library

```csharp

	private void OnCollisionEnter(Collision collision)
	{
		if (((1 << collision.collider.gameObject.layer) & 0x40A10111) > 0)
		{
			RemoveParachute();
			MakeLootable();
		}
		Interface.CallHook("OnSupplyDropLanded", this);
	}

```

## OnOvenCooked(BaseOven,Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an oven has finished cooking an item.
/// </summary>
/// <param name="oven">The oven that cooked the item.</param>
/// <param name="item">The item that was cooked.</param>
/// <param name="slot">The slot where the item was being cooked.</param>
/// <returns>
/// Returns a non-null value to override the default cooking behavior. 
/// If `null` is returned, the item is considered cooked as normal.
/// </returns>
object OnOvenCooked(BaseOven oven, Item item, BaseEntity slot)
{
    Puts($"Item {item.info.name} has been cooked by oven {oven.name}.");
    if (item.info.category == "Food" && item.fuel <= 0f)
    {
        Puts($"Item {item.info.name} is now fully cooked and ready to eat.");
        return null;
    }
    else
    {
        Puts($"Item {item.info.name} still needs more cooking time.");
        return "Not yet cooked";
    }
}
```
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		if (item != null)
		{
			ItemModBurnable component = item.info.GetComponent<ItemModBurnable>();
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, component);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnConstructionPlace(BaseEntity,Construction,Construction.Target,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a construction is placed.
/// </summary>
/// <param name="baseEntity">The entity being constructed.</param>
/// <param name="construction">The construction component.</param>
/// <param name="placement">The placement target.</param>
/// <param name="ownerPlayer">The player who placed the construction.</param>
/// <returns>
/// Returns `null` to allow the construction to be placed as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for the player who placed the construction.
/// </returns>
object OnConstructionPlace(BaseEntity baseEntity, Construction construction, Construction.Target placement, BasePlayer ownerPlayer)
{
    Puts($"Construction {baseEntity} has been placed by {ownerPlayer} at {placement}.");
    if (baseEntity is BuildingBlock buildingBlock && buildingBlock.blockDefinition == null)
    {
        Puts("Warning: Placing a building block that has no block definition!");
        return "Error: Block definition not found.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public GameObject DoPlacement(Construction.Target placement, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		BaseEntity baseEntity = component.CreateConstruction(placement, bNeedsValidPlacement: true);
		if (!baseEntity)
		{
			return null;
		}
		float num = 1f;
		float num2 = 0f;
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			baseEntity.skinID = ownerItem.skin;
			if (ownerItem.hasCondition)
			{
				num = ownerItem.conditionNormalized;
			}
		}
		PoolableEx.AwakeFromInstantiate(baseEntity.gameObject);
		BuildingBlock buildingBlock = baseEntity as BuildingBlock;
		if ((bool)buildingBlock)
		{
			buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
			if (!buildingBlock.blockDefinition)
			{
				Debug.LogError("Placing a building block that has no block definition!");
				return null;
			}
			buildingBlock.SetGrade(buildingBlock.blockDefinition.defaultGrade.gradeBase.type);
			num2 = buildingBlock.currentGrade.maxHealth;
		}
		BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
		if ((bool)baseCombatEntity)
		{
			num2 = ((buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth);
			baseCombatEntity.ResetLifeStateOnSpawn = false;
			baseCombatEntity.InitializeHealth(num2 * num, num2);
		}
		if (Interface.CallHook("OnConstructionPlace", baseEntity, component, placement, ownerPlayer) != null)
		{
			if (baseEntity.IsValid())
			{
				baseEntity.KillMessage();
			}
			else
			{
				GameManager.Destroy(baseEntity);
			}
			return null;
		}
		baseEntity.gameObject.SendMessage("SetDeployedBy", ownerPlayer, SendMessageOptions.DontRequireReceiver);
		baseEntity.OwnerID = ownerPlayer.userID;
		baseEntity.Spawn();
		if ((bool)buildingBlock)
		{
			Effect.server.Run("assets/bundled/prefabs/fx/build/frame_place.prefab", baseEntity, 0u, Vector3.zero, Vector3.zero);
		}
		StabilityEntity stabilityEntity = baseEntity as StabilityEntity;
		if ((bool)stabilityEntity)
		{
			stabilityEntity.UpdateSurroundingEntities();
		}
		return baseEntity.gameObject;
	}

```

## OnInventoryNetworkUpdate(PlayerInventory,ItemContainer,ProtoBuf.UpdateItemContainer,PlayerInventory.Type,bool)

```csharp
```csharp
/// <summary>
/// Called when an inventory network update is sent.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="container">The item container being updated.</param>
/// <param name="updateItemContainer">The ProtoBuf.UpdateItemContainer message containing the updated inventory data.</param>
/// <param name="type">The type of update (e.g. PlayerInventory.Type).</param>
/// <param name="bSendToEveryone">Whether to send the update to all players or just the player who owns the inventory.</param>
object OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updateItemContainer, PlayerInventory.Type type, bool bSendToEveryone)
{
    Puts($"Sending updated inventory for {inventory.UserIDString} with type {type} and container {container.GetCount()} items.");
    if (bSendToEveryone && inventory.UserID == "admin")
    {
        Puts($"Admin user {inventory.UserIDString} is being sent the full inventory update.");
        return null;
    }
    else
    {
        Puts($"Sending updated inventory for {inventory.UserIDString} with type {type} and container {container.GetCount()} items to self only.");
        return true;
    }
}
```
```

### Source Code from the Library

```csharp

	public void SendUpdatedInventory(Type type, ItemContainer container, bool bSendInventoryToEveryone = false)
	{
		using UpdateItemContainer updateItemContainer = Facepunch.Pool.Get<UpdateItemContainer>();
		updateItemContainer.type = (int)type;
		if (container != null)
		{
			container.dirty = false;
			updateItemContainer.container = Facepunch.Pool.Get<List<ProtoBuf.ItemContainer>>();
			updateItemContainer.container.Add(container.Save());
		}
		if (Interface.CallHook("OnInventoryNetworkUpdate", this, container, updateItemContainer, type, bSendInventoryToEveryone) == null)
		{
			if (bSendInventoryToEveryone)
			{
				base.baseEntity.ClientRPC(null, "UpdatedItemContainer", updateItemContainer);
			}
			else
			{
				base.baseEntity.ClientRPCPlayer(null, base.baseEntity, "UpdatedItemContainer", updateItemContainer);
			}
		}
	}

```

## OnGrowableStateChange(GrowableEntity,PlantProperties.State)

```csharp
```csharp
/// <summary>
/// Called when the state of a growable entity changes.
/// </summary>
/// <param name="entity">The growable entity whose state has changed.</param>
/// <param name="state">The new state of the growable entity.</param>
/// <returns>
/// Returns `null` to allow the state change, or any non-null value to prevent the state from changing.
/// </returns>
object OnGrowableStateChange(GrowableEntity entity, PlantProperties.State state)
{
    Puts($"Growable entity {entity.ID} has changed its state to {state}.");
    if (state == PlantProperties.State.Dead)
    {
        Puts($"Growable entity {entity.ID} has died.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChangeState(PlantProperties.State state, bool resetAge, bool loading = false)
	{
		if (Interface.CallHook("OnGrowableStateChange", this, state) != null || (base.isServer && State == state))
		{
			return;
		}
		State = state;
		if (!base.isServer)
		{
			return;
		}
		if (!loading)
		{
			if (currentStage.resources > 0f)
			{
				yieldPool = currentStage.yield;
			}
			if (state == PlantProperties.State.Crossbreed)
			{
				if (Properties.CrossBreedEffect.isValid)
				{
					Effect.server.Run(Properties.CrossBreedEffect.resourcePath, base.transform.position, Vector3.up);
				}
				GrowableGenetics.CrossBreed(this);
			}
			SendNetworkUpdate();
		}
		if (resetAge)
		{
			stageAge = 0f;
		}
	}

```

## OnLootEntityEnd(BasePlayer,ContainerIOEntity)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="entity">The entity that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ContainerIOEntity entity)
{
    Puts($"Player {player.UserIDString} stopped looting {entity.name}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## CanBeTargeted(BaseCombatEntity,HelicopterTurret)

```csharp
```csharp
/// <summary>
/// Called to determine if a target can be targeted by the helicopter turret.
/// </summary>
/// <param name="potentialTarget">The potential target entity.</param>
/// <param name="turret">The helicopter turret instance.</param>
/// <returns>
/// Returns `true` if the target can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBeTargeted(BaseCombatEntity potentialTarget, HelicopterTurret turret)
{
    Puts($"Checking if {potentialTarget.displayName} can be targeted by the helicopter turret.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", potentialtarget, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

```

## OnTeamUpdated(ulong,ProtoBuf.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a team is updated.
/// </summary>
/// <param name="currentTeam">The ID of the current team.</param>
/// <param name="playerTeam">Information about the player's team.</param>
/// <param name="basePlayer">The base player object.</param>
/// <returns>
/// Returns null to override the default behavior. 
/// If a non-null value is returned, it will be used as the new team information.
/// </returns>
object OnTeamUpdated(ulong currentTeam, ProtoBuf.PlayerTeam playerTeam, BasePlayer basePlayer)
{
    Puts($"Team {currentTeam} has been updated.");
    // Minimal code to demonstrate functionality
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void TeamUpdate(bool fullTeamUpdate)
	{
		if (!RelationshipManager.TeamsEnabled() || !IsConnected || currentTeam == 0L)
		{
			return;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(currentTeam);
		if (playerTeam == null)
		{
			return;
		}
		int num = 0;
		int num2 = 0;
		using PlayerTeam playerTeam2 = Facepunch.Pool.Get<PlayerTeam>();
		playerTeam2.teamLeader = playerTeam.teamLeader;
		playerTeam2.teamID = playerTeam.teamID;
		playerTeam2.teamName = playerTeam.teamName;
		playerTeam2.members = Facepunch.Pool.GetList<PlayerTeam.TeamMember>();
		playerTeam2.teamLifetime = playerTeam.teamLifetime;
		playerTeam2.teamPings = Facepunch.Pool.GetList<MapNote>();
		foreach (ulong member in playerTeam.members)
		{
			BasePlayer basePlayer = RelationshipManager.FindByID(member);
			PlayerTeam.TeamMember teamMember = Facepunch.Pool.Get<PlayerTeam.TeamMember>();
			teamMember.displayName = ((basePlayer != null) ? basePlayer.displayName : (SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member) ?? "DEAD"));
			teamMember.healthFraction = ((basePlayer != null && basePlayer.IsAlive()) ? basePlayer.healthFraction : 0f);
			teamMember.position = ((basePlayer != null) ? basePlayer.transform.position : Vector3.zero);
			teamMember.online = basePlayer != null && !basePlayer.IsSleeping();
			teamMember.wounded = basePlayer != null && basePlayer.IsWounded();
			if ((!sentInstrumentTeamAchievement || !sentSummerTeamAchievement) && basePlayer != null)
			{
				if ((bool)basePlayer.GetHeldEntity() && basePlayer.GetHeldEntity().IsInstrument())
				{
					num++;
				}
				if (basePlayer.isMounted)
				{
					if (basePlayer.GetMounted().IsInstrument())
					{
						num++;
					}
					if (basePlayer.GetMounted().IsSummerDlcVehicle)
					{
						num2++;
					}
				}
				if (num >= 4 && !sentInstrumentTeamAchievement)
				{
					GiveAchievement("TEAM_INSTRUMENTS");
					sentInstrumentTeamAchievement = true;
				}
				if (num2 >= 4)
				{
					GiveAchievement("SUMMER_INFLATABLE");
					sentSummerTeamAchievement = true;
				}
			}
			teamMember.userID = member;
			playerTeam2.members.Add(teamMember);
			if (basePlayer != null)
			{
				if (basePlayer.State.pings != null && basePlayer.State.pings.Count > 0 && basePlayer != this)
				{
					playerTeam2.teamPings.AddRange(basePlayer.State.pings);
				}
				if (fullTeamUpdate && basePlayer != this)
				{
					basePlayer.TeamUpdate(fullTeamUpdate: false);
				}
			}
		}
		playerTeam2.leaderMapNotes = Facepunch.Pool.GetList<MapNote>();
		PlayerState playerState = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(playerTeam.teamLeader);
		if (playerState?.pointsOfInterest != null)
		{
			foreach (MapNote item in playerState.pointsOfInterest)
			{
				playerTeam2.leaderMapNotes.Add(item);
			}
		}
		if (Interface.CallHook("OnTeamUpdated", currentTeam, playerTeam2, this) == null)
		{
			ClientRPCPlayerAndSpectators(null, this, "CLIENT_ReceiveTeamInfo", playerTeam2);
			if (playerTeam2.leaderMapNotes != null)
			{
				playerTeam2.leaderMapNotes.Clear();
			}
			if (playerTeam2.teamPings != null)
			{
				playerTeam2.teamPings.Clear();
			}
			BasePlayer basePlayer2 = FindByID(playerTeam.teamLeader);
			if (fullTeamUpdate && basePlayer2 != null && basePlayer2 != this)
			{
				basePlayer2.TeamUpdate(fullTeamUpdate: false);
			}
		}
	}

```

## OnRconConnection(System.Net.IPAddress)

```csharp
```csharp
/// <summary>
/// Called when an RCON connection is established.
/// </summary>
/// <param name="ipAddress">The IP address of the client attempting to connect.</param>
/// <returns>
/// Returns a non-null value to override the default behavior and close the socket. 
/// If `null` is returned, the connection will be processed as normal.
/// </returns>
System.Net.IPAddress OnRconConnection(System.Net.IPAddress ipAddress)
{
    Puts($"RCON connection from {ipAddress} has been established.");
    if (ipAddress == System.Net.IPAddress.Parse("192.168.1.1"))
    {
        Puts($"Ignoring RCON connection from {ipAddress} - banned.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", iPEndPoint.Address) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					Debug.Log("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString());
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

```

## OnEntityTakeDamage(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that took the damage.</param>
/// <param name="info">Information about the hit, including the damage type and amount.</param>
/// <returns>
/// Returns `null` to allow the entity to take the damage as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the entity from taking the damage.
/// </returns>
object OnEntityTakeDamage(ResourceEntity entity, HitInfo info)
{
    Puts($"Entity {entity.GetType().Name} took {info.damageTypes.Total()} damage.");
    if (info.damageTypes.Contains(DamageType.Fire))
    {
        Puts($"Entity {entity.GetType().Name} is immune to fire damage.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", this, info) != null)
		{
			return;
		}
		if (resourceDispenser != null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if ((bool)baseProtection)
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnKilled(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

```

## OnOutputUpdate(IOEntity)

```csharp
```csharp
/// <summary>
/// Called when an output is updated.
/// </summary>
/// <param name="ioEntity">The IO entity that owns the output being updated.</param>
/// <returns>
/// Returns `null` to allow the output to be updated normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for debugging purposes.
/// </returns>
object OnOutputUpdate(IOEntity ioEntity)
{
    Puts($"Output on {ioEntity.name} has been updated.");
    if (ioEntity.name == "Invalid Output")
    {
        Puts($"Warning: Attempting to update invalid output on {ioEntity.name}");
        return "Invalid Output";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void UpdateOutputs()
	{
		if (Interface.CallHook("OnOutputUpdate", this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		ensureOutputsUpdated = false;
		using (TimeWarning.New("ProcessIOOutputs"))
		{
			for (int i = 0; i < outputs.Length; i++)
			{
				IOSlot iOSlot = outputs[i];
				bool flag = true;
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if (!(iOEntity != null))
				{
					continue;
				}
				if (ioType == IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)
				{
					using (TimeWarning.New("FluidOutputProcessing"))
					{
						if (!iOEntity.AllowLiquidPassthrough(this, base.transform.TransformPoint(iOSlot.handlePosition)))
						{
							flag = false;
						}
					}
				}
				int passthroughAmount = GetPassthroughAmount(i);
				iOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);
			}
		}
	}

```

## OnExcavatorResourceSet(ExcavatorArm,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the resource target for an excavator arm is set.
/// </summary>
/// <param name="excavatorArm">The excavator arm that the resource target is being set for.</param>
/// <param name="resourceName">The name of the resource being targeted (e.g. "HQM", "Sulfur", etc.).</param>
/// <param name="player">The player who is setting the resource target.</param>
/// <returns>
/// Returns `null` to allow the resource target to be set, or any non-null value to prevent it from being set.
/// </returns>
object OnExcavatorResourceSet(ExcavatorArm excavatorArm, string resourceName, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is setting the resource target for excavator arm {excavatorArm.name} to {resourceName}.");
    if (resourceName == "Forbidden Resource")
    {
        Puts($"Player {player.displayName} is not allowed to set the resource target to {resourceName}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SetResourceTarget(RPCMessage msg)
	{
		string text = msg.read.String();
		if (Interface.CallHook("OnExcavatorResourceSet", this, text, msg.player) == null)
		{
			switch (text)
			{
			case "HQM":
				resourceMiningIndex = 0;
				break;
			case "Sulfur":
				resourceMiningIndex = 1;
				break;
			case "Stone":
				resourceMiningIndex = 2;
				break;
			case "Metal":
				resourceMiningIndex = 3;
				break;
			}
			if (!IsOn())
			{
				BeginMining();
			}
		}
	}

```

## OnContainerDropItems(ItemContainer)

```csharp
```csharp
/// <summary>
/// Called when items are dropped from a container.
/// </summary>
/// <param name="container">The container from which the items were dropped.</param>
/// <returns>
/// Returns `null` to allow the items to be dropped, or any non-null value to prevent them from being dropped.
/// </returns>
object OnContainerDropItems(ItemContainer container)
{
    Puts($"Dropping {container.itemList.Count} items from container {container.entityOwner.displayName} at position {container.position}.");
    if (container.entityOwner is Player player && player.IsInJail())
    {
        Puts($"Player {player.displayName} cannot drop items while in jail.");
        return "Cannot drop items while in jail.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp
	public static void DropItems(ItemContainer container, Vector3 position)
	{
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			float num2 = UnityEngine.Random.Range(0f, 2f);
			item.RemoveFromContainer();
			BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(UnityEngine.Random.Range(0f - num, num), 1f, UnityEngine.Random.Range(0f - num, num)));
			if (baseEntity == null)
			{
				item.Remove();
				continue;
			}
			if (baseEntity is DroppedItem droppedItem && container.entityOwner is LootContainer)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;
			}
			if (num2 > 0f)
			{
				baseEntity.SetVelocity(new Vector3(UnityEngine.Random.Range(-1f, 1f), UnityEngine.Random.Range(0f, 1f), UnityEngine.Random.Range(-1f, 1f)) * num2);
				baseEntity.SetAngularVelocity(new Vector3(UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f), UnityEngine.Random.Range(-10f, 10f)) * num2);
			}
		}
	}

```

## OnGrowableGathered(GrowableEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a growable entity is gathered.
/// </summary>
/// <param name="growable">The growable entity that was gathered.</param>
/// <param name="item">The item that was gathered from the growable entity.</param>
/// <param name="player">The player who gathered the item.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the item will be given to the player as normal.
/// </returns>
object OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} gathered {item.info.shortname} from a growable entity.");
    if (growable.GetStage() == 3 && item.amount > 5)
    {
        Puts($"The growable entity was fully grown and yielded an unusually large amount of {item.info.shortname}.");
        return "Fully grown";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void GiveFruit(BasePlayer player, int amount, bool applyCondition, bool eat)
	{
		Item item = ItemManager.Create(Properties.pickupItem, amount, 0uL);
		if (applyCondition)
		{
			item.conditionNormalized = Properties.fruitVisualScaleCurve.Evaluate(StageProgressFraction);
		}
		if (eat && player != null && IsFood())
		{
			ItemModConsume component = item.info.GetComponent<ItemModConsume>();
			if (component != null)
			{
				component.DoAction(item, player);
				return;
			}
		}
		if (player != null)
		{
			Interface.CallHook("OnGrowableGathered", this, item, player);
			Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
		}
		else
		{
			item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
		}
	}

```

## OnItemDeployed(Deployer,BaseEntity,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is deployed.
/// </summary>
/// <param name="deployer">The entity that deployed the item.</param>
/// <param name="baseEntity">The base entity where the item was deployed.</param>
/// <param name="baseDeployedEntity">The base entity that was deployed.</param>
object OnItemDeployed(BaseEntity deployer, BaseEntity baseEntity, BaseEntity baseDeployedEntity)
{
    Puts($"Item has been deployed by {deployer} on {baseEntity}.");
    if (baseDeployedEntity is Deployable deployable && deployable.entityType == "Turret")
    {
        Puts($"Turret has been deployed and will now attack enemies.");
        return null;
    }
    else if (baseDeployedEntity is Deployable deployable2 && deployable2.entityType == "Trap")
    {
        Puts($"Trap has been deployed and will now damage players who trigger it.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Slot(Deployable deployable, Ray ray, NetworkableId entityID)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ChatMessage("Building is blocked at player position!");
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (baseEntity == null || !baseEntity.HasSlot(deployable.slot) || baseEntity.GetSlot(deployable.slot) != null)
		{
			return;
		}
		if (ownerPlayer.Distance(baseEntity) > 3f)
		{
			ownerPlayer.ChatMessage("Too far away!");
			return;
		}
		if (!ownerPlayer.CanBuild(baseEntity.WorldSpaceBounds()))
		{
			ownerPlayer.ChatMessage("Building is blocked at placement position!");
			return;
		}
		Item ownerItem = GetOwnerItem();
		ItemModDeployable modDeployable = GetModDeployable();
		BaseEntity baseEntity2 = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath);
		if (baseEntity2 != null)
		{
			baseEntity2.skinID = ownerItem.skin;
			baseEntity2.SetParent(baseEntity, baseEntity.GetSlotAnchorName(deployable.slot));
			baseEntity2.OwnerID = ownerPlayer.userID;
			baseEntity2.OnDeployed(baseEntity, ownerPlayer, ownerItem);
			baseEntity2.Spawn();
			baseEntity.SetSlot(deployable.slot, baseEntity2);
			if (deployable.placeEffect.isValid)
			{
				Effect.server.Run(deployable.placeEffect.resourcePath, baseEntity.transform.position, Vector3.up);
			}
		}
		modDeployable.OnDeployed(baseEntity2, ownerPlayer);
		Interface.CallHook("OnItemDeployed", this, baseEntity, baseEntity2);
		Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);
		UseItemAmount(1);
	}

```

## OnStructureUpgrade(BuildingBlock,BasePlayer,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called when a structure is upgraded.
/// </summary>
/// <param name="block">The building block being upgraded.</param>
/// <param name="player">The player performing the upgrade.</param>
/// <param name="grade">The new grade of the building block.</param>
/// <param name="upgradeId">The ID of the upgrade being applied.</param>
/// <returns>
/// Returns a non-null value to override the default upgrade behavior. 
/// If `null` is returned, the structure will be upgraded as normal.
/// </returns>
object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade, ulong upgradeId)
{
    Puts($"Building block {block.name} has been upgraded by player {player.UserIDString} to grade {grade} with upgrade ID {upgradeId}");
    if (grade == BuildingGrade.Enum.Premium && !player.IsDonator())
    {
        Puts($"Player {player.UserIDString} does not have the required donator status to upgrade to premium.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoUpgradeToGrade(RPCMessage msg)
	{
		if (msg.player.CanInteract())
		{
			BuildingGrade.Enum @enum = (BuildingGrade.Enum)msg.read.Int32();
			ulong num = msg.read.UInt64();
			ConstructionGrade constructionGrade = blockDefinition.GetGrade(@enum, num);
			if (!(constructionGrade == null) && CanChangeToGrade(@enum, num, msg.player) && Interface.CallHook("OnStructureUpgrade", this, msg.player, @enum, num) == null && CanAffordUpgrade(@enum, num, msg.player) && !(base.SecondsSinceAttacked < 30f) && (num == 0L || msg.player.blueprints.steamInventory.HasItem((int)num)))
			{
				PayForUpgrade(constructionGrade, msg.player);
				Facepunch.Rust.Analytics.Azure.OnBuildingBlockUpgraded(msg.player, this, @enum);
				OnSkinChanged(skinID, num);
				ChangeGrade(@enum, playEffect: true);
			}
		}
	}

```

## CanUseMailbox(BasePlayer,Mailbox)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the mailbox.
/// </summary>
/// <param name="player">The player attempting to use the mailbox.</param>
/// <param name="mailbox">The mailbox being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the mailbox, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseMailbox(BasePlayer player, Mailbox mailbox)
{
    Puts($"Player {player.UserIDString} attempting to access mailbox {mailbox.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerIsOwner(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseMailbox", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return player.CanBuild();
	}

```

## OnRotateVendingMachine(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending machine is rotated.
/// </summary>
/// <param name="vendingMachine">The vending machine being rotated.</param>
/// <param name="player">The player who initiated the rotation.</param>
/// <returns>
/// Returns `null` to allow the vending machine to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnRotateVendingMachine(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending machine {vendingMachine.name} has been rotated by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot rotate the vending machine");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RotateVM(RPCMessage msg)
	{
		if (Interface.CallHook("OnRotateVendingMachine", this, msg.player) == null && CanRotate())
		{
			UpdateEmptyFlag();
			if (msg.player.CanBuild() && IsInventoryEmpty())
			{
				base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
				SendNetworkUpdate();
			}
		}
	}

```

## OnLootEntityEnd(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="lootableCorpse">The lootable corpse that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, LootableCorpse lootableCorpse)
{
    Puts($"Player {player.UserIDString} stopped looting the entity.");
    if (lootableCorpse.GetOwner() == player)
    {
        Puts($"Player {player.UserIDString} is now the owner of the entity.");
        // Perform any necessary actions when a player becomes the owner
    }
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnTrapDisarm(Landmine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to disarm a trap.
/// </summary>
/// <param name="landmine">The landmine being disarmed.</param>
/// <param name="player">The player attempting to disarm the landmine.</param>
/// <returns>
/// Returns `null` to allow the player to disarm the landmine, or any non-null value to prevent them from disarming it.
/// </returns>
object OnTrapDisarm(Landmine landmine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to disarm landmine at position {landmine.position}");
    if (player.userID == triggerPlayerID)
    {
        Puts($"Player {player.displayName} is the owner of the landmine and cannot disarm it.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Disarm(RPCMessage rpc)
	{
		if (rpc.player.userID != triggerPlayerID && Armed() && Interface.CallHook("OnTrapDisarm", this, rpc.player) == null)
		{
			SetFlag(Flags.On, b: false);
			if (UnityEngine.Random.Range(0, 100) < 15)
			{
				Invoke(TryExplode, 0.05f);
				return;
			}
			rpc.player.GiveItem(ItemManager.CreateByName("trap.landmine", 1, 0uL), GiveItemReason.PickedUp);
			Kill();
		}
	}

```

## OnEntityDistanceCheck(BaseEntity,BasePlayer,uint,string,float)

```csharp
```csharp
/// <summary>
/// Called when an entity's distance from a player is checked.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <param name="player">The player checking the distance.</param>
/// <param name="id">A unique identifier for the check, used to override default behavior if needed.</param>
/// <param name="debugName">A debug-friendly name for the entity, used for logging and debugging purposes.</param>
/// <param name="maximumDistance">The maximum allowed distance between the entity and the player.</param>
/// <returns>
/// Returns `true` if the entity is within the maximum allowed distance from the player, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a reason for why the entity was not considered close enough.
/// If `null` is returned, the default behavior of checking the entity's distance will be used.
/// </returns>
object OnEntityDistanceCheck(BaseEntity entity, BasePlayer player, uint id, string debugName, float maximumDistance)
{
    Puts($"Checking distance between {debugName} and {player.displayName}...");
    if (id == 12345 && entity.name == "Important Entity")
    {
        return "This entity is always considered close.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityDistanceCheck", ent, player, id, debugName, maximumDistance);
				if (obj is bool)
				{
					return (bool)obj;
				}
				return ent.Distance(player.eyes.position) <= maximumDistance;
			}

```

## OnTurretRotate(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret rotates its aim.
/// </summary>
/// <param name="turret">The AutoTurret instance that rotated.</param>
/// <param name="player">The player who triggered the rotation (if applicable).</param>
/// <returns>No return behavior.</returns>
void OnTurretRotate(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.name} has rotated its aim.");
    if (player != null)
    {
        Puts($"Turret {turret.name} aimed at player {player.UserIDString}.");
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void FlipAim(RPCMessage rpc)
	{
		if (!IsOnline() && IsAuthed(rpc.player) && !booting && Interface.CallHook("OnTurretRotate", this, rpc.player) == null)
		{
			base.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);
			SendNetworkUpdate();
		}
	}

```

## OnBookmarkControlEnded(ComputerStation,BasePlayer,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a bookmark control is ended.
/// </summary>
/// <param name="player">The player who was controlling the bookmark.</param>
/// <param name="remoteControllable">The IRemoteControllable component that was being controlled.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the control will be ended as normal.
/// </returns>
object OnBookmarkControlEnded(BasePlayer player, IRemoteControllable remoteControllable)
{
    Puts($"Bookmark control for {player.UserIDString} has been ended.");
    if (remoteControllable.GetEnt() is CCTV_RC && Rust.GameInfo.HasAchievements)
    {
        CancelInvoke(CheckCCTVAchievement);
    }
    CancelInvoke(ControlCheck);
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## OnWireConnect(BasePlayer,BaseNetworkable,int,BaseNetworkable,int,System.Collections.Generic.List<UnityEngine.Vector3>)

```csharp
```csharp
/// <summary>
/// Called when a wire connection is made between two entities.
/// </summary>
/// <param name="player">The player who made the connection.</param>
/// <param name="entity1">The first entity in the connection.</param>
/// <param name="inputSlot">The input slot on entity1 that was connected.</param>
/// <param name="entity2">The second entity in the connection.</param>
/// <param name="outputSlot">The output slot on entity2 that was connected.</param>
/// <param name="linePoints">The points along which the wire will run.</param>
/// <returns>
/// Returns a non-null value to override the default connection behavior. 
/// If `null` is returned, the connection is made as normal.
/// </returns>
object OnWireConnect(BasePlayer player, BaseNetworkable entity1, int inputSlot, BaseNetworkable entity2, int outputSlot, List<Vector3> linePoints)
{
    Puts($"Player {player.displayName} connected {entity1.ShortName()} to {entity2.ShortName()} at slot {inputSlot} and {outputSlot}.");
    // Add custom logic here if needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner]
	public void MakeConnection(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!CanPlayerUseWires(player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num > 18)
		{
			return;
		}
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < num; i++)
		{
			Vector3 item = msg.read.Vector3();
			list.Add(item);
		}
		NetworkableId uid = msg.read.EntityID();
		int num2 = msg.read.Int32();
		NetworkableId uid2 = msg.read.EntityID();
		int num3 = msg.read.Int32();
		WireColour wireColour = IntToColour(msg.read.Int32());
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		IOEntity iOEntity = ((baseNetworkable == null) ? null : baseNetworkable.GetComponent<IOEntity>());
		if (iOEntity == null)
		{
			return;
		}
		BaseNetworkable baseNetworkable2 = BaseNetworkable.serverEntities.Find(uid2);
		IOEntity iOEntity2 = ((baseNetworkable2 == null) ? null : baseNetworkable2.GetComponent<IOEntity>());
		if (!(iOEntity2 == null) && ValidateLine(list, iOEntity, iOEntity2, player, num3) && !(Vector3.Distance(baseNetworkable2.transform.position, baseNetworkable.transform.position) > maxWireLength) && num2 < iOEntity.inputs.Length && num3 < iOEntity2.outputs.Length && !(iOEntity.inputs[num2].connectedTo.Get() != null) && !(iOEntity2.outputs[num3].connectedTo.Get() != null) && (!iOEntity.inputs[num2].rootConnectionsOnly || iOEntity2.IsRootEntity()) && CanModifyEntity(player, iOEntity) && CanModifyEntity(player, iOEntity2) && Interface.CallHook("OnWireConnect", player, baseNetworkable, num2, baseNetworkable2, num3, list) == null)
		{
			iOEntity.inputs[num2].connectedTo.Set(iOEntity2);
			iOEntity.inputs[num2].connectedToSlot = num3;
			iOEntity.inputs[num2].wireColour = wireColour;
			iOEntity.inputs[num2].connectedTo.Init();
			iOEntity2.outputs[num3].connectedTo.Set(iOEntity);
			iOEntity2.outputs[num3].connectedToSlot = num2;
			iOEntity2.outputs[num3].linePoints = list.ToArray();
			iOEntity2.outputs[num3].wireColour = wireColour;
			iOEntity2.outputs[num3].connectedTo.Init();
			iOEntity2.outputs[num3].worldSpaceLineEndRotation = iOEntity.transform.TransformDirection(iOEntity.inputs[num2].handleDirection);
			iOEntity2.MarkDirtyForceUpdateOutputs();
			iOEntity2.SendNetworkUpdate();
			iOEntity.SendNetworkUpdate();
			iOEntity2.SendChangedToRoot(forceUpdate: true);
			iOEntity2.RefreshIndustrialPreventBuilding();
			if (wireType == IOEntity.IOType.Industrial)
			{
				iOEntity.NotifyIndustrialNetworkChanged();
				iOEntity2.NotifyIndustrialNetworkChanged();
			}
		}
	}

```

## CanUseGesture(BasePlayer,GestureConfig)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a gesture.
/// </summary>
/// <param name="player">The player attempting to use the gesture.</param>
/// <param name="gestureConfig">The configuration of the gesture being used.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the gesture, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as an error and the player will not be able to use the gesture.
/// </returns>
object CanUseGesture(BasePlayer player, GestureConfig gestureConfig)
{
    Puts($"Player {player.UserIDString} attempted to use gesture {gestureConfig.name}");
    if (player.IsAdmin && !player.IsNpc)
    {
        return true;
    }
    else if (player.blueprints.steamInventory.HasItem(gestureConfig.requiredItemId))
    {
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have required item for gesture {gestureConfig.name}");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public bool IsOwnedBy(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseGesture", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (gestureType == GestureType.NPC)
		{
			return player.IsNpc;
		}
		if (gestureType == GestureType.Cinematic)
		{
			return player.IsAdmin;
		}
		if (dlcItem != null && dlcItem.CanUse(player))
		{
			return true;
		}
		if (inventoryItem != null && player.blueprints.steamInventory.HasItem(inventoryItem.id))
		{
			return true;
		}
		return false;
	}

```

## OnClientDisconnect(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The connection of the disconnected client.</param>
/// <param name="reason">The reason for the disconnection, if any.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnect(Network.Connection connection, string reason)
{
    Puts($"Client {connection.ToString()} disconnected: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void ReadDisconnectReason(Message packet)
	{
		string text = packet.read.String(4096);
		string text2 = packet.connection.ToString();
		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
		{
			Interface.CallHook("OnClientDisconnect", packet.connection, text);
			DebugEx.Log(text2 + " disconnecting: " + text);
		}
	}

```

## OnEntityMarkHostile(BaseCombatEntity,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile.
/// </summary>
/// <param name="entity">The entity being marked as hostile.</param>
/// <param name="duration">The duration for which the entity should be considered hostile, in seconds. Defaults to 60 seconds.</param>
/// <returns>
/// Returns `null` to allow the entity to be marked as hostile, or any non-null value to prevent it from being marked.
/// </returns>
object OnEntityMarkHostile(BaseCombatEntity entity, float duration)
{
    Puts($"Entity {entity.UserIDString} has been marked as hostile for {duration} seconds.");
    if (duration > 120f)
    {
        Puts($"Entity {entity.UserIDString} is being marked as hostile for an extended period of time ({duration} seconds).");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			float b = UnityEngine.Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, b);
		}
	}

```

## OnSprayRemove(SprayCanSpray,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a spray can is removed from the game.
/// </summary>
/// <param name="spray">The spray can being removed.</param>
/// <param name="player">The player who removed the spray can.</param>
/// <returns>
/// Returns `null` to allow the spray can to be removed, or any non-null value to prevent it from being removed.
/// </returns>
object OnSprayRemove(SprayCanSpray spray, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has removed a spray can.");
    if (spray == null)
    {
        Puts("Error: Spray can is null.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	private void Server_RequestWaterClear(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && Menu_WaterClear_ShowIf(player) && Interface.CallHook("OnSprayRemove", this, player) == null)
		{
			Kill();
		}
	}

```

## OnServerRestartInterrupt()

```csharp
```csharp
/// <summary>
/// Called when the server restart is interrupted.
/// </summary>
/// <returns>
/// Returns `null` to allow the server restart to be interrupted, or any non-null value to prevent the interruption.
/// </returns>
object OnServerRestartInterrupt()
{
    Puts("Server restart has been interrupted.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if (SingletonComponent<ServerMgr>.Instance == null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Restart interrupted!");
			SingletonComponent<ServerMgr>.Instance.StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", strNotice, iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			SingletonComponent<ServerMgr>.Instance.StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

```

## OnPlayerRevive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player revives another player.
/// </summary>
/// <param name="reviver">The player who revived the other player.</param>
/// <param name="revivedPlayer">The player who was revived.</param>
/// <returns>
/// Returns `null` to allow the revival to occur, or any non-null value to prevent the revival.
/// </returns>
object OnPlayerRevive(BasePlayer reviver, BasePlayer revivedPlayer)
{
    Puts($"Player {reviver.displayName} has revived player {revivedPlayer.displayName}.");
    if (revivedPlayer.IsWounded() && !reviver.CanHeal())
    {
        Puts($"Player {revivedPlayer.displayName} cannot be healed by player {reviver.displayName}.");
        return "Cannot heal: Reviver does not have healing capabilities.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Facepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if (player != ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}

```

## OnNpcRadioChatter(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC's radio chatter is played.
/// </summary>
/// <param name="npc">The ScientistNPC instance.</param>
/// <returns>
/// Returns `null` to allow the radio chatter to play normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the message for the radio chatter.
/// </returns>
object OnNpcRadioChatter(ScientistNPC npc)
{
    Puts($"Playing radio chatter for NPC {npc.name}");
    if (npc.isTalkingToPlayer)
    {
        return "Hello, I'm just testing this radio thingy.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PlayRadioChatter()
	{
		if (RadioChatterEffects.Length != 0)
		{
			if (base.IsDestroyed || base.transform == null)
			{
				CancelInvoke(PlayRadioChatter);
			}
			else if (Interface.CallHook("OnNpcRadioChatter", this) == null)
			{
				Effect.server.Run(RadioChatterEffects[UnityEngine.Random.Range(0, RadioChatterEffects.Length)].resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
				QueueRadioChatter();
			}
		}
	}

```

## OnTechTreeNodeUnlocked(Workbench,TechTreeData.NodeInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a tech tree node is unlocked.
/// </summary>
/// <param name="node">The unlocked tech tree node.</param>
/// <param name="player">The player who unlocked the node.</param>
/// <returns>
/// Returns a non-null value to override the default unlock behavior. 
/// If `null` is returned, the node is unlocked as normal.
/// </returns>
object OnTechTreeNodeUnlocked(TechTreeData.NodeInstance node, BasePlayer player)
{
    Puts($"Node {node.name} has been unlocked by player {player.displayName}.");
    if (node.itemDef == null || !player.blueprints.IsUnlocked(node.itemDef))
    {
        return "Error: Node is not valid or already unlocked.";
    }
    // Additional logic can be added here to handle the unlock event.
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		TechTreeData.NodeInstance byID = techTree.GetByID(num);
		if (byID == null)
		{
			Debug.Log("Node for unlock not found :" + num);
		}
		else
		{
			if (!techTree.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTree.GetByID(output);
					if (byID2 != null && byID2.itemDef != null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", this);
					}
				}
				Debug.Log("Player unlocked group :" + byID.groupName);
			}
			else if (byID.itemDef != null && Interface.CallHook("OnTechTreeNodeUnlock", this, byID, player) == null)
			{
				int num2 = ResearchTable.ScrapForResearch(byID.itemDef, ResearchTable.ResearchType.TechTree);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num2)
				{
					player.inventory.Take(null, itemid, num2);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", this, byID, player);
					Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", this);
				}
			}
		}
	}

```

## OnAmmoUnload(BaseProjectile,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when ammo is unloaded from a projectile.
/// </summary>
/// <param name="projectile">The projectile from which the ammo is being unloaded.</param>
/// <param name="item">The item that was holding the projectile.</param>
/// <param name="player">The player who is unloading the ammo.</param>
/// <returns>
/// Returns `null` to allow the ammo to be unloaded, or any non-null value to prevent the ammo from being unloaded.
/// </returns>
object OnAmmoUnload(BaseProjectile projectile, Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is unloading ammo from projectile {projectile.name}.");
    if (item.ammoType == "restricted")
    {
        Puts($"Player {player.displayName} cannot unload restricted ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UnloadAmmo(Item item, BasePlayer player)
	{
		BaseProjectile component = item.GetHeldEntity().GetComponent<BaseProjectile>();
		if (!component.canUnloadAmmo || Interface.CallHook("OnAmmoUnload", component, item, player) != null || !component)
		{
			return;
		}
		int contents = component.primaryMagazine.contents;
		if (contents > 0)
		{
			component.primaryMagazine.contents = 0;
			SendNetworkUpdateImmediate();
			Item item2 = ItemManager.Create(component.primaryMagazine.ammoType, contents, 0uL);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
		}
	}

```

## OnPlayerRecovered(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who has recovered.</param>
/// <returns>No return behavior.</returns>
void OnPlayerRecovered(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered from being wounded.");
    if (player.isServer && !player.IsCrawling())
    {
        Puts($"Player {player.UserIDString} is now fully healed.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			if (IsCrawling())
			{
				base.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if ((bool)BaseGameMode.GetActiveGameMode(base.isServer))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", this);
		}
	}

```

## OnLiquidWeaponFired(LiquidWeapon,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a liquid weapon is fired.
/// </summary>
/// <param name="liquidWeapon">The liquid weapon that was fired.</param>
/// <param name="player">The player who fired the liquid weapon.</param>
/// <returns>No return behavior.</returns>
void OnLiquidWeaponFired(LiquidWeapon liquidWeapon, BasePlayer player)
{
    Puts($"Player {player.UserIDString} fired a {liquidWeapon.name}.");
    if (liquidWeapon.ammoType == "explosive")
    {
        Puts($"The explosive liquid weapon caused damage to the surrounding area.");
        // Handle explosive damage
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartFiring(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (OnCooldown())
		{
			return;
		}
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		if (CanFire(player))
		{
			CancelInvoke("FireTick");
			InvokeRepeating("FireTick", 0f, FireRate);
			SetFlag(Flags.On, b: true);
			StartCooldown(FireRate);
			if (base.isServer)
			{
				SendNetworkUpdateImmediate();
			}
			Interface.CallHook("OnLiquidWeaponFired", this, player);
		}
	}

```

## OnNetworkGroupEntered(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network object enters a network group.
/// </summary>
/// <param name="networkObject">The network object that entered the group.</param>
/// <param name="group">The network group that was entered.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupEntered(BaseNetworkable networkObject, Network.Visibility.Group group)
{
    Puts($"Network object {networkObject} has entered network group {group}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", this, group);
	}

```

## OnSleepingBagDestroy(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The destroyed sleeping bag.</param>
/// <param name="player">The player who destroyed the sleeping bag.</param>
/// <returns>
/// Returns `null` to allow the sleeping bag to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnSleepingBagDestroy(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Player {player.UserIDString} destroyed a sleeping bag.");
    if (sleepingBag.owner == player.userID)
    {
        Puts($"Player {player.UserIDString} is the owner of the destroyed sleeping bag.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(BasePlayer player, NetworkableId sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, player) != null)
		{
			return false;
		}
		if (sleepingBag2.canBePublic)
		{
			sleepingBag2.SetPublic(isPublic: true);
			sleepingBag2.deployerUserID = 0uL;
		}
		else
		{
			sleepingBag2.Kill();
		}
		player.SendRespawnOptions();
		Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, player);
		return true;
	}

```

## CanStackItem(Item,Item)

```csharp
```csharp
/// <summary>
/// Called to determine if two items can be stacked together.
/// </summary>
/// <param name="item1">The first item.</param>
/// <param name="item2">The second item.</param>
/// <returns>
/// Returns `true` if the items can be stacked, and `false` otherwise.
/// If a non-null value is returned, it will override the default stacking behavior.
/// </returns>
object CanStackItem(Item item1, Item item2)
{
    Puts($"Checking if {item1.info.name} and {item2.info.name} can be stacked.");
    if (item1 == item2)
    {
        return false;
    }
    if (item1.MaxStackable() <= 1 || item2.MaxStackable() <= 1)
    {
        return false;
    }
    if (item1.info.itemid != item2.info.itemid)
    {
        return false;
    }
    // Additional conditions to check for stacking
    if (item1.hasCondition && item1.condition != item1.info.condition.max && item2.hasCondition && item2.condition != item2.info.condition.max)
    {
        return false;
    }
    if (item1.instanceData != null && item1.instanceData.subEntity.IsValid && (bool)item1.info.GetComponent<ItemModSign>() && item2.instanceData != null && item2.instanceData.subEntity.IsValid && (bool)item2.info.GetComponent<ItemModSign>())
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStack(Item item)
	{
		object obj = Interface.CallHook("CanStackItem", this, item);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (item == this)
		{
			return false;
		}
		if (MaxStackable() <= 1)
		{
			return false;
		}
		if (item.MaxStackable() <= 1)
		{
			return false;
		}
		if (item.info.itemid != info.itemid)
		{
			return false;
		}
		if (hasCondition && condition != item.info.condition.max)
		{
			return false;
		}
		if (item.hasCondition && item.condition != item.info.condition.max)
		{
			return false;
		}
		if (!IsValid())
		{
			return false;
		}
		if (IsBlueprint() && blueprintTarget != item.blueprintTarget)
		{
			return false;
		}
		if (item.skin != skin)
		{
			return false;
		}
		if (item.info.amountType == ItemDefinition.AmountType.Genetics || info.amountType == ItemDefinition.AmountType.Genetics)
		{
			int num = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
			int num2 = ((instanceData != null) ? instanceData.dataInt : (-1));
			if (num != num2)
			{
				return false;
			}
		}
		if (item.instanceData != null && instanceData != null && (item.IsOn() != IsOn() || (item.instanceData.dataInt != instanceData.dataInt && item.info.Blueprint != null && item.info.Blueprint.workbenchLevelRequired == 3)))
		{
			return false;
		}
		if (instanceData != null && instanceData.subEntity.IsValid && (bool)info.GetComponent<ItemModSign>())
		{
			return false;
		}
		if (item.instanceData != null && item.instanceData.subEntity.IsValid && (bool)item.info.GetComponent<ItemModSign>())
		{
			return false;
		}
		return true;
	}

```

## OnCorpsePopulate(GingerbreadNPC,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when a corpse is populated with loot.
/// </summary>
/// <param name="npc">The NPC whose corpse is being populated.</param>
/// <param name="corpse">The corpse being populated.</param>
/// <returns>
/// Returns the populated corpse, or any non-null value to override the default population behavior. 
/// If `null` is returned, the corpse is populated as normal.
/// </returns>
object OnCorpsePopulate(GingerbreadNPC npc, NPCPlayerCorpse corpse)
{
    Puts($"Corpsing {npc.name}'s corpse.");
    if (corpse.playerName == "EvilGingerbread")
    {
        Puts($"Warning: EvilGingerbread's corpse has been found. Destroying it to prevent evil from spreading.");
        return null;
    }
    return corpse;
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse()
	{
		using (TimeWarning.New("Create corpse"))
		{
			string corpseResourcePath = CorpseResourcePath;
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse(corpseResourcePath) as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(inventory.containerMain);
				nPCPlayerCorpse.playerName = "Gingerbread";
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
				if (LootSpawnSlots.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int i = 0; i < lootSpawnSlots.Length; i++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
						for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnDieselEngineToggled(DieselEngine)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off.
/// </summary>
/// <param name="engine">The diesel engine that was toggled.</param>
/// <returns>No return behavior.</returns>
void OnDieselEngineToggled(DieselEngine engine)
{
    Puts($"Diesel engine {engine.GetId()} has been {(GetFlag(Flags.On) ? "turned off" : "turned on")}.");
}
```
```

### Source Code from the Library

```csharp

	public void EngineOff()
	{
		SetFlag(Flags.On, b: false);
		BroadcastEntityMessage("DieselEngineOff");
		Interface.CallHook("OnDieselEngineToggled", this);
	}

```

## OnPhoneDial(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone call is initiated.
/// </summary>
/// <param name="caller">The player initiating the call.</param>
/// <param name="callee">The telephone controller of the recipient.</param>
/// <param name="player">The BasePlayer object of the caller.</param>
/// <returns>
/// Returns `null` to allow the call to proceed as normal, or any non-null value to cancel the call.
/// </returns>
object OnPhoneDial(PhoneController caller, PhoneController callee, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is attempting to call {callee.GetPhoneNumber()}");
    if (caller == callee)
    {
        Puts("Cannot call self.");
        return "Cannot call self.";
    }
    // Additional logic can be added here to cancel the call based on certain conditions
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CallPhone(int number)
	{
		if (number == PhoneNumber)
		{
			OnDialFailed(Telephone.DialFailReason.CallSelf);
			return;
		}
		if (TelephoneManager.GetCurrentActiveCalls() + 1 > TelephoneManager.MaxConcurrentCalls)
		{
			OnDialFailed(Telephone.DialFailReason.NetworkBusy);
			return;
		}
		PhoneController telephone = TelephoneManager.GetTelephone(number);
		if (telephone != null)
		{
			if (Interface.CallHook("OnPhoneDial", this, telephone, currentPlayer) == null)
			{
				if (telephone.serverState == Telephone.CallState.Idle && telephone.CanReceiveCall())
				{
					SetPhoneState(Telephone.CallState.Dialing);
					lastDialedNumber = number;
					activeCallTo = telephone;
					activeCallTo.ReceiveCallFrom(this);
				}
				else
				{
					OnDialFailed(Telephone.DialFailReason.Engaged);
					telephone.OnIncomingCallWhileBusy();
				}
			}
		}
		else
		{
			OnDialFailed(Telephone.DialFailReason.WrongNumber);
		}
	}

```

## OnLootEntityEnd(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The container that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, DroppedItemContainer container)
{
    Puts($"Player {player.UserIDString} has finished looting the entity.");
    if (container.itemList.Count > 0 && container.itemList[0].item.name == "GoldenApple")
    {
        Puts($"Player {player.displayName} found a Golden Apple!");
    }
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		if (inventory == null || inventory.itemList == null || inventory.itemList.Count == 0)
		{
			Kill();
			return;
		}
		ResetRemovalTime();
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnInventoryItemsTake(PlayerInventory,System.Collections.Generic.List<Item>,int,int)

```csharp
```csharp
/// <summary>
/// Called when inventory items are taken from a player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="items">A list of items to take from the inventory.</param>
/// <param name="itemid">The ID of the item to take.</param>
/// <param name="amount">The amount of the item to take.</param>
/// <returns>
/// Returns a non-negative integer indicating how many items were taken. 
/// If `null` is returned, the default behavior will be used.
/// </returns>
object OnInventoryItemsTake(PlayerInventory inventory, List<Item> items, int itemid, int amount)
{
    Puts($"Taking {amount} x {itemid} from player's inventory.");
    if (itemid == 123 && amount > 5)
    {
        Puts($"Player is not allowed to take more than 5 x {itemid}.");
        return 0;
    }
    // Default behavior: Take the specified amount of items
    int taken = Math.Min(amount, inventory.GetCount(itemid));
    Puts($"Took {taken} x {itemid} from player's inventory.");
    return taken;
}
```
```

### Source Code from the Library

```csharp

	public int Take(List<Item> collect, int itemid, int amount)
	{
		object obj = Interface.CallHook("OnInventoryItemsTake", this, collect, itemid, amount);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			int num2 = containerMain.Take(collect, itemid, amount);
			num += num2;
			amount -= num2;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerBelt != null)
		{
			int num3 = containerBelt.Take(collect, itemid, amount);
			num += num3;
			amount -= num3;
		}
		if (amount <= 0)
		{
			return num;
		}
		if (containerWear != null)
		{
			int num4 = containerWear.Take(collect, itemid, amount);
			num += num4;
			amount -= num4;
		}
		return num;
	}

```

## CanCombineDroppedItem(DroppedItem,DroppedItem)

```csharp
```csharp
/// <summary>
/// Called to determine if two dropped items can be combined.
/// </summary>
/// <param name="item1">The first dropped item.</param>
/// <param name="item2">The second dropped item.</param>
/// <returns>
/// Returns `null` to allow the items to combine, or any non-null value to prevent them from combining.
/// </returns>
object CanCombineDroppedItem(DroppedItem item1, DroppedItem item2)
{
    Puts($"Checking if {item1.item.info.name} and {item2.item.info.name} can be combined.");
    if (item1.item.info != item2.item.info || (item1.item.IsBlueprint() && item1.item.blueprintTarget != item2.item.blueprintTarget) || (item1.item.hasCondition && item1.item.condition != item1.item.maxCondition) || (item2.item.hasCondition && item2.item.condition != item2.item.maxCondition))
    {
        Puts($"Items cannot be combined due to different info or conditions.");
        return null;
    }
    if (item1.item.info.amountType == ItemDefinition.AmountType.Genetics)
    {
        int num = ((item1.item.instanceData != null) ? item1.item.instanceData.dataInt : (-1));
        int num2 = ((item2.item.instanceData != null) ? item2.item.instanceData.dataInt : (-1));
        if (num != num2)
        {
            Puts($"Items cannot be combined due to different genetics.");
            return null;
        }
    }
    if ((item1.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item1.item) != null) || (item2.item.info != null && item2.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item2.item) != null))
    {
        Puts($"Items cannot be combined due to mod signs.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.DestroyItem();
			di.Kill();
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Interface.CallHook("OnDroppedItemCombined", this);
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
		}
	}

```

## OnDefaultItemsReceived(PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when default items are received by the player.
/// </summary>
/// <param name="playerInventory">The player's inventory.</param>
void OnDefaultItemsReceived(PlayerInventory playerInventory)
{
    Puts("Default items have been received.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday())
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas())
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.steamInventory.HasItem(infoInt) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);
			}
		}
	}

```

## IOnPlayerCommand(BasePlayer,string)

```csharp
Based on the provided code snippet, I will create a method structure for `IOnPlayerCommand(BasePlayer, string)`.

```csharp
/// <summary>
/// Called when a player executes a command.
/// </summary>
/// <param name="player">The player who executed the command.</param>
/// <param name="command">The command that was executed.</param>
object IOnPlayerCommand(BasePlayer player, string command)
{
    // Handle the command execution
}
```

This method takes two parameters: `player` and `command`. The `player` parameter represents the player who executed the command, and the `command` parameter represents the actual command that was executed.

In the provided code snippet, when a player executes a command starting with `/` or `\`, this method is called. Therefore, you can use this method to handle custom commands for your game.

Here's an example of how you could implement this method:

```csharp
object IOnPlayerCommand(BasePlayer player, string command)
{
    if (command.StartsWith("/mycustomcmd"))
    {
        // Handle the custom command execution
        ConsoleNetwork.SendClientCommand(player.net.connection, "chat.add2", 4, player.UserIDString, "You executed a custom command!", "#5af");
        return true;
    }
    else
    {
        // If the command is not handled, return false to indicate that it was not processed.
        return false;
    }
}
```

This example shows how you can handle a custom command `/mycustomcmd` by sending a chat message to the player who executed the command.
```

### Source Code from the Library

```csharp

	internal static bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)
	{
		if (!player)
		{
			player = null;
		}
		if (!enabled)
		{
			return false;
		}
		if (player != null && player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return false;
		}
		ServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;
		if (userGroup == ServerUsers.UserGroup.Banned)
		{
			return false;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0)
		{
			return false;
		}
		if (text.StartsWith("/") || text.StartsWith("\\"))
		{
			Interface.CallHook("IOnPlayerCommand", player, message);
			return false;
		}
		text = text.EscapeRichText();
		object obj = Interface.CallHook("IOnPlayerChat", userId, username, text, targetChannel, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured(ConsoleColor.DarkYellow, string.Concat("[", targetChannel, "] ", username, ": "), ConsoleColor.DarkGreen, text);
			string text2 = player?.ToString() ?? $"{username}[{userId}]";
			switch (targetChannel)
			{
			case ChatChannel.Team:
				DebugEx.Log("[TEAM CHAT] " + text2 + " : " + text);
				break;
			case ChatChannel.Cards:
				DebugEx.Log("[CARDS CHAT] " + text2 + " : " + text);
				break;
			default:
				DebugEx.Log("[CHAT] " + text2 + " : " + text);
				break;
			}
		}
		bool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;
		bool num = ((player != null) ? player.IsDeveloper : DeveloperList.Contains(userId));
		string text3 = "#5af";
		if (flag)
		{
			text3 = "#af5";
		}
		if (num)
		{
			text3 = "#fa5";
		}
		string text4 = username.EscapeRichText();
		ChatEntry ce = default(ChatEntry);
		ce.Channel = targetChannel;
		ce.Message = text;
		ce.UserId = ((player != null) ? player.UserIDString : userId.ToString());
		ce.Username = username;
		ce.Color = text3;
		ce.Time = Epoch.Current;
		Record(ce);
		switch (targetChannel)
		{
		case ChatChannel.Cards:
		{
			if (player == null)
			{
				return false;
			}
			if (!player.isMounted)
			{
				return false;
			}
			BaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;
			if (baseCardGameEntity == null || !baseCardGameEntity.GameController.IsAtTable(player))
			{
				return false;
			}
			List<Network.Connection> obj2 = Facepunch.Pool.GetList<Network.Connection>();
			baseCardGameEntity.GameController.GetConnectionsInGame(obj2);
			if (obj2.Count > 0)
			{
				ConsoleNetwork.SendClientCommand(obj2, "chat.add2", 3, userId, text, text4, text3, 1f);
			}
			Facepunch.Pool.FreeList(ref obj2);
			return true;
		}
		case ChatChannel.Global:
			ConsoleNetwork.BroadcastToAllClients("chat.add2", 0, userId, text, text4, text3, 1f);
			return true;
		case ChatChannel.Local:
		{
			if (!(player != null))
			{
				break;
			}
			float num2 = localChatRange * localChatRange;
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				float sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;
				if (!(sqrMagnitude > num2))
				{
					ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", 4, userId, text, text4, text3, Mathf.Clamp01(sqrMagnitude / num2 + 0.2f));
				}
			}
			return true;
		}
		case ChatChannel.Team:
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);
			if (playerTeam == null)
			{
				return false;
			}
			List<Network.Connection> onlineMemberConnections = playerTeam.GetOnlineMemberConnections();
			if (onlineMemberConnections != null)
			{
				ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add2", 1, userId, text, text4, text3, 1f);
			}
			playerTeam.BroadcastTeamChat(userId, text4, text, text3);
			return true;
		}
		}
		return false;
	}

```

## OnTurretModeToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when the turret mode is toggled.
/// </summary>
/// <param name="turret">The AutoTurret instance whose mode was toggled.</param>
/// <returns>No return behavior.</returns>
void OnTurretModeToggle(AutoTurret turret)
{
    Puts($"Turret {turret.GetGlobalName()} mode toggled to {(turret.GetFlag(Flags.Reserved1) ? "Peacekeeper" : "Default")}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetPeacekeepermode(bool isOn)
	{
		if (PeacekeeperMode() != isOn)
		{
			SetFlag(Flags.Reserved1, isOn);
			Effect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Interface.CallHook("OnTurretModeToggle", this);
		}
	}

```

## OnEntityLeave(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger comfort.
/// </summary>
/// <param name="trigger">The trigger that was left.</param>
/// <param name="entity">The entity that left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has left the comfort zone of trigger {trigger.name}");
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityLeave(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			_players.Remove(basePlayer);
		}
	}

```

## OnBradleyApcPatrol(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is patrolling.
/// </summary>
/// <param name="apc">The Bradley APC performing the patrol.</param>
/// <returns>
/// Returns `null` to allow the patrol to continue as normal, or any non-null value to override the default patrol behavior.
/// If a string is returned, it will be used as a message to display in the console.
/// </returns>
object OnBradleyApcPatrol(BradleyAPC apc)
{
    Puts($"Bradley APC {apc.GetId()} is patrolling.");
    if (apc.GetPosition() == Vector3.zero)
    {
        Puts("Bradley APC has reached its final destination.");
        return "Bradley APC has reached its final destination.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Patrol()
	{
		if (patrolPath == null || UnityEngine.Time.time < nextPatrolTime)
		{
			return;
		}
		nextPatrolTime = UnityEngine.Time.time + 20f;
		if ((HasPath() && !IsAtFinalDestination()) || Interface.CallHook("OnBradleyApcPatrol", this) != null)
		{
			return;
		}
		IAIPathInterestNode randomInterestNodeAwayFrom = patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position);
		IAIPathNode closestToPoint = patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);
		bool flag = false;
		List<IAIPathNode> nodes = Facepunch.Pool.GetList<IAIPathNode>();
		IAIPathNode iAIPathNode;
		if (GetEngagementPath(ref nodes))
		{
			flag = true;
			iAIPathNode = nodes[nodes.Count - 1];
		}
		else
		{
			iAIPathNode = patrolPath.GetClosestToPoint(base.transform.position);
		}
		if (!(Vector3.Distance(finalDestination, closestToPoint.Position) > 2f))
		{
			return;
		}
		if (closestToPoint == iAIPathNode)
		{
			currentPath.Clear();
			currentPath.Add(closestToPoint.Position);
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
		else
		{
			if (!AStarPath.FindPath(iAIPathNode, closestToPoint, out var path, out var _))
			{
				return;
			}
			currentPath.Clear();
			if (flag)
			{
				for (int i = 0; i < nodes.Count - 1; i++)
				{
					currentPath.Add(nodes[i].Position);
				}
			}
			foreach (IAIPathNode item in path)
			{
				currentPath.Add(item.Position);
			}
			currentPathIndex = -1;
			pathLooping = false;
			finalDestination = closestToPoint.Position;
		}
	}

```

## OnAdventGiftAwarded(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an Advent gift is awarded to a player.
/// </summary>
/// <param name="calendar">The Advent calendar instance.</param>
/// <param name="player">The player who received the gift.</param>
object OnAdventGiftAwarded(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been awarded an Advent gift from calendar {calendar.calendarName}.");
    if (player.userID == 1234567890) // Special case for a specific player
    {
        Puts($"Player {player.displayName} is not eligible for this gift.");
        return "Not Eligible";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AwardGift(BasePlayer player)
	{
		if (Interface.CallHook("OnAdventGiftAward", this, player) != null)
		{
			return;
		}
		DateTime now = DateTime.Now;
		int num = now.Day - startDay;
		if (now.Month == startMonth && num >= 0 && num < days.Length)
		{
			if (!playerRewardHistory.ContainsKey(player.userID))
			{
				playerRewardHistory.Add(player.userID, new List<int>());
			}
			playerRewardHistory[player.userID].Add(num);
			Effect.server.Run(giftEffect.resourcePath, player.transform.position);
			if (num >= 0 && num < crosses.Length)
			{
				Effect.server.Run(boxCloseEffect.resourcePath, base.transform.position + Vector3.up * 1.5f);
			}
			DayReward dayReward = days[num];
			for (int i = 0; i < dayReward.rewards.Length; i++)
			{
				ItemAmount itemAmount = dayReward.rewards[i];
				player.GiveItem(ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL), GiveItemReason.PickedUp);
			}
			Interface.CallHook("OnAdventGiftAwarded", this, player);
		}
	}

```

## OnPlayerSleepEnded(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's sleeping has ended.
/// </summary>
/// <param name="player">The player whose sleeping has ended.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnded(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has woken up from sleep.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is a VIP and will receive special treatment.");
        // Grant VIP privileges to the player
    }
    // Perform any other necessary actions when a player wakes up from sleep
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", this) == null)
		{
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if (userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			CancelInvoke(ScheduledDeath);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
			}
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", this);
			EACServer.LogPlayerSpawn(this);
		}
	}

```

## OnAmmoSwitch(BaseProjectile,BasePlayer,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when the player switches ammo for a projectile.
/// </summary>
/// <param name="projectile">The projectile being switched.</param>
/// <param name="player">The player switching the ammo.</param>
/// <param name="newAmmoDefinition">The new ammo definition to switch to.</param>
/// <returns>
/// Returns `null` if the ammo switch is allowed, or any non-null value to prevent the ammo switch.
/// </returns>
object OnAmmoSwitch(BaseProjectile projectile, BasePlayer player, ItemDefinition newAmmoDefinition)
{
    Puts($"Player {player.UserIDString} switched ammo for projectile {projectile.EntityID} to {newAmmoDefinition.itemid}.");
    if (newAmmoDefinition.itemid == "restricted_ammo")
    {
        Puts($"Player {player.displayName} is not allowed to switch to restricted ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SwitchAmmoTo(RPCMessage msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == primaryMagazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if (itemDefinition == null)
		{
			return;
		}
		ItemModProjectile component = itemDefinition.GetComponent<ItemModProjectile>();
		if ((bool)component && component.IsAmmo(primaryMagazine.definition.ammoTypes) && Interface.CallHook("OnAmmoSwitch", this, ownerPlayer, itemDefinition) == null)
		{
			if (primaryMagazine.contents > 0)
			{
				ownerPlayer.GiveItem(ItemManager.CreateByItemID(primaryMagazine.ammoType.itemid, primaryMagazine.contents, 0uL));
				primaryMagazine.contents = 0;
			}
			primaryMagazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			ownerPlayer.inventory.ServerUpdate(0f);
		}
	}

```

## OnEntityDeath(ResourceEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that died.</param>
/// <param name="hitInfo">Information about the hit that killed the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityDeath(ResourceEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.name} has died at position {hitInfo.position}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnKilled(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", this, info);
		Kill();
	}

```

## OnFireworkExhausted(BaseFirework)

```csharp
```csharp
/// <summary>
/// Called when a firework is exhausted.
/// </summary>
/// <param name="firework">The firework that has been exhausted.</param>
/// <returns>No return behavior.</returns>
void OnFireworkExhausted(BaseFirework firework)
{
    Puts($"Firework {firework.FireworkID} has been exhausted.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnExhausted()
	{
		SetFlag(Flags.Reserved8, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.OnFire, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.On, b: false, recursive: false, networkupdate: false);
		EnableGlobalBroadcast(wants: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkExhausted", this);
		Invoke(Cleanup, corpseDuration);
		_activeFireworks.Remove(this);
	}

```

## OnVehicleLockRequest(ModularCarGarage,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player requests to add a lock to a vehicle.
/// </summary>
/// <param name="garage">The modular car garage where the request is being made.</param>
/// <param name="player">The player making the request.</param>
/// <param name="lockType">The type of lock the player wants to add.</param>
/// <returns>
/// Returns `null` if the request should be processed normally. 
/// If a non-null value is returned, it will override the default behavior and prevent the lock from being added.
/// </returns>
object OnVehicleLockRequest(ModularCarGarage garage, BasePlayer player, string lockType)
{
    Puts($"Player {player.UserIDString} requested to add a {lockType} lock to the vehicle in {garage.name}.");
    if (lockType == "expensive")
    {
        Puts($"Player {player.displayName} does not have enough funds to purchase an expensive lock.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	public void RPC_RequestAddLock(RPCMessage msg)
	{
		if (!HasOccupant || carOccupant.CarLock.HasALock)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (player == null)
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("OnVehicleLockRequest", this, player, text) == null)
		{
			ItemAmount itemAmount = lockResourceCost;
			if ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && carOccupant.CarLock.TryAddALock(text, player.userID))
			{
				player.inventory.Take(null, itemAmount.itemDef.itemid, Mathf.CeilToInt(itemAmount.amount));
				Effect.server.Run(addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
	}

```

## OnServerInformationUpdated()

```csharp
```csharp
/// <summary>
/// Called when the server information is updated.
/// </summary>
void OnServerInformationUpdated()
{
    Puts("Server information has been updated.");
    // You can add custom logic here to handle the update event.
    // For example, you could send a notification to all connected clients.
    Interface.CallHook("OnServerInformationUpdated");
}
```
```

### Source Code from the Library

```csharp

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		using (TimeWarning.New("UpdateServerInformation"))
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.GetServerBrowserMapName();
			string text = "stok";
			if (Restarting)
			{
				text = "strst";
			}
			string text2 = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text3 = $"gm{GamemodeName()}";
			string text4 = (ConVar.Server.pve ? ",pve" : string.Empty);
			string text5 = ConVar.Server.tags?.Trim(',') ?? "";
			string text6 = ((!string.IsNullOrWhiteSpace(text5)) ? ("," + text5) : "");
			string text7 = BuildInfo.Current?.Scm?.ChangeId ?? "0";
			SteamServer.GameTags = $"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Network.Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},v{2388}{text4}{text6},h{AssemblyHash},{text},{text2},{text3},cs{text7}";
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = ConVar.Server.description.SplitToChunks(100).ToArray();
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			string value = World.Seed.ToString();
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			if (activeGameMode != null && !activeGameMode.ingameMap)
			{
				value = "0";
			}
			SteamServer.SetKey("world.seed", value);
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("logoimage", ConVar.Server.logoimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("uptime", ((int)UnityEngine.Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("ram_sys", (Performance.report.memoryUsageSystem / 1000000).ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
		Interface.CallHook("OnServerInformationUpdated");
	}

```

## OnQuarryGather(MiningQuarry,Item)

```csharp
```csharp
/// <summary>
/// Called when a quarry gathers an item.
/// </summary>
/// <param name="quarry">The mining quarry that gathered the item.</param>
/// <param name="item">The item that was gathered.</param>
/// <returns>
/// Returns `null` to allow the item to be processed normally, or any non-null value to override the default behavior.
/// If a non-null value is returned, it will be used as the reason for removing the item from the inventory.
/// </returns>
object OnQuarryGather(MiningQuarry quarry, Item item)
{
    Puts($"Quarry {quarry} gathered item {item.info.shortname}.");
    if (item.info.shortname == "Diamond")
    {
        Puts($"Quarry {quarry} gathered a rare diamond!");
        return "Diamonds are worth more than usual today.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ProcessResources()
	{
		if (_linkedDeposit == null || hopperPrefab.instance == null)
		{
			return;
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
		float num = Mathf.Min(workToAdd, pendingWork);
		pendingWork -= num;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			float workNeeded = resource.workNeeded;
			int num2 = Mathf.FloorToInt(resource.workDone / workNeeded);
			resource.workDone += num;
			int num3 = Mathf.FloorToInt(resource.workDone / workNeeded);
			if (resource.workDone > workNeeded)
			{
				resource.workDone %= workNeeded;
			}
			if (num2 != num3)
			{
				int iAmount = num3 - num2;
				Item item = ItemManager.Create(resource.type, iAmount, 0uL);
				Facepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);
				if (Interface.CallHook("OnQuarryGather", this, item) != null)
				{
					item.Remove();
				}
				else if (!item.MoveToContainer(hopperPrefab.instance.GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
	}

```

## OnVehicleModuleSelect(Item,ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is selected.
/// </summary>
/// <param name="vehicleItem">The item representing the vehicle.</param>
/// <param name="garage">The modular car garage where the selection occurred.</param>
/// <param name="player">The player who made the selection.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the module will be selected as normal.
/// </returns>
object OnVehicleModuleSelect(Item vehicleItem, ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.displayName} has selected the {vehicleItem.name} module in the {garage.name} garage.");
    if (vehicleItem.name == "Prohibited Module")
    {
        Puts($"Player {player.displayName} attempted to select a prohibited module. Access denied.");
        return "Access Denied: Prohibited Module";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!ObjectEx.IsUnityNull(container))
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!ObjectEx.IsUnityNull(container2))
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## CanAffordUpgrade(BasePlayer,BuildingBlock,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can afford an upgrade.
/// </summary>
/// <param name="player">The player attempting the upgrade.</param>
/// <param name="blockDefinition">The block definition being upgraded.</param>
/// <param name="grade">The grade of the upgrade.</param>
/// <param name="skin">The skin ID of the upgrade.</param>
/// <returns>
/// Returns `true` if the player can afford the upgrade, or `false` otherwise.
/// If a non-bool value is returned, it will be used as the result instead.
/// </returns>
object CanAffordUpgrade(BasePlayer player, BuildingBlock blockDefinition, BuildingGrade.Enum grade, ulong skin)
{
    Puts($"Checking if {player.UserIDString} can afford upgrade to {grade} with skin {skin}");
    object obj = Interface.CallHook("CanAffordUpgrade", player, blockDefinition, grade, skin);
    if (obj is bool)
    {
        return obj;
    }
    // Check if the player has enough resources
    foreach (ItemAmount item in blockDefinition.GetGrade(grade, skin).costToBuild)
    {
        if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
        {
            Puts($"Player {player.UserIDString} does not have enough resources to afford upgrade");
            return false;
        }
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAffordUpgrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanAffordUpgrade", player, this, iGrade, iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount item in blockDefinition.GetGrade(iGrade, iSkin).costToBuild)
		{
			if ((float)player.inventory.GetAmount(item.itemid) < item.amount)
			{
				return false;
			}
		}
		return true;
	}

```

## CanLootEntity(BasePlayer,ContainerIOEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, ContainerIOEntity entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.name}");
    if (entity.isLocked && !player.IsAdmin())
    {
        Puts($"Player {player.displayName} does not have permission to loot locked entity {entity.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (needsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if (onlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (panelToOpen == "")
		{
			panelToOpen = lootPanelName;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnEntityFromOwnerCheck(BaseEntity,BasePlayer,uint,string)

```csharp
```csharp
/// <summary>
/// Called when checking if an entity is from the owner.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <param name="owner">The owner of the entity.</param>
/// <param name="id">The ID of the entity or owner.</param>
/// <param name="debugName">A debug name for the entity or owner.</param>
/// <returns>
/// Returns `true` if the entity is from the owner, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object OnEntityFromOwnerCheck(BaseEntity entity, BasePlayer owner, uint id, string debugName)
{
    Puts($"Checking if {entity.name} ({debugName}) from {owner.displayName} ({id}) is valid.");
    // Custom logic to determine if the entity is from the owner
    return true;
}
```
```

### Source Code from the Library

```csharp
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityFromOwnerCheck", ent, player, id, debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				return true;
			}

```

## OnCupboardAuthorize(BuildingPrivlidge,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is authorized to access a cupboard.
/// </summary>
/// <param name="cupboard">The cupboard being accessed.</param>
/// <param name="player">The player accessing the cupboard.</param>
/// <returns>
/// Returns `null` to allow the player to access the cupboard, or any non-null value to prevent them from accessing it.
/// </returns>
object OnCupboardAuthorize(BuildingPrivlidge cupboard, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has been authorized to access cupboard {cupboard.entityID}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and can always access the cupboard");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal void OnDeployed(BaseEntity ent, BasePlayer player)
	{
		if (player.IsValid() && !string.IsNullOrEmpty(UnlockAchievement))
		{
			player.GiveAchievement(UnlockAchievement);
		}
		if (ent is BuildingPrivlidge buildingPrivlidge && Interface.CallHook("OnCupboardAuthorize", buildingPrivlidge, player) == null)
		{
			buildingPrivlidge.AddPlayer(player);
		}
	}

```

## OnEntityMarkHostile(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when an entity is marked as hostile.
/// </summary>
/// <param name="entity">The entity being marked as hostile.</param>
/// <param name="duration">The duration for which the entity will be marked as hostile, in seconds.</param>
/// <returns>
/// Returns `null` to allow the entity to be marked as hostile, or any non-null value to prevent it from being marked.
/// </returns>
object OnEntityMarkHostile(BasePlayer entity, float duration)
{
    Puts($"Entity {entity.UserIDString} has been marked as hostile for {duration} seconds.");
    if (duration > 120f)
    {
        Puts($"Entity {entity.UserIDString} will be marked as hostile for more than 2 minutes.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", this, duration) == null)
		{
			double currentTimestamp = TimeEx.currentTimestamp;
			double val = currentTimestamp + (double)duration;
			State.unHostileTimestamp = Math.Max(State.unHostileTimestamp, val);
			DirtyPlayerState();
			double num = Math.Max(State.unHostileTimestamp - currentTimestamp, 0.0);
			ClientRPCPlayer(null, this, "SetHostileLength", (float)num);
		}
	}

```

## OnSendModelState(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the client needs to send the player's current state.
/// </summary>
/// <param name="player">The player whose state is being sent.</param>
/// <returns>
/// Returns `null` to allow the state to be sent, or any non-null value to prevent the state from being sent.
/// </returns>
object OnSendModelState(BasePlayer player)
{
    Puts($"Sending model state for player {player.UserIDString}.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.UserIDString} is an admin and their state will not be sent.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendModelState(bool force = false)
	{
		if (!force && (!wantsSendModelState || nextModelStateUpdate > UnityEngine.Time.time))
		{
			return;
		}
		wantsSendModelState = false;
		nextModelStateUpdate = UnityEngine.Time.time + 0.1f;
		if (!IsDead() && !IsSpectating())
		{
			modelState.sleeping = IsSleeping();
			modelState.mounted = isMounted;
			modelState.relaxed = IsRelaxed();
			modelState.onPhone = HasActiveTelephone && !activeTelephone.IsMobile;
			modelState.crawling = IsCrawling();
			if (!base.limitNetworking && Interface.CallHook("OnSendModelState", this) == null)
			{
				ClientRPC(null, "OnModelState", modelState);
			}
		}
	}

```

## OnFireworkDesignChange(PatternFirework,ProtoBuf.PatternFirework.Design,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a firework design is changed.
/// </summary>
/// <param name="design">The new firework design.</param>
/// <param name="player">The player who made the change.</param>
/// <returns>
/// Returns `null` to allow the design change, or any non-null value to prevent the design from being updated.
/// </returns>
object OnFireworkDesignChange(ProtoBuf.PatternFirework.Design design, BasePlayer player)
{
    Puts($"Firework design changed by {player.displayName}.");
    if (design.stars.Count > 10)
    {
        Puts($"Firework design has too many stars. Limiting to 10.");
        while (design.stars.Count > 10)
        {
            int index = design.stars.Count - 1;
            design.stars[index].Dispose();
            design.stars.RemoveAt(index);
        }
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		ProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);
		if (Interface.CallHook("OnFireworkDesignChange", this, design, rpc.player) != null)
		{
			return;
		}
		if (design?.stars != null)
		{
			while (design.stars.Count > MaxStars)
			{
				int index = design.stars.Count - 1;
				design.stars[index].Dispose();
				design.stars.RemoveAt(index);
			}
			foreach (ProtoBuf.PatternFirework.Star star in design.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			design.editedBy = rpc.player.userID;
		}
		Design?.Dispose();
		Design = design;
		Interface.CallHook("OnFireworkDesignChanged", this, design, rpc.player);
		SendNetworkUpdateImmediate();
	}

```

## CanVendingAcceptItem(VendingMachine,Item,int)

```csharp
```csharp
/// <summary>
/// Called to determine if a vending machine can accept an item.
/// </summary>
/// <param name="vendingMachine">The vending machine attempting to accept the item.</param>
/// <param name="item">The item being attempted to be accepted.</param>
/// <param name="targetSlot">The slot on the vending machine where the item is being placed.</param>
/// <returns>
/// Returns `true` if the vending machine can accept the item, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior and be used as the return value.
/// </returns>
object CanVendingAcceptItem(VendingMachine vendingMachine, Item item, int targetSlot)
{
    Puts($"Vending machine {vendingMachine.name} attempting to accept item {item.displayName} into slot {targetSlot}");
    if (item.isIndustrial && !industrialItemsAllowed)
    {
        Puts($"Vending machine {vendingMachine.name} cannot accept industrial items");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanVendingAcceptItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BasePlayer ownerPlayer = item.GetOwnerPlayer();
		if (transactionActive || industrialItemIncoming)
		{
			return true;
		}
		if (item.parent == null)
		{
			return true;
		}
		if (base.inventory.itemList.Contains(item))
		{
			return true;
		}
		if (ownerPlayer == null)
		{
			return false;
		}
		return CanPlayerAdmin(ownerPlayer);
	}

```

## OnItemAddedToContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is added to a container.
/// </summary>
/// <param name="container">The container that the item was added to.</param>
/// <param name="item">The item that was added to the container.</param>
/// <returns>No return behavior.</returns>
void OnItemAddedToContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been added to container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Insert(Item item)
	{
		if (itemList.Contains(item))
		{
			return false;
		}
		if (IsFull())
		{
			return false;
		}
		itemList.Add(item);
		item.parent = this;
		if (!FindPosition(item))
		{
			return false;
		}
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: true);
		}
		Interface.CallHook("OnItemAddedToContainer", this, item);
		return true;
	}

```

## OnFeedbackReported(BasePlayer,string,string,Facepunch.Models.ReportType)

```csharp
```csharp
/// <summary>
/// Called when a player reports feedback.
/// </summary>
/// <param name="player">The player who reported the feedback.</param>
/// <param name="subject">The subject of the feedback report.</param>
/// <param name="message">The message of the feedback report.</param>
/// <param name="reportType">The type of the feedback report (e.g. bug, suggestion, etc.).</param>
/// <returns>
/// Returns a non-null value to override the default reporting behavior.
/// If `null` is returned, the feedback is reported as normal.
/// </returns>
object OnFeedbackReported(BasePlayer player, string subject, string message, ReportType reportType)
{
    Puts($"Player {player.displayName} has reported feedback: {subject}, {message}, {reportType}");
    if (reportType == ReportType.Bug && !string.IsNullOrEmpty(message))
    {
        Puts($"Player {player.displayName} has reported a bug with the following message: {message}");
        return "Bug reported";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnFeedbackReport(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		ReportType reportType = (ReportType)Mathf.Clamp(msg.read.Int32(), 0, 5);
		if (ConVar.Server.printReportsToConsole)
		{
			DebugEx.Log($"[FeedbackReport] {this} reported {reportType} - \"{text}\" \"{text2}\"");
			RCon.Broadcast(RCon.LogType.Report, new
			{
				PlayerId = UserIDString,
				PlayerName = displayName,
				Subject = text,
				Message = text2,
				Type = reportType
			});
		}
		if (!string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))
		{
			string image = msg.read.StringMultiLine(60000);
			Facepunch.Models.Feedback feedback = default(Facepunch.Models.Feedback);
			feedback.Type = reportType;
			feedback.Message = text2;
			feedback.Subject = text;
			Facepunch.Models.Feedback feedback2 = feedback;
			feedback2.AppInfo.Image = image;
			Facepunch.Feedback.ServerReport(ConVar.Server.reportsServerEndpoint, userID, ConVar.Server.reportsServerEndpointKey, feedback2);
		}
		Interface.CallHook("OnFeedbackReported", this, text, text2, reportType);
	}

```

## OnQueueCycle(int)

```csharp
```csharp
/// <summary>
/// Called when the game's queue is cycled.
/// </summary>
/// <param name="availableSlots">The number of available slots in the game.</param>
/// <returns>
/// Returns `null` to allow the queue cycle to proceed normally, or any non-null value to cancel the cycle.
/// </returns>
object OnQueueCycle(int availableSlots)
{
    Puts($"Game queue cycled with {availableSlots} available slots.");
    if (availableSlots == 0)
    {
        Puts("No available slots in game. Queue cycle cancelled.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Cycle(int availableSlots)
	{
		if (Interface.CallHook("OnQueueCycle", availableSlots) == null && queue.Count != 0)
		{
			if (availableSlots - Joining > 0)
			{
				JoinGame(queue[0]);
			}
			SendMessages();
		}
	}

```

## OnBuildingMerge(ServerBuildingManager,BuildingManager.Building,BuildingManager.Building)

```csharp
```csharp
/// <summary>
/// Called when two buildings are merged into one.
/// </summary>
/// <param name="serverBuildingManager">The server's building manager.</param>
/// <param name="building1">The first building being merged.</param>
/// <param name="building2">The second building being merged.</param>
/// <returns>No return behavior.</returns>
void OnBuildingMerge(ServerBuildingManager serverBuildingManager, Building building1, Building building2)
{
    Puts($"Merging buildings {building1.ID} and {building2.ID} into one.");
    if (building1.HasDecayEntities() && building2.HasDecayEntities())
    {
        Puts($"Both buildings have decay entities. Attaching them to the merged building.");
        foreach (var entity in building2.decayEntities)
        {
            entity.AttachToBuilding(building1.ID);
        }
    }
    if (AI.nav_carve_use_building_optimization)
    {
        Puts($"Updating nav mesh carving for both buildings after merge.");
        building1.isNavMeshCarvingDirty = true;
        building2.isNavMeshCarvingDirty = true;
        int ticks = 3;
        UpdateNavMeshCarver(building1, ref ticks, 0);
        UpdateNavMeshCarver(building1, ref ticks, 0);
    }
}
```
```

### Source Code from the Library

```csharp

	private void Merge(Building building1, Building building2)
	{
		Interface.CallHook("OnBuildingMerge", this, building1, building2);
		while (building2.HasDecayEntities())
		{
			building2.decayEntities[0].AttachToBuilding(building1.ID);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building1.isNavMeshCarvingDirty = true;
			building2.isNavMeshCarvingDirty = true;
			int ticks = 3;
			UpdateNavMeshCarver(building1, ref ticks, 0);
			UpdateNavMeshCarver(building1, ref ticks, 0);
		}
	}

```

## CanLock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called when a player tries to lock the object.
/// </summary>
/// <param name="player">The player attempting to lock the object.</param>
/// <param name="lockObject">The CodeLock object being locked.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(BasePlayer player, CodeLock lockObject)
{
    Puts($"Player {player.UserIDString} is trying to lock the code lock.");
    if (lockObject.IsLocked())
    {
        Puts($"The code lock is already locked by another player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && !IsLocked() && code.Length == 4 && Interface.CallHook("CanLock", rpc.player, this) == null && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectLocked.resourcePath);
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
		}
	}

```

## OnCrateDropped(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a crate is dropped.
/// </summary>
/// <param name="crate">The crate that was dropped.</param>
/// <returns>No return behavior.</returns>
void OnCrateDropped(HackableLockedCrate crate)
{
    Puts($"Crate {crate.CrateID} has been dropped.");
}
```
```

### Source Code from the Library

```csharp

	public void SetWasDropped()
	{
		wasDropped = true;
		Interface.CallHook("OnCrateDropped", this);
	}

```

## OnConnectionDequeue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a connection is dequeued from the server.
/// </summary>
/// <param name="connection">The connection being dequeued.</param>
/// <returns>
/// Returns `null` to allow the connection to be dequeued, or any non-null value to prevent it from being dequeued.
/// </returns>
object OnConnectionDequeue(Network.Connection connection)
{
    Puts($"Connection {connection.ID} has been dequeued.");
    if (connection.ID == "blocked_connection")
    {
        Puts($"Connection {connection.ID} was blocked from dequeuing.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RemoveConnection(Connection connection)
	{
		if (Interface.CallHook("OnConnectionDequeue", connection) == null)
		{
			if (queue.Remove(connection))
			{
				nextMessageTime = 0f;
			}
			joining.Remove(connection);
		}
	}

```

## OnSendCommand(Network.Connection,string,object[])

```csharp
```csharp
/// <summary>
/// Called when a client sends a command to the server.
/// </summary>
/// <param name="connection">The connection of the client sending the command.</param>
/// <param name="command">The command being sent.</param>
/// <param name="args">Any arguments associated with the command.</param>
/// <returns>
/// Returns `null` to allow the command to be processed, or any non-null value to prevent the command from being processed.
/// </returns>
object OnSendCommand(Connection connection, string command, params object[] args)
{
    Puts($"Client {connection.UserIDString} sent command: {command} with arguments: [{string.Join(", ", args)}]");
    if (command == "kick")
    {
        Puts($"Client {connection.UserIDString} is not allowed to use the kick command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(Connection cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnSendCommand", cn, strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			string val = ConsoleSystem.BuildCommand(strCommand, args);
			netWrite.String(val);
			netWrite.Send(new SendInfo(cn));
		}
	}

```

## OnLootNetworkUpdate(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when the loot network is updated.
/// </summary>
/// <param name="loot">The updated loot data.</param>
/// <returns>No return behavior.</returns>
void OnLootNetworkUpdate(PlayerLoot loot)
{
    Puts($"Loot network updated with entity ID {loot.entityID} and item ID {loot.itemID}");
    if (loot.containers != null && loot.containers.Count > 0)
    {
        Puts($"Containers updated: {string.Join(", ", loot.containers.Select(c => c.containerType))}");
    }
}
```
```

### Source Code from the Library

```csharp

	private void SendUpdate()
	{
		isInvokingSendUpdate = false;
		if (!base.baseEntity.IsValid() || Interface.CallHook("OnLootNetworkUpdate", this) != null)
		{
			return;
		}
		using PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>();
		if ((bool)entitySource && entitySource.net != null)
		{
			playerUpdateLoot.entityID = entitySource.net.ID;
		}
		if (itemSource != null)
		{
			playerUpdateLoot.itemID = itemSource.uid;
		}
		if (containers.Count > 0)
		{
			playerUpdateLoot.containers = Pool.Get<List<ProtoBuf.ItemContainer>>();
			foreach (ItemContainer container in containers)
			{
				playerUpdateLoot.containers.Add(container.Save());
			}
		}
		base.baseEntity.ClientRPCPlayer(null, base.baseEntity, "UpdateLoot", playerUpdateLoot);
	}

```

## CanUnlockTechTreeNode(BasePlayer,TechTreeData.NodeInstance,TechTreeData)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a specific tech tree node.
/// </summary>
/// <param name="player">The player attempting to unlock the node.</param>
/// <param name="node">The tech tree node being unlocked.</param>
/// <param name="techTreeData">The data for the tech tree.</param>
/// <returns>
/// Returns `true` if the player can unlock the node, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the return value.
/// </returns>
object CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)
{
    Puts($"Player {player.UserIDString} attempting to unlock tech tree node {node.Name}");
    if (techTreeData.IsNodeLocked(node))
    {
        return false;
    }
    object obj = Interface.CallHook("CanUnlockTechTreeNode", player, node, techTreeData);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerCanUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNode", player, node, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerHasPathForUnlock(player, node))
		{
			return !HasPlayerUnlocked(player, node);
		}
		return false;
	}

```

## CanBeTargeted(BaseCombatEntity,AutoTurret)

```csharp
```csharp
/// <summary>
/// Called to check if a target can be targeted by the turret.
/// </summary>
/// <param name="target">The target entity.</param>
/// <param name="turret">The turret entity.</param>
/// <returns>
/// Returns `true` if the target can be targeted, `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BaseCombatEntity target, AutoTurret turret)
{
    Puts($"Checking if {target} can be targeted by {turret}.");
    if (target == null || turret == null)
    {
        return false;
    }
    // Add custom logic here to determine if the target can be targeted
    // For example:
    if (target.isClient || target.ShouldBeBlocked(turret))
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		object obj2 = Interface.CallHook("CanBeTargeted", obj, this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		List<RaycastHit> obj3 = Facepunch.Pool.GetList<RaycastHit>();
		Vector3 position = eyePos.transform.position;
		if (GamePhysics.CheckSphere(position, 0.1f, 2097152))
		{
			return false;
		}
		Vector3 vector = AimOffset(obj);
		float num = Vector3.Distance(vector, position);
		Vector3 vector2 = Vector3.Cross((vector - position).normalized, Vector3.up);
		for (int i = 0; (float)i < (CheckPeekers() ? 3f : 1f); i++)
		{
			Vector3 normalized = (vector + vector2 * visibilityOffsets[i] - position).normalized;
			obj3.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized), 0f, obj3, num * 1.1f, 1218652417);
			for (int j = 0; j < obj3.Count; j++)
			{
				BaseEntity entity = RaycastHitEx.GetEntity(obj3[j]);
				if ((!(entity != null) || !entity.isClient) && (!(entity != null) || !(entity.ToPlayer() != null) || entity.EqualNetID(obj)) && (!(entity != null) || !entity.EqualNetID(this)))
				{
					if (entity != null && (entity == obj || entity.EqualNetID(obj)))
					{
						Facepunch.Pool.FreeList(ref obj3);
						peekIndex = i;
						return true;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj3);
		return false;
	}

```

## IOnBasePlayerAttacked(BasePlayer,HitInfo)

```csharp
Based on the provided code snippet, I will create a method structure for `IOnBasePlayerAttacked` with minimal code to demonstrate functionality.

```csharp
/// <summary>
/// Called when a player is attacked.
/// </summary>
/// <param name="info">Information about the attack.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If a string is returned, the player will be kicked with the provided message as the reason. 
/// If `null` is returned, the player is handled as normal.
/// </returns>
object IOnBasePlayerAttacked(HitInfo info)
{
    Puts("IOnBasePlayerAttacked called!");
    
    // Minimal code to demonstrate functionality
    if (info.Initiator != null && info.Initiator != this)
    {
        info.damageTypes.ScaleAll(0f);
    }
    
    return null;
}
```

Note that the `return` statement is omitted since the method's return type is not explicitly specified in the provided code snippet. If you want to specify a return type, please let me know and I'll be happy to assist you further.
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("IOnBasePlayerAttacked", this, info) != null)
		{
			return;
		}
		float oldHealth = base.health;
		if (InSafeZone() && !IsHostile() && info.Initiator != null && info.Initiator != this)
		{
			info.damageTypes.ScaleAll(0f);
		}
		if (base.isServer)
		{
			HitArea boneArea = info.boneArea;
			if (boneArea != (HitArea)(-1))
			{
				List<Item> obj = Facepunch.Pool.GetList<Item>();
				obj.AddRange(inventory.containerWear.itemList);
				for (int i = 0; i < obj.Count; i++)
				{
					Item item = obj[i];
					if (item != null)
					{
						ItemModWearable component = item.info.GetComponent<ItemModWearable>();
						if (!(component == null) && component.ProtectsArea(boneArea))
						{
							item.OnAttacked(info);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
				inventory.ServerUpdate(0f);
			}
		}
		base.OnAttacked(info);
		if (base.isServer && base.isServer && info.hasDamage)
		{
			if (!info.damageTypes.Has(DamageType.Bleeding) && info.damageTypes.IsBleedCausing() && !IsWounded() && !IsImmortalTo(info))
			{
				metabolism.bleeding.Add(info.damageTypes.Total() * 0.2f);
			}
			if (isMounted)
			{
				GetMounted().MounteeTookDamage(this, info);
			}
			CheckDeathCondition(info);
			if (net != null && net.connection != null)
			{
				ClientRPCPlayer(null, this, "TakeDamageHit");
			}
			string text = StringPool.Get(info.HitBone);
			bool flag = Vector3.Dot((info.PointEnd - info.PointStart).normalized, eyes.BodyForward()) > 0.4f;
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((bool)initiatorPlayer && !info.damageTypes.IsMeleeType())
			{
				initiatorPlayer.LifeStoryShotHit(info.Weapon);
			}
			if (info.isHeadshot)
			{
				if (flag)
				{
					SignalBroadcast(Signal.Flinch_RearHead, string.Empty);
				}
				else
				{
					SignalBroadcast(Signal.Flinch_Head, string.Empty);
				}
				if (!initiatorPlayer || !initiatorPlayer.limitNetworking)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/headshot.prefab", this, 0u, new Vector3(0f, 2f, 0f), Vector3.zero, (initiatorPlayer != null) ? initiatorPlayer.net.connection : null);
				}
				if ((bool)initiatorPlayer)
				{
					initiatorPlayer.stats.Add("headshot", 1, (Stats)5);
					if (initiatorPlayer.IsBeingSpectated)
					{
						foreach (BaseEntity child in initiatorPlayer.children)
						{
							if (child is BasePlayer basePlayer)
							{
								basePlayer.ClientRPCPlayer(null, basePlayer, "SpectatedPlayerHeadshot");
							}
						}
					}
				}
			}
			else if (flag)
			{
				SignalBroadcast(Signal.Flinch_RearTorso, string.Empty);
			}
			else if (text == "spine" || text == "spine2")
			{
				SignalBroadcast(Signal.Flinch_Stomach, string.Empty);
			}
			else
			{
				SignalBroadcast(Signal.Flinch_Chest, string.Empty);
			}
		}
		if (stats != null)
		{
			if (IsWounded())
			{
				stats.combat.LogAttack(info, "wounded", oldHealth);
			}
			else if (IsDead())
			{
				stats.combat.LogAttack(info, "killed", oldHealth);
			}
			else
			{
				stats.combat.LogAttack(info, "", oldHealth);
			}
		}
		if (ConVar.Global.cinematicGingerbreadCorpses)
		{
			info.HitMaterial = ConVar.Global.GingerbreadMaterialID();
		}
	}

```

## OnMlrsFire(MLRS,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the MLRS fires a rocket.
/// </summary>
/// <param name="mlrs">The MLRS instance that fired the rocket.</param>
/// <param name="owner">The player who owns the MLRS.</param>
/// <returns>
/// Returns `null` to allow the MLRS to fire normally, or any non-null value to prevent it from firing.
/// </returns>
object OnMlrsFire(MLRS mlrs, BasePlayer owner)
{
    Puts($"MLRS {mlrs.GetId()} fired a rocket owned by player {owner.UserIDString}");
    if (owner.IsAdmin())
    {
        Puts($"Player {owner.displayName} is an admin and cannot fire the MLRS");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !(_mounted == null) && Interface.CallHook("OnMlrsFire", this, owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			InvokeRepeating(FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", this, owner);
		}
	}

```

## OnFlameThrowerBurn(FlameThrower,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a flame thrower burns an entity.
/// </summary>
/// <param name="flameThrower">The flame thrower that caused the burn.</param>
/// <param name="entity">The entity that was burned.</param>
object OnFlameThrowerBurn(FlameThrower flameThrower, BaseEntity entity)
{
    Puts($"Entity {entity.EntityID} has been burned by flame thrower {flameThrower.EntityID}.");
    if (entity.IsPlayer)
    {
        // Handle player burn
        return;
    }
    else
    {
        // Handle non-player entity burn
        return;
    }
}
```
```

### Source Code from the Library

```csharp

	public void FlameTick()
	{
		float num = UnityEngine.Time.realtimeSinceStartup - lastFlameTick;
		lastFlameTick = UnityEngine.Time.realtimeSinceStartup;
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		ReduceAmmo(num);
		SendNetworkUpdate();
		Ray ray = ownerPlayer.eyes.BodyRay();
		Vector3 origin = ray.origin;
		RaycastHit hitInfo;
		bool num2 = UnityEngine.Physics.SphereCast(ray, 0.3f, out hitInfo, flameRange, 1218652417);
		if (!num2)
		{
			hitInfo.point = origin + ray.direction * flameRange;
		}
		float num3 = (ownerPlayer.IsNpc ? npcDamageScale : 1f);
		float amount = damagePerSec[0].amount;
		damagePerSec[0].amount = amount * num * num3;
		DamageUtil.RadiusDamage(ownerPlayer, LookupPrefab(), hitInfo.point - ray.direction * 0.1f, flameRadius * 0.5f, flameRadius, damagePerSec, 2279681, useLineOfSight: true);
		damagePerSec[0].amount = amount;
		if (num2 && UnityEngine.Time.realtimeSinceStartup >= nextFlameTime && hitInfo.distance > 1.1f)
		{
			nextFlameTime = UnityEngine.Time.realtimeSinceStartup + 0.45f;
			Vector3 point = hitInfo.point;
			BaseEntity baseEntity = GameManager.server.CreateEntity(fireballPrefab.resourcePath, point - ray.direction * 0.25f);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnFlameThrowerBurn", this, baseEntity);
				baseEntity.creatorEntity = ownerPlayer;
				baseEntity.Spawn();
			}
		}
		if (ammo == 0)
		{
			SetFlameState(wantsOn: false);
		}
		GetOwnerItem()?.LoseCondition(num);
	}

```

## CanLootEntity(BasePlayer,LootableCorpse)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted (in this case, a corpse).</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, LootableCorpse entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot corpse {entity.GetGlobalID()}");
    if (player.IsAdmin())
    {
        return null;
    }
    else
    {
        return "You do not have permission to loot this entity.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_LootCorpse(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!player || !player.CanInteract() || !CanLoot() || containers == null || Interface.CallHook("CanLootEntity", player, this) != null || !player.inventory.loot.StartLootingEntity(this))
		{
			return;
		}
		SetFlag(Flags.Open, b: true);
		for (int i = 0; i < containers.Length; i++)
		{
			ItemContainer itemContainer = containers[i];
			if (CanLootContainer(itemContainer, i))
			{
				player.inventory.loot.AddContainer(itemContainer);
			}
		}
		player.inventory.loot.SendImmediate();
		ClientRPCPlayer(null, player, "RPC_ClientLootCorpse");
		SendNetworkUpdate();
	}

```

## OnTeamUpdate(ulong,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's team is updated.
/// </summary>
/// <param name="oldTeam">The player's old team.</param>
/// <param name="newTeam">The player's new team.</param>
/// <param name="player">The player whose team was updated.</param>
/// <returns>
/// Returns `null` to allow the team update, or any non-null value to prevent the team from being updated.
/// </returns>
object OnTeamUpdate(ulong oldTeam, ulong newTeam, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has changed teams from {oldTeam} to {newTeam}");
    if (newTeam == 1234567890)
    {
        Puts($"Player {player.displayName} is not allowed to join team {newTeam}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateTeam(ulong newTeam)
	{
		if (Interface.CallHook("OnTeamUpdate", currentTeam, newTeam, this) == null)
		{
			currentTeam = newTeam;
			SendNetworkUpdate();
			if (RelationshipManager.ServerInstance.FindTeam(newTeam) == null)
			{
				ClearTeam();
			}
			else
			{
				TeamUpdate();
			}
		}
	}

```

## IOnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
void IOnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.displayName} has connected to the server.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void PlayerInit(Network.Connection c)
	{
		using (TimeWarning.New("PlayerInit", 10))
		{
			CancelInvoke(base.KillMessage);
			SetPlayerFlag(PlayerFlags.Connected, b: true);
			activePlayerList.Add(this);
			bots.Remove(this);
			userID = c.userid;
			UserIDString = userID.ToString();
			displayName = c.username;
			c.player = this;
			secondsConnected = 0;
			currentTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userID)?.teamID ?? 0;
			SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerName(userID, displayName);
			tickInterpolator.Reset(base.transform.position);
			tickHistory.Reset(base.transform.position);
			eyeHistory.Clear();
			lastTickTime = 0f;
			lastInputTime = 0f;
			SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
			stats.Init();
			InvokeRandomized(StatSave, UnityEngine.Random.Range(5f, 10f), 30f, UnityEngine.Random.Range(0f, 6f));
			previousLifeStory = SingletonComponent<ServerMgr>.Instance.persistance.GetLastLifeStory(userID);
			SetPlayerFlag(PlayerFlags.IsAdmin, c.authLevel != 0);
			SetPlayerFlag(PlayerFlags.IsDeveloper, DeveloperList.IsDeveloper(this));
			if (IsDead() && net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
			{
				SendNetworkGroupChange();
			}
			net.OnConnected(c);
			net.StartSubscriber();
			SendAsSnapshot(net.connection);
			ClientRPCPlayer(null, this, "StartLoading");
			if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerConnected(this);
			}
			if (net != null)
			{
				EACServer.OnStartLoading(net.connection);
			}
			Interface.CallHook("IOnPlayerConnected", this);
			if (IsAdmin)
			{
				if (ConVar.AntiHack.noclip_protection <= 0)
				{
					ChatMessage("antihack.noclip_protection is disabled!");
				}
				if (ConVar.AntiHack.speedhack_protection <= 0)
				{
					ChatMessage("antihack.speedhack_protection is disabled!");
				}
				if (ConVar.AntiHack.flyhack_protection <= 0)
				{
					ChatMessage("antihack.flyhack_protection is disabled!");
				}
				if (ConVar.AntiHack.projectile_protection <= 0)
				{
					ChatMessage("antihack.projectile_protection is disabled!");
				}
				if (ConVar.AntiHack.melee_protection <= 0)
				{
					ChatMessage("antihack.melee_protection is disabled!");
				}
				if (ConVar.AntiHack.eye_protection <= 0)
				{
					ChatMessage("antihack.eye_protection is disabled!");
				}
			}
		}
	}

```

## OnMaxStackable(Item)

```csharp
```csharp
/// <summary>
/// Called to determine the maximum stackable quantity of an item.
/// </summary>
/// <param name="item">The item being checked.</param>
/// <returns>
/// Returns the maximum stackable quantity, or any non-null value to override the default behavior. 
/// If `null` is returned, the default maximum stackable quantity will be used.
/// </returns>
object OnMaxStackable(Item item)
{
    Puts($"Checking max stackable for item {item.name}");
    if (item.category == "Rare")
    {
        Puts($"Item {item.name} has a custom max stackable of 10");
        return 10;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int MaxStackable()
	{
		int num = info.stackable;
		if (parent != null && parent.maxStackSize > 0)
		{
			num = Mathf.Min(parent.maxStackSize, num);
		}
		object obj = Interface.CallHook("OnMaxStackable", this);
		if (obj is int)
		{
			return (int)obj;
		}
		return num;
	}

```

## OnFireworkDesignChanged(PatternFirework,ProtoBuf.PatternFirework.Design,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a firework design is changed.
/// </summary>
/// <param name="design">The new firework design.</param>
/// <param name="player">The player who made the change.</param>
/// <returns>
/// Returns `null` to allow the design change, or any non-null value to prevent the design from being updated.
/// </returns>
object OnFireworkDesignChanged(ProtoBuf.PatternFirework.Design design, BasePlayer player)
{
    Puts($"Firework design changed by {player.displayName}.");
    if (design.stars.Count > 10)
    {
        Puts($"Firework design has too many stars. Limiting to 10.");
        while (design.stars.Count > 10)
        {
            int index = design.stars.Count - 1;
            design.stars[index].Dispose();
            design.stars.RemoveAt(index);
        }
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void ServerSetFireworkDesign(RPCMessage rpc)
	{
		if (!PlayerCanModify(rpc.player))
		{
			return;
		}
		ProtoBuf.PatternFirework.Design design = ProtoBuf.PatternFirework.Design.Deserialize(rpc.read);
		if (Interface.CallHook("OnFireworkDesignChange", this, design, rpc.player) != null)
		{
			return;
		}
		if (design?.stars != null)
		{
			while (design.stars.Count > MaxStars)
			{
				int index = design.stars.Count - 1;
				design.stars[index].Dispose();
				design.stars.RemoveAt(index);
			}
			foreach (ProtoBuf.PatternFirework.Star star in design.stars)
			{
				star.position = new Vector2(Mathf.Clamp(star.position.x, -1f, 1f), Mathf.Clamp(star.position.y, -1f, 1f));
				star.color = new Color(Mathf.Clamp01(star.color.r), Mathf.Clamp01(star.color.g), Mathf.Clamp01(star.color.b), 1f);
			}
			design.editedBy = rpc.player.userID;
		}
		Design?.Dispose();
		Design = design;
		Interface.CallHook("OnFireworkDesignChanged", this, design, rpc.player);
		SendNetworkUpdateImmediate();
	}

```

## OnVendingShopOpen(InvisibleVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine that was opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>
/// Returns `null` to allow the vending shop to open normally, or any non-null value to override the default behavior.
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object OnVendingShopOpen(InvisibleVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending shop opened by {player} at position {vendingMachine.transform.position}");
    if (vendingMachine.name == "Prohibited Vending Machine")
    {
        Puts($"Vending shop {vendingMachine.name} has been blocked from opening.");
        return "Blocked: Prohibited vending machine.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", vendingMachine, player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!(conversingPlayer == player) && !(conversingPlayer == null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			List<Item> list = player.inventory.FindItemIDs(itemDefinition.itemid);
			foreach (Item item in list)
			{
				num -= item.amount;
			}
			if (num > 0)
			{
				int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
				ForceSpeechNode(player, speechNodeIndex2);
				break;
			}
			Facepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
			num = nPCConversationResultAction.scrapCost;
			foreach (Item item2 in list)
			{
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			lastActionPlayer = player;
			BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
			lastActionPlayer = null;
			break;
		}
	}

```

## OnDemoRecordingStarted(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is started.
/// </summary>
/// <param name="demoPath">The path where the demo will be recorded.</param>
/// <param name="player">The player who initiated the demo recording.</param>
object OnDemoRecordingStarted(string demoPath, BasePlayer player)
{
    Puts($"Demo recording started by {player.UserIDString} at {demoPath}");
    if (demoPath == "/home/user/demos/invalid.dem")
    {
        Puts($"Demo recording failed due to invalid path: {demoPath}");
        return "Invalid demo path.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartDemoRecording()
	{
		if (net != null && net.connection != null && !net.connection.IsRecording)
		{
			string text = $"demos/{UserIDString}/{DateTime.Now:yyyy-MM-dd-hhmmss}.dem";
			if (Interface.CallHook("OnDemoRecordingStart", text, this) == null)
			{
				Debug.Log(ToString() + " recording started: " + text);
				net.connection.StartRecording(text, new Demo.Header
				{
					version = Demo.Version,
					level = UnityEngine.Application.loadedLevelName,
					levelSeed = World.Seed,
					levelSize = World.Size,
					checksum = World.Checksum,
					localclient = userID,
					position = eyes.position,
					rotation = eyes.HeadForward(),
					levelUrl = World.Url,
					recordedTime = DateTime.Now.ToBinary()
				});
				SendNetworkUpdateImmediate();
				SendGlobalSnapshot();
				SendFullSnapshot();
				SendEntityUpdate();
				TreeManager.SendSnapshot(this);
				ServerMgr.SendReplicatedVars(net.connection);
				InvokeRepeating(MonitorDemoRecording, 10f, 10f);
				Interface.CallHook("OnDemoRecordingStarted", text, this);
			}
		}
	}

```

## OnHealingItemUse(MedicalTool,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a healing item is used on a player.
/// </summary>
/// <param name="medicalTool">The medical tool being used.</param>
/// <param name="player">The player receiving the healing effect.</param>
/// <returns>
/// Returns `null` to allow the healing effect to be applied, or any non-null value to prevent the healing effect from being applied.
/// </returns>
object OnHealingItemUse(MedicalTool medicalTool, BasePlayer player)
{
    Puts($"Medical tool {medicalTool.name} used on player {player.displayName}");
    if (player.IsWounded())
    {
        // Additional logic can be added here to handle the healing effect
        return null;
    }
    else
    {
        // The player is not wounded, so no healing effect is applied
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	private void GiveEffectsTo(BasePlayer player)
	{
		if (!player)
		{
			return;
		}
		ItemDefinition ownerItemDefinition = GetOwnerItemDefinition();
		ItemModConsumable component = ownerItemDefinition.GetComponent<ItemModConsumable>();
		if (!component)
		{
			Debug.LogWarning("No consumable for medicaltool :" + base.name);
		}
		else
		{
			if (Interface.CallHook("OnHealingItemUse", this, player) != null)
			{
				return;
			}
			BasePlayer ownerPlayer = GetOwnerPlayer();
			Facepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);
			if (player != ownerPlayer)
			{
				if (Interface.CallHook("OnPlayerRevive", GetOwnerPlayer(), player) != null)
				{
					return;
				}
				if (player.IsWounded() && canRevive)
				{
					player.StopWounded(ownerPlayer);
				}
			}
			foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
			{
				if (effect.type == MetabolismAttribute.Type.Health)
				{
					player.health += effect.amount;
				}
				else
				{
					player.metabolism.ApplyChange(effect.type, effect.amount, effect.time);
				}
			}
			if (player is BasePet)
			{
				player.SendNetworkUpdateImmediate();
			}
		}
	}

```

## OnBoatPathGenerate()

```csharp
```csharp
/// <summary>
/// Called when the boat path is generated.
/// </summary>
/// <returns>
/// Returns a non-null value to override the default path generation behavior. 
/// If a List<Vector3> is returned, it will be used as the new path instead of the one generated by this method.
/// </returns>
List<Vector3> OnBoatPathGenerate()
{
    Puts("Generating boat path...");
    // You can return a custom path here if needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * (float)Math.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float y = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num5 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num5 * ((float)Math.PI / 180f)) * num4, y, Mathf.Cos(num5 * ((float)Math.PI / 180f)) * num4));
		}
		float num6 = 4f;
		float num7 = 200f;
		bool flag = true;
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 vector = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 b = list[index2];
				Vector3 b2 = list[index];
				Vector3 origin = vector;
				Vector3 normalized = (Vector3.zero - vector).normalized;
				Vector3 vector2 = vector + normalized * num6;
				if (Vector3.Distance(vector2, b) > num7 || Vector3.Distance(vector2, b2) > num7)
				{
					continue;
				}
				bool flag2 = true;
				int num8 = 16;
				for (int l = 0; l < num8; l++)
				{
					float num9 = (float)l / (float)num8 * 360f;
					Vector3 normalized2 = new Vector3(Mathf.Sin(num9 * ((float)Math.PI / 180f)), y, Mathf.Cos(num9 * ((float)Math.PI / 180f))).normalized;
					Vector3 vector3 = vector2 + normalized2 * 1f;
					GetWaterDepth(vector3);
					Vector3 direction = normalized;
					if (vector3 != Vector3.zero)
					{
						direction = (vector3 - vector2).normalized;
					}
					if (UnityEngine.Physics.SphereCast(origin, 3f, direction, out var _, minDistanceFromShore, 1218511105))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = vector2;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning("Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log("Generated ocean patrol path with node count: " + list.Count);
		return list;
	}

```

## CanUseWires(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use wires.
/// </summary>
/// <param name="player">The player in question.</param>
/// <returns>
/// Returns `true` if the player can use wires, and `false` otherwise.
/// If this method returns `null`, the default behavior will be used (i.e., the player cannot use wires unless they have building permission).
/// </returns>
bool CanUseWires(BasePlayer player)
{
    Puts($"Checking if {player.UserIDString} can use wires");
    object obj = Interface.CallHook("CanUseWires", player);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If the player doesn't have building permission, they cannot use wires
    if (!player.CanBuild())
    {
        Puts($"Player {player.UserIDString} does not have building permission");
        return false;
    }
    
    // Check if there are any colliders within a 0.1f radius of the player's eyes that are tagged as "IgnoreWireCheck"
    List<Collider> obj2 = Facepunch.Pool.GetList<Collider>();
    GamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);
    bool result = obj2.All((Collider collider) => collider.gameObject.CompareTag("IgnoreWireCheck"));
    Facepunch.Pool.FreeList(ref obj2);
    
    return result;
}
```
```

### Source Code from the Library

```csharp

	public static bool CanPlayerUseWires(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseWires", player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		List<Collider> obj2 = Facepunch.Pool.GetList<Collider>();
		GamePhysics.OverlapSphere(player.eyes.position, 0.1f, obj2, 536870912, QueryTriggerInteraction.Collide);
		bool result = obj2.All((Collider collider) => collider.gameObject.CompareTag("IgnoreWireCheck"));
		Facepunch.Pool.FreeList(ref obj2);
		return result;
	}

```

## OnEntityEnter(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger.
/// </summary>
/// <param name="trigger">The trigger that was entered.</param>
/// <param name="entity">The entity that entered the trigger.</param>
/// <returns>
/// Returns `null` to allow the entity to enter the trigger, or any non-null value to prevent them from entering.
/// </returns>
object OnEntityEnter(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has entered trigger {trigger.name}");
    if (entity is Player player && player.IsSpectating())
    {
        Puts($"Player {player.displayName} is spectating and cannot enter trigger {trigger.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityEnter(BaseEntity ent)
	{
		if (!(ent == null))
		{
			if (entityContents == null)
			{
				entityContents = new HashSet<BaseEntity>();
			}
			if (Interface.CallHook("OnEntityEnter", this, ent) == null)
			{
				entityContents.Add(ent);
			}
		}
	}

```

## OnTurretAuthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret authorizes a player.
/// </summary>
/// <param name="turret">The AutoTurret that authorized the player.</param>
/// <param name="player">The BasePlayer who was authorized.</param>
/// <returns>
/// Returns `null` to allow the authorization, or any non-null value to prevent the authorization.
/// </returns>
object OnTurretAuthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"AutoTurret {turret.EntityID} has authorized player {player.displayName}.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot be authorized by the AutoTurret.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AddSelfAuthorize(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!IsOnline() && player2.CanBuild() && !AtMaxAuthCapacity() && Interface.CallHook("OnTurretAuthorize", this, player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == player2.userID);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = player2.userID;
			playerNameID.username = player2.displayName;
			authorizedPlayers.Add(playerNameID);
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, player2, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", player2.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnEntityKill(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is killed.
/// </summary>
/// <param name="entity">The entity being killed.</param>
/// <returns>
/// Returns `null` to allow the entity to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnEntityKill(BaseNetworkable entity)
{
    Puts($"Entity {entity.ShortName} has been killed.");
    if (entity is Player && ((Player)entity).IsAdmin)
    {
        Puts($"Entity {entity.ShortName} was an admin player and cannot be killed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning("Calling kill - but already IsDestroyed!? " + this);
		}
		else if (Interface.CallHook("OnEntityKill", this) == null)
		{
			OnParentDestroyingEx.BroadcastOnParentDestroying(base.gameObject);
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

```

## OnResearchCostDetermine(Item,ResearchTable)

```csharp
```csharp
/// <summary>
/// Called to determine the cost of research for a given item.
/// </summary>
/// <param name="item">The item being researched.</param>
/// <param name="researchTable">The table used for determining research costs.</param>
/// <returns>
/// Returns an integer representing the cost of research, or `null` if no custom cost is specified.
/// If a non-integer value is returned, it will be ignored and the default cost will be used.
/// </returns>
object OnResearchCostDetermine(Item item, ResearchTable researchTable)
{
    Puts($"Determining research cost for {item.info.name}...");
    if (researchTable == null || researchTable.isCustom)
    {
        return 100; // Default research cost
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public int ScrapForResearch(Item item)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", item, this);
		if (obj is int)
		{
			return (int)obj;
		}
		return ScrapForResearch(item.info);
	}

```

## OnClothingItemChanged(PlayerInventory,Item,bool)

```csharp
```csharp
/// <summary>
/// Called when a clothing item is added or removed from the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The clothing item that was added or removed.</param>
/// <param name="added">Whether the item was added (true) or removed (false).</param>
/// <returns>No return behavior.</returns>
void OnClothingItemChanged(PlayerInventory inventory, Item item, bool added)
{
    Puts($"Clothing item {item.info.name} {(added ? "added" : "removed")} from player's inventory.");
    if (!added && item.info.category == "Hat")
    {
        Puts($"Player's hat has been removed. Updating server state...");
        ServerUpdate(0f);
    }
}
```
```

### Source Code from the Library

```csharp

	private void OnClothingChanged(Item item, bool bAdded)
	{
		base.baseEntity.SV_ClothingChanged();
		ItemManager.DoRemoves();
		ServerUpdate(0f);
		Interface.CallHook("OnClothingItemChanged", this, item, bAdded);
	}

```

## CanCatchFish(BasePlayer,BaseFishingRod,Item)

```csharp
This is a C# code snippet that appears to be part of a fishing game mechanic in the Rust game. It's a server-side script that handles the process of catching a fish. Here's a breakdown of what it does:

1. **Input Handling**: The script checks for various input flags (e.g., `HasReelInInput`, `AllowPullInDirection`) to determine if the player is trying to catch a fish.
2. **State Management**: It updates the current state of the fishing process, which can be one of three states: Waiting, Catching, or Caught.
3. **Fish State Updates**: The script updates the fish's state based on the input flags and the current state of the fishing process.
4. **Strain Timer**: It increments a strain timer that affects the fish's behavior and ultimately determines whether it will be caught or not.
5. **Catch Logic**: If the fish is caught, the script:
	* Cancels any ongoing catch process.
	* Updates the player's inventory with the caught fish.
	* Triggers various hooks (e.g., `CanCatchFish`, `OnFishCatch`) to allow for custom behavior.
	* Resets the fishing line after a short delay.

Some notable aspects of this code include:

* The use of flags and state management to handle complex game logic.
* The incorporation of hooks to allow for customization by other scripts or plugins.
* The use of timers and delays to create a sense of realism and anticipation in the game.
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1218511105))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(null, "Client_HookedSomething");
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(null, "Client_UpdateFishState", (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else
		{
			if (!(num2 <= FishCatchDistance) && !ForceSuccess)
			{
				return;
			}
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					fishLookup.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(null, "Client_OnCaughtFish", currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## OnPhoneNameUpdate(PhoneController,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player updates the name on their phone.
/// </summary>
/// <param name="phoneController">The phone controller updating the name.</param>
/// <param name="newName">The new name to be displayed on the phone.</param>
/// <param name="player">The player who owns the phone.</param>
/// <returns>
/// Returns `null` to allow the update, or any non-null value to prevent the update.
/// </returns>
object OnPhoneNameUpdate(PhoneController phoneController, string newName, BasePlayer player)
{
    Puts($"Player {player.UserIDString} updated their phone name to: {newName}");
    if (newName == "Admin")
    {
        Puts($"Player {player.displayName} is not allowed to set the phone name to 'Admin'.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!(msg.player != currentPlayer))
		{
			string text = msg.read.String();
			if (text.Length > 20)
			{
				text = text.Substring(0, 20);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", this, text, msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", this, PhoneName, msg.player);
			}
		}
	}

```

## CanLootEntity(BasePlayer,DroppedItemContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, DroppedItemContainer entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.GetDisplayName()}");
    if (player.IsAdmin)
    {
        return null;
    }
    else
    {
        return "Not allowed: Only admins can loot this entity.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_OpenLoot(RPCMessage rpc)
	{
		if (inventory != null)
		{
			BasePlayer player = rpc.player;
			if ((bool)player && player.CanInteract() && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(this))
			{
				SetFlag(Flags.Open, b: true);
				player.inventory.loot.AddContainer(inventory);
				player.inventory.loot.SendImmediate();
				player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", lootPanelName);
				SendNetworkUpdate();
			}
		}
	}

```

## OnXmasStockingFill(Stocking)

```csharp
```csharp
/// <summary>
/// Called when a Christmas stocking is filled with loot.
/// </summary>
/// <param name="stocking">The stocking being filled.</param>
/// <returns>
/// Returns `null` to allow the stocking to be filled, or any non-null value to prevent it from being filled.
/// </returns>
object OnXmasStockingFill(Stocking stocking)
{
    Puts($"Stocking {stocking.name} is being filled with loot.");
    if (stocking.inventory.Count >= 10)
    {
        Puts($"Stocking {stocking.name} already has enough loot, skipping fill operation.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log("CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! " + base.name);
		}
		else if (IsEmpty() && Interface.CallHook("OnXmasStockingFill", this) == null)
		{
			base.SpawnLoot();
			SetFlag(Flags.On, b: true);
			Hurt(MaxHealth() * 0.1f, DamageType.Generic, null, useProtection: false);
		}
	}

```

## CanNetworkTo(BaseNetworkable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player should be allowed to network with this entity.
/// </summary>
/// <param name="entity">The entity to check.</param>
/// <param name="player">The player attempting to network.</param>
/// <returns>
/// Returns `true` if the player is allowed to network, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanNetworkTo(BaseNetworkable entity, BasePlayer player)
{
    Puts($"Checking if {player.UserIDString} can network with {entity.ShortName}");
    // Example: Allow players in the same group to network
    if (player.net.group == entity.net.group)
    {
        return true;
    }
    // Example: Deny players who are not subscribers of the entity's group
    if (!player.net.subscriber.IsSubscribed(entity.net.group))
    {
        Puts($"Player {player.UserIDString} is not a subscriber to {entity.ShortName}'s group");
        return false;
    }
    return null; // Default to allowing networking
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (net.group == null)
		{
			return true;
		}
		return player.net.subscriber.IsSubscribed(net.group);
	}

```

## OnRecyclerToggle(Recycler,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the recycler is toggled on or off.
/// </summary>
/// <param name="recycler">The recycler being toggled.</param>
/// <param name="player">The player who toggled the recycler.</param>
/// <returns>
/// Returns `null` to allow the recycler to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnRecyclerToggle(Recycler recycler, BasePlayer player)
{
    Puts($"Recycler {recycler.name} has been toggled by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot toggle the recycler.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (flag == IsOn() || msg.player == null || Interface.CallHook("OnRecyclerToggle", this, msg.player) != null || (flag && !HasRecyclable()))
		{
			return;
		}
		if (flag)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item.CollectedForCrafting(msg.player);
			}
			StartRecycling();
		}
		else
		{
			StopRecycling();
		}
	}

```

## OnThreatLevelUpdate(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the threat level of a player needs to be updated.
/// </summary>
/// <param name="player">The player whose threat level is being updated.</param>
/// <returns>
/// Returns `null` if the player's threat level should not be updated, or any non-null value to indicate that the threat level has been updated.
/// The returned value can be used to determine the new threat level of the player.
/// </returns>
object OnThreatLevelUpdate(BasePlayer player)
{
    Puts($"Updating threat level for player {player.UserIDString}.");
    if (player.inventory.containerWear.itemList.Count > 2)
    {
        return cachedThreatLevel + 1f;
    }
    foreach (Item item in player.inventory.containerBelt.itemList)
    {
        BaseEntity heldEntity = item.GetHeldEntity();
        if ((bool)heldEntity && heldEntity is BaseProjectile && !(heldEntity is BowWeapon))
        {
            return cachedThreatLevel + 2f;
        }
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void EnsureUpdated()
	{
		if (UnityEngine.Time.realtimeSinceStartup - lastUpdateTime < 30f)
		{
			return;
		}
		lastUpdateTime = UnityEngine.Time.realtimeSinceStartup;
		cachedThreatLevel = 0f;
		if (IsSleeping() || Interface.CallHook("OnThreatLevelUpdate", this) != null)
		{
			return;
		}
		if (inventory.containerWear.itemList.Count > 2)
		{
			cachedThreatLevel += 1f;
		}
		foreach (Item item in inventory.containerBelt.itemList)
		{
			BaseEntity heldEntity = item.GetHeldEntity();
			if ((bool)heldEntity && heldEntity is BaseProjectile && !(heldEntity is BowWeapon))
			{
				cachedThreatLevel += 2f;
				break;
			}
		}
	}

```

## CanEntityBeHostile(BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Determines whether an entity can be hostile.
/// </summary>
/// <param name="entity">The entity to check.</param>
/// <returns>
/// Returns `true` if the entity can be hostile, and `false` otherwise.
/// If a non-bool value is returned by the hook, it will be treated as `true`.
/// </returns>
bool CanEntityBeHostile(BaseCombatEntity entity)
{
    Puts($"Checking if entity {entity.UserIDString} can be hostile...");
    object obj = Interface.CallHook("CanEntityBeHostile", entity);
    return (obj is bool) ? (bool)obj : true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnPlayerStudyBlueprint(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player studies a blueprint.
/// </summary>
/// <param name="player">The player studying the blueprint.</param>
/// <param name="item">The item being studied (the blueprint).</param>
/// <returns>
/// Returns `null` to allow the default behavior of unlocking the blueprint and its additional unlocks. 
/// If a non-null value is returned, it will override this behavior.
/// </returns>
object OnPlayerStudyBlueprint(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} has studied the blueprint {item.Info().Name}.");
    // You can add custom logic here to modify or cancel the default behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (item.GetOwnerPlayer() != player)
		{
			bool flag = false;
			foreach (ItemContainer container in player.inventory.loot.containers)
			{
				if (item.GetRootContainer() == container)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
		}
		if (!(command == "study") || !item.IsBlueprint())
		{
			return;
		}
		ItemDefinition blueprintTargetDef = item.blueprintTargetDef;
		ItemBlueprint blueprint = blueprintTargetDef.Blueprint;
		bool flag2 = player.blueprints.IsUnlocked(blueprintTargetDef);
		if (flag2 && blueprint != null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock in blueprint.additionalUnlocks)
			{
				if (!player.blueprints.IsUnlocked(additionalUnlock))
				{
					flag2 = false;
				}
			}
		}
		if (blueprint != null && blueprint.defaultBlueprint)
		{
			flag2 = true;
		}
		if (flag2 || Interface.CallHook("OnPlayerStudyBlueprint", player, item) != null)
		{
			return;
		}
		Item item2 = item;
		if (item.amount > 1)
		{
			item2 = item.SplitItem(1);
		}
		item2.UseItem();
		player.blueprints.Unlock(blueprintTargetDef);
		Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, blueprintTargetDef, "blueprint");
		if (blueprint != null && blueprint.additionalUnlocks != null && blueprint.additionalUnlocks.Count > 0)
		{
			foreach (ItemDefinition additionalUnlock2 in blueprint.additionalUnlocks)
			{
				player.blueprints.Unlock(additionalUnlock2);
				Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, additionalUnlock2, "blueprint");
			}
		}
		if (studyEffect.isValid)
		{
			Effect.server.Run(studyEffect.resourcePath, player, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
	}

```

## OnSensorDetect(HBHFSensor,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sensor detects a player.
/// </summary>
/// <param name="sensor">The HBHFSensor that detected the player.</param>
/// <param name="player">The BasePlayer that was detected.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or any non-null value to override it. 
/// If a boolean is returned, it will be used as a flag to determine whether the player should be included in the detection count.
/// </returns>
object OnSensorDetect(HBHFSensor sensor, BasePlayer player)
{
    Puts($"Sensor {sensor.name} detected player {player.displayName}.");
    if (player.isSuperAdmin)
    {
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePassthroughAmount()
	{
		if (base.isClient)
		{
			return;
		}
		int num = detectedPlayers;
		detectedPlayers = 0;
		if (myTrigger.entityContents != null)
		{
			foreach (BaseEntity entityContent in myTrigger.entityContents)
			{
				if (entityContent == null || !entityContent.IsVisible(base.transform.position + base.transform.forward * 0.1f, 10f))
				{
					continue;
				}
				BasePlayer component = entityContent.GetComponent<BasePlayer>();
				if (Interface.CallHook("OnSensorDetect", this, component) == null)
				{
					bool flag = component.CanBuild();
					if ((!flag || ShouldIncludeAuthorized()) && (flag || ShouldIncludeOthers()) && component != null && component.IsAlive() && !component.IsSleeping() && component.isServer)
					{
						detectedPlayers++;
					}
				}
			}
		}
		if (num != detectedPlayers && IsPowered())
		{
			MarkDirty();
			if (detectedPlayers > num)
			{
				Effect.server.Run(detectUp.resourcePath, base.transform.position, Vector3.up);
			}
			else if (detectedPlayers < num)
			{
				Effect.server.Run(detectDown.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnOvenCook(BaseOven,Item)

```csharp
```csharp
/// <summary>
/// Called when an oven cooks an item.
/// </summary>
/// <param name="oven">The oven performing the cooking.</param>
/// <param name="item">The item being cooked.</param>
/// <returns>
/// Returns a non-null value to override the default cooking behavior. 
/// If `null` is returned, the item is cooked as normal.
/// </returns>
object OnOvenCook(BaseOven oven, Item item)
{
    Puts($"Oven {oven} is cooking item {item}.");
    if (item.info.GetComponent<ItemModBurnable>().IsSpoiled())
    {
        Puts($"Item {item} has spoiled and cannot be cooked.");
        return "Cannot cook spoiled item.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Cook()
	{
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", this, item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if ((bool)slot)
		{
			slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);
		}
		if (item != null)
		{
			ItemModBurnable component = item.info.GetComponent<ItemModBurnable>();
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, component);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", this, item, slot);
	}

```

## OnVendingShopOpened(InvisibleVendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine that was opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>
/// Returns `null` to allow the player to interact with the vending shop, or any non-null value to override the default behavior.
/// </returns>
object OnVendingShopOpened(InvisibleVendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending shop opened by {player} at position {vendingMachine.transform.position}.");
    if (vendingMachine.name == "Prohibited Vending Machine")
    {
        Puts($"Vending shop at position {vendingMachine.transform.position} has been blocked from opening.");
        return "Blocked: Unauthorized vending machine.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnConversationAction(BasePlayer player, string action)
	{
		if (action == "openvending")
		{
			InvisibleVendingMachine vendingMachine = GetVendingMachine();
			if (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)
			{
				ForceEndConversation(player);
				if (Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
				{
					vendingMachine.PlayerOpenLoot(player, "vendingmachine.customer", doPositionChecks: false);
					Interface.CallHook("OnVendingShopOpened", vendingMachine, player);
				}
				return;
			}
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition("scrap");
		NPCConversationResultAction[] array = conversationResultActions;
		foreach (NPCConversationResultAction nPCConversationResultAction in array)
		{
			if (!(nPCConversationResultAction.action == action))
			{
				continue;
			}
			CleanupConversingPlayers();
			foreach (BasePlayer conversingPlayer in conversingPlayers)
			{
				if (!(conversingPlayer == player) && !(conversingPlayer == null))
				{
					int speechNodeIndex = GetConversationFor(player).GetSpeechNodeIndex("startbusy");
					ForceSpeechNode(conversingPlayer, speechNodeIndex);
				}
			}
			int num = nPCConversationResultAction.scrapCost;
			List<Item> list = player.inventory.FindItemIDs(itemDefinition.itemid);
			foreach (Item item in list)
			{
				num -= item.amount;
			}
			if (num > 0)
			{
				int speechNodeIndex2 = GetConversationFor(player).GetSpeechNodeIndex("toopoor");
				ForceSpeechNode(player, speechNodeIndex2);
				break;
			}
			Facepunch.Rust.Analytics.Azure.OnNPCVendor(player, this, nPCConversationResultAction.scrapCost, nPCConversationResultAction.action);
			num = nPCConversationResultAction.scrapCost;
			foreach (Item item2 in list)
			{
				int num2 = Mathf.Min(num, item2.amount);
				item2.UseItem(num2);
				num -= num2;
				if (num <= 0)
				{
					break;
				}
			}
			lastActionPlayer = player;
			BroadcastEntityMessage(nPCConversationResultAction.broadcastMessage, nPCConversationResultAction.broadcastRange);
			lastActionPlayer = null;
			break;
		}
	}

```

## CanHelicopterStrafe(PatrolHelicopterAI)

```csharp
```csharp
/// <summary>
/// Called to determine if the helicopter can strafe.
/// </summary>
/// <param name="ai">The PatrolHelicopterAI instance.</param>
/// <returns>
/// Returns `true` if the helicopter can strafe, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
bool CanHelicopterStrafe(PatrolHelicopterAI ai)
{
    Puts("Helicopter attempting to strafe.");
    // Minimal code to demonstrate functionality
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (UnityEngine.Time.realtimeSinceStartup - lastStrafeTime >= 20f)
		{
			return CanInterruptState();
		}
		return false;
	}

```

## OnWindmillUpdate(ElectricWindmill)

```csharp
```csharp
/// <summary>
/// Called when the windmill's state is updated.
/// </summary>
/// <param name="windmill">The ElectricWindmill instance whose state has been updated.</param>
/// <returns>No return behavior.</returns>
void OnWindmillUpdate(ElectricWindmill windmill)
{
    Puts($"Windmill {windmill.windmillName} has been updated.");
    if (windmill.currentEnergy > 50f)
    {
        Puts($"Windmill {windmill.windmillName} is producing excess energy.");
        // Handle excess energy production
    }
}
```
```

### Source Code from the Library

```csharp

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", this);
		}
	}

```

## OnHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter drops a crate.
/// </summary>
/// <param name="helicopter">The helicopter that dropped the crate.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityID()} has dropped a crate.");
}
```
```

### Source Code from the Library

```csharp

	public void DropCrate()
	{
		if (numCrates > 0)
		{
			Vector3 pos = base.transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if ((bool)baseEntity)
			{
				Interface.CallHook("OnHelicopterDropCrate", this);
				baseEntity.SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

```

## OnItemResearch(ResearchTable,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts researching an item.
/// </summary>
/// <param name="researchTable">The research table being used.</param>
/// <param name="item">The item being researched.</param>
/// <param name="player">The player performing the research.</param>
/// <returns>
/// Returns a non-null value to override the default research behavior. 
/// If `null` is returned, the research will proceed as normal.
/// </returns>
object OnItemResearch(ResearchTable researchTable, Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} started researching item {item.info.name} on research table {researchTable.name}");
    if (item.info.category == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to research restricted items.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Facepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnCargoShipEgress(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship starts egressing.
/// </summary>
/// <param name="ship">The cargo ship starting to egress.</param>
/// <returns>
/// Returns `null` to allow the ship to start egressing, or any non-null value to prevent it from egressing.
/// </returns>
object OnCargoShipEgress(CargoShip ship)
{
    Puts($"Cargo ship {ship.Name} has started egressing.");
    if (ship.IsDamaged())
    {
        Puts($"Cargo ship {ship.Name} is damaged and cannot egress.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StartEgress()
	{
		if (!egressing && Interface.CallHook("OnCargoShipEgress", this) == null)
		{
			egressing = true;
			CancelInvoke(PlayHorn);
			radiation.SetActive(value: true);
			SetFlag(Flags.Reserved8, b: true);
			InvokeRepeating(UpdateRadiation, 10f, 1f);
			Invoke(DelayedDestroy, 60f * egress_duration_minutes);
		}
	}

```

## CanBeTargeted(BasePlayer,GunTrap)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the gun trap.
/// </summary>
/// <param name="player">The player being checked.</param>
/// <param name="gunTrap">The gun trap doing the checking.</param>
/// <returns>
/// Returns `true` if the player can be targeted, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, GunTrap gunTrap)
{
    Puts($"Checking if player {player.UserIDString} can be targeted by gun trap {gunTrap.NetID()}");
    // Custom logic to determine if the player can be targeted
    // For example:
    if (player.IsAdmin())
    {
        return false;
    }
    else if (player.IsBuildingAuthed())
    {
        return true;
    }
    else
    {
        // Default behavior: allow targeting
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = item.GetComponent<BasePlayer>();
				if (component.IsSleeping() || !component.IsAlive())
				{
					continue;
				}
				object obj2 = Interface.CallHook("CanBeTargeted", component, this);
				if (obj2 is bool)
				{
					Pool.FreeList(ref obj);
					return (bool)obj2;
				}
				if (component.IsBuildingAuthed())
				{
					continue;
				}
				obj.Clear();
				GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
				for (int i = 0; i < obj.Count; i++)
				{
					BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
					if (entity != null && (entity == this || entity.EqualNetID(this)))
					{
						flag = true;
						break;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeList(ref obj);
		return flag;
	}

```

## CanSamSiteShoot(SamSite)

```csharp
```csharp
/// <summary>
/// Called to determine if the SAM site can shoot.
/// </summary>
/// <param name="samSite">The SAM site instance.</param>
/// <returns>
/// Returns `null` to allow the SAM site to shoot, or any non-null value to prevent it from shooting.
/// </returns>
object CanSamSiteShoot(SamSite samSite)
{
    Puts($"Checking if SAM site can shoot...");
    // Add custom logic here to determine if the SAM site can shoot
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void WeaponTick()
	{
		if (IsDead() || UnityEngine.Time.time < lockOnTime || UnityEngine.Time.time < nextBurstTime)
		{
			return;
		}
		if (!IsPowered())
		{
			firedCount = 0;
			return;
		}
		if (firedCount >= 6)
		{
			float timeBetweenBursts = mostRecentTargetType.timeBetweenBursts;
			nextBurstTime = UnityEngine.Time.time + timeBetweenBursts;
			firedCount = 0;
			return;
		}
		EnsureReloaded();
		if (Interface.CallHook("CanSamSiteShoot", this) == null && HasAmmo())
		{
			bool num = ammoItem != null && ammoItem.amount == lowAmmoThreshold;
			if (!staticRespawn && ammoItem != null)
			{
				ammoItem.UseItem();
			}
			firedCount++;
			float speedMultiplier = 1f;
			if (!ObjectEx.IsUnityNull(currentTarget))
			{
				speedMultiplier = currentTarget.SAMTargetType.speedMultiplier;
			}
			FireProjectile(tubes[currentTubeIndex].position, currentAimDir, speedMultiplier);
			Effect.server.Run(muzzleFlashTest.resourcePath, this, StringPool.Get("Tube " + (currentTubeIndex + 1)), Vector3.zero, Vector3.up);
			currentTubeIndex++;
			if (currentTubeIndex >= tubes.Length)
			{
				currentTubeIndex = 0;
			}
			if (num)
			{
				MarkIODirty();
			}
		}
	}

```

## CanBypassQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can bypass the queue.
/// </summary>
/// <param name="connection">The player's connection.</param>
/// <returns>
/// Returns `true` if the player can bypass the queue, or `false` otherwise.
/// If this method returns `null`, it will be treated as returning `false`.
/// </returns>
bool CanBypassQueue(Network.Connection connection)
{
    Puts($"Checking if {connection.UserIDString} can bypass queue...");
    object obj = Interface.CallHook("CanBypassQueue", connection);
    if (obj is bool && (bool)obj)
    {
        return true;
    }
    if (DeveloperList.Contains(connection.userid))
    {
        return true;
    }
    ServerUsers.User user = ServerUsers.Get(connection.userid);
    if (user != null && user.group == ServerUsers.UserGroup.Moderator)
    {
        return true;
    }
    if (user != null && user.group == ServerUsers.UserGroup.Owner)
    {
        return true;
    }
    if (user != null && user.group == ServerUsers.UserGroup.SkipQueue)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.SkipQueue)
		{
			return true;
		}
		return false;
	}

```

## OnNpcConversationRespond(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
```csharp
/// <summary>
/// Called when a player responds to an NPC's conversation.
/// </summary>
/// <param name="npc">The NPC initiating the conversation.</param>
/// <param name="player">The player responding to the conversation.</param>
/// <param name="conversationData">The data for the current conversation.</param>
/// <param name="responseNode">The node representing the player's response.</param>
/// <returns>
/// Returns `null` if the NPC should proceed with the conversation as normal. 
/// If a non-null value is returned, it will override the default behavior and be used to determine what happens next in the conversation.
/// </returns>
object OnNpcConversationRespond(NPCTalking npc, BasePlayer player, ConversationData conversationData, ConversationData.ResponseNode responseNode)
{
    Puts($"Player {player.UserID} responded to NPC {npc.name}'s conversation with node {responseNode.id}");
    if (responseNode.id == "special_node")
    {
        Puts($"Player {player.UserID} triggered special node in NPC {npc.name}'s conversation");
        return "Special Node";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode != null && Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) == null)
		{
			if (responseNode.conditions.Length != 0)
			{
				UpdateFlags();
			}
			bool flag = responseNode.PassesConditions(player, this);
			if (flag && !string.IsNullOrEmpty(responseNode.actionString))
			{
				OnConversationAction(player, responseNode.actionString);
			}
			int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
			if (speechNodeIndex == -1)
			{
				ForceEndConversation(player);
				return;
			}
			ForceSpeechNode(player, speechNodeIndex);
			Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
		}
	}

```

## OnFindSpawnPoint(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a spawn point for a player is needed.
/// </summary>
/// <param name="player">The player who needs a spawn point.</param>
/// <returns>
/// Returns a non-null value to override the default spawn point behavior. 
/// If a `BasePlayer.SpawnPoint` object is returned, it will be used as the spawn point for the player.
/// </returns>
object OnFindSpawnPoint(BasePlayer player)
{
    Puts($"Finding spawn point for player {player.displayName}...");
    if (player.isModerator)
    {
        // Return a custom spawn point for moderators
        return new BasePlayer.SpawnPoint() { pos = Vector3(0, 10, 0), rot = Quaternion.identity };
    }
    else if (player.isSuperAdmin)
    {
        // Return a custom spawn point for super admins
        return new BasePlayer.SpawnPoint() { pos = Vector3(0, 20, 0), rot = Quaternion.identity };
    }
    else
    {
        // Use the default spawn point behavior
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null)
	{
		object obj = Interface.CallHook("OnFindSpawnPoint", forPlayer);
		if (obj is BasePlayer.SpawnPoint)
		{
			return (BasePlayer.SpawnPoint)obj;
		}
		bool flag = false;
		BaseGameMode baseGameMode = Gamemode();
		if ((bool)baseGameMode && baseGameMode.useCustomSpawns)
		{
			BasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);
			if (playerSpawn != null)
			{
				return playerSpawn;
			}
		}
		if (SingletonComponent<SpawnHandler>.Instance != null && !flag)
		{
			BasePlayer.SpawnPoint spawnPoint = SpawnHandler.GetSpawnPoint();
			if (spawnPoint != null)
			{
				return spawnPoint;
			}
		}
		BasePlayer.SpawnPoint spawnPoint2 = new BasePlayer.SpawnPoint();
		GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (array.Length != 0)
		{
			GameObject gameObject = array[UnityEngine.Random.Range(0, array.Length)];
			spawnPoint2.pos = gameObject.transform.position;
			spawnPoint2.rot = gameObject.transform.rotation;
		}
		else
		{
			Debug.Log("Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
			if (MainCamera.mainCamera != null)
			{
				spawnPoint2.pos = MainCamera.position;
				spawnPoint2.rot = MainCamera.rotation;
			}
		}
		if (UnityEngine.Physics.Raycast(new Ray(spawnPoint2.pos, Vector3.down), out var hitInfo, 32f, 1537286401))
		{
			spawnPoint2.pos = hitInfo.point;
		}
		return spawnPoint2;
	}

```

## OnEventTrigger(TriggeredEventPrefab)

```csharp
```csharp
/// <summary>
/// Called when an event is triggered.
/// </summary>
/// <param name="eventPrefab">The prefab of the triggered event.</param>
/// <returns>
/// Returns `null` to allow the event to trigger normally, or any non-null value to prevent the event from triggering.
/// </returns>
object OnEventTrigger(TriggeredEventPrefab eventPrefab)
{
    Puts($"Event {eventPrefab.resourcePath} has been triggered.");
    if (eventPrefab.eventType == EventType.Dangerous)
    {
        Puts($"Warning: Event {eventPrefab.resourcePath} is a dangerous event. Proceed with caution.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void RunEvent()
	{
		if (Interface.CallHook("OnEventTrigger", this) != null)
		{
			return;
		}
		Debug.Log("[event] " + targetPrefab.resourcePath);
		BaseEntity baseEntity = GameManager.server.CreateEntity(targetPrefab.resourcePath);
		if (!baseEntity)
		{
			return;
		}
		baseEntity.SendMessage("TriggeredEventSpawn", SendMessageOptions.DontRequireReceiver);
		baseEntity.Spawn();
		if (!shouldBroadcastSpawn)
		{
			return;
		}
		foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
		{
			if ((bool)activePlayer && activePlayer.IsConnected)
			{
				activePlayer.ShowToast(GameTip.Styles.Server_Event, spawnPhrase);
			}
		}
	}

```

## OnFuelConsume(BaseOven,Item,ItemModBurnable)

```csharp
```csharp
/// <summary>
/// Called when a fuel item is consumed by the oven.
/// </summary>
/// <param name="oven">The oven consuming the fuel.</param>
/// <param name="fuel">The fuel item being consumed.</param>
/// <param name="burnable">The burnable item being smelted.</param>
/// <returns>
/// Returns a non-null value to override the default consumption behavior. 
/// If `null` is returned, the fuel is consumed as normal.
/// </returns>
object OnFuelConsume(BaseOven oven, Item fuel, ItemModBurnable burnable)
{
    Puts($"Oven {oven.info.shortname} is consuming fuel {fuel.info.shortname} to smelt {burnable.info.shortname}.");
    if (fuel.amount < GetFuelRate())
    {
        Puts($"Not enough fuel to smelt {burnable.info.shortname}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		if (Interface.CallHook("OnFuelConsume", this, fuel, burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Facepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", this, fuel, burnable);
	}

```

## CanPickupEntity(BasePlayer,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pickup an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or any non-null value to override the default behavior. 
/// If a string is returned, the player will be notified with the provided message as the reason.
/// If `null` is returned, the default pickup rules apply.
/// </returns>
object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
{
    Puts($"Player {player.UserIDString} attempting to pick up entity {entity.EntityID}.");
    if (entity.IsLocked())
    {
        return "Cannot pick up locked entity.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (pickup.enabled)
		{
			if (!pickup.requireBuildingPrivilege || player.CanBuild())
			{
				if (pickup.requireHammer)
				{
					return player.IsHoldingEntity<Hammer>();
				}
				return true;
			}
			return false;
		}
		return false;
	}

```

## OnBuyVendingItem(VendingMachine,BasePlayer,int,int)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to buy an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <param name="player">The player attempting to make the purchase.</param>
/// <param name="itemIndex">The index of the item being purchased.</param>
/// <param name="quantity">The quantity of the item being purchased.</param>
/// <returns>
/// Returns `null` to allow the player to complete the purchase, or any non-null value to cancel the transaction.
/// </returns>
object OnBuyVendingItem(VendingMachine vendingMachine, BasePlayer player, int itemIndex, int quantity)
{
    Puts($"Player {player.UserIDString} attempted to buy {quantity}x {itemIndex} from vending machine {vendingMachine.name}");
    if (player.credits < GetPurchasePrice(itemIndex, quantity))
    {
        Puts($"Player {player.UserIDString} does not have enough credits to make the purchase.");
        return "Insufficient funds.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void BuyItem(RPCMessage rpc)
	{
		if (OccupiedCheck(rpc.player))
		{
			int num = rpc.read.Int32();
			int num2 = rpc.read.Int32();
			if (IsVending())
			{
				rpc.player.ShowToast(GameTip.Styles.Red_Normal, WaitForVendingMessage);
			}
			else if (Interface.CallHook("OnBuyVendingItem", this, rpc.player, num, num2) == null)
			{
				SetPendingOrder(rpc.player, num, num2);
				Invoke(CompletePendingOrder, GetBuyDuration());
			}
		}
	}

```

## OnTurretAssign(AutoTurret,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is assigned to a player.
/// </summary>
/// <param name="turret">The AutoTurret being assigned.</param>
/// <param name="playerId">The ID of the player being assigned.</param>
/// <param name="player">The BasePlayer object representing the player being assigned.</param>
/// <returns>
/// Returns a non-null value to override the default assignment behavior. 
/// If `null` is returned, the turret is assigned as normal.
/// </returns>
object OnTurretAssign(AutoTurret turret, ulong playerId, BasePlayer player)
{
    Puts($"Turret {turret.name} has been assigned to player {player.displayName} with ID {playerId}.");
    if (playerId == 1234567890L)
    {
        Puts($"Player {player.displayName} is not authorized to use this turret.");
        return "Unauthorized: Player ID mismatch.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", this, num, msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = num;
			playerNameID.username = username;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(playerNameID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", this, num, msg.player);
		}
	}

```

## CanCastFishingRod(BasePlayer,BaseFishingRod,Item,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to cast their fishing rod.
/// </summary>
/// <param name="player">The player attempting to cast.</param>
/// <param name="fishingRod">The fishing rod being used.</param>
/// <param name="lure">The lure being used on the fishing rod.</param>
/// <param name="position">The position where the player is trying to cast their line.</param>
/// <returns>
/// Returns a non-null value to override the default casting behavior. 
/// If `true` is returned, the player can cast their line as normal.
/// If `false` is returned, the player cannot cast their line at this location.
/// </returns>
object CanCastFishingRod(BasePlayer player, BaseFishingRod fishingRod, Item lure, Vector3 position)
{
    Puts($"Player {player.UserID} is attempting to cast their fishing rod at position {position}.");
    if (position == new Vector3(0f, 10f, 0f))
    {
        Puts($"Player {player.UserID} cannot cast their line at this location.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void Server_RequestCast(RPCMessage msg)
	{
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		object obj = Interface.CallHook("CanCastFishingRod", ownerPlayer, this, currentLure, pos);
		if (!(obj is bool) || (bool)obj)
		{
			FishingBobber component = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();
			component.transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component.Spawn();
			component.InitialiseBobber(ownerPlayer, surfaceBody, pos);
			lureUsed = currentLure.info;
			currentLure.UseItem();
			if (fishLookup == null)
			{
				fishLookup = PrefabAttribute.server.Find<FishLookup>(prefabID);
			}
			currentFishTarget = fishLookup.GetFish(component.transform.position, surfaceBody, lureUsed, out fishableModifier, lastFish);
			lastFish = fishableModifier;
			currentBobber.Set(component);
			ClientRPC(null, "Client_ReceiveCastPoint", component.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));
			catchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;
			float val = (lureUsed.TryGetComponent<ItemModCompostable>(out var component2) ? component2.BaitValue : 0f);
			val = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);
			catchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);
			playerStartPosition = ownerPlayer.transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			InvokeRepeating(CatchProcess, 0f, 0f);
			inQueue = false;
			Interface.CallHook("OnFishingRodCast", this, ownerPlayer, currentLure);
		}
	}

```

## OnFindBurnable(BaseOven)

```csharp
```csharp
/// <summary>
/// Called when an oven is searching for a burnable item.
/// </summary>
/// <param name="oven">The oven searching for a burnable item.</param>
/// <returns>
/// Returns the first burnable item found in the oven's inventory, or `null` if no burnable items are found.
/// If the return value is not an Item object, it will be treated as null.
/// </returns>
Item OnFindBurnable(BaseOven oven)
{
    Puts($"Oven {oven.GetInventory().GetSlot(0).item.name} is searching for a burnable item.");
    if (oven.GetInventory().GetSlot(0).item.name == "Wood")
    {
        return null;
    }
    return oven.GetInventory().GetFirstItem();
}
```
```

### Source Code from the Library

```csharp

	public Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (base.inventory == null)
		{
			return null;
		}
		foreach (Item item in base.inventory.itemList)
		{
			if (IsBurnableItem(item))
			{
				return item;
			}
		}
		return null;
	}

```

## OnVehicleModuleDeselected(ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is deselected.
/// </summary>
/// <param name="garage">The modular car garage.</param>
/// <param name="player">The player who deselected the module.</param>
/// <returns>No return behavior.</returns>
void OnVehicleModuleDeselected(ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.UserIDString} deselected a vehicle module in garage {garage.garageID}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_DeselectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player.inventory.loot.IsLooting() && !(player.inventory.loot.entitySource != this))
		{
			if (player.inventory.loot.RemoveContainerAt(3))
			{
				player.inventory.loot.SendImmediate();
			}
			Interface.CallHook("OnVehicleModuleDeselected", this, player);
		}
	}

```

## OnMapMarkersCleared(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when all map markers are cleared.
/// </summary>
/// <param name="player">The player who initiated the clear.</param>
void OnMapMarkersCleared(BasePlayer player)
{
    Puts($"All map markers have been cleared for player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(1uL)]
	public void Server_ClearMapMarkers(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkersClear", this, State.pointsOfInterest) != null)
		{
			return;
		}
		ServerCurrentDeathNote?.Dispose();
		ServerCurrentDeathNote = null;
		if (State.pointsOfInterest != null)
		{
			foreach (MapNote item in State.pointsOfInterest)
			{
				item?.Dispose();
			}
			State.pointsOfInterest.Clear();
		}
		DirtyPlayerState();
		TeamUpdate();
		Interface.CallHook("OnMapMarkersCleared", this);
	}

```

## OnTurretClearList(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the turret's list of authorized players is cleared.
/// </summary>
/// <param name="turret">The AutoTurret instance.</param>
/// <param name="player">The player whose authorization was cleared.</param>
/// <returns>No return behavior.</returns>
void OnTurretClearList(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.entityID} has cleared the list of authorized players for {player.displayName}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void ClearList(RPCMessage rpc)
	{
		if (!booting && !IsOnline() && IsAuthed(rpc.player) && Interface.CallHook("OnTurretClearList", this, rpc.player) == null)
		{
			authorizedPlayers.Clear();
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "clear", rpc.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnTeamCreated(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team is created.
/// </summary>
/// <param name="player">The player who created the team.</param>
/// <param name="team">The newly created team.</param>
/// <returns>No return behavior.</returns>
void OnTeamCreated(BasePlayer player, PlayerTeam team)
{
    Puts($"Team {team.teamID} created by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Facepunch.Rust.Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnItemCraft(ItemCraftTask,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is crafted.
/// </summary>
/// <param name="itemCraftTask">The task associated with the crafting.</param>
/// <param name="owner">The player who initiated the crafting.</param>
/// <param name="fromTempBlueprint">The blueprint used for the crafting (if any).</param>
/// <returns>
/// Returns a non-null value to override the default crafting behavior. 
/// If `true` is returned, the crafting will be allowed as normal.
/// If `false` is returned, the crafting will be cancelled.
/// </returns>
object OnItemCraft(ItemCraftTask itemCraftTask, BasePlayer owner, Item fromTempBlueprint)
{
    Puts($"Player {owner.displayName} has initiated an item craft with task UID {itemCraftTask.taskUID}.");
    if (fromTempBlueprint != null && fromTempBlueprint.itemid == 12345)
    {
        Puts($"Player {owner.displayName} is attempting to craft a restricted item.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CraftItem(ItemBlueprint bp, BasePlayer owner, ProtoBuf.Item.InstanceData instanceData = null, int amount = 1, int skinID = 0, Item fromTempBlueprint = null, bool free = false)
	{
		if (!CanCraft(bp, amount, free))
		{
			return false;
		}
		taskUID++;
		ItemCraftTask itemCraftTask = Facepunch.Pool.Get<ItemCraftTask>();
		itemCraftTask.blueprint = bp;
		if (!free)
		{
			CollectIngredients(bp, itemCraftTask, amount, owner);
		}
		itemCraftTask.endTime = 0f;
		itemCraftTask.taskUID = taskUID;
		itemCraftTask.owner = owner;
		itemCraftTask.instanceData = instanceData;
		if (itemCraftTask.instanceData != null)
		{
			itemCraftTask.instanceData.ShouldPool = false;
		}
		itemCraftTask.amount = amount;
		itemCraftTask.skinID = skinID;
		if (fromTempBlueprint != null && itemCraftTask.takenItems != null)
		{
			fromTempBlueprint.RemoveFromContainer();
			itemCraftTask.takenItems.Add(fromTempBlueprint);
			itemCraftTask.conditionScale = 0.5f;
		}
		object obj = Interface.CallHook("OnItemCraft", itemCraftTask, owner, fromTempBlueprint);
		if (obj is bool)
		{
			if (fromTempBlueprint != null && itemCraftTask.instanceData != null)
			{
				fromTempBlueprint.instanceData = itemCraftTask.instanceData;
			}
			return (bool)obj;
		}
		queue.AddLast(itemCraftTask);
		if (itemCraftTask.owner != null)
		{
			itemCraftTask.owner.Command("note.craft_add", itemCraftTask.taskUID, itemCraftTask.blueprint.targetItem.itemid, amount, itemCraftTask.skinID);
		}
		return true;
	}

```

## OnTerrainInitialized()

```csharp
```csharp
/// <summary>
/// Called when the terrain has been initialized.
/// </summary>
void OnTerrainInitialized()
{
    Puts("Terrain initialization complete.");
    
    // Minimal code to demonstrate functionality
    // You can add any necessary setup or initialization here
}
```
```

### Source Code from the Library

```csharp

	public void PostSetupComponents()
	{
		TerrainExtension[] components = GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

```

## CanPurchaseItem(BasePlayer,Item,System.Action<BasePlayer, Item>,VendingMachine,ItemContainer)

```csharp
Based on the provided code, here is a method structure that follows the specified format:

```csharp
/// <summary>
/// Called when an item can be purchased from a vending machine.
/// </summary>
/// <param name="buyer">The player who is purchasing the item.</param>
/// <param name="item">The item being purchased.</param>
/// <param name="onItemPurchased">An action to invoke after the item has been purchased.</param>
/// <param name="vendingMachine">The vending machine from which the item was purchased.</param>
/// <param name="targetContainer">The container into which the item will be placed, or null if it should be dropped at the player's feet.</param>
/// <returns>
/// Returns a non-null value to override the default purchase behavior. 
/// If true is returned, the item will be purchased and added to the target container.
/// </returns>
public bool CanPurchaseItem(Player buyer, Item item, Action<Player, Item> onItemPurchased, VendingMachine vendingMachine, Container targetContainer)
{
    // Implementation of this method would go here
}
```

This method structure follows the specified format by including a summary description, parameters for the player who is purchasing the item, the item being purchased, an action to invoke after the item has been purchased, and the vending machine from which the item was purchased. The return value indicates whether the item should be purchased and added to the target container.
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions, targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> obj2 = Facepunch.Pool.GetList<Item>();
		GetItemsToSell(sellOrder, obj2);
		if (obj2 == null || obj2.Count == 0)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = obj2.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
		if (source.Count == 0)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
		if (num3 < num4)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			TakeCurrencyItem(item);
			onCurrencyRemoved?.Invoke(buyer, item);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		Facepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem * numberOfTransactions, sellOrder.currencyIsBP, numberOfTransactions, droneMarketTerminal);
		int num7 = 0;
		foreach (Item item4 in obj2)
		{
			int num8 = num - num7;
			Item item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);
			if (item2 == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item2.amount;
				object obj3 = Interface.CallHook("CanPurchaseItem", buyer, item2, onItemPurchased, this, targetContainer);
				if (obj3 is bool)
				{
					return (bool)obj3;
				}
				RecordSaleAnalytics(item2);
				if (targetContainer == null)
				{
					GiveSoldItem(item2, buyer);
				}
				else if (!item2.MoveToContainer(targetContainer))
				{
					item2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
				}
				onItemPurchased?.Invoke(buyer, item2);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## CanDismountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when an entity is dismounted.
/// </summary>
/// <param name="entity">The entity being dismounted.</param>
/// <param name="player">The player who was mounted on the entity.</param>
/// <returns>
/// Returns a non-null value to override the default dismount behavior. 
/// If `null` is returned, the entity is dismounted as normal.
/// </returns>
object OnEntityDismounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Entity {entity} has been dismounted by player {player}.");
    if (entity == null || player == null)
    {
        return null;
    }
    // Add custom logic here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
		}
		else
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.SendModelState(force: true);
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPCPlayer(null, player, "ForcePositionToParentOffset", baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPCPlayer(null, player, "ForcePositionTo", res);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnBradleyApcInitialize(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is initialized.
/// </summary>
/// <param name="apc">The Bradley APC instance.</param>
/// <returns>
/// Returns `null` to allow the APC to initialize normally, or any non-null value to override the default initialization behavior.
/// </returns>
object OnBradleyApcInitialize(BradleyAPC apc)
{
    Puts($"Bradley APC initialized at position: {apc.transform.position}");
    // If you want to change the destination of the APC, do it here
    apc.destination = new Vector3(10.0f, 5.0f, 2.0f);
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Initialize()
	{
		if (Interface.CallHook("OnBradleyApcInitialize", this) == null)
		{
			myRigidBody.centerOfMass = centerOfMass.localPosition;
			destination = base.transform.position;
			finalDestination = base.transform.position;
		}
	}

```

## OnSprinklerSplashed(Sprinkler)

```csharp
```csharp
/// <summary>
/// Called when a sprinkler splashes.
/// </summary>
/// <param name="sprinkler">The sprinkler that splashed.</param>
/// <returns>
/// Returns `true` if the splash was handled by a hook, otherwise returns `false`.
/// </returns>
bool OnSprinklerSplashed(Sprinkler sprinkler)
{
    Puts($"Sprinkler {sprinkler} has splashed.");
    // You can add custom logic here to handle the splash
    return false;
}
```
```

### Source Code from the Library

```csharp

	private void DoSplash()
	{
		using (TimeWarning.New("SprinklerSplash"))
		{
			int num = WaterPerSplash;
			if ((float)updateSplashableCache > SplashFrequency * 4f || forceUpdateSplashables)
			{
				cachedSplashables.Clear();
				forceUpdateSplashables = false;
				updateSplashableCache = 0f;
				Vector3 position = Eyes.position;
				Vector3 up = base.transform.up;
				float sprinklerEyeHeightOffset = Server.sprinklerEyeHeightOffset;
				float value = Vector3.Angle(up, Vector3.up) / 180f;
				value = Mathf.Clamp(value, 0.2f, 1f);
				sprinklerEyeHeightOffset *= value;
				Vector3 startPosition = position + up * (Server.sprinklerRadius * 0.5f);
				Vector3 endPosition = position + up * sprinklerEyeHeightOffset;
				List<BaseEntity> obj = Facepunch.Pool.GetList<BaseEntity>();
				Vis.Entities(startPosition, endPosition, Server.sprinklerRadius, obj, 1236478737);
				if (obj.Count > 0)
				{
					foreach (BaseEntity item in obj)
					{
						if (!item.isClient && item is ISplashable splashable && !cachedSplashables.Contains(splashable) && splashable.WantsSplash(currentFuelType, num) && item.IsVisible(position) && (!(item is IOEntity entity) || !IsConnectedTo(entity, IOEntity.backtracking)))
						{
							cachedSplashables.Add(splashable);
						}
					}
				}
				Facepunch.Pool.FreeList(ref obj);
			}
			if (cachedSplashables.Count > 0)
			{
				int amount = num / cachedSplashables.Count;
				foreach (ISplashable cachedSplashable in cachedSplashables)
				{
					if (!ObjectEx.IsUnityNull(cachedSplashable) && cachedSplashable.WantsSplash(currentFuelType, amount))
					{
						int num2 = cachedSplashable.DoSplash(currentFuelType, amount);
						num -= num2;
						if (num <= 0)
						{
							break;
						}
					}
				}
			}
			if (DecayPerSplash > 0f)
			{
				Hurt(DecayPerSplash);
			}
		}
		Interface.CallHook("OnSprinklerSplashed", this);
	}

```

## CanDeployItem(BasePlayer,Deployer,NetworkableId)

```csharp
```csharp
/// <summary>
/// Called to check if an item can be deployed.
/// </summary>
/// <param name="player">The player attempting to deploy the item.</param>
/// <param name="deployer">The deployable item being used.</param>
/// <param name="networkableId">The ID of the entity being targeted for deployment.</param>
/// <returns>
/// Returns `null` if the item can be deployed, or any non-null value to prevent deployment.
/// </returns>
object CanDeployItem(BasePlayer player, Deployer deployer, NetworkableId networkableId)
{
    Puts($"Player {player.UserIDString} is attempting to deploy {deployer.name} on entity {networkableId}.");
    if (networkableId == "restricted")
    {
        Puts($"Deployment of {deployer.name} on entity {networkableId} has been blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDeploy(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Deployable deployable = GetDeployable();
		if (deployable == null)
		{
			return;
		}
		Ray ray = msg.read.Ray();
		NetworkableId networkableId = msg.read.EntityID();
		if (Interface.CallHook("CanDeployItem", msg.player, this, networkableId) == null)
		{
			if (deployable.toSlot)
			{
				DoDeploy_Slot(deployable, ray, networkableId);
			}
			else
			{
				DoDeploy_Regular(deployable, ray);
			}
		}
	}

```

## OnMapMarkerAdd(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a new map marker is added.
/// </summary>
/// <param name="player">The player who added the marker.</param>
/// <param name="mapNote">The details of the map note, including its position and description.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkerAdd(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.UserIDString} added a new map marker at {mapNote.position} with description: {mapNote.description}");
    if (mapNote.description == "Restricted Area")
    {
        Puts($"Player {player.displayName} is not allowed to add markers in restricted areas.");
        return;
    }
    Interface.CallHook("OnMapMarkerAdded", player, mapNote);
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 13L;
			if (State.pointsOfInterest == null)
			{
				State.pointsOfInterest = Facepunch.Pool.GetList<MapNote>();
			}
			if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
			{
				msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, ConVar.Server.maximumMapMarkers.ToString());
				return;
			}
			MapNote mapNote = MapNote.Deserialize(msg.read);
			ValidateMapNote(mapNote);
			mapNote.colourIndex = State.pointsOfInterest.Count;
			State.pointsOfInterest.Add(mapNote);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, mapNote);
		}
	}

```

## CanMountEntity(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when an entity is mounted by a player.
/// </summary>
/// <param name="player">The player mounting the entity.</param>
/// <param name="entity">The entity being mounted.</param>
/// <returns>
/// Returns `null` to allow the entity to be mounted, or any non-null value to prevent it from being mounted.
/// </returns>
object CanMountEntity(BasePlayer player, BaseMountable entity)
{
    Puts($"Player {player.UserIDString} is trying to mount {entity.GetType().Name}");
    if (entity.IsBroken())
    {
        Puts($"Cannot mount {entity.GetType().Name} because it's broken.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform transform = mountAnchor.transform;
			player.MountObject(this);
			player.MovePosition(transform.position);
			player.transform.rotation = transform.rotation;
			player.ServerRotation = transform.rotation;
			player.OverrideViewAngles(transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnWaterCollect(WaterPump,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when water is collected from a resource.
/// </summary>
/// <param name="pump">The water pump collecting the water.</param>
/// <param name="itemDefinition">The item definition of the collected water.</param>
/// <returns>
/// Returns `null` to allow the water collection, or any non-null value to prevent it.
/// </returns>
object OnWaterCollect(WaterPump pump, ItemDefinition itemDefinition)
{
    Puts($"Water collected from resource at position {pump.position} with definition {itemDefinition.name}");
    if (itemDefinition.category == "poisonous")
    {
        Puts($"Collected water is poisonous and cannot be used.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CreateWater()
	{
		if (!IsFull())
		{
			ItemDefinition atPoint = WaterResource.GetAtPoint(WaterResourceLocation.position);
			if (atPoint != null && Interface.CallHook("OnWaterCollect", this, atPoint) == null)
			{
				base.inventory.AddItem(atPoint, AmountPerPump, 0uL);
				UpdateOnFlag();
			}
		}
	}

```

## OnEngineStarted(MotorRowboat,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the engine is started.
/// </summary>
/// <param name="rowboat">The rowboat that the engine belongs to.</param>
/// <param name="driver">The player driving the rowboat.</param>
/// <returns>
/// Returns `null` to allow the engine to start, or any non-null value to prevent it from starting.
/// </returns>
object OnEngineStarted(MotorRowboat rowboat, BasePlayer driver)
{
    Puts($"Engine started on {rowboat.GetDisplayName()} by player {driver.UserIDString}");
    if (driver == null)
    {
        Puts($"Error: Driver is not set for {rowboat.GetDisplayName()}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.Reserved1, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
		}
	}

```

## CanWaterBallSplash(ItemDefinition,UnityEngine.Vector3,float,int)

```csharp
```csharp
/// <summary>
/// Called when a water ball splashes.
/// </summary>
/// <param name="liquidDef">The definition of the liquid being splashed.</param>
/// <param name="position">The position where the splash is occurring.</param>
/// <param name="radius">The radius of the splash.</param>
/// <param name="amount">The amount of liquid to splash.</param>
/// <returns>
/// Returns a non-null value to override the default splash behavior. 
/// If `true` is returned, the splash will be allowed as normal.
/// If `false` is returned, the splash will be blocked.
/// </returns>
bool CanWaterBallSplash(ItemDefinition liquidDef, Vector3 position, float radius, int amount)
{
    Puts($"A water ball is splashing at {position} with a radius of {radius} and an amount of {amount} units of {liquidDef.name}.");
    if (liquidDef.name == "Toxic Waste")
    {
        Puts($"The splash is blocked due to the toxic nature of the liquid.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)
	{
		object obj = Interface.CallHook("CanWaterBallSplash", liquidDef, position, radius, amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		List<BaseEntity> obj2 = Pool.GetList<BaseEntity>();
		Vis.Entities(position, radius, obj2, 1219701523);
		int num = 0;
		int num2 = amount;
		while (amount > 0 && num < 3)
		{
			List<ISplashable> obj3 = Pool.GetList<ISplashable>();
			foreach (BaseEntity item in obj2)
			{
				if (!item.isClient && item is ISplashable splashable && !obj3.Contains(splashable) && splashable.WantsSplash(liquidDef, amount))
				{
					obj3.Add(splashable);
				}
			}
			if (obj3.Count == 0)
			{
				break;
			}
			int b = Mathf.CeilToInt(amount / obj3.Count);
			foreach (ISplashable item2 in obj3)
			{
				int num3 = item2.DoSplash(liquidDef, Mathf.Min(amount, b));
				amount -= num3;
				if (amount <= 0)
				{
					break;
				}
			}
			Pool.FreeList(ref obj3);
			num++;
		}
		Pool.FreeList(ref obj2);
		return amount < num2;
	}

```

## OnNpcGiveSoldItem(NPCVendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC vending machine gives a sold item to a player.
/// </summary>
/// <param name="vendingMachine">The NPC vending machine that gave the item.</param>
/// <param name="soldItem">The item that was given to the player.</param>
/// <param name="buyer">The player who bought the item.</param>
/// <returns>
/// Returns `null` to allow the item to be given, or any non-null value to prevent the item from being given.
/// </returns>
object OnNpcGiveSoldItem(NPCVendingMachine vendingMachine, Item soldItem, BasePlayer buyer)
{
    Puts($"NPC {vendingMachine.name} gave player {buyer.UserIDString} item {soldItem.displayName}");
    if (soldItem.category == "rare")
    {
        Puts($"Player {buyer.UserIDString} is not allowed to buy rare items from NPC {vendingMachine.name}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnNpcGiveSoldItem", this, soldItem, buyer) == null)
		{
			base.GiveSoldItem(soldItem, buyer);
		}
	}

```

## OnItemLock(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is locked or unlocked.
/// </summary>
/// <param name="item">The item being locked or unlocked.</param>
/// <returns>
/// Returns `null` to allow the item to be locked or unlocked, or any non-null value to prevent it from being locked or unlocked.
/// </returns>
object OnItemLock(Item item)
{
    Puts($"Item {item.Name} has been locked.");
    if (item.Name == "Golden Key")
    {
        Puts($"Item {item.Name} cannot be locked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LockUnlock(bool bNewState)
	{
		if (HasFlag(Flag.IsLocked) != bNewState && (!bNewState || Interface.CallHook("OnItemLock", this) == null) && (bNewState || Interface.CallHook("OnItemUnlock", this) == null))
		{
			SetFlag(Flag.IsLocked, bNewState);
			MarkDirty();
		}
	}

```

## OnTeamRejectInvite(BasePlayer,RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team rejects an invite from another player.
/// </summary>
/// <param name="inviter">The player who sent the invitation.</param>
/// <param name="team">The team that rejected the invitation.</param>
/// <returns>
/// Returns `null` to allow the team to reject the invitation, or any non-null value to override the rejection behavior.
/// </returns>
object OnTeamRejectInvite(BasePlayer inviter, PlayerTeam team)
{
    Puts($"Team {team.Name} has rejected an invite from player {inviter.UserIDString}");
    if (team.Name == "Admins")
    {
        Puts($"Team {team.Name} has blocked the invitation from player {inviter.displayName}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void rejectinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamRejectInvite", basePlayer, playerTeam) == null)
			{
				playerTeam.RejectInvite(basePlayer);
			}
		}
	}

```

## OnLiquidWeaponFiringStopped(LiquidWeapon)

```csharp
```csharp
/// <summary>
/// Called when a liquid weapon's firing is stopped.
/// </summary>
/// <param name="liquidWeapon">The liquid weapon that stopped firing.</param>
/// <returns>No return behavior.</returns>
void OnLiquidWeaponFiringStopped(LiquidWeapon liquidWeapon)
{
    Puts($"Liquid weapon {liquidWeapon.name} has stopped firing.");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StopFiring()
	{
		CancelInvoke("FireTick");
		if (!RequiresPumping)
		{
			pressure = MaxPressure;
		}
		SetFlag(Flags.On, b: false);
		if (base.isServer)
		{
			SendNetworkUpdateImmediate();
		}
		Interface.CallHook("OnLiquidWeaponFiringStopped", this);
	}

```

## OnFireworkStarted(BaseFirework)

```csharp
```csharp
/// <summary>
/// Called when a firework is started.
/// </summary>
/// <param name="firework">The firework that was started.</param>
/// <returns>No return behavior.</returns>
void OnFireworkStarted(BaseFirework firework)
{
    Puts($"Firework {firework.FireworkID} has been started.");
}
```
```

### Source Code from the Library

```csharp

	public virtual void Begin()
	{
		SetFlag(Flags.OnFire, b: false);
		SetFlag(Flags.On, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		Interface.CallHook("OnFireworkStarted", this);
		Invoke(OnExhausted, activityLength);
	}

```

## OnMissionSucceeded(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is successfully completed.
/// </summary>
/// <param name="instance">The mission instance that was completed.</param>
/// <param name="assignee">The player who was assigned to the mission.</param>
/// <returns>No return behavior.</returns>
void OnMissionSucceeded(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts($"Mission {instance.missionName} completed by player {assignee.displayName}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionSuccess(MissionInstance instance, BasePlayer assignee)
	{
		instance.status = MissionStatus.Accomplished;
		MissionEnded(instance, assignee);
		MissionComplete(instance, assignee);
		Interface.CallHook("OnMissionSucceeded", this, instance, assignee);
	}

```

## OnVehicleModuleMove(BaseVehicleModule,BaseModularVehicle,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is moved.
/// </summary>
/// <param name="module">The vehicle module being moved.</param>
/// <param name="vehicle">The modular vehicle the module belongs to.</param>
/// <param name="player">The player moving the module.</param>
/// <returns>
/// Returns `true` if the module can be moved, or `false` if it cannot.
/// If a non-bool value is returned, the method will return false.
/// </returns>
object OnVehicleModuleMove(BaseVehicleModule module, BaseModularVehicle vehicle, BasePlayer player)
{
    Puts($"Player {player.UserIDString} is moving module {module.DisplayName} on vehicle {vehicle.DisplayName}");
    if (module.IsLocked)
    {
        Puts($"Module {module.DisplayName} is locked and cannot be moved.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanMoveFrom(BasePlayer player, Item item)
	{
		BaseVehicleModule moduleForItem = GetModuleForItem(item);
		if (moduleForItem != null)
		{
			object obj = Interface.CallHook("OnVehicleModuleMove", moduleForItem, this, player);
			if (obj != null)
			{
				if (!(obj is bool))
				{
					return false;
				}
				return (bool)obj;
			}
			return moduleForItem.CanBeMovedNow();
		}
		return true;
	}

```

## CanNetworkTo(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the server should network with a given player.
/// </summary>
/// <param name="player">The player in question.</param>
/// <returns>
/// Returns `true` if the server should network with the player, and `false` otherwise.
/// If this method returns `null`, the default behavior will be used.
/// </returns>
object CanNetworkTo(BasePlayer player)
{
    Puts($"Checking if server should network with player {player.UserIDString}");
    if (player.IsBanned())
    {
        Puts($"Server will not network with banned player {player.UserIDString}");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", this, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsSpectating() && player != this && !player.net.connection.info.GetBool("global.specnet"))
		{
			return false;
		}
		return base.ShouldNetworkTo(player);
	}

```

## OnTerrainCreate(TerrainGenerator)

```csharp
```csharp
/// <summary>
/// Called when a terrain is created.
/// </summary>
/// <param name="generator">The terrain generator used to create the terrain.</param>
/// <returns>
/// Returns `null` if the default terrain creation behavior should be used. 
/// If a non-null value is returned, it will override the default behavior and return that value instead.
/// </returns>
object OnTerrainCreate(TerrainGenerator generator)
{
    Puts("Terrain created.");
    // You can add custom logic here to modify or replace the generated terrain
    return null;
}
```
```

### Source Code from the Library

```csharp

	public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
	{
		Interface.CallHook("OnTerrainCreate", this);
		Terrain component = Terrain.CreateTerrainGameObject(new TerrainData
		{
			baseMapResolution = GetBaseMapRes(),
			heightmapResolution = heightmapResolution,
			alphamapResolution = alphamapResolution,
			size = new Vector3(World.Size, 1000f, World.Size)
		}).GetComponent<Terrain>();
		component.transform.position = base.transform.position + new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);
		component.drawInstanced = false;
		component.castShadows = config.CastShadows;
		component.materialType = Terrain.MaterialType.Custom;
		component.materialTemplate = config.Material;
		component.gameObject.tag = base.gameObject.tag;
		component.gameObject.layer = base.gameObject.layer;
		component.gameObject.GetComponent<TerrainCollider>().sharedMaterial = config.GenericMaterial;
		TerrainMeta terrainMeta = component.gameObject.AddComponent<TerrainMeta>();
		component.gameObject.AddComponent<TerrainPhysics>();
		component.gameObject.AddComponent<TerrainColors>();
		component.gameObject.AddComponent<TerrainCollision>();
		component.gameObject.AddComponent<TerrainBiomeMap>();
		component.gameObject.AddComponent<TerrainAlphaMap>();
		component.gameObject.AddComponent<TerrainHeightMap>();
		component.gameObject.AddComponent<TerrainSplatMap>();
		component.gameObject.AddComponent<TerrainTopologyMap>();
		component.gameObject.AddComponent<TerrainWaterMap>();
		component.gameObject.AddComponent<TerrainPlacementMap>();
		component.gameObject.AddComponent<TerrainPath>();
		component.gameObject.AddComponent<TerrainTexturing>();
		terrainMeta.terrain = component;
		terrainMeta.config = config;
		Object.DestroyImmediate(base.gameObject);
		return component.gameObject;
	}

```

## OnBonusItemDrop(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is dropped.
/// </summary>
/// <param name="item">The dropped item.</param>
/// <param name="player">The player who dropped the item.</param>
/// <returns>
/// Returns a non-null value to override the default drop behavior. 
/// If `null` is returned, the item will be dropped as normal.
/// </returns>
object OnBonusItemDrop(Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} has dropped a bonus item: {item.info.name}");
    if (item.info.name == "Golden Coin")
    {
        Puts($"Player {player.displayName} has dropped a Golden Coin!");
        return "Golden Coin found!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnFireBallDamage(FireBall,BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a fireball deals damage to an entity.
/// </summary>
/// <param name="fireBall">The fireball that dealt the damage.</param>
/// <param name="entity">The entity that was damaged.</param>
/// <param name="hitInfo">Information about the hit, including the damage type and amount.</param>
/// <returns>
/// Returns a non-null value to override the default damage behavior. 
/// If `null` is returned, the entity will be damaged as normal.
/// </returns>
object OnFireBallDamage(FireBall fireBall, BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Fireball dealt {hitInfo.damageTypes.Get(DamageType.Heat)} damage to {entity}.");
    if (entity is BasePlayer && entity.SteamId == 1234567890)
    {
        Puts($"Player with SteamID 1234567890 was damaged by fireball.");
        return "Blocked: Player is immune to fireball damage.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoRadialDamage()
	{
		List<Collider> obj = Pool.GetList<Collider>();
		Vector3 position = base.transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Colliders(position, radius, obj, AttackLayers);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = ((creatorEntity == null) ? GameObjectEx.ToBaseEntity(base.gameObject) : creatorEntity);
		hitInfo.PointStart = base.transform.position;
		foreach (Collider item in obj)
		{
			if (item.isTrigger && (item.gameObject.layer == 29 || item.gameObject.layer == 18))
			{
				continue;
			}
			BaseCombatEntity baseCombatEntity = GameObjectEx.ToBaseEntity(item.gameObject) as BaseCombatEntity;
			if (!(baseCombatEntity == null) && baseCombatEntity.isServer && baseCombatEntity.IsAlive() && (!ignoreNPC || !baseCombatEntity.IsNpc) && baseCombatEntity.IsVisible(position))
			{
				if (baseCombatEntity is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", baseCombatEntity, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = baseCombatEntity.transform.position;
				hitInfo.HitPositionWorld = baseCombatEntity.transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", this, baseCombatEntity, hitInfo);
				baseCombatEntity.OnAttacked(hitInfo);
			}
		}
		Pool.FreeList(ref obj);
	}

```

## OnPhoneNameUpdated(PhoneController,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone's name is updated.
/// </summary>
/// <param name="phoneController">The controller of the phone being updated.</param>
/// <param name="newName">The new name for the phone.</param>
/// <param name="player">The player who made the update.</param>
/// <returns>
/// Returns `null` to allow the update, or any non-null value to prevent the update.
/// </returns>
object OnPhoneNameUpdated(PhoneController phoneController, string newName, BasePlayer player)
{
    Puts($"Phone {phoneController.GetDisplayName()} updated by {player.displayName} with new name: {newName}");
    if (newName == "Admin Phone")
    {
        Puts($"Phone {phoneController.GetDisplayName()} cannot be renamed to 'Admin Phone'.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdatePhoneName(BaseEntity.RPCMessage msg)
	{
		if (!(msg.player != currentPlayer))
		{
			string text = msg.read.String();
			if (text.Length > 20)
			{
				text = text.Substring(0, 20);
			}
			if (Interface.CallHook("OnPhoneNameUpdate", this, text, msg.player) == null)
			{
				PhoneName = text;
				base.baseEntity.SendNetworkUpdate();
				Interface.CallHook("OnPhoneNameUpdated", this, PhoneName, msg.player);
			}
		}
	}

```

## OnLiquidVesselFill(BaseLiquidVessel,BasePlayer,LiquidContainer)

```csharp
```csharp
/// <summary>
/// Called when a liquid vessel is being filled.
/// </summary>
/// <param name="vessel">The liquid vessel being filled.</param>
/// <param name="player">The player who owns the vessel.</param>
/// <param name="container">The liquid container being used to fill the vessel, or null if filling from the world.</param>
/// <returns>
/// Returns `null` to allow the vessel to be filled as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the vessel from being filled.
/// </returns>
object OnLiquidVesselFill(BaseLiquidVessel vessel, BasePlayer player, LiquidContainer container)
{
    Puts($"Liquid vessel {vessel.name} owned by {player.displayName} is being filled.");
    if (container != null && container.info == "Toxic Waste")
    {
        Puts($"Filling vessel with toxic waste has been prevented.");
        return "Cannot fill vessel with toxic waste.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FillCheck()
	{
		if (base.isClient)
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		float f = (UnityEngine.Time.realtimeSinceStartup - lastFillTime) * fillMlPerSec;
		Vector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);
		LiquidContainer facingLiquidContainer = GetFacingLiquidContainer();
		if (Interface.CallHook("OnLiquidVesselFill", this, ownerPlayer, facingLiquidContainer) != null)
		{
			return;
		}
		if (facingLiquidContainer == null && CanFillFromWorld())
		{
			AddLiquid(WaterResource.GetAtPoint(pos), Mathf.FloorToInt(f));
		}
		else if (facingLiquidContainer != null && facingLiquidContainer.HasLiquidItem())
		{
			int num = Mathf.CeilToInt((1f - HeldFraction()) * (float)MaxHoldable());
			if (num > 0)
			{
				Item liquidItem = facingLiquidContainer.GetLiquidItem();
				int num2 = Mathf.Min(Mathf.CeilToInt(f), Mathf.Min(liquidItem.amount, num));
				AddLiquid(liquidItem.info, num2);
				liquidItem.UseItem(num2);
				facingLiquidContainer.OpenTap(2f);
			}
		}
		lastFillTime = UnityEngine.Time.realtimeSinceStartup;
	}

```

## OnMeleeAttack(BasePlayer,HitInfo)

```csharp
This is a C# code snippet that appears to be part of a larger system, likely a game or simulation. It's implementing some sort of anti-hacking mechanism for melee attacks.

Here's a breakdown of the code:

**Purpose**: The purpose of this code is to detect and prevent hacking attempts in melee attacks. Specifically, it checks if an attacker is too far away from their target, and if so, logs a violation and penalizes the attacker.

**Variables**:

* `player`: The player performing the attack.
* `hitInfo`: Information about the hit (e.g., position, normal vector).
* `flag6`, `flag7`, `flag8`: Flags used to track various conditions.
* `num13`, `num14`, `num15`: Numbers used in calculations.
* `layerMask`: A mask used for line-of-sight checks.

**Main Logic**:

1. The code first checks if the attacker is too far away from their target (i.e., `flag6` is true). If so, it logs a violation and penalizes the attacker.
2. If not, it proceeds to check if there's a valid line of sight between the attacker and the target. This involves checking three lines of sight: from the attacker's eyes to the target, from the target to the attacker's eyes, and from the attacker's eyes to the point where they hit the target.
3. If all three lines of sight are valid, it sets `num15` to 1 (indicating a direct line of sight).
4. If not, it sets `num15` to 0 (indicating an indirect line of sight).

**Penalty and Logging**:

* If the attacker is too far away or there's no valid line of sight, the code logs a violation and penalizes the attacker using the `AntiHack.AddViolation` method.
* Additionally, it logs an invalid hit using the `player.stats.combat.LogInvalid` method.

Overall, this code snippet appears to be part of a larger system that aims to prevent hacking attempts in melee attacks by detecting and penalizing attackers who are too far away from their targets or lack a valid line of sight.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PlayerAttack(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		using (TimeWarning.New("PlayerAttack", 50))
		{
			using PlayerAttack playerAttack = ProtoBuf.PlayerAttack.Deserialize(msg.read);
			if (playerAttack == null)
			{
				return;
			}
			HitInfo hitInfo = Facepunch.Pool.Get<HitInfo>();
			hitInfo.LoadFromAttack(playerAttack.attack, serverSide: true);
			hitInfo.Initiator = player;
			hitInfo.Weapon = this;
			hitInfo.WeaponPrefab = this;
			hitInfo.Predicted = msg.connection;
			hitInfo.damageProperties = damageProperties;
			if (Interface.CallHook("OnMeleeAttack", player, hitInfo) != null)
			{
				return;
			}
			if (hitInfo.IsNaNOrInfinity())
			{
				string shortPrefabName = base.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
				player.stats.combat.LogInvalid(hitInfo, "melee_nan");
				return;
			}
			BaseEntity hitEntity = hitInfo.HitEntity;
			BasePlayer basePlayer = hitInfo.HitEntity as BasePlayer;
			bool flag = basePlayer != null;
			bool flag2 = flag && basePlayer.IsSleeping();
			bool flag3 = flag && basePlayer.IsWounded();
			bool flag4 = flag && basePlayer.isMounted;
			bool flag5 = flag && basePlayer.HasParent();
			bool flag6 = hitEntity != null;
			bool flag7 = flag6 && hitEntity.IsNpc;
			bool flag8;
			int layerMask;
			Vector3 center;
			Vector3 position;
			Vector3 vector;
			Vector3 vector2;
			Vector3 vector3;
			int num15;
			if (ConVar.AntiHack.melee_protection > 0)
			{
				flag8 = true;
				float num = 1f + ConVar.AntiHack.melee_forgiveness;
				float melee_clientframes = ConVar.AntiHack.melee_clientframes;
				float melee_serverframes = ConVar.AntiHack.melee_serverframes;
				float num2 = melee_clientframes / 60f;
				float num3 = melee_serverframes * Mathx.Max(UnityEngine.Time.deltaTime, UnityEngine.Time.smoothDeltaTime, UnityEngine.Time.fixedDeltaTime);
				float num4 = (player.desyncTimeClamped + num2 + num3) * num;
				layerMask = (ConVar.AntiHack.melee_terraincheck ? 10551296 : 2162688);
				if (flag && hitInfo.boneArea == (HitArea)(-1))
				{
					string shortPrefabName2 = base.ShortPrefabName;
					string shortPrefabName3 = basePlayer.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.MeleeHack, "Bone is invalid  (" + shortPrefabName2 + " on " + shortPrefabName3 + " bone " + hitInfo.HitBone + ")");
					player.stats.combat.LogInvalid(hitInfo, "melee_bone");
					flag8 = false;
				}
				if (ConVar.AntiHack.melee_protection >= 2)
				{
					if (flag6)
					{
						float num5 = hitEntity.MaxVelocity() + hitEntity.GetParentVelocity().magnitude;
						float num6 = hitEntity.BoundsPadding() + num4 * num5;
						float num7 = hitEntity.Distance(hitInfo.HitPositionWorld);
						if (num7 > num6)
						{
							string shortPrefabName4 = base.ShortPrefabName;
							string shortPrefabName5 = hitEntity.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num7 + "m > " + num6 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(hitInfo, "melee_target");
							flag8 = false;
						}
					}
					if (ConVar.AntiHack.melee_protection >= 4 && flag8 && flag && !flag7 && !flag2 && !flag3 && !flag4 && !flag5)
					{
						float magnitude = basePlayer.GetParentVelocity().magnitude;
						float num8 = basePlayer.BoundsPadding() + num4 * magnitude + ConVar.AntiHack.tickhistoryforgiveness;
						float num9 = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld);
						if (num9 > num8)
						{
							string shortPrefabName6 = base.ShortPrefabName;
							string shortPrefabName7 = basePlayer.ShortPrefabName;
							AntiHack.Log(player, AntiHackType.ProjectileHack, "Player too far away (" + shortPrefabName6 + " on " + shortPrefabName7 + " with " + num9 + "m > " + num8 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(hitInfo, "player_distance");
							flag8 = false;
						}
					}
				}
				if (ConVar.AntiHack.melee_protection >= 1)
				{
					if (ConVar.AntiHack.melee_protection >= 4)
					{
						float magnitude2 = player.GetParentVelocity().magnitude;
						float num10 = player.BoundsPadding() + num4 * magnitude2 + num * maxDistance;
						float num11 = player.tickHistory.Distance(player, hitInfo.HitPositionWorld);
						if (num11 > num10)
						{
							string shortPrefabName8 = base.ShortPrefabName;
							string text = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName8 + " on " + text + " with " + num11 + "m > " + num10 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(hitInfo, "melee_initiator");
							flag8 = false;
						}
					}
					else
					{
						float num12 = player.MaxVelocity() + player.GetParentVelocity().magnitude;
						float num13 = player.BoundsPadding() + num4 * num12 + num * maxDistance;
						float num14 = player.Distance(hitInfo.HitPositionWorld);
						if (num14 > num13)
						{
							string shortPrefabName9 = base.ShortPrefabName;
							string text2 = (flag6 ? hitEntity.ShortPrefabName : "world");
							AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName9 + " on " + text2 + " with " + num14 + "m > " + num13 + "m in " + num4 + "s)");
							player.stats.combat.LogInvalid(hitInfo, "melee_initiator");
							flag8 = false;
						}
					}
				}
				if (ConVar.AntiHack.melee_protection >= 3)
				{
					if (flag6)
					{
						Vector3 pointStart = hitInfo.PointStart;
						Vector3 hitPositionWorld = hitInfo.HitPositionWorld;
						center = player.eyes.center;
						position = player.eyes.position;
						vector = pointStart;
						vector2 = hitInfo.PositionOnRay(hitPositionWorld) + hitInfo.HitNormalWorld.normalized * 0.001f;
						vector3 = hitPositionWorld;
						if (GamePhysics.LineOfSight(center, position, layerMask) && GamePhysics.LineOfSight(position, vector, layerMask) && GamePhysics.LineOfSight(vector, vector2, layerMask))
						{
							num15 = (GamePhysics.LineOfSight(vector2, vector3, layerMask, hitEntity) ? 1 : 0);
							if (num15 != 0)
							{
								player.stats.Add("hit_" + hitEntity.Categorize() + "_direct_los", 1, Stats.Server);
								goto IL_0709;
							}
						}
						else
						{
							num15 = 0;
						}
						player.stats.Add("hit_" + hitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
						goto IL_0709;
					}
					goto IL_07c4;
				}
				goto IL_0902;
			}
			goto IL_0914;
			IL_0709:
			if (num15 == 0)
			{
				string shortPrefabName10 = base.ShortPrefabName;
				string shortPrefabName11 = hitEntity.ShortPrefabName;
				AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat("Line of sight (", shortPrefabName10, " on ", shortPrefabName11, ") ", center, " ", position, " ", vector, " ", vector2, " ", vector3));
				player.stats.combat.LogInvalid(hitInfo, "melee_los");
				flag8 = false;
			}
			goto IL_07c4;
			IL_0902:
			if (!flag8)
			{
				AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
				return;
			}
			goto IL_0914;
			IL_07c4:
			if (flag8 && flag && !flag7)
			{
				Vector3 hitPositionWorld2 = hitInfo.HitPositionWorld;
				Vector3 position2 = basePlayer.eyes.position;
				Vector3 vector4 = basePlayer.CenterPoint();
				float melee_losforgiveness = ConVar.AntiHack.melee_losforgiveness;
				bool flag9 = GamePhysics.LineOfSight(hitPositionWorld2, position2, layerMask, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(position2, hitPositionWorld2, layerMask, melee_losforgiveness, 0f);
				if (!flag9)
				{
					flag9 = GamePhysics.LineOfSight(hitPositionWorld2, vector4, layerMask, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(vector4, hitPositionWorld2, layerMask, melee_losforgiveness, 0f);
				}
				if (!flag9)
				{
					string shortPrefabName12 = base.ShortPrefabName;
					string shortPrefabName13 = basePlayer.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat("Line of sight (", shortPrefabName12, " on ", shortPrefabName13, ") ", hitPositionWorld2, " ", position2, " or ", hitPositionWorld2, " ", vector4));
					player.stats.combat.LogInvalid(hitInfo, "melee_los");
					flag8 = false;
				}
			}
			goto IL_0902;
			IL_0914:
			player.metabolism.UseHeart(heartStress * 0.2f);
			using (TimeWarning.New("DoAttackShared", 50))
			{
				DoAttackShared(hitInfo);
			}
		}
	}

```

## OnTeamLeave(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player leaves their team.
/// </summary>
/// <param name="team">The team the player is leaving.</param>
/// <param name="player">The player leaving the team.</param>
/// <returns>
/// Returns `null` to allow the player to leave the team, or any non-null value to prevent them from leaving.
/// </returns>
object OnTeamLeave(PlayerTeam team, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has left team {team.Name}");
    if (team.Name == "Admins")
    {
        Puts($"Player {player.displayName} is not allowed to leave the Admin team");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void leaveteam(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam != 0L)
		{
			PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
			if (playerTeam != null && Interface.CallHook("OnTeamLeave", playerTeam, basePlayer) == null)
			{
				playerTeam.RemovePlayer(basePlayer.userID);
				basePlayer.ClearTeam();
			}
		}
	}

```

## OnMapMarkerRemove(BasePlayer,System.Collections.Generic.List<ProtoBuf.MapNote>,int)

```csharp
```csharp
/// <summary>
/// Called when a map marker is removed.
/// </summary>
/// <param name="player">The player who initiated the removal.</param>
/// <param name="markers">A list of all markers on the map.</param>
/// <param name="index">The index of the marker to be removed.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkerRemove(BasePlayer player, List<ProtoBuf.MapNote> markers, int index)
{
    Puts($"Map marker at index {index} has been removed by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(10uL)]
	public void Server_RemovePointOfInterest(RPCMessage msg)
	{
		int num = msg.read.Int32();
		if (State.pointsOfInterest != null && State.pointsOfInterest.Count > num && num >= 0 && Interface.CallHook("OnMapMarkerRemove", this, State.pointsOfInterest, num) == null)
		{
			State.pointsOfInterest[num].Dispose();
			State.pointsOfInterest.RemoveAt(num);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
		}
	}

```

## OnEntityControl(AutoTurret,ulong)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to control an entity.
/// </summary>
/// <param name="entity">The entity being controlled.</param>
/// <param name="playerID">The ID of the player attempting to control the entity.</param>
/// <returns>
/// Returns `true` if the player can control the entity, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior and be used as the return value.
/// </returns>
object OnEntityControl(AutoTurret entity, ulong playerID)
{
    Puts($"Player {playerID} attempted to control entity {entity.EntityID}");
    if (playerID == 1234567890)
    {
        Puts($"Player {playerID} is not allowed to control entities.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", this, playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (booting)
		{
			return false;
		}
		if (IsPowered())
		{
			return !PeacekeeperMode();
		}
		return false;
	}

```

## IOnBasePlayerHurt(BasePlayer,HitInfo)

```csharp
Here is the method structure with minimal code to demonstrate functionality:

```csharp
/// <summary>
/// Called when a player is hurt.
/// </summary>
/// <param name="info">The hit information.</param>
void IOnBasePlayerHurt(HitInfo info)
{
    Puts("Player was hurt!");
}
```

Note that the return type of this method is `void`, as it does not return any value. The method takes a single parameter, `info`, which is an instance of `HitInfo`.
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (IsDead() || (IsImmortalTo(info) && info.damageTypes.Total() >= 0f) || Interface.CallHook("IOnBasePlayerHurt", this, info) != null)
		{
			return;
		}
		if (ConVar.Server.pve && (bool)info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)
		{
			(info.Initiator as BasePlayer).Hurt(info.damageTypes.Total(), DamageType.Generic);
			return;
		}
		if (info.damageTypes.Has(DamageType.Fun_Water))
		{
			bool flag = true;
			Item activeItem = GetActiveItem();
			if (activeItem != null && (activeItem.info.shortname == "gun.water" || activeItem.info.shortname == "pistol.water"))
			{
				float value = metabolism.wetness.value;
				metabolism.wetness.Add(ConVar.Server.funWaterWetnessGain);
				bool flag2 = metabolism.wetness.value >= ConVar.Server.funWaterDamageThreshold;
				flag = !flag2;
				if (info.InitiatorPlayer != null)
				{
					if (flag2 && value < ConVar.Server.funWaterDamageThreshold)
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_SOAKED");
					}
					if (metabolism.radiation_level.Fraction() > 0.2f && !string.IsNullOrEmpty("SUMMER_RADICAL"))
					{
						info.InitiatorPlayer.GiveAchievement("SUMMER_RADICAL");
					}
				}
			}
			if (flag)
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
		}
		if (info.damageTypes.Get(DamageType.Drowned) > 5f && drownEffect.isValid)
		{
			Effect.server.Run(drownEffect.resourcePath, this, StringPool.Get("head"), Vector3.zero, Vector3.zero);
		}
		if (modifiers != null)
		{
			if (info.damageTypes.Has(DamageType.Radiation))
			{
				info.damageTypes.Scale(DamageType.Radiation, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Resistance)));
			}
			if (info.damageTypes.Has(DamageType.RadiationExposure))
			{
				info.damageTypes.Scale(DamageType.RadiationExposure, 1f - Mathf.Clamp01(modifiers.GetValue(Modifier.ModifierType.Radiation_Exposure_Resistance)));
			}
		}
		metabolism.pending_health.Subtract(info.damageTypes.Total() * 10f);
		BasePlayer initiatorPlayer = info.InitiatorPlayer;
		if ((bool)initiatorPlayer && initiatorPlayer != this)
		{
			if (initiatorPlayer.InSafeZone() || InSafeZone())
			{
				initiatorPlayer.MarkHostileFor(300f);
			}
			if (initiatorPlayer.IsNpc && initiatorPlayer.Family == BaseNpc.AiStatistics.FamilyEnum.Murderer && info.damageTypes.Get(DamageType.Explosion) > 0f)
			{
				info.damageTypes.ScaleAll(Halloween.scarecrow_beancan_vs_player_dmg_modifier);
			}
		}
		base.Hurt(info);
		if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
		{
			BasePlayer instigator = info?.InitiatorPlayer;
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerHurt(instigator, this, info);
		}
		EACServer.LogPlayerTakeDamage(this, info);
		metabolism.SendChangesToClient();
		if (info.PointStart != Vector3.zero && (info.damageTypes.Total() >= 0f || IsGod()))
		{
			int arg = (int)info.damageTypes.GetMajorityDamageType();
			if (info.Weapon != null && info.damageTypes.Has(DamageType.Bullet))
			{
				BaseProjectile component = info.Weapon.GetComponent<BaseProjectile>();
				if (component != null && component.IsSilenced())
				{
					arg = 12;
				}
			}
			ClientRPCPlayerAndSpectators(null, this, "DirectionalDamage", info.PointStart, arg, Mathf.CeilToInt(info.damageTypes.Total()));
		}
		cachedNonSuicideHitInfo = info;
	}

```

## OnEntityLeave(TriggerBase,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity leaves the trigger.
/// </summary>
/// <param name="trigger">The trigger that the entity left.</param>
/// <param name="entity">The entity that left the trigger.</param>
/// <returns>No return behavior.</returns>
void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
{
    Puts($"Entity {entity.ClassName} has left trigger {trigger.EntityId}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnEntityLeave(BaseEntity ent)
	{
		if (entityContents != null && Interface.CallHook("OnEntityLeave", this, ent) == null)
		{
			entityContents.Remove(ent);
		}
	}

```

## CanChangeGrade(BasePlayer,BuildingBlock,BuildingGrade.Enum,ulong)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can change the grade of a building block.
/// </summary>
/// <param name="player">The player attempting to change the grade.</param>
/// <param name="block">The building block being modified.</param>
/// <param name="grade">The new grade to apply.</param>
/// <param name="skinId">The ID of the skin associated with the block.</param>
/// <returns>
/// Returns `true` if the player can change the grade, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as an override to the default behavior.
/// </returns>
object CanChangeGrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade, ulong skinId)
{
    Puts($"Player {player.UserIDString} attempted to change the grade of building block {block.BlockName} to {grade} with skin ID {skinId}");
    if (grade == BuildingGrade.Enum.Premium && !HasPremiumUpgrade(player))
    {
        Puts($"Player {player.UserIDString} does not have a premium upgrade and cannot change the grade to Premium");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanChangeToGrade(BuildingGrade.Enum iGrade, ulong iSkin, BasePlayer player)
	{
		object obj = Interface.CallHook("CanChangeGrade", player, this, iGrade, iSkin);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasUpgradePrivilege(iGrade, iSkin, player))
		{
			return !IsUpgradeBlocked();
		}
		return false;
	}

```

## IOnUserApprove(Network.Connection)

```csharp
Here's the refactored code with improved readability and maintainability:

```csharp
public void OnNewConnection(Connection connection)
{
    // Initialize connection properties
    connection.connected = false;

    // Validate token length
    if (connection.token == null || connection.token.Length < 32)
    {
        Reject(connection, "Invalid Token");
        return;
    }

    // Validate SteamID
    if (connection.userid == 0L)
    {
        Reject(connection, "Invalid SteamID");
        return;
    }

    // Handle incompatible protocol version
    if (connection.protocol != 2388 && !DeveloperList.Contains(connection.userid))
    {
        Reject(connection, "Incompatible Version");
        return;
    }

    // Check for banned users
    if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
    {
        var user = ServerUsers.Get(connection.userid);
        string reason = user?.notes ?? "no reason given";
        string expiryText = user != null && user.expiry > 0 ? $" for {user.expiry - Epoch.Current.FormatSecondsLong()}" : "";
        Reject(connection, $"You are banned from this server{expiryText} ({reason})");
        return;
    }

    // Set auth level based on user group
    if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
    {
        connection.authLevel = 1u;
    }
    else if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
    {
        connection.authLevel = 2u;
    }
    else if (DeveloperList.Contains(connection.userid))
    {
        connection.authLevel = 3u;
    }

    // Call hook to override default approval behavior
    var result = Interface.CallHook("IOnUserApprove", connection);
    if (result == null)
    {
        m_AuthConnection.Add(connection);
        StartCoroutine(AuthorisationRoutine(connection));
    }
}
```

Changes made:

* Improved code formatting and indentation for better readability.
* Added whitespace between logical blocks of code to improve maintainability.
* Renamed some variables for clarity.
* Removed unnecessary comments.
* Combined similar checks into a single block.
* Used early returns to simplify the code flow.
```

### Source Code from the Library

```csharp

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0L)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2388)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log("Not kicking " + connection.userid + " for incompatible protocol (is a developer)");
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			ServerUsers.User user = ServerUsers.Get(connection.userid);
			string text = user?.notes ?? "no reason given";
			string text2 = ((user != null && user.expiry > 0) ? (" for " + (user.expiry - Epoch.Current).FormatSecondsLong()) : "");
			Reject(connection, "You are banned from this server" + text2 + " (" + text + ")");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log(connection.ToString() + " has auth level 1");
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log(connection.ToString() + " has auth level 2");
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log(connection.ToString() + " is a developer");
			connection.authLevel = 3u;
		}
		if (Interface.CallHook("IOnUserApprove", connection) == null)
		{
			m_AuthConnection.Add(connection);
			StartCoroutine(AuthorisationRoutine(connection));
		}
	}

```

## OnItemUse(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is used.
/// </summary>
/// <param name="item">The item being used.</param>
/// <param name="amountToConsume">The amount of the item to consume. Defaults to 1.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If an integer is returned, it will be used as the new amount to consume.
/// </returns>
object OnItemUse(Item item, int amountToConsume)
{
    Puts($"Item {item.Name} has been used.");
    if (amountToConsume > 0)
    {
        // Perform any necessary actions when the item is used
        return null;
    }
    else
    {
        // Handle invalid or zero consumption amounts
        return "Error: Invalid amount to consume.";
    }
}
```
```

### Source Code from the Library

```csharp

	public void UseItem(int amountToConsume = 1)
	{
		if (amountToConsume > 0)
		{
			object obj = Interface.CallHook("OnItemUse", this, amountToConsume);
			if (obj is int)
			{
				amountToConsume = (int)obj;
			}
			amount -= amountToConsume;
			if (amount <= 0)
			{
				amount = 0;
				Remove();
			}
			else
			{
				MarkDirty();
			}
		}
	}

```

## CanLootEntity(BasePlayer,IndustrialCrafter)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `true` to allow the player to loot the entity, or `false` to prevent them from doing so.
/// </returns>
bool CanLootEntity(BasePlayer player, IndustrialCrafter entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot {entity.GetType().Name}.");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.HasPermission("can_loot_industrial_crafters"))
    {
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to loot {entity.GetType().Name}.");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		if (Interface.CallHook("CanLootEntity", player, this) != null)
		{
			return false;
		}
		if (NeedsBuildingPrivilegeToUse && !player.CanBuild())
		{
			return false;
		}
		if (OnlyOneUser && IsOpen())
		{
			player.ChatMessage("Already in use");
			return false;
		}
		if (player.inventory.loot.StartLootingEntity(this, doPositionChecks))
		{
			SetFlag(Flags.Open, b: true);
			player.inventory.loot.AddContainer(inventory);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", LootPanelName);
			SendNetworkUpdate();
			return true;
		}
		return false;
	}

```

## OnLootPlayer(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player is looted.
/// </summary>
/// <param name="looter">The player doing the looting.</param>
/// <param name="target">The player being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootPlayer(BasePlayer looter, BasePlayer target)
{
    Puts($"Player {looter.UserIDString} is looting player {target.UserIDString}");
    if (looter.UserID == 123456) // Example: Only allow admin to loot
    {
        Puts($"Player {looter.UserIDString} does not have permission to loot.");
        return;
    }
    // Additional logic can be added here
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_LootPlayer(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && CanBeLooted(player) && player.inventory.loot.StartLootingEntity(this))
		{
			player.inventory.loot.AddContainer(inventory.containerMain);
			player.inventory.loot.AddContainer(inventory.containerWear);
			player.inventory.loot.AddContainer(inventory.containerBelt);
			Interface.CallHook("OnLootPlayer", this, player);
			player.inventory.loot.SendImmediate();
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "player_corpse");
		}
	}

```

## OnTurretAssigned(AutoTurret,ulong,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is assigned to a player.
/// </summary>
/// <param name="turret">The AutoTurret being assigned.</param>
/// <param name="playerId">The ID of the player being assigned the turret.</param>
/// <param name="player">The BasePlayer instance being assigned the turret.</param>
object OnTurretAssigned(AutoTurret turret, ulong playerId, BasePlayer player)
{
    Puts($"Turret {turret.entityID} has been assigned to player {player.displayName} with ID {playerId}");
    if (playerId == 1234567890L)
    {
        Puts($"Player {player.displayName} is not allowed to have a turret.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (AtMaxAuthCapacity() || msg.player == null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", this, num, msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(), num);
			PlayerNameID playerNameID = new PlayerNameID();
			playerNameID.userid = num;
			playerNameID.username = username;
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(playerNameID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", this, num, msg.player);
		}
	}

```

## OnTurretShutdown(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret is shutting down.
/// </summary>
/// <param name="turret">The AutoTurret instance being shut down.</param>
/// <returns>
/// Returns `null` to allow the turret to shut down normally, or any non-null value to prevent it from shutting down.
/// </returns>
object OnTurretShutdown(AutoTurret turret)
{
    Puts($"Turret {turret.name} is shutting down.");
    if (turret.isMalfunctioning)
    {
        Puts($"Turret {turret.name} has malfunctioned and cannot shut down.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateShutdown()
	{
		if ((!IsOffline() || booting) && Interface.CallHook("OnTurretShutdown", this) == null)
		{
			CancelInvoke(SetOnline);
			booting = false;
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

```

## OnSurveyGather(SurveyCharge,Item)

```csharp
```csharp
/// <summary>
/// Called when a survey charge is gathered.
/// </summary>
/// <param name="surveyCharge">The survey charge that was gathered.</param>
/// <param name="item">The item that was dropped as a result of the survey charge being gathered.</param>
void OnSurveyGather(SurveyCharge surveyCharge, Item item)
{
    Puts($"Survey charge {surveyCharge} has been gathered and an item {item} has been dropped.");
    if (item.type == "Oil")
    {
        Puts($"An oil item {item} has been dropped as a result of the survey charge being gathered.");
        // Additional logic for oil items can be added here
    }
    else if (item.type == "Gas")
    {
        Puts($"A gas item {item} has been dropped as a result of the survey charge being gathered.");
        // Additional logic for gas items can be added here
    }
    else
    {
        Puts($"An unknown item type {item.type} has been dropped as a result of the survey charge being gathered.");
        // Additional logic for unknown item types can be added here
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		base.Explode();
		if (WaterLevel.Test(base.transform.position, waves: true, this))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(base.transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(base.transform.position, out var hitOut, 0.3f, 8388608))
		{
			return;
		}
		Vector3 point = hitOut.point;
		_ = hitOut.normal;
		List<SurveyCrater> obj = Pool.GetList<SurveyCrater>();
		Vis.Entities(base.transform.position, 10f, obj, 1);
		bool num = obj.Count > 0;
		Pool.FreeList(ref obj);
		if (num)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag = true;
				if (resource.isLiquid)
				{
					flag2 = true;
				}
				for (int i = 0; i < num2; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", this, item);
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);
					item.Drop(base.transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
				}
			}
		}
		if (flag)
		{
			string strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);
			BaseEntity baseEntity = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if ((bool)baseEntity)
			{
				baseEntity.Spawn();
			}
		}
	}

```

## OnCorpsePopulate(ScarecrowNPC,string)

```csharp
```csharp
/// <summary>
/// Called when a corpse is populated.
/// </summary>
/// <param name="scarecrowNPC">The Scarecrow NPC that was killed.</param>
/// <param name="corpseDefinition">The definition of the corpse to be spawned.</param>
/// <returns>
/// Returns a non-null value to override the default corpse population behavior. 
/// If a `BaseCorpse` is returned, it will be used as the new corpse instead of the default one.
/// </returns>
object OnCorpsePopulate(ScarecrowNPC scarecrowNPC, string corpseDefinition)
{
    Puts($"A Scarecrow NPC has been killed and its corpse is being populated.");
    if (corpseDefinition == "assets/prefabs/npc/murderer/murderer_corpse.prefab")
    {
        Puts($"The corpse of the Scarecrow NPC is being spawned with the default definition.");
        return null;
    }
    else
    {
        Puts($"A custom corpse definition is being used for the Scarecrow NPC.");
        // Return a custom BaseCorpse object here.
        return new CustomBaseCorpse();
    }
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse()
	{
		using (TimeWarning.New("Create corpse"))
		{
			string text = "assets/prefabs/npc/murderer/murderer_corpse.prefab";
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse(text) as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				nPCPlayerCorpse.playerName = "Scarecrow";
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
				if (LootSpawnSlots.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", this, text);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int i = 0; i < lootSpawnSlots.Length; i++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
						for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnInventoryAmmoFind(PlayerInventory,System.Collections.Generic.List<Item>,Rust.AmmoTypes)

```csharp
```csharp
/// <summary>
/// Called when inventory ammo is being searched for.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="ammoList">A list of items to search for ammo in.</param>
/// <param name="ammoType">The type of ammo to find.</param>
/// <returns>
/// Returns `null` if the default behavior should be used, or any non-null value to override the default behavior.
/// If a string is returned, it will be displayed as an error message. 
/// If `null` is returned, the inventory search will continue normally.
/// </returns>
object OnInventoryAmmoFind(PlayerInventory inventory, List<Item> ammoList, Rust.AmmoTypes ammoType)
{
    Puts($"Searching for {ammoType} ammo in player's inventory.");
    if (ammoList.Contains(inventory.GetAmmo(ammoType)))
    {
        return null;
    }
    else
    {
        return "No ammo found.";
    }
}
```
```

### Source Code from the Library

```csharp

	public void FindAmmo(List<Item> list, AmmoTypes ammoType)
	{
		if (Interface.CallHook("OnInventoryAmmoFind", this, list, ammoType) == null)
		{
			if (containerMain != null)
			{
				containerMain.FindAmmo(list, ammoType);
			}
			if (containerBelt != null)
			{
				containerBelt.FindAmmo(list, ammoType);
			}
		}
	}

```

## OnPlayerDisconnected(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player disconnects from the server.
/// </summary>
/// <param name="player">The disconnected player.</param>
/// <param name="reason">The reason for the disconnection.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDisconnected(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} disconnected with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void OnDisconnected(string strReason, Network.Connection connection)
	{
		Facepunch.Rust.Analytics.Azure.OnPlayerDisconnected(connection, strReason);
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		PlatformService.Instance.EndPlayerSession(connection.userid);
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((bool)basePlayer)
		{
			Interface.CallHook("OnPlayerDisconnected", basePlayer, strReason);
			basePlayer.OnDisconnected();
		}
	}

```

## OnItemCraftCancelled(ItemCraftTask)

```csharp
```csharp
/// <summary>
/// Called when an item craft task is cancelled.
/// </summary>
/// <param name="task">The cancelled item craft task.</param>
/// <returns>No return behavior.</returns>
void OnItemCraftCancelled(ItemCraftTask task)
{
    Puts($"Item craft task {task.taskUID} has been cancelled.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public bool CancelTask(int iID, bool ReturnItems)
	{
		if (queue.Count == 0)
		{
			return false;
		}
		ItemCraftTask itemCraftTask = queue.FirstOrDefault((ItemCraftTask x) => x.taskUID == iID && !x.cancelled);
		if (itemCraftTask == null)
		{
			return false;
		}
		itemCraftTask.cancelled = true;
		if (itemCraftTask.owner == null)
		{
			return true;
		}
		Interface.CallHook("OnItemCraftCancelled", itemCraftTask);
		itemCraftTask.owner.Command("note.craft_done", itemCraftTask.taskUID, 0);
		if (itemCraftTask.takenItems != null && itemCraftTask.takenItems.Count > 0 && ReturnItems)
		{
			foreach (Item takenItem in itemCraftTask.takenItems)
			{
				if (takenItem != null && takenItem.amount > 0)
				{
					if (takenItem.IsBlueprint() && takenItem.blueprintTargetDef == itemCraftTask.blueprint.targetItem)
					{
						takenItem.UseItem(itemCraftTask.numCrafted);
					}
					if (takenItem.amount > 0 && !takenItem.MoveToContainer(itemCraftTask.owner.inventory.containerMain))
					{
						takenItem.Drop(itemCraftTask.owner.inventory.containerMain.dropPosition + UnityEngine.Random.value * Vector3.down + UnityEngine.Random.insideUnitSphere, itemCraftTask.owner.inventory.containerMain.dropVelocity);
						itemCraftTask.owner.Command("note.inv", takenItem.info.itemid, -takenItem.amount);
					}
				}
			}
		}
		return true;
	}

```

## OnToggleVendingBroadcast(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the vending broadcast toggle is changed.
/// </summary>
/// <param name="vendingMachine">The vending machine that was toggled.</param>
/// <param name="player">The player who performed the action.</param>
/// <returns>No return behavior.</returns>
void OnToggleVendingBroadcast(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending broadcast toggle changed by {player.displayName} for vending machine {vendingMachine.name}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Broadcast(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		bool b = msg.read.Bit();
		if (CanPlayerAdmin(player))
		{
			SetFlag(Flags.Reserved4, b);
			Interface.CallHook("OnToggleVendingBroadcast", this, player);
			UpdateMapMarker();
		}
	}

```

## OnPhoneDialFail(PhoneController,Telephone.DialFailReason,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dial attempt fails.
/// </summary>
/// <param name="phoneController">The phone controller that failed to dial.</param>
/// <param name="reason">The reason for the dial failure.</param>
/// <param name="caller">The player who attempted to make the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialFail(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer caller)
{
    Puts($"Phone dial attempt failed for {caller.displayName} with reason: {reason}");
    if (reason == Telephone.DialFailReason.NoAnswer)
    {
        Puts($"No answer from the recipient of the call.");
        // Play a "no answer" sound effect or animation
    }
    else if (reason == Telephone.DialFailReason.OutOfRange)
    {
        Puts($"The caller is out of range for this phone signal.");
        // Display an error message to the player
    }
}
```
```

### Source Code from the Library

```csharp

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", this, reason, currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(null, "ClientOnDialFailed", (int)reason);
			activeCallTo = null;
			if (IsInvoking(TimeOutCall))
			{
				CancelInvoke(TimeOutCall);
			}
			if (IsInvoking(TriggerTimeOut))
			{
				CancelInvoke(TriggerTimeOut);
			}
			if (IsInvoking(TimeOutDialing))
			{
				CancelInvoke(TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", this, reason, currentPlayer);
		}
	}

```

## OnPlayerRespawned(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>
/// Returns `null` to allow the player to respawn normally, or any non-null value to override the default respawn behavior.
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object OnPlayerRespawned(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has respawned.");
    if (player.UserID == "123456")
    {
        Puts($"Player {player.UserIDString} has been blocked from respawning.");
        return "Blocked: Unauthorized player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RespawnAt(Vector3 position, Quaternion rotation, BaseEntity spawnPointEntity = null)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((bool)activeGameMode && !activeGameMode.CanPlayerRespawn(this))
		{
			return;
		}
		SetPlayerFlag(PlayerFlags.Wounded, b: false);
		SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
		SetPlayerFlag(PlayerFlags.Unused2, b: false);
		SetPlayerFlag(PlayerFlags.Unused1, b: false);
		SetPlayerFlag(PlayerFlags.ReceivingSnapshot, b: true);
		SetPlayerFlag(PlayerFlags.DisplaySash, b: false);
		respawnId = Guid.NewGuid().ToString("N");
		ServerPerformance.spawns++;
		SetParent(null, worldPositionStays: true);
		base.transform.SetPositionAndRotation(position, rotation);
		tickInterpolator.Reset(position);
		tickHistory.Reset(position);
		eyeHistory.Clear();
		estimatedVelocity = Vector3.zero;
		estimatedSpeed = 0f;
		estimatedSpeed2D = 0f;
		lastTickTime = 0f;
		StopWounded();
		ResetWoundingVars();
		StopSpectating();
		UpdateNetworkGroup();
		EnablePlayerCollider();
		RemovePlayerRigidbody();
		StartSleeping();
		LifeStoryStart();
		metabolism.Reset();
		if (modifiers != null)
		{
			modifiers.RemoveAll();
		}
		InitializeHealth(StartHealth(), StartMaxHealth());
		bool flag = false;
		if (ConVar.Server.respawnWithLoadout)
		{
			string infoString = GetInfoString("client.respawnloadout", string.Empty);
			if (!string.IsNullOrEmpty(infoString) && Inventory.LoadLoadout(infoString, out var so))
			{
				so.LoadItemsOnTo(this);
				flag = true;
			}
		}
		if (!flag)
		{
			inventory.GiveDefaultItems();
		}
		SendNetworkUpdateImmediate();
		ClientRPCPlayer(null, this, "StartLoading");
		Facepunch.Rust.Analytics.Azure.OnPlayerRespawned(this, spawnPointEntity);
		if ((bool)activeGameMode)
		{
			BaseGameMode.GetActiveGameMode(serverside: true).OnPlayerRespawn(this);
		}
		if (net != null)
		{
			EACServer.OnStartLoading(net.connection);
		}
		Interface.CallHook("OnPlayerRespawned", this);
	}

```

## OnFireworkDamage(BaseFirework,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a firework is damaged.
/// </summary>
/// <param name="firework">The firework that was damaged.</param>
/// <param name="info">Information about the damage, including the type and amount of damage.</param>
/// <returns>
/// Returns `null` to allow the firework to be damaged normally. 
/// If a non-null value is returned, it will override the default behavior for this firework.
/// </returns>
object OnFireworkDamage(BaseFirework firework, HitInfo info)
{
    Puts($"Firework {firework.Name} was damaged with damage type {info.damageTypes} and amount {info.damage}.");
    if (info.damage > 50)
    {
        Puts($"Firework {firework.Name} has been severely damaged and will explode soon.");
        return "ExplodeSoon";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (base.isServer && Interface.CallHook("OnFireworkDamage", this, info) == null && info.damageTypes.Has(DamageType.Heat))
		{
			StaggeredTryLightFuse();
		}
	}

```

## OnBradleyApcHunt(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC is hunting.
/// </summary>
/// <param name="bradleyAPC">The Bradley APC instance.</param>
/// <returns>
/// Returns a non-null value to override the default hunting behavior. 
/// If `null` is returned, the Bradley APC will continue with its normal hunting routine.
/// </returns>
object OnBradleyApcHunt(BradleyAPC bradleyAPC)
{
    Puts($"Bradley APC {bradleyAPC.GetId()} has started hunting.");
    // You can add custom logic here to override the default hunting behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateMovement_Hunt()
	{
		if (Interface.CallHook("OnBradleyApcHunt", this) != null || patrolPath == null)
		{
			return;
		}
		TargetInfo targetInfo = targetList[0];
		if (!targetInfo.IsValid())
		{
			return;
		}
		if (HasPath() && targetInfo.IsVisible())
		{
			if (currentPath.Count > 1)
			{
				Vector3 item = currentPath[currentPathIndex];
				ClearPath();
				currentPath.Add(item);
				finalDestination = item;
				currentPathIndex = 0;
			}
		}
		else
		{
			if (!(UnityEngine.Time.time > nextEngagementPathTime) || HasPath() || targetInfo.IsVisible())
			{
				return;
			}
			bool flag = false;
			IAIPathNode start = patrolPath.GetClosestToPoint(base.transform.position);
			List<IAIPathNode> nodes = Facepunch.Pool.GetList<IAIPathNode>();
			if (GetEngagementPath(ref nodes))
			{
				flag = true;
				start = nodes[nodes.Count - 1];
			}
			IAIPathNode iAIPathNode = null;
			List<IAIPathNode> nearNodes = Facepunch.Pool.GetList<IAIPathNode>();
			patrolPath.GetNodesNear(targetInfo.lastSeenPosition, ref nearNodes, 30f);
			Stack<IAIPathNode> stack = null;
			float num = float.PositiveInfinity;
			float y = mainTurretEyePos.localPosition.y;
			foreach (IAIPathNode item2 in nearNodes)
			{
				Stack<IAIPathNode> path = new Stack<IAIPathNode>();
				if (targetInfo.entity.IsVisible(item2.Position + new Vector3(0f, y, 0f)) && AStarPath.FindPath(start, item2, out path, out var pathCost) && pathCost < num)
				{
					stack = path;
					num = pathCost;
					iAIPathNode = item2;
				}
			}
			if (stack == null && nearNodes.Count > 0)
			{
				Stack<IAIPathNode> path2 = new Stack<IAIPathNode>();
				IAIPathNode iAIPathNode2 = nearNodes[UnityEngine.Random.Range(0, nearNodes.Count)];
				if (AStarPath.FindPath(start, iAIPathNode2, out path2, out var pathCost2) && pathCost2 < num)
				{
					stack = path2;
					iAIPathNode = iAIPathNode2;
				}
			}
			if (stack != null)
			{
				currentPath.Clear();
				if (flag)
				{
					for (int i = 0; i < nodes.Count - 1; i++)
					{
						currentPath.Add(nodes[i].Position);
					}
				}
				foreach (IAIPathNode item3 in stack)
				{
					currentPath.Add(item3.Position);
				}
				currentPathIndex = -1;
				pathLooping = false;
				finalDestination = iAIPathNode.Position;
			}
			Facepunch.Pool.FreeList(ref nearNodes);
			Facepunch.Pool.FreeList(ref nodes);
			nextEngagementPathTime = UnityEngine.Time.time + 5f;
		}
	}

```

## OnBuildingSplit(BuildingManager.Building,uint)

```csharp
```csharp
/// <summary>
/// Called when a building is split into smaller parts.
/// </summary>
/// <param name="building">The original building being split.</param>
/// <param name="newBuildingID">The ID of the new building created by splitting the original building.</param>
object OnBuildingSplit(BuildingManager.Building building, uint newBuildingID)
{
    Puts($"Building {building.buildingID} has been split into a new building with ID {newBuildingID}");
    // You can add custom logic here to handle the split building
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void Split(Building building)
	{
		while (building.HasBuildingBlocks())
		{
			BuildingBlock buildingBlock = building.buildingBlocks[0];
			uint newID = BuildingManager.server.NewBuildingID();
			Interface.CallHook("OnBuildingSplit", building, newID);
			buildingBlock.EntityLinkBroadcast(delegate(BuildingBlock b)
			{
				b.AttachToBuilding(newID);
			});
		}
		while (building.HasBuildingPrivileges())
		{
			BuildingPrivlidge buildingPrivlidge = building.buildingPrivileges[0];
			BuildingBlock nearbyBuildingBlock = buildingPrivlidge.GetNearbyBuildingBlock();
			buildingPrivlidge.AttachToBuilding(nearbyBuildingBlock ? nearbyBuildingBlock.buildingID : 0u);
		}
		while (building.HasDecayEntities())
		{
			DecayEntity decayEntity = building.decayEntities[0];
			BuildingBlock nearbyBuildingBlock2 = decayEntity.GetNearbyBuildingBlock();
			decayEntity.AttachToBuilding(nearbyBuildingBlock2 ? nearbyBuildingBlock2.buildingID : 0u);
		}
		if (AI.nav_carve_use_building_optimization)
		{
			building.isNavMeshCarvingDirty = true;
			int ticks = 2;
			UpdateNavMeshCarver(building, ref ticks, 0);
		}
	}

```

## OnPortalUsed(BasePlayer,BasePortal)

```csharp
```csharp
/// <summary>
/// Called when a player uses a portal.
/// </summary>
/// <param name="player">The player using the portal.</param>
/// <param name="portal">The portal being used.</param>
/// <returns>
/// Returns `null` to allow the player to use the portal normally, or any non-null value to override the default behavior.
/// If a string is returned, the player will be kicked with the provided message as the reason.
/// </returns>
object OnPortalUsed(BasePlayer player, BasePortal portal)
{
    Puts($"Player {player.displayName} has used portal {portal.name}.");
    if (portal.name == "Forbidden Portal")
    {
        Puts($"Player {player.displayName} has been blocked from using portal {portal.name}.");
        return "Blocked: Unauthorized access.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void UsePortal(BasePlayer player)
	{
		if (Interface.CallHook("OnPortalUse", player, this) != null)
		{
			return;
		}
		LinkPortal();
		if (targetPortal != null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			Vector3 position = player.transform.position;
			Vector3 vector = targetPortal.GetLocalEntryExitPosition();
			Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 vector3 = vector2;
			if (isMirrored)
			{
				Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);
				vector = targetPortal.relativeAnchor.transform.TransformPoint(position2);
				vector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);
			}
			else
			{
				vector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, vector, Vector3.up);
			}
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(vector);
			player.ForceUpdateTriggers();
			player.ClientRPCPlayer(null, player, "ForceViewAnglesTo", vector3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			player.ClientRPCPlayer(null, player, "StartLoading_Quick", arg1: true);
			Interface.CallHook("OnPortalUsed", player, this);
		}
		else
		{
			Debug.Log("No portal...");
		}
	}

```

## CanHackCrate(BasePlayer,HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hack a crate.
/// </summary>
/// <param name="player">The player attempting to hack the crate.</param>
/// <param name="crate">The crate being hacked.</param>
/// <returns>
/// Returns `null` to allow the player to hack the crate, or any non-null value to prevent them from hacking it.
/// </returns>
object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
{
    Puts($"Player {player.UserIDString} is attempting to hack crate {crate.CrateID}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} has admin privileges and can hack the crate.");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} does not have admin privileges and cannot hack the crate.");
        return true;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Hack(RPCMessage msg)
	{
		if (!IsBeingHacked() && Interface.CallHook("CanHackCrate", msg.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);
			OriginalHackerPlayer = msg.player.userID;
			StartHacking();
		}
	}

```

## OnTurretToggle(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret's online status is toggled.
/// </summary>
/// <param name="turret">The AutoTurret whose online status has been changed.</param>
/// <returns>
/// Returns `null` to allow the turret's online status to be changed, or any non-null value to prevent the change.
/// </returns>
object OnTurretToggle(AutoTurret turret)
{
    Puts($"Turret {turret.GetBase().GetDisplayName()} has been {(turret.HasFlag(Flags.On) ? "turned off" : "turned on")}.");
    if (turret.GetAttachedWeapon()?.IsBroken() ?? false)
    {
        Puts($"Turret {turret.GetBase().GetDisplayName()} is unable to change its online status due to a broken weapon.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetIsOnline(bool online)
	{
		if (online != HasFlag(Flags.On) && Interface.CallHook("OnTurretToggle", this) == null)
		{
			SetFlag(Flags.On, online);
			booting = false;
			GetAttachedWeapon()?.SetLightsOn(online);
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
			}
		}
	}

```

## OnPlayerInput(BasePlayer,InputState)

```csharp
```csharp
/// <summary>
/// Called when a player inputs something.
/// </summary>
/// <param name="player">The player who inputted something.</param>
/// <param name="inputState">The state of the player's input (e.g. keyboard, mouse, etc.).</param>
/// <returns>
/// Returns `null` to allow the default behavior to occur.
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnPlayerInput(BasePlayer player, InputState inputState)
{
    Puts($"Player {player.displayName} has inputted something.");
    // You can add custom logic here if needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsIncapacitated())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## CanTrainCarCouple(TrainCar,TrainCar)

```csharp
```csharp
/// <summary>
/// Called when a train car is attempting to couple with another.
/// </summary>
/// <param name="trainCar">The train car attempting to couple.</param>
/// <param name="couplingOwner">The owner of the coupling being attempted.</param>
/// <returns>
/// Returns `true` if the coupling can be made, or `false` if it cannot. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object CanTrainCarCouple(TrainCar trainCar, TrainCar couplingOwner)
{
    Puts($"Train car {trainCar.GetId()} is attempting to couple with owner {couplingOwner.GetId()}");
    if (trainCar.IsDamaged())
    {
        Puts($"Train car {trainCar.GetId()} cannot couple due to damage.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool TryCouple(TrainCoupling theirCoupling, bool reflect)
	{
		if (!isValid)
		{
			return false;
		}
		if (CoupledTo == theirCoupling)
		{
			return true;
		}
		if (IsCoupled)
		{
			return false;
		}
		object obj = Interface.CallHook("CanTrainCarCouple", owner, theirCoupling.owner);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (reflect && !theirCoupling.TryCouple(this, reflect: false))
		{
			return false;
		}
		controller.OnPreCouplingChange();
		CoupledTo = theirCoupling;
		owner.SetFlag(flag, b: true, recursive: false, networkupdate: false);
		owner.SendNetworkUpdate();
		return true;
	}

```

## OnFlameExplosion(FlameExplosive,UnityEngine.Collider)

```csharp
```csharp
/// <summary>
/// Called when a flame explosion occurs.
/// </summary>
/// <param name="explosive">The explosive that caused the flame explosion.</param>
/// <param name="collider">The collider of the explosive.</param>
object OnFlameExplosion(FlameExplosive explosive, Collider collider)
{
    Puts($"A flame explosion has occurred at position {explosive.transform.position}.");
    // You can add custom logic here to handle the flame explosion
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FlameExplode(Vector3 surfaceNormal)
	{
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = base.transform.position;
		if (blockCreateUnderwater && WaterLevel.Test(position))
		{
			base.Explode();
			return;
		}
		Collider component = GetComponent<Collider>();
		if ((bool)component)
		{
			component.enabled = false;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);
			if ((bool)baseEntity)
			{
				float num = (float)i / numToCreate;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);
				baseEntity.transform.SetPositionAndRotation(position, Quaternion.LookRotation(modifiedAimConeDirection));
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				baseEntity.Spawn();
				Interface.CallHook("OnFlameExplosion", this, component);
				Vector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * UnityEngine.Random.Range(1f, 1.1f));
				FireBall component2 = baseEntity.GetComponent<FireBall>();
				if (component2 != null)
				{
					component2.SetDelayedVelocity(vector);
				}
				else
				{
					baseEntity.SetVelocity(vector);
				}
			}
		}
		base.Explode();
	}

```

## OnEntityMounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player mounts an entity.
/// </summary>
/// <param name="entity">The entity being mounted.</param>
/// <param name="player">The player mounting the entity.</param>
/// <returns>
/// Returns `null` to allow the player to mount the entity, or any non-null value to prevent them from mounting.
/// </returns>
object OnEntityMounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has mounted {entity.name}");
    if (entity.name == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to mount {entity.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void MountPlayer(BasePlayer player)
	{
		if (!(_mounted != null) && !(mountAnchor == null) && Interface.CallHook("CanMountEntity", player, this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform transform = mountAnchor.transform;
			player.MountObject(this);
			player.MovePosition(transform.position);
			player.transform.rotation = transform.rotation;
			player.ServerRotation = transform.rotation;
			player.OverrideViewAngles(transform.rotation.eulerAngles);
			_mounted.eyes.NetworkUpdate(transform.rotation);
			player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", this, player);
		}
	}

```

## OnSignLocked(Signage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is locked by a player.
/// </summary>
/// <param name="sign">The sign that was locked.</param>
/// <param name="player">The player who locked the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignLocked(Signage sign, BasePlayer player)
{
    Puts($"Sign {sign.EntityID} has been locked by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void LockSign(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanUpdateSign(msg.player))
		{
			SetFlag(Flags.Locked, b: true);
			SendNetworkUpdate();
			base.OwnerID = msg.player.userID;
			Interface.CallHook("OnSignLocked", this, msg.player);
		}
	}

```

## OnCorpsePopulate(HumanNPC,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when a corpse is populated.
/// </summary>
/// <param name="npc">The NPC whose corpse is being populated.</param>
/// <param name="corpse">The corpse being populated.</param>
/// <returns>
/// Returns a non-null value to override the default population behavior. 
/// If a `BaseCorpse` object is returned, it will be used as the final corpse instead of the one created by this method.
/// </returns>
object OnCorpsePopulate(HumanNPC npc, NPCPlayerCorpse corpse)
{
    Puts($"Corpse for {npc.name} has been populated.");
    if (corpse.playerSteamID == "1234567890")
    {
        Puts($"Corpse for {npc.name} has been modified to have a custom Steam ID.");
        return new BaseCorpse();
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse()
	{
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse("assets/prefabs/npc/scientist/scientist_corpse.prefab") as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				nPCPlayerCorpse.playerName = OverrideCorpseName();
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				nPCPlayerCorpse.TakeChildren(this);
				for (int i = 0; i < nPCPlayerCorpse.containers.Length; i++)
				{
					ItemContainer itemContainer = nPCPlayerCorpse.containers[i];
					if (i != 1)
					{
						itemContainer.Clear();
					}
				}
				if (LootSpawnSlots.Length != 0)
				{
					object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
					if (obj is BaseCorpse)
					{
						return (BaseCorpse)obj;
					}
					LootContainer.LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
					for (int j = 0; j < lootSpawnSlots.Length; j++)
					{
						LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[j];
						for (int k = 0; k < lootSpawnSlot.numberToSpawn; k++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= lootSpawnSlot.probability)
							{
								lootSpawnSlot.definition.SpawnIntoContainer(nPCPlayerCorpse.containers[0]);
							}
						}
					}
				}
			}
			return nPCPlayerCorpse;
		}
	}

```

## CanUpdateSign(BasePlayer,PhotoFrame)

```csharp
```csharp
/// <summary>
/// Determines whether a player can update the sign of this object.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <returns>
/// Returns `true` if the player is allowed to update the sign, or `false` otherwise.
/// If a non-null value other than `bool` is returned by the hook, it will be used as the return value.
/// </returns>
object CanUpdateSign(BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempted to update the sign.");
    if (player.IsAdmin || player.IsDeveloper)
    {
        Puts("Admin or developer, allowing sign update.");
        return true;
    }
    object obj = Interface.CallHook("CanUpdateSign", player, this);
    if (obj is bool)
    {
        return (bool)obj;
    }
    if (!player.CanBuild())
    {
        Puts("Player cannot build, denying sign update.");
        return false;
    }
    if (IsLocked())
    {
        Puts($"Sign locked to owner {base.OwnerID}, checking player ID...");
        return player.userID == base.OwnerID;
    }
    Puts("No restrictions, allowing sign update.");
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## CanHelicopterDropCrate(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called to determine if a helicopter can drop a crate.
/// </summary>
/// <param name="helicopter">The helicopter attempting to drop the crate.</param>
/// <returns>
/// Returns `true` if the helicopter is allowed to drop the crate, and `false` otherwise.
/// If any other type of object is returned, it will be treated as a custom reason for not dropping the crate.
/// </returns>
object CanHelicopterDropCrate(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().GetEntityId()} attempting to drop crate.");
    if (helicopter.IsLowOnFuel())
    {
        Puts($"Helicopter {helicopter.GetReference().GetEntityId()} is low on fuel and cannot drop crate.");
        return "Not enough fuel.";
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

```

## OnOvenToggle(BaseOven,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the oven is toggled on or off.
/// </summary>
/// <param name="oven">The oven being toggled.</param>
/// <param name="player">The player who toggled the oven.</param>
/// <returns>
/// Returns `null` to allow the oven to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnOvenToggle(BaseOven oven, BasePlayer player)
{
    Puts($"Oven {oven.name} was toggled by player {player.UserIDString}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and can toggle the oven.");
        return null;
    }
    else
    {
        Puts($"Player {player.displayName} does not have permission to toggle the oven.");
        return true;
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	protected virtual void SVSwitch(RPCMessage msg)
	{
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnOvenToggle", this, msg.player) == null && flag != IsOn() && (!needsBuildingPrivilegeToUse || msg.player.CanBuild()))
		{
			if (flag)
			{
				StartCooking();
			}
			else
			{
				StopCooking();
			}
		}
	}

```

## OnExplosiveDud(DudTimedExplosive)

```csharp
```csharp
/// <summary>
/// Called when an explosive device becomes a dud.
/// </summary>
/// <param name="explosive">The explosive device that became a dud.</param>
/// <returns>No return behavior.</returns>
void OnExplosiveDud(DudTimedExplosive explosive)
{
    Puts($"Explosive device {explosive.GetId()} has become a dud.");
    if (explosive.creatorEntity != null && explosive.creatorEntity.IsNpc)
    {
        Puts($"The NPC {explosive.creatorEntity.GetId()} created the dud.");
    }
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		if (creatorEntity != null && creatorEntity.IsNpc)
		{
			base.Explode();
		}
		else if (UnityEngine.Random.Range(0f, 1f) < dudChance && Interface.CallHook("OnExplosiveDud", this) == null)
		{
			BecomeDud();
		}
		else
		{
			base.Explode();
		}
	}

```

## OnGiveSoldItem(VendingMachine,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player buys an item from a vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine that sold the item.</param>
/// <param name="item">The item that was bought.</param>
/// <param name="buyer">The player who bought the item.</param>
/// <returns>
/// Returns `null` to allow the player to receive the item, or any non-null value to prevent them from receiving it.
/// </returns>
object OnGiveSoldItem(VendingMachine vendingMachine, Item item, BasePlayer buyer)
{
    Puts($"Player {buyer.displayName} bought {item.info.name} from vending machine {vendingMachine.name}");
    if (item.info.category == "rare")
    {
        Puts($"Player {buyer.displayName} cannot afford the rare item {item.info.name}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void GiveSoldItem(Item soldItem, BasePlayer buyer)
	{
		if (Interface.CallHook("OnGiveSoldItem", this, soldItem, buyer) == null)
		{
			buyer.GiveItem(soldItem, GiveItemReason.PickedUp);
		}
	}

```

## OnPlayerCorpseSpawned(BasePlayer,PlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when a player's corpse is spawned.
/// </summary>
/// <param name="player">The player whose corpse was spawned.</param>
/// <param name="corpse">The player's corpse.</param>
/// <returns>
/// Returns `null` to allow the default corpse spawning behavior. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnPlayerCorpseSpawned(BasePlayer player, PlayerCorpse corpse)
{
    Puts($"Player {player.displayName}'s corpse has been spawned.");
    if (corpse.playerName == "JohnDoe")
    {
        Puts($"Player {player.displayName}'s corpse will be overridden with a custom model.");
        return new CustomCorpseModel();
    }
    return null;
}

class CustomCorpseModel : PlayerCorpse
{
    public override void Spawn()
    {
        // Override the default spawning behavior here.
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse()
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = "assets/prefabs/player/player_corpse.prefab";
			bool flag = false;
			if (ConVar.Global.cinematicGingerbreadCorpses)
			{
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);
						flag = component.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab) as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			UnityEngine.Random.State state = UnityEngine.Random.state;
			UnityEngine.Random.InitState((int)(seed + steamid));
			float result = UnityEngine.Random.Range(0f, 1f);
			UnityEngine.Random.state = state;
			return result;
		}
	}

```

## OnNpcTargetSense(BaseEntity,BaseEntity,AIBrainSenses)

```csharp
```csharp
/// <summary>
/// Called when an NPC senses a target.
/// </summary>
/// <param name="owner">The owner of the AI brain.</param>
/// <param name="target">The entity being sensed as a target.</param>
/// <param name="brainSenses">The AIBrainSenses object containing information about the AI's senses.</param>
/// <returns>
/// Returns `null` to allow the NPC to sense the target, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a reason for overriding the default behavior.
/// </returns>
object OnNpcTargetSense(BaseEntity owner, BaseEntity target, AIBrainSenses brainSenses)
{
    Puts($"NPC {owner} senses {target} as a target.");
    if (target == null || !target.IsValid())
    {
        return "Invalid target.";
    }
    // Add custom logic here to override the default behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)
	{
		if (Interface.CallHook("OnNpcTargetSense", owner, ent, brainSenses) != null)
		{
			return;
		}
		IAISenses iAISenses = owner as IAISenses;
		BasePlayer basePlayer = ent as BasePlayer;
		if (basePlayer != null && PlayerIgnoreList.Contains(basePlayer))
		{
			return;
		}
		bool flag = false;
		if (iAISenses != null && iAISenses.IsThreat(ent))
		{
			flag = true;
			if (brainSenses != null)
			{
				brainSenses.LastThreatTimestamp = UnityEngine.Time.realtimeSinceStartup;
			}
		}
		for (int i = 0; i < All.Count; i++)
		{
			if (All[i].Entity == ent)
			{
				SeenInfo value = All[i];
				value.Position = ent.transform.position;
				value.Timestamp = Mathf.Max(UnityEngine.Time.realtimeSinceStartup, value.Timestamp);
				All[i] = value;
				return;
			}
		}
		if (basePlayer != null)
		{
			if (ConVar.AI.ignoreplayers && !basePlayer.IsNpc)
			{
				return;
			}
			Players.Add(ent);
		}
		if (iAISenses != null)
		{
			if (iAISenses.IsTarget(ent))
			{
				Targets.Add(ent);
			}
			if (iAISenses.IsFriendly(ent))
			{
				Friendlies.Add(ent);
			}
			if (flag)
			{
				Threats.Add(ent);
			}
		}
		All.Add(new SeenInfo
		{
			Entity = ent,
			Position = ent.transform.position,
			Timestamp = UnityEngine.Time.realtimeSinceStartup
		});
	}

```

## OnSleepingBagValidCheck(SleepingBag,ulong,bool)

```csharp
```csharp
/// <summary>
/// Called to validate a sleeping bag for a player.
/// </summary>
/// <param name="sleepingBag">The sleeping bag being validated.</param>
/// <param name="playerID">The ID of the player using the sleeping bag.</param>
/// <param name="ignoreTimers">Whether to ignore timers when validating the sleeping bag.</param>
/// <returns>
/// Returns `true` if the sleeping bag is valid for the player, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as an error and the sleeping bag will not be considered valid.
/// </returns>
object OnSleepingBagValidCheck(SleepingBag sleepingBag, ulong playerID, bool ignoreTimers)
{
    Puts($"Checking validity of sleeping bag for player {playerID} with timers {(ignoreTimers ? "ignored" : "considered")}.");
    if (sleepingBag.DeployerUserID == playerID && !ignoreTimers)
    {
        return sleepingBag.UnlockTime < UnityEngine.Time.realtimeSinceStartup;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		object obj = Interface.CallHook("OnSleepingBagValidCheck", this, playerID, ignoreTimers);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (deployerUserID == playerID)
		{
			if (!ignoreTimers)
			{
				return unlockTime < UnityEngine.Time.realtimeSinceStartup;
			}
			return true;
		}
		return false;
	}

```

## CanTakeCutting(BasePlayer,GrowableEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can take a cutting from the growable entity.
/// </summary>
/// <param name="player">The player attempting to take the cutting.</param>
/// <param name="entity">The growable entity being interacted with.</param>
/// <returns>
/// Returns `null` to allow the player to take the cutting, or any non-null value to prevent them from taking it.
/// </returns>
object CanTakeCutting(BasePlayer player, GrowableEntity entity)
{
    Puts($"Player {player.UserIDString} is attempting to take a cutting from growable entity {entity.GetID()}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.UserIDString} has been granted permission to take cuttings.");
        return null;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to take cuttings.");
        return true;
    }
}
```
```

### Source Code from the Library

```csharp

	public void TakeClones(BasePlayer player)
	{
		if (player == null || !CanClone() || Interface.CallHook("CanTakeCutting", player, this) != null)
		{
			return;
		}
		int num = Properties.BaseCloneCount + Genes.GetGeneTypeCount(GrowableGenetics.GeneType.Yield) / 2;
		if (num > 0)
		{
			Item item = ItemManager.Create(Properties.CloneItem, num, 0uL);
			GrowableGeneEncoding.EncodeGenesToItem(this, item);
			Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player);
			player.GiveItem(item, GiveItemReason.ResourceHarvested);
			if (Properties.pickEffect.isValid)
			{
				Effect.server.Run(Properties.pickEffect.resourcePath, base.transform.position, Vector3.up);
			}
			Die();
		}
	}

```

## CanNpcEat(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an NPC wants to eat a given entity.
/// </summary>
/// <param name="npc">The NPC in question.</param>
/// <param name="entity">The entity the NPC is considering eating.</param>
/// <returns>
/// Returns `true` if the NPC wants to eat the entity, and `false` otherwise.
/// If a non-null value other than `bool` is returned, it will be used as the return value instead of this default behavior.
/// </returns>
object CanNpcEat(BaseNpc npc, BaseEntity entity)
{
    Puts($"NPC {npc.name} wants to eat {entity.name}");
    if (entity.HasTrait(TraitFlag.Poisoned))
    {
        Puts($"NPC {npc.name} does not want to eat {entity.name} because it is poisoned.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", this, best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

```

## OnMlrsTargetSet(MLRS,UnityEngine.Vector3,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the MLRS target is set.
/// </summary>
/// <param name="mlrs">The MLRS instance.</param>
/// <param name="worldPosition">The world position of the target.</param>
/// <param name="player">The player who set the target.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the MLRS target is set as normal.
/// </returns>
object OnMlrsTargetSet(MLRS mlrs, Vector3 worldPosition, BasePlayer player)
{
    Puts($"MLRS target set at {worldPosition} by player {player.username}");
    if (worldPosition.x < 0f || worldPosition.z < 0f || worldPosition.y < 0f)
    {
        Puts($"Invalid target position: {worldPosition}");
        return "Invalid target position";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 vector = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", this, worldPos, _mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Vector3 center = allSafeZone.triggerCollider.bounds.center;
				center.y = 0f;
				float num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 vector2 = trueTargetHitPos - center;
					trueTargetHitPos = center + vector2.normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", this, trueTargetHitPos, _mounted);
	}

```

## OnBookmarkDelete(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a bookmark is deleted.
/// </summary>
/// <param name="station">The computer station where the bookmark was deleted.</param>
/// <param name="player">The player who deleted the bookmark.</param>
/// <param name="identifier">The identifier of the deleted bookmark.</param>
/// <returns>
/// Returns `null` to allow the bookmark to be deleted, or any non-null value to prevent it from being deleted.
/// </returns>
object OnBookmarkDelete(ComputerStation station, BasePlayer player, string identifier)
{
    Puts($"Bookmark {identifier} was deleted by player {player.UserIDString} on computer station {station.name}");
    if (identifier == "admin-only")
    {
        Puts($"Attempted to delete admin-only bookmark {identifier}, but it cannot be deleted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void DeleteBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		string text = msg.read.String();
		if (IsValidIdentifier(text) && controlBookmarks.Contains(text) && Interface.CallHook("OnBookmarkDelete", this, player, text) == null)
		{
			controlBookmarks.Remove(text);
			SendControlBookmarks(player);
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if (baseEntity != null && baseEntity.TryGetComponent<IRemoteControllable>(out var component) && component.GetIdentifier() == text)
			{
				StopControl(player);
			}
		}
	}

```

## OnStashHidden(StashContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a stash is hidden.
/// </summary>
/// <param name="stash">The stash container being hidden.</param>
/// <param name="player">The player who hid the stash.</param>
/// <returns>No return behavior.</returns>
void OnStashHidden(StashContainer stash, BasePlayer player)
{
    Puts($"Stash {stash.GetID()} has been hidden by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", rpc.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", this, rpc.player);
		}
	}

```

## OnExperimentEnd(Workbench)

```csharp
```csharp
/// <summary>
/// Called when an experiment ends.
/// </summary>
/// <param name="workbench">The workbench where the experiment ended.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the experiment will be processed as normal.
/// </returns>
object OnExperimentEnd(Workbench workbench)
{
    Puts($"Experiment on {workbench.name} has ended.");
    if (workbench.experimentResourceItem.amount < 100 && workbench.pendingBlueprint != null)
    {
        Puts($"Insufficient resources to create blueprint on {workbench.name}.");
        return "Not enough resources.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ExperimentComplete()
	{
		Item experimentResourceItem = GetExperimentResourceItem();
		int scrapForExperiment = GetScrapForExperiment();
		if (pendingBlueprint == null)
		{
			Debug.LogWarning("Pending blueprint was null!");
		}
		if (Interface.CallHook("OnExperimentEnd", this) != null)
		{
			return;
		}
		if (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && pendingBlueprint != null)
		{
			experimentResourceItem.UseItem(scrapForExperiment);
			Item item = ItemManager.Create(GetBlueprintTemplate(), 1, 0uL);
			item.blueprintTarget = pendingBlueprint.itemid;
			creatingBlueprint = true;
			if (!item.MoveToContainer(base.inventory, 0))
			{
				item.Drop(GetDropPosition(), GetDropVelocity());
			}
			creatingBlueprint = false;
			if (experimentSuccessEffect.isValid)
			{
				Effect.server.Run(experimentSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
		}
		SetFlag(Flags.On, b: false);
		pendingBlueprint = null;
		base.inventory.SetLocked(isLocked: false);
		SendNetworkUpdate();
		Interface.CallHook("OnExperimentEnded", this);
	}

```

## OnPlayerLand(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="velocity">The velocity at which the player landed.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLand(BasePlayer player, float velocity)
{
    Puts($"Player {player.UserIDString} landed with a velocity of {velocity} m/s.");
    if (velocity > 50f)
    {
        Puts($"Player {player.displayName} experienced severe fall damage.");
        // Additional logic to handle severe fall damage
    }
}
```
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Facepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnEntitySpawned(BaseNetworkable)

```csharp
```csharp
/// <summary>
/// Called when an entity is spawned.
/// </summary>
/// <param name="entity">The entity that was spawned.</param>
/// <returns>No return behavior.</returns>
void OnEntitySpawned(BaseNetworkable entity)
{
    Puts($"Entity {entity.EntityID} has been spawned.");
    if (entity is BasePlayer player && player.UserIDString == "admin")
    {
        Puts($"Admin player {player.displayName} has been spawned.");
        // Perform any necessary actions for the admin player
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Spawn()
	{
		SpawnShared();
		if (net == null)
		{
			net = Network.Net.sv.CreateNetworkable();
		}
		creationFrame = UnityEngine.Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", this);
		SendNetworkUpdateImmediate(justCreated: true);
		if (Rust.Application.isLoading && !Rust.Application.isLoadingSave)
		{
			base.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

```

## OnEntityDeath(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity dies.
/// </summary>
/// <param name="entity">The entity that died.</param>
/// <param name="info">Information about the hit that killed the entity, including the initiator player and hit info.</param>
void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
{
    Puts($"Entity {entity.name} has died.");
    if (info != null && (bool)info.InitiatorPlayer)
    {
        BasePlayer initiatorPlayer = info.InitiatorPlayer;
        if (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)
        {
            initiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, entity.prefabID.ToString(), 1f);
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		if (ConVar.Global.developer > 1)
		{
			Debug.Log("[Combat]".PadRight(10) + base.gameObject.name + " died");
		}
		health = 0f;
		lifestate = LifeState.Dead;
		Interface.CallHook("OnEntityDeath", this, info);
		if (info != null && (bool)info.InitiatorPlayer)
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)
			{
				initiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, prefabID.ToString(), 1f);
			}
		}
		using (TimeWarning.New("OnKilled"))
		{
			OnKilled(info);
		}
	}

```

## CanResearchItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to research an item.
/// </summary>
/// <param name="player">The player attempting to research the item.</param>
/// <param name="item">The item being researched.</param>
/// <returns>
/// Returns `null` if the player is allowed to research the item, or any non-null value to prevent them from researching it.
/// </returns>
object CanResearchItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} attempted to research item {item.info.name}.");
    if (item.info.category == "Forbidden")
    {
        Puts($"Player {player.displayName} is not allowed to research the forbidden item: {item.info.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void DoResearch(RPCMessage msg)
	{
		if (IsResearching())
		{
			return;
		}
		BasePlayer player = msg.player;
		Item targetItem = GetTargetItem();
		if (targetItem != null && Interface.CallHook("CanResearchItem", player, targetItem) == null && targetItem.amount <= 1 && IsItemResearchable(targetItem))
		{
			Interface.CallHook("OnItemResearch", this, targetItem, player);
			targetItem.CollectedForCrafting(player);
			researchFinishedTime = UnityEngine.Time.realtimeSinceStartup + researchDuration;
			Invoke(ResearchAttemptFinished, researchDuration);
			base.inventory.SetLocked(isLocked: true);
			int scrapCost = ScrapForResearch(targetItem);
			Facepunch.Rust.Analytics.Azure.OnResearchStarted(player, this, targetItem, scrapCost);
			SetFlag(Flags.On, b: true);
			SendNetworkUpdate();
			player.inventory.loot.SendImmediate();
			if (researchStartEffect.isValid)
			{
				Effect.server.Run(researchStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			msg.player.GiveAchievement("RESEARCH_ITEM");
		}
	}

```

## OnBonusItemDropped(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bonus item is dropped.
/// </summary>
/// <param name="item">The dropped item.</param>
/// <param name="player">The player who dropped the item.</param>
/// <returns>
/// Returns a non-null value to override the default drop behavior. 
/// If `null` is returned, the item will be dropped as normal.
/// </returns>
object OnBonusItemDrop(Item item, BasePlayer player)
{
    Puts($"Player {player.displayName} has dropped a bonus item: {item.info.name}");
    if (item.info.name == "Golden Coin")
    {
        Puts($"Player {player.displayName} has dropped a Golden Coin!");
        return "Golden Coin found!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		base.DropBonusItems(initiator, container);
		if (initiator == null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if (basePlayer == null || scrapAmount <= 0 || !(scrapDef != null))
		{
			return;
		}
		float num = ((basePlayer.modifiers != null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", item, basePlayer) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", item, basePlayer);
			}
		}
	}

```

## OnHammerHit(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a hammer hits an entity.
/// </summary>
/// <param name="owner">The player who wielded the hammer.</param>
/// <param name="info">Information about the hit, including the entity and position of impact.</param>
/// <returns>
/// Returns `null` to allow the default repair behavior. 
/// If a non-null value is returned, it will override the default repair behavior.
/// </returns>
object OnHammerHit(BasePlayer owner, HitInfo info)
{
    Puts($"Player {owner.UserIDString} hit entity with hammer at position: {info.HitPosition}");
    if (info.HitEntity is BaseBuilding)
    {
        Puts($"Entity hit was a building.");
        return "Building cannot be repaired.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAttackShared(HitInfo info)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		BaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;
		if (baseCombatEntity != null && ownerPlayer != null && base.isServer)
		{
			if (Interface.CallHook("OnHammerHit", ownerPlayer, info) != null)
			{
				return;
			}
			using (TimeWarning.New("DoRepair", 50))
			{
				baseCombatEntity.DoRepair(ownerPlayer);
			}
		}
		info.DoDecals = false;
		if (base.isServer)
		{
			Effect.server.ImpactEffect(info);
		}
		else
		{
			Effect.client.ImpactEffect(info);
		}
	}

```

## OnBuildingPrivilege(BaseEntity,OBB)

```csharp
```csharp
/// <summary>
/// Called when a building privilege is requested.
/// </summary>
/// <param name="entity">The entity requesting the building privilege.</param>
/// <param name="obb">The OBB (oriented bounding box) of the building.</param>
/// <returns>
/// Returns a non-null value to override the default building privilege behavior. 
/// If `null` is returned, the default building privilege will be used.
/// </returns>
object OnBuildingPrivilege(BaseEntity entity, OBB obb)
{
    Puts($"Entity {entity.UserIDString} requested building privilege for OBB: {obb}");
    if (obb.Contains(entity.Position))
    {
        Puts($"Entity {entity.UserIDString} is within the OBB and has been granted building privilege.");
        return new BuildingPrivilege(true);
    }
    else
    {
        Puts($"Entity {entity.UserIDString} is outside the OBB and has not been granted building privilege.");
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
	{
		object obj = Interface.CallHook("OnBuildingPrivilege", this, obb);
		if (obj is BuildingPrivlidge)
		{
			return (BuildingPrivlidge)obj;
		}
		BuildingBlock other = null;
		BuildingPrivlidge result = null;
		List<BuildingBlock> obj2 = Facepunch.Pool.GetList<BuildingBlock>();
		Vis.Entities(obb.position, 16f + obb.extents.magnitude, obj2, 2097152);
		for (int i = 0; i < obj2.Count; i++)
		{
			BuildingBlock buildingBlock = obj2[i];
			if (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || obb.Distance(buildingBlock.WorldSpaceBounds()) > 16f)
			{
				continue;
			}
			BuildingManager.Building building = buildingBlock.GetBuilding();
			if (building != null)
			{
				BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
				if (!(dominatingBuildingPrivilege == null))
				{
					other = buildingBlock;
					result = dominatingBuildingPrivilege;
				}
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		return result;
	}

```

## OnTeamAcceptInvite(RelationshipManager.PlayerTeam,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a team accepts an invite from a player.
/// </summary>
/// <param name="team">The team accepting the invite.</param>
/// <param name="player">The player sending the invite.</param>
/// <returns>
/// Returns `null` to allow the team to accept the invite, or any non-null value to prevent them from accepting the invite.
/// </returns>
object OnTeamAcceptInvite(PlayerTeam team, BasePlayer player)
{
    Puts($"Team {team.Name} has accepted an invite from player {player.UserIDString}");
    if (team.Name == "Admins")
    {
        Puts($"Team {team.Name} is not accepting invites from players.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void acceptinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (!(basePlayer == null) && basePlayer.currentTeam == 0L)
		{
			ulong uLong = arg.GetULong(0, 0uL);
			PlayerTeam playerTeam = ServerInstance.FindTeam(uLong);
			if (playerTeam == null)
			{
				basePlayer.ClearPendingInvite();
			}
			else if (Interface.CallHook("OnTeamAcceptInvite", playerTeam, basePlayer) == null)
			{
				playerTeam.AcceptInvite(basePlayer);
			}
		}
	}

```

## OnBradleyApcThink(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when the Bradley APC thinks.
/// </summary>
/// <param name="bradleyAPC">The Bradley APC instance.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the Bradley APC will continue with its normal AI routine.
/// </returns>
object OnBradleyApcThink(BradleyAPC bradleyAPC)
{
    Puts($"The Bradley APC {bradleyAPC.name} has started thinking.");
    if (bradleyAPC.targetList.Count > 0 && bradleyAPC.targetList[0].IsValid() && bradleyAPC.targetList[0].IsVisible())
    {
        // Override the main gun target
        bradleyAPC.mainGunTarget = bradleyAPC.targetList[0].entity as BaseCombatEntity;
    }
    else
    {
        // Reset the main gun target
        bradleyAPC.mainGunTarget = null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoSimpleAI()
	{
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
		if (Interface.CallHook("OnBradleyApcThink", this) != null || !DoAI)
		{
			return;
		}
		if (targetList.Count > 0)
		{
			if (targetList[0].IsValid() && targetList[0].IsVisible())
			{
				mainGunTarget = targetList[0].entity as BaseCombatEntity;
			}
			else
			{
				mainGunTarget = null;
			}
			UpdateMovement_Hunt();
		}
		else
		{
			mainGunTarget = null;
			UpdateMovement_Patrol();
		}
		AdvancePathMovement(force: false);
		float num = Vector3.Distance(base.transform.position, destination);
		float value = Vector3.Distance(base.transform.position, finalDestination);
		if (num > stoppingDist)
		{
			Vector3 lhs = Direction2D(destination, base.transform.position);
			float num2 = Vector3.Dot(lhs, base.transform.right);
			float num3 = Vector3.Dot(lhs, base.transform.right);
			float num4 = Vector3.Dot(lhs, -base.transform.right);
			if (Vector3.Dot(lhs, -base.transform.forward) > num2)
			{
				if (num3 >= num4)
				{
					turning = 1f;
				}
				else
				{
					turning = -1f;
				}
			}
			else
			{
				turning = Mathf.Clamp(num2 * 3f, -1f, 1f);
			}
			float throttleScaleFromTurn = 1f - Mathf.InverseLerp(0f, 0.3f, Mathf.Abs(turning));
			AvoidObstacles(ref throttleScaleFromTurn);
			float num5 = Vector3.Dot(myRigidBody.velocity, base.transform.forward);
			if (!(throttle > 0f) || !(num5 < 0.5f))
			{
				timeSinceSeemingStuck = 0f;
			}
			else if ((float)timeSinceSeemingStuck > 10f)
			{
				timeSinceStuckReverseStart = 0f;
				timeSinceSeemingStuck = 0f;
			}
			float num6 = Mathf.InverseLerp(0.1f, 0.4f, Vector3.Dot(base.transform.forward, Vector3.up));
			if ((float)timeSinceStuckReverseStart < 3f)
			{
				throttle = -0.75f;
				turning = 1f;
			}
			else
			{
				throttle = (0.1f + Mathf.InverseLerp(0f, 20f, value) * 1f) * throttleScaleFromTurn + num6;
			}
		}
		DoWeaponAiming();
		SendNetworkUpdate();
	}

```

## OnPlayerDeath(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player dies.
/// </summary>
/// <param name="player">The player who died.</param>
/// <param name="info">Information about the hit that caused the death, if any.</param>
/// <returns>
/// Returns `null` to allow the player to die normally. If a non-null value is returned, it will override the default death behavior.
/// </returns>
object OnPlayerDeath(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} has died.");
    if (info != null && info.Attacker != null)
    {
        Puts($"Player was killed by {info.Attacker.UserIDString} with a {info.Weapon}.");
        return "Killed by another player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Die(HitInfo info = null)
	{
		using (TimeWarning.New("Player.Die"))
		{
			if (!IsDead())
			{
				if (Belt != null && ShouldDropActiveItem())
				{
					Vector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));
					Belt.DropActive(GetDropPosition(), GetInheritedDropVelocity() + vector.normalized * 3f);
				}
				if (!WoundInsteadOfDying(info) && Interface.CallHook("OnPlayerDeath", this, info) == null)
				{
					SleepingBag.OnPlayerDeath(this);
					base.Die(info);
				}
			}
		}
	}

```

## OnVendingShopOpened(VendingMachine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop is opened.
/// </summary>
/// <param name="vendingMachine">The vending machine that was opened.</param>
/// <param name="player">The player who opened the vending shop.</param>
/// <returns>
/// Returns `null` to allow the shop to open normally, or any non-null value to prevent the shop from opening.
/// </returns>
object OnVendingShopOpened(VendingMachine vendingMachine, BasePlayer player)
{
    Puts($"Vending shop {vendingMachine.name} opened by player {player.UserIDString}");
    if (player.GetPlayerFlag(PlayerFlags.VendingShopOwner))
    {
        Puts($"Player {player.displayName} is the owner of this vending shop.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_OpenShop(RPCMessage msg)
	{
		if (OccupiedCheck(msg.player) && Interface.CallHook("OnVendingShopOpen", this, msg.player) == null)
		{
			SendSellOrders(msg.player);
			PlayerOpenLoot(msg.player, customerPanel);
			Interface.CallHook("OnVendingShopOpened", this, msg.player);
		}
	}

```

## OnLootEntity(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an entity.
/// </summary>
/// <param name="player">The player starting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntity(BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player.UserIDString} started looting entity {entity.baseEntityID}");
}
```
```

### Source Code from the Library

```csharp

	public bool StartLootingEntity(BaseEntity targetEntity, bool doPositionChecks = true)
	{
		Clear();
		if (!targetEntity)
		{
			return false;
		}
		if (!targetEntity.OnStartBeingLooted(base.baseEntity))
		{
			return false;
		}
		Assert.IsTrue(targetEntity.isServer, "Assure is server");
		PositionChecks = doPositionChecks;
		entitySource = targetEntity;
		itemSource = null;
		Interface.CallHook("OnLootEntity", GetComponent<BasePlayer>(), targetEntity);
		MarkDirty();
		if (targetEntity is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = base.baseEntity.userID;
		}
		return true;
	}

```

## OnMissionFailed(BaseMission,BaseMission.MissionInstance,BasePlayer,BaseMission.MissionFailReason)

```csharp
```csharp
/// <summary>
/// Called when a mission fails.
/// </summary>
/// <param name="mission">The mission that failed.</param>
/// <param name="instance">The mission instance that failed.</param>
/// <param name="assignee">The player who was assigned the mission.</param>
/// <param name="failReason">The reason why the mission failed.</param>
/// <returns>No return behavior.</returns>
void OnMissionFailed(BaseMission mission, MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
{
    Puts($"Mission {mission.name} failed for player {assignee.UserIDString} with reason: {failReason}");
    if (failReason == MissionFailReason.PlayerKilled)
    {
        Puts($"Player {assignee.displayName} was killed during the mission.");
        // Additional logic can be added here to handle this specific failure reason
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionFailed(MissionInstance instance, BasePlayer assignee, MissionFailReason failReason)
	{
		assignee.ChatMessage("You have failed the mission : " + missionName.english);
		DoMissionEffect(failedEffect.resourcePath, assignee);
		Facepunch.Rust.Analytics.Server.MissionFailed(this, failReason);
		Facepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, failReason);
		instance.status = MissionStatus.Failed;
		MissionEnded(instance, assignee);
		Interface.CallHook("OnMissionFailed", this, instance, assignee, failReason);
	}

```

## OnReactiveTargetReset(ReactiveTarget)

```csharp
```csharp
/// <summary>
/// Called when a reactive target is reset.
/// </summary>
/// <param name="target">The reactive target being reset.</param>
/// <returns>No return behavior.</returns>
void OnReactiveTargetReset(ReactiveTarget target)
{
    Puts($"Reactive target {target.Name} has been reset.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void ResetTarget()
	{
		if (IsKnockedDown() && CanToggle())
		{
			CancelInvoke(ResetTarget);
			SetFlag(Flags.On, b: true);
			knockdownHealth = 100f;
			SendPowerBurst();
			Interface.CallHook("OnReactiveTargetReset", this);
		}
	}

```

## OnTeamInvite(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player invites another player to join their team.
/// </summary>
/// <param name="inviter">The player inviting the other player.</param>
/// <param name="invitee">The player being invited.</param>
/// <returns>
/// Returns `null` to allow the invite, or any non-null value to prevent the invite.
/// </returns>
object OnTeamInvite(BasePlayer inviter, BasePlayer invitee)
{
    Puts($"Player {inviter.UserIDString} has invited player {invitee.UserIDString} to join their team.");
    if (invitee.currentTeam != 0L)
    {
        Puts($"Player {invitee.UserIDString} is already on a team and cannot be invited.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void sendinvite(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam == null || playerTeam.GetLeader() == null || playerTeam.GetLeader() != basePlayer || !UnityEngine.Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), out var hitInfo, 5f, 1218652417, QueryTriggerInteraction.Ignore))
		{
			return;
		}
		BaseEntity entity = RaycastHitEx.GetEntity(hitInfo);
		if ((bool)entity)
		{
			BasePlayer component = entity.GetComponent<BasePlayer>();
			if ((bool)component && component != basePlayer && !component.IsNpc && component.currentTeam == 0L && Interface.CallHook("OnTeamInvite", basePlayer, component) == null)
			{
				playerTeam.SendInvite(component);
			}
		}
	}

```

## OnPlayerLanded(BasePlayer,float)

```csharp
```csharp
/// <summary>
/// Called when a player lands after falling.
/// </summary>
/// <param name="player">The player who landed.</param>
/// <param name="fallFactor">A value between 0 and 1 representing the severity of the fall, where 0 is no damage and 1 is maximum damage.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanded(BasePlayer player, float fallFactor)
{
    Puts($"Player {player.UserIDString} landed with a fall factor of {fallFactor}");
    if (fallFactor > 0.5f)
    {
        Puts($"Player {player.displayName} took significant damage from the fall.");
        // Apply additional effects or penalties here
    }
}
```
```

### Source Code from the Library

```csharp

	public void ApplyFallDamageFromVelocity(float velocity)
	{
		float num = Mathf.InverseLerp(-15f, -100f, velocity);
		if (num != 0f && Interface.CallHook("OnPlayerLand", this, num) == null)
		{
			metabolism.bleeding.Add(num * 0.5f);
			float num2 = num * 500f;
			Facepunch.Rust.Analytics.Azure.OnFallDamage(this, velocity, num2);
			Hurt(num2, DamageType.Fall);
			if (num2 > 20f && fallDamageEffect.isValid)
			{
				Effect.server.Run(fallDamageEffect.resourcePath, base.transform.position, Vector3.zero);
			}
			Interface.CallHook("OnPlayerLanded", this, num);
		}
	}

```

## OnPlayerSetInfo(Network.Connection,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's information is updated.
/// </summary>
/// <param name="connection">The network connection of the player.</param>
/// <param name="key">The key of the information being updated (e.g. "name", "email", etc.).</param>
/// <param name="value">The new value for the specified key.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSetInfo(Network.Connection connection, string key, string value)
{
    Puts($"Player's {key} has been updated to: {value}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void SetInfo(string key, string val)
	{
		if (IsConnected)
		{
			Interface.CallHook("OnPlayerSetInfo", net.connection, key, val);
			net.connection.info.Set(key, val);
		}
	}

```

## OnEntityStabilityCheck(StabilityEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity's stability is checked.
/// </summary>
/// <param name="entity">The entity being checked.</param>
/// <returns>
/// Returns a non-null value to override the default stability check behavior. 
/// If `null` is returned, the entity's stability will be checked as normal.
/// </returns>
object OnEntityStabilityCheck(StabilityEntity entity)
{
    Puts($"Checking stability of entity {entity.name}.");
    if (entity.isDamaged)
    {
        Puts($"Entity {entity.name} has been damaged and its stability is being overridden.");
        return "Damaged";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StabilityCheck()
	{
		if (base.IsDestroyed || Interface.CallHook("OnEntityStabilityCheck", this) != null)
		{
			return;
		}
		if (supports == null)
		{
			InitializeSupports();
		}
		bool flag = false;
		int num = DistanceFromGround();
		if (num != cachedDistanceFromGround)
		{
			cachedDistanceFromGround = num;
			flag = true;
		}
		float num2 = SupportValue();
		if (Mathf.Abs(cachedStability - num2) > Stability.accuracy)
		{
			cachedStability = num2;
			flag = true;
		}
		if (flag)
		{
			dirty = true;
			UpdateConnectedEntities();
			UpdateStability();
		}
		else if (dirty)
		{
			dirty = false;
			SendNetworkUpdate();
		}
		if (num2 < Stability.collapse)
		{
			if (stabilityStrikes < Stability.strikes)
			{
				UpdateStability();
				stabilityStrikes++;
			}
			else
			{
				Kill(DestroyMode.Gib);
			}
		}
		else
		{
			stabilityStrikes = 0;
		}
	}

```

## CanSetBedPublic(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called when a player tries to set their bed public.
/// </summary>
/// <param name="player">The player trying to set their bed public.</param>
/// <param name="sleepingBag">The sleeping bag being used by the player.</param>
/// <returns>
/// Returns `true` if the player is allowed to set their bed public, and `false` otherwise.
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
bool CanSetBedPublic(BasePlayer player, SleepingBag sleepingBag)
{
    Puts($"Player {player.UserID} is trying to set their bed public.");
    if (player.UserID == 12345) // Example: block a specific user
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public virtual void RPC_MakePublic(RPCMessage msg)
	{
		if (!canBePublic || !msg.player.CanInteract() || (deployerUserID != msg.player.userID && !msg.player.CanBuild()))
		{
			return;
		}
		bool flag = msg.read.Bit();
		if (flag == IsPublic() || Interface.CallHook("CanSetBedPublic", msg.player, this) != null)
		{
			return;
		}
		SetPublic(flag);
		if (!IsPublic())
		{
			BaseGameMode.CanAssignBedResult? canAssignBedResult = BaseGameMode.GetActiveGameMode(serverside: true)?.CanAssignBed(msg.player, this, msg.player.userID, 1, 0, this);
			if (canAssignBedResult.HasValue)
			{
				if (canAssignBedResult.Value.Result)
				{
					msg.player.ShowToast(GameTip.Styles.Blue_Long, bagLimitPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				else
				{
					msg.player.ShowToast(GameTip.Styles.Blue_Long, cannotMakeBedPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (!canAssignBedResult.Value.Result)
				{
					return;
				}
			}
			deployerUserID = msg.player.userID;
			Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, deployerUserID = msg.player.userID);
		}
		else
		{
			Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, 0uL);
		}
		SendNetworkUpdate();
	}

```

## OnPlayerWantsDismount(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player wants to dismount from a mountable object.
/// </summary>
/// <param name="player">The player attempting to dismount.</param>
/// <param name="mountable">The mountable object the player is currently on.</param>
/// <returns>
/// Returns `null` to allow the player to dismount, or any non-null value to prevent them from dismounting.
/// </returns>
object OnPlayerWantsDismount(BasePlayer player, BaseMountable mountable)
{
    Puts($"Player {player.UserIDString} wants to dismount from {mountable.ShortName}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot be prevented from dismounting");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", player, this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", player, this) == null)
		{
			AttemptDismount(player);
		}
	}

```

## OnFuelAmountCheck(EntityFuelSystem,Item)

```csharp
```csharp
/// <summary>
/// Called when the fuel amount is being checked.
/// </summary>
/// <param name="entity">The entity with a fuel system.</param>
/// <param name="fuelItem">The item containing the fuel.</param>
/// <returns>
/// Returns an integer representing the current fuel amount. If `null` or any non-integer value is returned, the default behavior will be used.
/// </returns>
int OnFuelAmountCheck(EntityFuelSystem entity, Item fuelItem)
{
    Puts($"Checking fuel amount for {entity.GetDisplayName()} with fuel item {fuelItem.GetDisplayName()}");
    if (fuelItem.amount < 10)
    {
        return 0;
    }
    return fuelItem.amount;
}
```
```

### Source Code from the Library

```csharp

	public int GetFuelAmount()
	{
		Item fuelItem = GetFuelItem();
		object obj = Interface.CallHook("OnFuelAmountCheck", this, fuelItem);
		if (obj is int)
		{
			return (int)obj;
		}
		if (fuelItem == null || fuelItem.amount < 1)
		{
			return 0;
		}
		return fuelItem.amount;
	}

```

## OnWeaponFired(BaseProjectile,BasePlayer,ItemModProjectile,ProtoBuf.ProjectileShoot)

```csharp
Based on the provided code snippet, I will attempt to create a method structure for the `OnWeaponFired` function.

**Method Structure:**

```csharp
/// <summary>
/// Called when a weapon is fired.
/// </summary>
/// <param name="baseProjectile">The base projectile.</param>
/// <param name="basePlayer">The player who fired the weapon.</param>
/// <param name="itemModProjectile">The item mod projectile component.</param>
/// <param name="protoBufProjectileShoot">The projectile shoot data.</param>
void OnWeaponFired(BaseProjectile baseProjectile, BasePlayer basePlayer, ItemModProjectile itemModProjectile, ProtoBuf.ProjectileShoot protoBufProjectileShoot)
{
    // Minimal code to demonstrate functionality
}
```

**Return Type Instructions:**

* The return type of this function is not explicitly specified in the provided code snippet. However, based on the context, it appears that this function does not return any value.
* If you need to return a specific value or object from this function, please specify the return type accordingly.

Please note that I've only extracted the method signature and basic documentation from the provided code snippet. You may need to modify the method structure based on your specific requirements and implementation details.
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0 && !UsingInfiniteAmmoCheat)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_missing");
			return;
		}
		ItemDefinition primaryMagazineAmmo = PrimaryMagazineAmmo;
		ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
		if (primaryMagazineAmmo.itemid != projectileShoot.ammoType)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Ammo mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "ammo_mismatch");
			return;
		}
		if (!UsingInfiniteAmmoCheat)
		{
			primaryMagazine.contents--;
		}
		ItemModProjectile component = primaryMagazineAmmo.GetComponent<ItemModProjectile>();
		if (component == null)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		if (projectileShoot.projectiles.Count > component.numProjectiles)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Count mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "count_mismatch");
			return;
		}
		Interface.CallHook("OnWeaponFired", this, msg.player, component, projectileShoot);
		if (player.InGesture)
		{
			return;
		}
		SignalBroadcast(Signal.Attack, string.Empty, msg.connection);
		player.CleanupExpiredProjectiles();
		Guid projectileGroupId = Guid.NewGuid();
		foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
		{
			if (player.HasFiredProjectile(projectile.projectileID))
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
				player.stats.combat.LogInvalid(player, this, "duplicate_id");
			}
			else if (ValidateEyePos(player, projectile.startPos))
			{
				player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, primaryMagazineAmmo, projectileGroupId);
				if (!player.limitNetworking)
				{
					CreateProjectileEffectClientside(component.projectileObject.resourcePath, projectile.startPos, projectile.startVel, projectile.seed, msg.connection, IsSilenced());
				}
			}
		}
		player.MakeNoise(player.transform.position, BaseCombatEntity.ActionVolume.Loud);
		player.stats.Add(component.category + "_fired", projectileShoot.projectiles.Count(), (Stats)5);
		player.LifeStoryShotFired(this);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay) + animationDelay);
		player.MarkHostileFor();
		UpdateItemCondition();
		DidAttackServerside();
		float num = 0f;
		if (component.projectileObject != null)
		{
			GameObject gameObject = component.projectileObject.Get();
			if (gameObject != null)
			{
				Projectile component2 = gameObject.GetComponent<Projectile>();
				if (component2 != null)
				{
					foreach (DamageTypeEntry damageType in component2.damageTypes)
					{
						num += damageType.amount;
					}
				}
			}
		}
		float num2 = NoiseRadius;
		if (IsSilenced())
		{
			num2 *= AI.npc_gun_noise_silencer_modifier;
		}
		Sensation sensation = default(Sensation);
		sensation.Type = SensationType.Gunshot;
		sensation.Position = player.transform.position;
		sensation.Radius = num2;
		sensation.DamagePotential = num;
		sensation.InitiatorPlayer = player;
		sensation.Initiator = player;
		Sense.Stimulate(sensation);
		EACServer.LogPlayerUseWeapon(player, this);
	}

```

## OnSamSiteTarget(SamSite,SamSite.ISamSiteTarget)

```csharp
```csharp
/// <summary>
/// Called when a target is scanned for the Sam Site.
/// </summary>
/// <param name="samSite">The Sam Site instance.</param>
/// <param name="target">The potential target to be added to the list of targets.</param>
/// <returns>
/// Returns `null` if the target should not be added. If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnSamSiteTarget(SamSite samSite, ISamSiteTarget target)
{
    Puts($"Scanning for targets around Sam Site {samSite}.");
    if (target == null || !target.IsValidSAMTarget(samSite.staticRespawn))
    {
        return null;
    }
    // Add custom logic here to determine whether the target should be added or not.
    // For example, you could check if the target is within a certain distance from the Sam Site.
    if (Vector3.Distance(target.CenterPoint(), samSite.eyePoint.transform.position) > 100f)
    {
        return null;
    }
    return target;
}
```
```

### Source Code from the Library

```csharp

	public void TargetScan()
	{
		if (!IsPowered())
		{
			lastTargetVisibleTime = 0f;
			return;
		}
		if (UnityEngine.Time.time > lastTargetVisibleTime + 3f)
		{
			ClearTarget();
		}
		if (!staticRespawn)
		{
			int num = ((ammoItem != null && ammoItem.parent == base.inventory) ? ammoItem.amount : 0);
			bool flag = lastAmmoCount < lowAmmoThreshold;
			bool flag2 = num < lowAmmoThreshold;
			if (num != lastAmmoCount && flag != flag2)
			{
				MarkIODirty();
			}
			lastAmmoCount = num;
		}
		if (HasValidTarget() || IsDead())
		{
			return;
		}
		List<ISamSiteTarget> obj = Facepunch.Pool.GetList<ISamSiteTarget>();
		if (Interface.CallHook("OnSamSiteTargetScan", this, obj) == null)
		{
			if (!IsInDefenderMode())
			{
				AddTargetSet(obj, 32768, targetTypeVehicle.scanRadius);
			}
			AddTargetSet(obj, 1048576, targetTypeMissile.scanRadius);
		}
		ISamSiteTarget samSiteTarget = null;
		foreach (ISamSiteTarget item in obj)
		{
			if (!item.isClient && !(item.CenterPoint().y < eyePoint.transform.position.y) && item.IsVisible(eyePoint.transform.position, item.SAMTargetType.scanRadius * 2f) && item.IsValidSAMTarget(staticRespawn) && Interface.CallHook("OnSamSiteTarget", this, item) == null)
			{
				samSiteTarget = item;
				break;
			}
		}
		if (!ObjectEx.IsUnityNull(samSiteTarget) && currentTarget != samSiteTarget)
		{
			lockOnTime = UnityEngine.Time.time + 0.5f;
		}
		SetTarget(samSiteTarget);
		if (!ObjectEx.IsUnityNull(currentTarget))
		{
			lastTargetVisibleTime = UnityEngine.Time.time;
		}
		Facepunch.Pool.FreeList(ref obj);
		if (ObjectEx.IsUnityNull(currentTarget))
		{
			CancelInvoke(WeaponTick);
		}
		else
		{
			InvokeRandomized(WeaponTick, 0f, 0.5f, 0.2f);
		}
		void AddTargetSet(List<ISamSiteTarget> allTargets, int layerMask, float scanRadius)
		{
			List<ISamSiteTarget> obj2 = Facepunch.Pool.GetList<ISamSiteTarget>();
			Vis.Entities(eyePoint.transform.position, scanRadius, obj2, layerMask, QueryTriggerInteraction.Ignore);
			allTargets.AddRange(obj2);
			Facepunch.Pool.FreeList(ref obj2);
		}
	}

```

## OnItemRemove(Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from the game.
/// </summary>
/// <param name="item">The item being removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemove(Item item)
{
    Puts($"Item {item.info.name} has been removed.");
    if (item.info.category == "Forbidden")
    {
        Puts($"Item {item.info.name} is a forbidden item and cannot be removed.");
        // Add any additional logic to handle the removal of forbidden items
    }
}
```
```

### Source Code from the Library

```csharp

	public void Remove(float fTime = 0f)
	{
		if (removeTime > 0f || Interface.CallHook("OnItemRemove", this) != null)
		{
			return;
		}
		if (isServer)
		{
			ItemMod[] itemMods = info.itemMods;
			for (int i = 0; i < itemMods.Length; i++)
			{
				itemMods[i].OnRemove(this);
			}
		}
		this.onCycle = null;
		removeTime = UnityEngine.Time.time + fTime;
		this.OnDirty = null;
		position = -1;
		if (isServer)
		{
			ItemManager.RemoveItem(this, fTime);
		}
	}

```

## OnSignUpdated(Signage,BasePlayer,int)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated.
/// </summary>
/// <param name="sign">The signage being updated.</param>
/// <param name="player">The player who updated the sign.</param>
/// <param name="index">The index of the sign in the paintable sources array.</param>
/// <returns>
/// Returns a non-null value to override the default update behavior. 
/// If `null` is returned, the sign is updated as normal.
/// </returns>
object OnSignUpdated(Signage sign, BasePlayer player, int index)
{
    Puts($"Sign at index {index} has been updated by player {player}.");
    if (sign == null || !sign.IsValid())
    {
        Puts($"Invalid sign at index {index}.");
        return null;
    }
    // Additional logic can be added here to handle the sign update.
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server.MaxDistance(5f)]
	public void UpdateSign(RPCMessage msg)
	{
		if (msg.player == null || !CanUpdateSign(msg.player))
		{
			return;
		}
		int num = msg.read.Int32();
		if (num < 0 || num >= paintableSources.Length)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (msg.read.Unread > 0 && msg.read.Bit() && !msg.player.IsAdmin)
		{
			UnityEngine.Debug.LogWarning($"{msg.player} tried to upload a sign from a file but they aren't admin, ignoring");
			return;
		}
		EnsureInitialized();
		if (array == null)
		{
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = 0u;
		}
		else
		{
			if (!ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				return;
			}
			if (textureIDs[num] != 0)
			{
				FileStorage.server.RemoveExact(textureIDs[num], FileStorage.Type.png, net.ID, (uint)num);
			}
			textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, net.ID, (uint)num);
		}
		LogEdit(msg.player);
		SendNetworkUpdate();
		Interface.CallHook("OnSignUpdated", this, msg.player, num);
	}

```

## OnInventoryAmmoItemFind(PlayerInventory,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when an ammo item is found in the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="itemDefinition">The definition of the ammo item to find.</param>
/// <returns>
/// Returns the found ammo item, or `null` if not found.
/// If a non-null value is returned, it will override the default behavior and return that value instead.
/// </returns>
Item OnInventoryAmmoItemFind(PlayerInventory inventory, ItemDefinition itemDefinition)
{
    Puts($"Searching for {itemDefinition.shortname} in player's inventory...");
    if (inventory.containerMain.FindItemsByItemName(itemDefinition.shortname) != null)
    {
        return inventory.containerMain.FindItemsByItemName(itemDefinition.shortname);
    }
    else if (inventory.containerBelt.FindItemsByItemName(itemDefinition.shortname) != null)
    {
        return inventory.containerBelt.FindItemsByItemName(itemDefinition.shortname);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public Item GetAmmo()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return null;
		}
		object obj = Interface.CallHook("OnInventoryAmmoItemFind", ownerPlayer.inventory, fuelType);
		if (obj is Item)
		{
			return (Item)obj;
		}
		Item item = ownerPlayer.inventory.containerMain.FindItemsByItemName(fuelType.shortname);
		if (item == null)
		{
			item = ownerPlayer.inventory.containerBelt.FindItemsByItemName(fuelType.shortname);
		}
		return item;
	}

```

## OnDieselEngineToggle(DieselEngine,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the diesel engine is toggled on or off.
/// </summary>
/// <param name="engine">The diesel engine being toggled.</param>
/// <param name="player">The player who toggled the engine.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the engine will be turned on or off as normal.
/// </returns>
object OnDieselEngineToggle(DieselEngine engine, BasePlayer player)
{
    Puts($"Player {player.UserIDString} toggled diesel engine {engine.name}.");
    if (player.GetStat("diesel_engine_toggle_count") >= 10)
    {
        Puts($"Player {player.displayName} has toggled the diesel engine too many times. Engine will not turn on.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	public void EngineSwitch(RPCMessage msg)
	{
		if (Interface.CallHook("OnDieselEngineToggle", this, msg.player) != null)
		{
			return;
		}
		if (msg.read.Bit())
		{
			if (GetFuelAmount() > 0)
			{
				EngineOn();
				if (Rust.GameInfo.HasAchievements && msg.player != null)
				{
					msg.player.stats.Add("excavator_activated", 1, Stats.All);
					msg.player.stats.Save(forceSteamSave: true);
				}
			}
		}
		else
		{
			EngineOff();
		}
	}

```

## OnLootItem(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player starts looting an item.
/// </summary>
/// <param name="player">The player starting to loot the item.</param>
/// <param name="item">The item being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootItem(BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} started looting item: {item.name}");
}
```
```

### Source Code from the Library

```csharp

	public void StartLootingItem(Item item)
	{
		Clear();
		if (item != null && item.contents != null)
		{
			PositionChecks = true;
			containers.Add(item.contents);
			item.contents.onDirty += MarkDirty;
			itemSource = item;
			entitySource = item.GetWorldEntity();
			Interface.CallHook("OnLootItem", GetComponent<BasePlayer>(), item);
			MarkDirty();
		}
	}

```

## OnPlayerTick(BasePlayer,PlayerTick,bool)

```csharp
```csharp
/// <summary>
/// Called when a player's tick is processed.
/// </summary>
/// <param name="player">The player whose tick is being processed.</param>
/// <param name="tickMessage">The message containing the player's input state and other relevant information.</param>
/// <param name="wasPlayerStalled">A boolean indicating whether the player was stalled during the previous tick.</param>
/// <returns>
/// Returns a non-null value to override the default tick processing behavior. 
/// If `null` is returned, the tick is processed as normal.
/// </returns>
object OnPlayerTick(BasePlayer player, PlayerTick tickMessage, bool wasPlayerStalled)
{
    Puts($"Processing tick for player {player.Name}.");
    if (wasPlayerStalled)
    {
        Puts($"Player {player.Name} was stalled during the previous tick.");
        // Handle stall logic here
    }
    else
    {
        // Handle normal tick processing logic here
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void OnReceiveTick(PlayerTick msg, bool wasPlayerStalled)
	{
		if (msg.inputState != null)
		{
			serverInput.Flip(msg.inputState);
		}
		if (Interface.CallHook("OnPlayerTick", this, msg, wasPlayerStalled) != null)
		{
			return;
		}
		if (serverInput.current.buttons != serverInput.previous.buttons)
		{
			ResetInputIdleTime();
		}
		if (Interface.CallHook("OnPlayerInput", this, serverInput) != null || IsReceivingSnapshot)
		{
			return;
		}
		if (IsSpectating())
		{
			using (TimeWarning.New("Tick_Spectator"))
			{
				Tick_Spectator();
				return;
			}
		}
		if (IsDead())
		{
			return;
		}
		if (IsSleeping())
		{
			if (serverInput.WasJustPressed(BUTTON.FIRE_PRIMARY) || serverInput.WasJustPressed(BUTTON.FIRE_SECONDARY) || serverInput.WasJustPressed(BUTTON.JUMP) || serverInput.WasJustPressed(BUTTON.DUCK))
			{
				EndSleeping();
				SendNetworkUpdateImmediate();
			}
			UpdateActiveItem(default(ItemId));
			return;
		}
		UpdateActiveItem(msg.activeItem);
		UpdateModelStateFromTick(msg);
		if (!IsIncapacitated())
		{
			if (isMounted)
			{
				GetMounted().PlayerServerInput(serverInput, this);
			}
			UpdatePositionFromTick(msg, wasPlayerStalled);
			UpdateRotationFromTick(msg);
		}
	}

```

## OnFishingStopped(BaseFishingRod,BaseFishingRod.FailReason)

```csharp
```csharp
/// <summary>
/// Called when fishing is stopped.
/// </summary>
/// <param name="fishingRod">The fishing rod that was being used.</param>
/// <param name="reason">The reason why fishing was stopped (e.g. Success, FailReason).</param>
/// <returns>No return behavior.</returns>
void OnFishingStopped(BaseFishingRod fishingRod, FailReason reason)
{
    Puts($"Fishing stopped with reason: {reason}");
    if (reason == FailReason.Success)
    {
        Puts("Fishing was successful!");
    }
    else
    {
        Puts("Fishing failed.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void Server_Cancel(FailReason reason)
	{
		if (GetItem() != null)
		{
			GetItem().LoseCondition((reason == FailReason.Success) ? ConditionLossOnSuccess : ConditionLossOnFail);
		}
		SetFlag(Flags.Busy, b: false);
		UpdateFlags();
		CancelInvoke(CatchProcess);
		CurrentState = CatchState.None;
		SetFlag(Flags.Reserved1, b: false);
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		if (fishingBobber != null)
		{
			fishingBobber.Kill();
			currentBobber.Set(null);
		}
		ClientRPC(null, "Client_ResetLine", (int)reason);
		Interface.CallHook("OnFishingStopped", this, reason);
	}

```

## OnItemRemovedFromContainer(ItemContainer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is removed from a container.
/// </summary>
/// <param name="container">The container from which the item was removed.</param>
/// <param name="item">The item that was removed.</param>
/// <returns>No return behavior.</returns>
void OnItemRemovedFromContainer(ItemContainer container, Item item)
{
    Puts($"Item {item.Name} has been removed from container {container.Name}");
}
```
```

### Source Code from the Library

```csharp

	public bool Remove(Item item)
	{
		if (!itemList.Contains(item))
		{
			return false;
		}
		if (onPreItemRemove != null)
		{
			onPreItemRemove(item);
		}
		itemList.Remove(item);
		item.parent = null;
		MarkDirty();
		if (onItemAddedRemoved != null)
		{
			onItemAddedRemoved(item, arg2: false);
		}
		Interface.CallHook("OnItemRemovedFromContainer", this, item);
		return true;
	}

```

## OnMlrsFiringEnded(MLRS)

```csharp
```csharp
/// <summary>
/// Called when the MLRS firing has ended.
/// </summary>
/// <param name="mlrs">The MLRS module that fired.</param>
/// <returns>No return behavior.</returns>
void OnMlrsFiringEnded(MLRS mlrs)
{
    Puts($"MLRS {mlrs.GetReference()} firing has ended.");
    if (mlrs.GetAmmoCount() == 0)
    {
        Puts($"MLRS {mlrs.GetReference()} is out of ammo.");
        // Add additional logic here if needed
    }
}
```
```

### Source Code from the Library

```csharp

	public void EndFiring()
	{
		CancelInvoke(FireNextRocket);
		rocketOwnerRef.Set(null);
		if (TryGetAimingModule(out var item))
		{
			item.LoseCondition(1f);
		}
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Broken, b: true, recursive: false, networkupdate: false);
		SendNetworkUpdate_Flags();
		timeSinceBroken = 0f;
		Interface.CallHook("OnMlrsFiringEnded", this);
	}

```

## IOnLoseCondition(Item,float)

```csharp
```csharp
/// <summary>
/// Called when a item loses condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>
/// Returns `null` to allow the item to lose condition, or any non-null value to prevent it from losing condition.
/// If a string is returned, the item will be destroyed with the provided message as the reason.
/// </returns>
object IOnLoseCondition(Item item, float amount)
{
    Puts($"Item {item.info.shortname} lost {amount} condition.");
    if (amount > 0.5f)
    {
        Puts($"Item {item.info.shortname} has been severely damaged.");
        return "Destroyed: Severe damage.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void LoseCondition(float amount)
	{
		if (hasCondition && !Debugging.disablecondition && Interface.CallHook("IOnLoseCondition", this, amount) == null)
		{
			float num = condition;
			condition -= amount;
			if (ConVar.Global.developer > 0)
			{
				Debug.Log(info.shortname + " was damaged by: " + amount + "cond is: " + condition + "/" + maxCondition);
			}
			if (condition <= 0f && condition < num)
			{
				OnBroken();
			}
		}
	}

```

## OnDroppedItemCombined(DroppedItem)

```csharp
```csharp
/// <summary>
/// Called when two items are combined into one.
/// </summary>
/// <param name="di">The DroppedItem that was combined.</param>
void OnDroppedItemCombined(DroppedItem di)
{
    Puts($"Items combined: {item.info.name} and {di.item.info.name}");
    if (di.item.info.amountType == ItemDefinition.AmountType.Genetics && item.instanceData.dataInt != di.item.instanceData.dataInt)
    {
        return;
    }
    
    int totalAmount = di.item.amount + item.amount;
    if (totalAmount <= item.MaxStackable() && totalAmount != 0)
    {
        DropReason = DropReasonEnum.Player;
        di.DestroyItem();
        di.Kill();
        item.amount = totalAmount;
        item.MarkDirty();
        
        if (GetDespawnDuration() < float.PositiveInfinity)
        {
            Interface.CallHook("OnDroppedItemCombined", this);
            Invoke(IdleDestroy, GetDespawnDuration());
        }
        
        Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
    }
}
```
```

### Source Code from the Library

```csharp

	public void OnDroppedOn(DroppedItem di)
	{
		if (item == null || di.item == null || Interface.CallHook("CanCombineDroppedItem", this, di) != null || di.item.info != item.info || (di.item.IsBlueprint() && di.item.blueprintTarget != item.blueprintTarget) || (di.item.hasCondition && di.item.condition != di.item.maxCondition) || (item.hasCondition && item.condition != item.maxCondition))
		{
			return;
		}
		if (di.item.info != null)
		{
			if (di.item.info.amountType == ItemDefinition.AmountType.Genetics)
			{
				int num = ((di.item.instanceData != null) ? di.item.instanceData.dataInt : (-1));
				int num2 = ((item.instanceData != null) ? item.instanceData.dataInt : (-1));
				if (num != num2)
				{
					return;
				}
			}
			if ((di.item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(di.item) != null) || (item.info != null && item.info.GetComponent<ItemModSign>() != null && ItemModAssociatedEntity<SignContent>.GetAssociatedEntity(item) != null))
			{
				return;
			}
		}
		int num3 = di.item.amount + item.amount;
		if (num3 <= item.MaxStackable() && num3 != 0)
		{
			if (di.DropReason == DropReasonEnum.Player)
			{
				DropReason = DropReasonEnum.Player;
			}
			di.DestroyItem();
			di.Kill();
			item.amount = num3;
			item.MarkDirty();
			if (GetDespawnDuration() < float.PositiveInfinity)
			{
				Interface.CallHook("OnDroppedItemCombined", this);
				Invoke(IdleDestroy, GetDespawnDuration());
			}
			Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", this, 0u, Vector3.zero, Vector3.zero);
		}
	}

```

## OnItemDropped(Item,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is dropped.
/// </summary>
/// <param name="item">The item being dropped.</param>
/// <param name="baseEntity">The BaseEntity representing the dropped item, or null if the item cannot be dropped.</param>
/// <returns>No return behavior.</returns>
void OnItemDropped(Item item, BaseEntity baseEntity)
{
    Puts($"Item {item.info.name} has been dropped.");
    if (baseEntity != null && baseEntity is BasePlayer)
    {
        Puts($"The item was dropped by player {((BasePlayer)baseEntity).displayName}");
    }
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity Drop(Vector3 vPos, Vector3 vVelocity, Quaternion rotation = default(Quaternion))
	{
		RemoveFromWorld();
		BaseEntity baseEntity = null;
		if (vPos != Vector3.zero && !info.HasFlag(ItemDefinition.Flag.NoDropping))
		{
			baseEntity = CreateWorldObject(vPos, rotation);
			if ((bool)baseEntity)
			{
				baseEntity.SetVelocity(vVelocity);
			}
		}
		else
		{
			Remove();
		}
		Interface.CallHook("OnItemDropped", this, baseEntity);
		RemoveFromContainer();
		return baseEntity;
	}

```

## OnPhoneDialFailed(PhoneController,Telephone.DialFailReason,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dial attempt fails.
/// </summary>
/// <param name="phoneController">The phone controller that failed to dial.</param>
/// <param name="reason">The reason for the dial failure (e.g. invalid number, busy line, etc.).</param>
/// <param name="player">The player who attempted to make the call.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialFailed(PhoneController phoneController, Telephone.DialFailReason reason, BasePlayer player)
{
    Puts($"Phone dial failed for player {player.UserIDString} with reason: {reason}");
    if (reason == Telephone.DialFailReason.InvalidNumber)
    {
        Puts($"Player {player.displayName} attempted to call an invalid number.");
        // Play a sound or show a message to the player indicating that the number is invalid
    }
    else if (reason == Telephone.DialFailReason.BusyLine)
    {
        Puts($"Player {player.displayName} encountered a busy line.");
        // Play a sound or show a message to the player indicating that the line is busy
    }
}
```
```

### Source Code from the Library

```csharp

	public void OnDialFailed(Telephone.DialFailReason reason)
	{
		if (Interface.CallHook("OnPhoneDialFail", this, reason, currentPlayer) == null)
		{
			SetPhoneState(Telephone.CallState.Idle);
			base.baseEntity.ClientRPC(null, "ClientOnDialFailed", (int)reason);
			activeCallTo = null;
			if (IsInvoking(TimeOutCall))
			{
				CancelInvoke(TimeOutCall);
			}
			if (IsInvoking(TriggerTimeOut))
			{
				CancelInvoke(TriggerTimeOut);
			}
			if (IsInvoking(TimeOutDialing))
			{
				CancelInvoke(TimeOutDialing);
			}
			Interface.CallHook("OnPhoneDialFailed", this, reason, currentPlayer);
		}
	}

```

## IOnPlayerBanned(Network.Connection,AuthResponse)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="connection">The connection of the banned player.</param>
/// <param name="status">The reason for the ban (e.g. VACBanned, PublisherBanned).</param>
/// <returns>No return behavior.</returns>
void IOnPlayerBanned(Network.Connection connection, AuthResponse status)
{
    Puts($"Player {connection.username} has been banned with reason: {status}");
    ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + connection.username.EscapeRichText() + $" ({status})");
}
```
```

### Source Code from the Library

```csharp

	internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
	{
		if (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))
		{
			return;
		}
		Network.Connection connection = Network.Net.sv.connections.FirstOrDefault((Network.Connection x) => x.userid == SteamId);
		if (connection == null)
		{
			Debug.LogWarning($"Steam gave us a {Status} ticket response for unconnected id {SteamId}");
			return;
		}
		switch (Status)
		{
		case AuthResponse.OK:
			Debug.LogWarning($"Steam gave us a 'ok' ticket response for already connected id {SteamId}");
			return;
		case AuthResponse.TimedOut:
			return;
		case AuthResponse.VACBanned:
		case AuthResponse.PublisherBanned:
			if (!bannedPlayerNotices.Contains(SteamId))
			{
				Interface.CallHook("IOnPlayerBanned", connection, Status);
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + connection.username.EscapeRichText() + " (banned by anticheat)");
				bannedPlayerNotices.Add(SteamId);
			}
			break;
		}
		Debug.Log($"Kicking {connection.ipaddress}/{connection.userid}/{connection.username} (Steam Status \"{Status.ToString()}\")");
		connection.authStatus = Status.ToString();
		Network.Net.sv.Kick(connection, "Steam: " + Status);
	}

```

## OnTick()

```csharp
```csharp
/// <summary>
/// Called every tick to perform server-side updates.
/// </summary>
void OnTick()
{
    Puts("Server is ticking...");
    // Perform any necessary server-side updates here...
    // For example, you could update the game state or check for any important events.
    
    // If you need to return a value from this method, consider using an object type and returning it.
    // However, in this case, since we're not performing any complex operations that require a return value,
    // we can simply omit the return statement.
}
```
```

### Source Code from the Library

```csharp

	private void DoTick()
	{
		Interface.CallHook("OnTick");
		RCon.Update();
		CompanionServer.Server.Update();
		for (int i = 0; i < Network.Net.sv.connections.Count; i++)
		{
			Network.Connection connection = Network.Net.sv.connections[i];
			if (!connection.isAuthenticated && !(connection.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Network.Net.sv.Kick(connection, "Authentication Timed Out");
			}
		}
	}

```

## OnPayForPlacement(BasePlayer,Planner,Construction)

```csharp
```csharp
/// <summary>
/// Called when a player pays for placement of a construction component.
/// </summary>
/// <param name="player">The player paying for the placement.</param>
/// <param name="planner">The planner used to deploy the component.</param>
/// <param name="component">The construction component being placed.</param>
/// <returns>
/// Returns `null` if the payment is successful, or any non-null value to cancel the payment.
/// </returns>
object OnPayForPlacement(BasePlayer player, Planner planner, Construction component)
{
    Puts($"Player {player.UserIDString} paid for placement of construction component {component.name}");
    // Check if the player has enough funds
    if (player.inventory.GetAmount(component.defaultGrade.costToBuild[0].itemDef.itemid) < component.defaultGrade.costToBuild[0].amount)
    {
        Puts($"Player {player.UserIDString} does not have enough funds to pay for placement.");
        return "Insufficient funds";
    }
    // Remove the payment items from the player's inventory
    foreach (ItemAmount item in component.defaultGrade.costToBuild)
    {
        player.inventory.Take(new List<Item>(), item.itemDef.itemid, (int)item.amount);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void PayForPlacement(BasePlayer player, Construction component)
	{
		if (Interface.CallHook("OnPayForPlacement", player, this, component) != null)
		{
			return;
		}
		if (isTypeDeployable)
		{
			GetItem().UseItem();
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount item in component.defaultGrade.costToBuild)
		{
			player.inventory.Take(list, item.itemDef.itemid, (int)item.amount);
			player.Command("note.inv", item.itemDef.itemid, item.amount * -1f);
		}
		foreach (Item item2 in list)
		{
			item2.Remove();
		}
	}

```

## OnPlayerRecover(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player recovers from being wounded.
/// </summary>
/// <param name="player">The player who recovered.</param>
/// <returns>
/// Returns `null` to allow the player to recover normally, or any non-null value to prevent them from recovering.
/// </returns>
object OnPlayerRecover(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has recovered from being wounded.");
    if (player.GetPlayerFlag(PlayerFlags.Admin))
    {
        Puts($"Player {player.displayName} is an admin and cannot be wounded.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecoverFromWounded()
	{
		if (Interface.CallHook("OnPlayerRecover", this) == null)
		{
			if (IsCrawling())
			{
				base.health = UnityEngine.Random.Range(2f, 6f) + healingWhileCrawling;
			}
			healingWhileCrawling = 0f;
			SetPlayerFlag(PlayerFlags.Wounded, b: false);
			SetPlayerFlag(PlayerFlags.Incapacitated, b: false);
			if ((bool)BaseGameMode.GetActiveGameMode(base.isServer))
			{
				BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);
			}
			Interface.CallHook("OnPlayerRecovered", this);
		}
	}

```

## CanBeAwardedAdventGift(AdventCalendar,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be awarded an Advent gift.
/// </summary>
/// <param name="calendar">The Advent calendar instance.</param>
/// <param name="player">The player being checked for the gift award.</param>
/// <returns>
/// Returns `true` if the player can be awarded the gift, and `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeAwardedAdventGift(AdventCalendar calendar, BasePlayer player)
{
    Puts($"Checking if {player.displayName} can receive today's Advent gift.");
    object result = Interface.CallHook("CanBeAwardedAdventGift", calendar, player);
    if (result is bool)
    {
        return !(bool)result;
    }
    // If a non-bool value is returned, use it to override the default behavior
    return result;
}
```
```

### Source Code from the Library

```csharp

	public bool WasAwardedTodaysGift(BasePlayer player)
	{
		object obj = Interface.CallHook("CanBeAwardedAdventGift", this, player);
		if (obj is bool)
		{
			return !(bool)obj;
		}
		if (!playerRewardHistory.ContainsKey(player.userID))
		{
			return false;
		}
		DateTime now = DateTime.Now;
		if (now.Month != startMonth)
		{
			return true;
		}
		int num = now.Day - startDay;
		if (num < 0 || num >= days.Length)
		{
			return true;
		}
		if (playerRewardHistory[player.userID].Contains(num))
		{
			return true;
		}
		return false;
	}

```

## OnTrapArm(BearTrap,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a bear trap is armed.
/// </summary>
/// <param name="trap">The bear trap being armed.</param>
/// <param name="player">The player who triggered the trap.</param>
/// <returns>
/// Returns `null` to allow the trap to be armed, or any non-null value to prevent it from arming.
/// </returns>
object OnTrapArm(BearTrap trap, BasePlayer player)
{
    Puts($"Bear trap {trap.name} has been armed by player {player.displayName}");
    if (player.IsAdmin())
    {
        Puts($"Player {player.displayName} is an admin and cannot trigger traps.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_Arm(RPCMessage rpc)
	{
		if (!Armed() && Interface.CallHook("OnTrapArm", this, rpc.player) == null)
		{
			Arm();
		}
	}

```

## OnEntityEnter(TriggerComfort,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity enters the trigger comfort zone.
/// </summary>
/// <param name="trigger">The trigger that was entered.</param>
/// <param name="entity">The entity that entered the trigger.</param>
/// <returns>
/// Returns `null` to allow the entity to enter the trigger, or any non-null value to prevent them from entering.
/// </returns>
object OnEntityEnter(TriggerComfort trigger, BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has entered the comfort zone of trigger {trigger.name}");
    if (entity is BasePlayer player && player.IsAdmin)
    {
        Puts($"Admin player {player.displayName} has entered the comfort zone");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnEntityEnter(BaseEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((bool)basePlayer && Interface.CallHook("OnEntityEnter", this, ent) == null)
		{
			_players.Add(basePlayer);
		}
	}

```

## OnStructureDemolish(BuildingBlock,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when a structure is demolished.
/// </summary>
/// <param name="block">The building block being demolished.</param>
/// <param name="player">The player demolishing the structure.</param>
/// <param name="isForced">Whether the demolition was forced or not.</param>
/// <returns>
/// Returns `null` to allow the structure to be demolished, or any non-null value to prevent it from being demolished.
/// </returns>
object OnStructureDemolish(BuildingBlock block, BasePlayer player, bool isForced)
{
    Puts($"Structure {block.BlockName} has been demolished by player {player.UserIDString}.");
    if (isForced && block.IsImportant)
    {
        Puts($"Forced demolition of important structure {block.BlockName} prevented.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoDemolish(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanDemolish(msg.player) && Interface.CallHook("OnStructureDemolish", this, msg.player, false) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnBuildingBlockDemolished(msg.player, this);
			Kill(DestroyMode.Gib);
		}
	}

```

## OnVehicleHornPressed(VehicleModuleSeating,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle's horn is pressed.
/// </summary>
/// <param name="module">The seating module of the vehicle.</param>
/// <param name="player">The player who pressed the horn.</param>
/// <returns>No return behavior.</returns>
void OnVehicleHornPressed(VehicleModuleSeating module, BasePlayer player)
{
    Puts($"Player {player.UserIDString} pressed the horn on vehicle {module.VehicleName}");
}
```
```

### Source Code from the Library

```csharp

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		if (hornLoop != null && IsOnThisModule(player))
		{
			bool flag = inputState.IsDown(BUTTON.FIRE_PRIMARY);
			if (flag != HasFlag(Flags.Reserved8))
			{
				SetFlag(Flags.Reserved8, flag);
			}
			if (flag)
			{
				Interface.CallHook("OnVehicleHornPressed", this, player);
				hornPlayer = player;
			}
		}
	}

```

## OnConnectionQueue(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a connection is added to the queue.
/// </summary>
/// <param name="connection">The connection being queued.</param>
/// <returns>
/// Returns `null` to allow the connection to be queued, or any non-null value to prevent it from queuing.
/// </returns>
object OnConnectionQueue(Network.Connection connection)
{
    Puts($"Connection {connection.ID} has been added to the queue.");
    if (connection.IP == "192.168.1.1")
    {
        Puts($"Connection {connection.ID} with IP {connection.IP} has been blocked from queuing.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal void Join(Connection connection)
	{
		if (Interface.CallHook("OnConnectionQueue", connection) == null)
		{
			connection.state = Connection.State.InQueue;
			queue.Add(connection);
			nextMessageTime = 0f;
			if (CanJumpQueue(connection))
			{
				JoinGame(connection);
			}
		}
	}

```

## OnProjectileRicochet(BasePlayer,ProtoBuf.PlayerProjectileRicochet)

```csharp
```csharp
/// <summary>
/// Called when a projectile ricochets.
/// </summary>
/// <param name="player">The player who fired the projectile.</param>
/// <param name="ricochetData">The data about the ricochet, including the hit position, velocity, and travel time.</param>
/// <returns>
/// Returns `null` to allow the ricochet to be processed normally. 
/// If a non-null value is returned, it will override the default behavior for this ricochet.
/// </returns>
object OnProjectileRicochet(BasePlayer player, ProtoBuf.PlayerProjectileRicochet ricochetData)
{
    Puts($"Projectile {ricochetData.projectileID} has ricocheted off of something.");
    if (ricochetData.hitPosition.IsNaNOrInfinity() || ricochetData.inVelocity.IsNaNOrInfinity() || ricochetData.outVelocity.IsNaNOrInfinity() || ricochetData.hitNormal.IsNaNOrInfinity() || float.IsNaN(ricochetData.travelTime) || float.IsInfinity(ricochetData.travelTime))
    {
        AntiHack.Log(player, AntiHackType.ProjectileHack, "Contains NaN (" + ricochetData.projectileID + ")");
        return null;
    }
    else if (!firedProjectiles.TryGetValue(ricochetData.projectileID, out _))
    {
        AntiHack.Log(player, AntiHackType.ProjectileHack, "Missing ID (" + ricochetData.projectileID + ")");
        return null;
    }
    else if (UnityEngine.Time.realtimeSinceStartup - 8f < 0)
    {
        AntiHack.Log(player, AntiHackType.ProjectileHack, "Lifetime is zero (" + ricochetData.projectileID + ")");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	public void OnProjectileRicochet(RPCMessage msg)
	{
		PlayerProjectileRicochet playerProjectileRicochet = PlayerProjectileRicochet.Deserialize(msg.read);
		if (playerProjectileRicochet != null)
		{
			FiredProjectile value;
			if (playerProjectileRicochet.hitPosition.IsNaNOrInfinity() || playerProjectileRicochet.inVelocity.IsNaNOrInfinity() || playerProjectileRicochet.outVelocity.IsNaNOrInfinity() || playerProjectileRicochet.hitNormal.IsNaNOrInfinity() || float.IsNaN(playerProjectileRicochet.travelTime) || float.IsInfinity(playerProjectileRicochet.travelTime))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Contains NaN (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (!firedProjectiles.TryGetValue(playerProjectileRicochet.projectileID, out value))
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Missing ID (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (value.firedTime < UnityEngine.Time.realtimeSinceStartup - 8f)
			{
				AntiHack.Log(this, AntiHackType.ProjectileHack, "Lifetime is zero (" + playerProjectileRicochet.projectileID + ")");
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
			else if (Interface.CallHook("OnProjectileRicochet", this, playerProjectileRicochet) == null)
			{
				value.ricochets++;
				firedProjectiles[playerProjectileRicochet.projectileID] = value;
				playerProjectileRicochet.ResetToPool();
				playerProjectileRicochet = null;
			}
		}
	}

```

## OnEntityPickedUp(BaseCombatEntity,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an entity is picked up by a player.
/// </summary>
/// <param name="entity">The entity that was picked up.</param>
/// <param name="item">The item that the entity was converted into.</param>
/// <param name="player">The player who picked up the entity.</param>
/// <returns>No return behavior.</returns>
void OnEntityPickedUp(BaseCombatEntity entity, Item item, BasePlayer player)
{
    Puts($"Entity {entity.ShortName} was picked up by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnPickedUp(Item createdItem, BasePlayer player)
	{
		Interface.CallHook("OnEntityPickedUp", this, createdItem, player);
	}

```

## OnNpcConversationResponded(NPCTalking,BasePlayer,ConversationData,ConversationData.ResponseNode)

```csharp
```csharp
/// <summary>
/// Called when an NPC's conversation responds to a player.
/// </summary>
/// <param name="npc">The NPC initiating the conversation.</param>
/// <param name="player">The player responding to the conversation.</param>
/// <param name="conversationData">The data for the ongoing conversation.</param>
/// <param name="responseNode">The node representing the player's response.</param>
/// <returns>
/// Returns `null` if the default behavior should be executed, or a non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for ending the conversation.
/// </returns>
object OnNpcConversationResponded(NPCTalking npc, BasePlayer player, ConversationData conversationData, ConversationData.ResponseNode responseNode)
{
    Puts($"NPC {npc.name} has responded to player {player.displayName}'s conversation.");
    if (responseNode.conditions.Length != 0 && !responseNode.PassesConditions(player, this))
    {
        Puts($"Player {player.displayName} failed the condition for NPC {npc.name}'s response.");
        return "Failed: Condition not met.";
    }
    Interface.CallHook("OnNpcConversationResponded", this, player, conversationData, responseNode);
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(5uL)]
	public void Server_ResponsePressed(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		int num2 = msg.read.Int32();
		ConversationData conversationFor = GetConversationFor(player);
		if (conversationFor == null)
		{
			return;
		}
		ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];
		if (responseNode != null && Interface.CallHook("OnNpcConversationRespond", this, player, conversationFor, responseNode) == null)
		{
			if (responseNode.conditions.Length != 0)
			{
				UpdateFlags();
			}
			bool flag = responseNode.PassesConditions(player, this);
			if (flag && !string.IsNullOrEmpty(responseNode.actionString))
			{
				OnConversationAction(player, responseNode.actionString);
			}
			int speechNodeIndex = conversationFor.GetSpeechNodeIndex(flag ? responseNode.resultingSpeechNode : responseNode.GetFailedSpeechNode(player, this));
			if (speechNodeIndex == -1)
			{
				ForceEndConversation(player);
				return;
			}
			ForceSpeechNode(player, speechNodeIndex);
			Interface.CallHook("OnNpcConversationResponded", this, player, conversationFor, responseNode);
		}
	}

```

## OnWorldProjectileCreate(HitInfo,Item)

```csharp
```csharp
/// <summary>
/// Called when a world projectile is created.
/// </summary>
/// <param name="hitInfo">The hit info of the projectile.</param>
/// <param name="item">The item that was used to create the projectile.</param>
/// <returns>
/// Returns a non-null value to override the default projectile creation behavior. 
/// If `null` is returned, the projectile will be created as normal.
/// </returns>
object OnWorldProjectileCreate(HitInfo hitInfo, Item item)
{
    Puts($"A world projectile has been created at position {hitInfo.HitPositionWorld} with velocity {hitInfo.ProjectileVelocity}.");
    if (item.GetDefinition().GetProjectileType() == ProjectileType.Explosive && hitInfo.DidHit)
    {
        Puts($"The projectile is an explosive type and will detonate on impact.");
        return "Detonated: Explosive projectile.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			return;
		}
		baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		component.AddForce(projectileVelocity.normalized * 200f);
		component.WakeUp();
	}

```

## OnCrateLanded(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a hackable locked crate lands.
/// </summary>
/// <param name="crate">The landed crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateLanded(HackableLockedCrate crate)
{
    Puts($"Hackable locked crate landed at position {crate.transform.position}");
}
```
```

### Source Code from the Library

```csharp

	public void LandCheck()
	{
		RaycastHit hitInfo;
		if (hasLanded)
		{
			Interface.CallHook("OnCrateLanded", this);
		}
		else if (UnityEngine.Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out hitInfo, 1f, 1218511105))
		{
			Effect.server.Run(landEffect.resourcePath, hitInfo.point, Vector3.up);
			hasLanded = true;
			CancelInvoke(LandCheck);
		}
	}

```

## OnExplosiveFuseSet(TimedExplosive,float)

```csharp
```csharp
/// <summary>
/// Called when an explosive fuse is set.
/// </summary>
/// <param name="explosive">The explosive device.</param>
/// <param name="fuseLength">The length of the fuse in seconds.</param>
/// <returns>
/// Returns a non-null value to override the default fuse length. If `null` is returned, the original fuse length will be used.
/// </returns>
object OnExplosiveFuseSet(TimedExplosive explosive, float fuseLength)
{
    Puts($"Explosive fuse set for {explosive.Name} with a fuse length of {fuseLength} seconds.");
    if (fuseLength < 0.5f)
    {
        Puts($"Warning: Fuse length is too short for {explosive.Name}.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			object obj = Interface.CallHook("OnExplosiveFuseSet", this, fuseLength);
			if (obj is float)
			{
				fuseLength = (float)obj;
			}
			Invoke(Explode, fuseLength);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

```

## CanEquipItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether an item can be equipped into a specific slot.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The item to equip.</param>
/// <param name="slot">The target equipment slot.</param>
/// <returns>
/// Returns `true` if the item can be equipped, or `false` otherwise.
/// If a non-boolean value is returned, it will override the default behavior.
/// </returns>
bool CanEquipItem(PlayerInventory inventory, Item item, int slot)
{
    object result = Interface.CallHook("CanEquipItem", inventory, item, slot);
    if (result is bool)
    {
        return (bool)result;
    }
    // Default implementation
    ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
    if (component == null || !component.CanExistInSlot(slot))
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanEquipItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanEquipItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ItemModContainerRestriction component = item.info.GetComponent<ItemModContainerRestriction>();
		if (component == null)
		{
			return true;
		}
		Item[] array = containerBelt.itemList.ToArray();
		foreach (Item item2 in array)
		{
			if (item2 != item)
			{
				ItemModContainerRestriction component2 = item2.info.GetComponent<ItemModContainerRestriction>();
				if (!(component2 == null) && !component.CanExistWith(component2) && !item2.MoveToContainer(containerMain))
				{
					item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity());
				}
			}
		}
		return true;
	}

```

## CanLootEntity(BasePlayer,ResourceContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can loot an entity.
/// </summary>
/// <param name="player">The player attempting to loot the entity.</param>
/// <param name="entity">The entity being looted.</param>
/// <returns>
/// Returns `null` to allow the player to loot the entity, or any non-null value to prevent them from looting.
/// </returns>
object CanLootEntity(BasePlayer player, BaseEntity entity)
{
    Puts($"Player {player.UserIDString} is attempting to loot entity {entity.EntityID}");
    if (entity.IsLocked)
    {
        Puts($"Entity {entity.EntityID} is locked and cannot be looted.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.IsVisible(3f)]
	private void StartLootingContainer(BaseEntity.RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((bool)player && player.CanInteract() && lootable && Interface.CallHook("CanLootEntity", player, this) == null && player.inventory.loot.StartLootingEntity(base.baseEntity))
		{
			lastAccessTime = UnityEngine.Time.realtimeSinceStartup;
			player.inventory.loot.AddContainer(container);
		}
	}

```

## InitLogging()

```csharp
```csharp
/// <summary>
/// Called to initialize logging.
/// </summary>
void InitLogging()
{
    Puts("Initializing logging...");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	private void StartupShared()
	{
		Interface.CallHook("InitLogging");
		ItemManager.Initialize();
	}

```

## OnPlayerColliderEnable(BasePlayer,UnityEngine.CapsuleCollider)

```csharp
```csharp
/// <summary>
/// Called when a player's collider is enabled.
/// </summary>
/// <param name="player">The player whose collider is being enabled.</param>
/// <param name="collider">The capsule collider of the player.</param>
/// <returns>
/// Returns `null` to allow the collider to be enabled, or any non-null value to prevent it from being enabled.
/// </returns>
object OnPlayerColliderEnable(BasePlayer player, UnityEngine.CapsuleCollider collider)
{
    Puts($"Player {player.UserIDString}'s collider has been enabled.");
    if (collider == null)
    {
        Puts($"Player {player.UserIDString} does not have a valid collider.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void EnablePlayerCollider()
	{
		if (!playerCollider.enabled && Interface.CallHook("OnPlayerColliderEnable", this, playerCollider) == null)
		{
			RefreshColliderSize(forced: true);
			playerCollider.enabled = true;
		}
	}

```

## OnNpcAttack(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC starts attacking.
/// </summary>
/// <param name="npc">The NPC performing the attack.</param>
/// <param name="target">The entity being attacked.</param>
/// <returns>
/// Returns `null` to allow the NPC to perform the attack, or any non-null value to prevent them from attacking.
/// </returns>
object OnNpcAttack(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} is attacking {target.displayName}");
    if (target == null || target.IsDead)
    {
        Puts($"Target {target.displayName} is dead or invalid.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartAttack()
	{
		if ((bool)AttackTarget && AttackReady() && Interface.CallHook("OnNpcAttack", this, AttackTarget) == null && !((AttackTarget.ServerPosition - ServerPosition).magnitude > AttackRange))
		{
			nextAttackTime = UnityEngine.Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if ((bool)combatTarget)
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(null, "Attack", AttackTarget.ServerPosition);
			}
		}
	}

```

## OnClientAuth(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client authenticates with the server.
/// </summary>
/// <param name="connection">The client connection.</param>
/// <returns>
/// Returns `null` to allow the client to authenticate normally, or any non-null value to override the default authentication behavior.
/// If a string is returned, the client will be kicked with the provided message as the reason.
/// </returns>
object OnClientAuth(Network.Connection connection)
{
    Puts($"Client {connection} has authenticated with the server.");
    if (connection.protocol > 2388)
    {
        Puts($"Client {connection} has an outdated protocol version. Kicking...");
        return "Wrong Connection Protocol: Server update required!";
    }
    else
    {
        connection.token = connection.read.BytesWithSize(512u);
        if (connection.token == null || connection.token.Length < 1)
        {
            Network.Net.sv.Kick(connection, "Invalid Token");
        }
        else
        {
            auth.OnNewConnection(connection);
        }
    }
}
```
```

### Source Code from the Library

```csharp

	private void OnGiveUserInformation(Message packet)
	{
		if (packet.connection.state != 0)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid connection state");
			return;
		}
		packet.connection.state = Network.Connection.State.Connecting;
		if (packet.read.UInt8() != 228)
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Connection Protocol");
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String(128);
		packet.connection.username = packet.read.String();
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Network.Net.sv.Kick(packet.connection, "Invalid Username");
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.Unread >= 4)
		{
			text = packet.read.String(128);
		}
		Interface.CallHook("OnClientAuth", packet.connection);
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their branch is '", text, "' not '", branch, "'"));
			Network.Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!");
		}
		else if (packet.connection.protocol > 2388)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2388));
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!");
		}
		else if (packet.connection.protocol < 2388)
		{
			DebugEx.Log(string.Concat("Kicking ", packet.connection, " - their protocol is ", packet.connection.protocol, " not ", 2388));
			Network.Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!");
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize(512u);
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Network.Net.sv.Kick(packet.connection, "Invalid Token");
			}
			else
			{
				auth.OnNewConnection(packet.connection);
			}
		}
	}

```

## OnInventoryItemsFind(PlayerInventory,int)

```csharp
```csharp
/// <summary>
/// Called when inventory items are being searched for.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="id">The ID of the item to search for.</param>
/// <returns>
/// Returns a list of items that match the provided ID. If no items are found, returns an empty list.
/// If `null` is returned, the default behavior will be used (i.e., searching through all containers).
/// </returns>
List<Item> OnInventoryItemsFind(PlayerInventory inventory, int id)
{
    Puts($"Searching for item with ID {id} in player's inventory.");
    if (inventory.GetItemCount(id) > 0)
    {
        return new List<Item> { inventory.GetItemByItemID(id) };
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public List<Item> FindItemIDs(int id)
	{
		object obj = Interface.CallHook("OnInventoryItemsFind", this, id);
		if (obj is List<Item>)
		{
			return (List<Item>)obj;
		}
		List<Item> list = new List<Item>();
		if (containerMain != null)
		{
			list.AddRange(containerMain.FindItemsByItemID(id));
		}
		if (containerBelt != null)
		{
			list.AddRange(containerBelt.FindItemsByItemID(id));
		}
		if (containerWear != null)
		{
			list.AddRange(containerWear.FindItemsByItemID(id));
		}
		return list;
	}

```

## OnNpcConversationEnded(NPCTalking,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an NPC conversation with a player ends.
/// </summary>
/// <param name="npc">The NPC that ended the conversation.</param>
/// <param name="player">The player who was in the conversation.</param>
/// <returns>No return behavior.</returns>
void OnNpcConversationEnded(NPCTalking npc, BasePlayer player)
{
    Puts($"NPC {npc.name} ended conversation with player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	public void ForceEndConversation(BasePlayer player)
	{
		ClientRPCPlayer(null, player, "Client_EndConversation");
		Interface.CallHook("OnNpcConversationEnded", this, player);
	}

```

## OnResourceDepositCreated(ResourceDepositManager.ResourceDeposit)

```csharp
```csharp
/// <summary>
/// Called when a new resource deposit is created.
/// </summary>
/// <param name="resourceDeposit">The newly created resource deposit.</param>
void OnResourceDepositCreated(ResourceDeposit resourceDeposit)
{
    Puts($"New resource deposit created at position {resourceDeposit.origin}.");
    if (resourceDeposit.Contains(ItemManager.FindItemDefinition("hq.metal.ore")))
    {
        Puts($"This resource deposit contains HQ metal ore, which is a rare and valuable resource.");
    }
    else
    {
        Puts($"This resource deposit does not contain any HQ metal ore.");
    }
    Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
}
```
```

### Source Code from the Library

```csharp

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		Vector2i indexFrom = GetIndexFrom(pos);
		UnityEngine.Random.State state = UnityEngine.Random.state;
		UnityEngine.Random.InitState((int)new Vector2(indexFrom.x, indexFrom.y).Seed(World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3(indexFrom.x * 20, 0f, indexFrom.y * 20)
		};
		if (UnityEngine.Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else if (0 == 0)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, UnityEngine.Random.Range(30000, 100000), UnityEngine.Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
			float num = 0f;
			num = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num2 = 0f;
			num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num2)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, UnityEngine.Random.Range(10000, 100000), UnityEngine.Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
			}
			float num3 = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
				{
					num3 += 0.25f;
				}
			}
			else
			{
				num3 += 0.15f;
			}
			if (UnityEngine.Random.Range(0f, 1f) >= 1f - num3)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", resourceDeposit);
		UnityEngine.Random.state = state;
		return resourceDeposit;
	}

```

## OnItemRepair(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an item is repaired.
/// </summary>
/// <param name="player">The player who performed the repair.</param>
/// <param name="itemToRepair">The item being repaired.</param>
/// <returns>
/// Returns a non-null value to override the default repair behavior. 
/// If `null` is returned, the item is repaired as normal.
/// </returns>
object OnItemRepair(BasePlayer player, Item itemToRepair)
{
    Puts($"Item {itemToRepair.info.shortname} has been repaired by player {player.displayName}.");
    if (itemToRepair.info.category == "Component" && itemToRepair.conditionNormalized > 0.5f)
    {
        Puts($"Item {itemToRepair.info.shortname} is already in good condition and does not need repair.");
        return "Already in good condition.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void RepairAnItem(Item itemToRepair, BasePlayer player, BaseEntity repairBenchEntity, float maxConditionLostOnRepair, bool mustKnowBlueprint)
	{
		if (itemToRepair == null)
		{
			return;
		}
		ItemDefinition info = itemToRepair.info;
		ItemBlueprint component = info.GetComponent<ItemBlueprint>();
		if (!component || !info.condition.repairable || itemToRepair.condition == itemToRepair.maxCondition)
		{
			return;
		}
		if (mustKnowBlueprint)
		{
			ItemDefinition itemDefinition = ((info.isRedirectOf != null) ? info.isRedirectOf : info);
			if (!player.blueprints.HasUnlocked(itemDefinition) && (!(itemDefinition.Blueprint != null) || itemDefinition.Blueprint.isResearchable))
			{
				return;
			}
		}
		if (Interface.CallHook("OnItemRepair", player, itemToRepair) != null)
		{
			return;
		}
		float num = RepairCostFraction(itemToRepair);
		bool flag = false;
		List<ItemAmount> obj = Facepunch.Pool.GetList<ItemAmount>();
		GetRepairCostList(component, obj);
		foreach (ItemAmount item in obj)
		{
			if (item.itemDef.category != ItemCategory.Component)
			{
				int amount = player.inventory.GetAmount(item.itemDef.itemid);
				if (Mathf.CeilToInt(item.amount * num) > amount)
				{
					flag = true;
					break;
				}
			}
		}
		if (flag)
		{
			Facepunch.Pool.FreeList(ref obj);
			return;
		}
		foreach (ItemAmount item2 in obj)
		{
			if (item2.itemDef.category != ItemCategory.Component)
			{
				int amount2 = Mathf.CeilToInt(item2.amount * num);
				player.inventory.Take(null, item2.itemid, amount2);
				Facepunch.Rust.Analytics.Azure.LogResource(Facepunch.Rust.Analytics.Azure.ResourceMode.Consumed, "repair", item2.itemDef.shortname, amount2, repairBenchEntity, null, safezone: false, null, 0uL, null, itemToRepair);
			}
		}
		Facepunch.Pool.FreeList(ref obj);
		float conditionNormalized = itemToRepair.conditionNormalized;
		float maxConditionNormalized = itemToRepair.maxConditionNormalized;
		itemToRepair.DoRepair(maxConditionLostOnRepair);
		Facepunch.Rust.Analytics.Azure.OnItemRepaired(player, repairBenchEntity, itemToRepair, conditionNormalized, maxConditionNormalized);
		if (Global.developer > 0)
		{
			Debug.Log("Item repaired! condition : " + itemToRepair.condition + "/" + itemToRepair.maxCondition);
		}
		Effect.server.Run("assets/bundled/prefabs/fx/repairbench/itemrepair.prefab", repairBenchEntity, 0u, Vector3.zero, Vector3.zero);
	}

```

## OnBookmarkControlStarted(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a bookmark control is started.
/// </summary>
/// <param name="player">The player starting the bookmark control.</param>
/// <param name="identifier">The identifier of the remote controllable entity being controlled.</param>
/// <param name="remoteControllable">The remote controllable entity being controlled.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the bookmark control will be started as normal.
/// </returns>
object OnBookmarkControlStarted(BasePlayer player, string identifier, IRemoteControllable remoteControllable)
{
    Puts($"Player {player.UserIDString} has started controlling bookmark {identifier}.");
    if (remoteControllable == null || !remoteControllable.CanControl(player.userID))
    {
        Puts($"Player {player.UserIDString} does not have permission to control bookmark {identifier}.");
        return "Unauthorized: Player does not have permission.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## OnPlayerWound(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player is wounded.
/// </summary>
/// <param name="player">The player who was wounded.</param>
/// <param name="info">Information about the hit that caused the wound, including damage type and location.</param>
/// <returns>
/// Returns `null` to allow the player to become wounded normally. 
/// If a non-null value is returned, it will override the default behavior for this player.
/// </returns>
object OnPlayerWound(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} has been wounded.");
    if (info.damageTypes.GetMajorityDamageType() == DamageType.Fall && !player.IsCrawling())
    {
        Puts($"Player {player.displayName} was wounded by fall damage while standing.");
        return "Fall damage warning: Player is not crawling.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void BecomeWounded(HitInfo info = null)
	{
		if (IsWounded() || Interface.CallHook("OnPlayerWound", this, info) != null)
		{
			return;
		}
		bool flag = info != null && info.damageTypes.GetMajorityDamageType() == DamageType.Fall;
		if (IsCrawling())
		{
			woundedByFallDamage |= flag;
			GoToIncapacitated(info);
			return;
		}
		woundedByFallDamage = flag;
		if (flag || !ConVar.Server.crawlingenabled)
		{
			GoToIncapacitated(info);
		}
		else
		{
			GoToCrawling(info);
		}
	}

```

## CanWearItem(PlayerInventory,Item,int)

```csharp
```csharp
/// <summary>
/// Determines whether a player can wear an item.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="item">The item to be worn.</param>
/// <param name="targetSlot">The slot where the item will be worn.</param>
/// <returns>
/// Returns `true` if the player can wear the item, and `false` otherwise.
/// </returns>
bool CanWearItem(PlayerInventory inventory, Item item, int targetSlot)
{
    Puts($"Checking if player can wear {item.name} in slot {targetSlot}");
    object obj = Interface.CallHook("CanWearItem", this, item, targetSlot);
    if (obj is bool)
    {
        return (bool)obj;
    }
    // If the hook returns null or a non-boolean value, default to not allowing the item to be worn
    return false;
}
```
```

### Source Code from the Library

```csharp

	private bool CanWearItem(Item item, int targetSlot)
	{
		object obj = Interface.CallHook("CanWearItem", this, item, targetSlot);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return CanWearItem(item, canAdjustClothing: true);
	}

```

## CanDropActiveItem(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if the player's active item should be dropped.
/// </summary>
/// <param name="player">The player whose active item is being considered for drop.</param>
/// <returns>
/// Returns `true` to allow the player's active item to be dropped, or `false` to prevent it from being dropped.
/// If a non-bool value is returned, the default behavior will be used (i.e., the item will be dropped).
/// </returns>
bool CanDropActiveItem(BasePlayer player)
{
    Puts($"Checking if {player.UserIDString}'s active item should be dropped.");
    // For example, let's say we want to prevent players from dropping their active items in a specific area
    if (player.transform.position.x < -1000 && player.transform.position.z < -1000)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool ShouldDropActiveItem()
	{
		object obj = Interface.CallHook("CanDropActiveItem", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnBookmarkAdd(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a bookmark is added.
/// </summary>
/// <param name="station">The computer station where the bookmark was added.</param>
/// <param name="player">The player who added the bookmark.</param>
/// <param name="bookmarkName">The name of the bookmark being added.</param>
/// <returns>
/// Returns `null` to allow the bookmark to be added, or any non-null value to prevent it from being added.
/// </returns>
object OnBookmarkAdd(ComputerStation station, BasePlayer player, string bookmarkName)
{
    Puts($"Player {player.UserIDString} added a new bookmark: {bookmarkName}");
    if (bookmarkName == "admin-only")
    {
        Puts($"Player {player.displayName} tried to add an admin-only bookmark.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void AddBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player) || isStatic)
		{
			return;
		}
		if (UnityEngine.Time.realtimeSinceStartup < nextAddTime)
		{
			player.ChatMessage("Slow down...");
			return;
		}
		if (controlBookmarks.Count >= 128)
		{
			player.ChatMessage("Too many bookmarks, delete some");
			return;
		}
		nextAddTime = UnityEngine.Time.realtimeSinceStartup + 1f;
		string text = msg.read.String();
		if (Interface.CallHook("OnBookmarkAdd", this, player, text) == null)
		{
			ForceAddBookmark(text);
			SendControlBookmarks(player);
		}
	}

```

## OnVendingShopRename(VendingMachine,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vending shop's name is updated.
/// </summary>
/// <param name="vendingMachine">The vending machine being renamed.</param>
/// <param name="newName">The new name of the vending shop.</param>
/// <param name="player">The player who performed the rename action.</param>
/// <returns>
/// Returns `null` to allow the rename, or any non-null value to prevent the rename.
/// </returns>
object OnVendingShopRename(VendingMachine vendingMachine, string newName, BasePlayer player)
{
    Puts($"Vending shop {vendingMachine.name} renamed by {player.displayName} to {newName}");
    if (newName == "Admin Shop")
    {
        Puts($"Vending shop {vendingMachine.name} cannot be renamed to Admin Shop");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_UpdateShopName(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		string obj = msg.read.String(32);
		if (CanPlayerAdmin(player) && Interface.CallHook("OnVendingShopRename", this, obj, player) == null)
		{
			shopName = obj;
			UpdateMapMarker();
		}
	}

```

## OnSignUpdated(PhotoFrame,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sign is updated.
/// </summary>
/// <param name="sign">The PhotoFrame representing the updated sign.</param>
/// <param name="player">The player who updated the sign.</param>
/// <returns>No return behavior.</returns>
void OnSignUpdated(PhotoFrame sign, BasePlayer player)
{
    Puts($"Sign at {sign.GetPosition()} has been updated by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(5f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void UpdateSign(RPCMessage msg)
	{
		if (!(msg.player == null) && CanUpdateSign(msg.player))
		{
			byte[] array = msg.read.BytesWithSize();
			if (array != null && ImageProcessing.IsValidPNG(array, 1024, 1024))
			{
				FileStorage.server.RemoveAllByEntity(net.ID);
				_overlayTextureCrc = FileStorage.server.Store(array, FileStorage.Type.png, net.ID);
				LogEdit(msg.player);
				SendNetworkUpdate();
				Interface.CallHook("OnSignUpdated", this, msg.player);
			}
		}
	}

```

## OnPhoneCallStart(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone call starts.
/// </summary>
/// <param name="caller">The player making the call.</param>
/// <param name="receiver">The player receiving the call.</param>
/// <param name="player">The current player, if applicable.</param>
/// <returns>
/// Returns `null` to allow the phone call to start normally. 
/// If a non-null value is returned, it will override the default behavior and prevent the call from starting.
/// </returns>
object OnPhoneCallStart(PhoneController caller, PhoneController receiver, BasePlayer player)
{
    Puts($"Phone call started between {caller.UserIDString} and {receiver.UserIDString}");
    if (player != null && player.IsBusy)
    {
        Puts($"Player {player.UserIDString} is currently busy and cannot receive calls.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void BeginCall()
	{
		if (Interface.CallHook("OnPhoneCallStart", this, activeCallTo, currentPlayer) == null)
		{
			if (IsMobile && activeCallTo != null && !activeCallTo.RequirePower)
			{
				_ = currentPlayer != null;
			}
			SetPhoneStateWithPlayer(Telephone.CallState.InProcess);
			Invoke(TimeOutCall, TelephoneManager.MaxCallLength);
			Interface.CallHook("OnPhoneCallStarted", this, activeCallTo, currentPlayer);
		}
	}

```

## CanBradleyApcTarget(BradleyAPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if the Bradley APC can target a given entity.
/// </summary>
/// <param name="bradleyAPC">The Bradley APC instance.</param>
/// <param name="entity">The entity to check for targeting.</param>
/// <returns>
/// Returns `true` if the Bradley APC can target the entity, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanBradleyApcTarget(BradleyAPC bradleyAPC, BaseEntity entity)
{
    Puts($"Checking if Bradley APC can target {entity}.");
    bool flag = VisibilityTest(entity);
    object obj = Interface.CallHook("CanBradleyApcTarget", bradleyAPC, entity);
    if (obj is bool)
    {
        return (bool)obj;
    }
    return flag;
}
```
```

### Source Code from the Library

```csharp

	public bool VisibilityTest(BaseEntity ent)
	{
		if (ent == null)
		{
			return false;
		}
		if (!(Vector3.Distance(ent.transform.position, base.transform.position) < viewDistance))
		{
			return false;
		}
		bool flag = false;
		if (ent is BasePlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			Vector3 position = mainTurret.transform.position;
			flag = IsVisible(basePlayer.eyes.position, position) || IsVisible(basePlayer.transform.position + Vector3.up * 0.1f, position);
			if (!flag && basePlayer.isMounted && basePlayer.GetMounted().VehicleParent() != null && basePlayer.GetMounted().VehicleParent().AlwaysAllowBradleyTargeting)
			{
				flag = IsVisible(basePlayer.GetMounted().VehicleParent().bounds.center, position);
			}
			if (flag)
			{
				flag = !UnityEngine.Physics.SphereCast(new Ray(position, Vector3Ex.Direction(basePlayer.eyes.position, position)), 0.05f, Vector3.Distance(basePlayer.eyes.position, position), 10551297);
			}
		}
		else
		{
			Debug.LogWarning("Standard vis test!");
			flag = IsVisible(ent.CenterPoint());
		}
		object obj = Interface.CallHook("CanBradleyApcTarget", this, ent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return flag;
	}

```

## CanDesignFirework(BasePlayer,PatternFirework)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can design a firework.
/// </summary>
/// <param name="player">The player attempting to design the firework.</param>
/// <param name="firework">The firework being designed.</param>
/// <returns>
/// Returns `true` if the player is allowed to design the firework, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanDesignFirework(BasePlayer player, PatternFirework firework)
{
    Puts($"Player {player.UserIDString} is attempting to design a firework.");
    if (firework.Pattern == "Restricted")
    {
        Puts($"Player {player.displayName} does not have permission to design the restricted firework pattern.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	private bool PlayerCanModify(BasePlayer player)
	{
		if (player == null || !player.CanInteract())
		{
			return false;
		}
		object obj = Interface.CallHook("CanDesignFirework", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
		if (buildingPrivilege != null && !buildingPrivilege.CanAdministrate(player))
		{
			return false;
		}
		return true;
	}

```

## OnDispenserGather(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser gathers an item.
/// </summary>
/// <param name="dispenser">The dispenser that gathered the item.</param>
/// <param name="player">The player who used the dispenser.</param>
/// <param name="item">The item gathered by the dispenser.</param>
/// <returns>
/// Returns `null` to allow the dispenser to gather the item as normal, or any non-null value to override the default behavior.
/// </returns>
object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Dispenser {dispenser} gathered item {item.info.shortname} for player {player}.");
    if (item.info.shortname == "Resource")
    {
        Puts($"Dispenser {dispenser} gathered resource for player {player}.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float f = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		f = Mathf.Round(f);
		float num3 = f * destroyFraction * 2f;
		if (itemAmt.amount <= f + num3)
		{
			float num4 = (f + num3) / itemAmt.amount;
			f /= num4;
			num3 /= num4;
		}
		itemAmt.amount -= Mathf.Floor(f);
		itemAmt.amount -= Mathf.Floor(num3);
		if (f < 1f)
		{
			f = ((UnityEngine.Random.Range(0f, 1f) <= f) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (f >= 1f)
		{
			int num5 = CalculateGatherBonus(entity, itemAmt, f);
			int iAmount = Mathf.FloorToInt(f) + num5;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (Interface.CallHook("OnDispenserGather", this, entity, item) == null && item != null)
			{
				OverrideOwnership(item, attackWeapon);
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnElevatorMove(Elevator,int)

```csharp
```csharp
/// <summary>
/// Called when an elevator is moving.
/// </summary>
/// <param name="elevator">The elevator that is moving.</param>
/// <param name="targetFloor">The target floor of the elevator's movement.</param>
/// <returns>
/// Returns `null` to allow the elevator to move normally, or any non-null value to prevent it from moving.
/// </returns>
object OnElevatorMove(Elevator elevator, int targetFloor)
{
    Puts($"Elevator {elevator.name} is moving to floor {targetFloor}.");
    if (targetFloor == 13)
    {
        Puts($"Elevator {elevator.name} has been blocked from reaching floor {targetFloor}.");
        return "Blocked: Unauthorized access.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, Elevator fromElevator)
	{
		timeToTravel = 0f;
		if (Interface.CallHook("OnElevatorMove", this, targetFloor) != null)
		{
			return false;
		}
		if (IsBusy())
		{
			return false;
		}
		if (!IsStatic && ioEntity != null && !ioEntity.IsPowered())
		{
			return false;
		}
		if (!IsValidFloor(targetFloor))
		{
			return false;
		}
		if (!liftEntity.CanMove())
		{
			return false;
		}
		int num = LiftPositionToFloor();
		if (num == targetFloor)
		{
			OpenLiftDoors();
			OpenDoorsAtFloor(num);
			fromElevator.OpenLiftDoors();
			return false;
		}
		Vector3 worldSpaceFloorPosition = GetWorldSpaceFloorPosition(targetFloor);
		if (!GamePhysics.LineOfSight(liftEntity.transform.position, worldSpaceFloorPosition, 2097152))
		{
			return false;
		}
		OnMoveBegin();
		Vector3 vector = base.transform.InverseTransformPoint(worldSpaceFloorPosition);
		timeToTravel = TimeToTravelDistance(Mathf.Abs(liftEntity.transform.localPosition.y - vector.y));
		LeanTween.moveLocalY(liftEntity.gameObject, vector.y, timeToTravel).delay = LiftMoveDelay;
		timeToTravel += LiftMoveDelay;
		SetFlag(Flags.Busy, b: true);
		if (targetFloor < Floor)
		{
			liftEntity.ToggleHurtTrigger(state: true);
		}
		Invoke(ClearBusy, timeToTravel + 1f);
		liftEntity.NotifyNewFloor(targetFloor, Floor);
		if (ioEntity != null)
		{
			ioEntity.SetFlag(Flags.Busy, b: true);
			ioEntity.SendChangedToRoot(forceUpdate: true);
		}
		return true;
	}

```

## OnEngineStatsRefreshed(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called when the engine performance stats are refreshed.
/// </summary>
/// <param name="engine">The engine module.</param>
/// <param name="storage">The engine storage data.</param>
/// <returns>
/// Returns a non-null value to override the default refresh behavior. 
/// If `null` is returned, the engine performance stats will be refreshed as normal.
/// </returns>
object OnEngineStatsRefreshed(VehicleModuleEngine engine, Rust.Modular.EngineStorage storage)
{
    Puts($"Engine {engine.GetDisplayName()} has been refreshed.");
    if (storage == null || !storage.isUsable)
    {
        Puts($"Engine {engine.GetDisplayName()} is not usable.");
        return true;
    }
    else
    {
        Puts($"Engine {engine.GetDisplayName()} is now usable.");
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## OnRespawnInformationGiven(BasePlayer,ProtoBuf.RespawnInformation)

```csharp
```csharp
/// <summary>
/// Called when respawn information is given to a player.
/// </summary>
/// <param name="player">The player receiving the respawn information.</param>
/// <param name="respawnInfo">The respawn information being sent.</param>
object OnRespawnInformationGiven(BasePlayer player, RespawnInformation respawnInfo)
{
    Puts($"Sending respawn information to {player.UserIDString}.");
    if (respawnInfo.spawnOptions.Count == 0)
    {
        Puts($"No spawn options available for {player.UserIDString}.");
        return null;
    }
    foreach (RespawnInformation.SpawnOptions option in respawnInfo.spawnOptions)
    {
        Puts($"Spawn option: {option.name}, ID: {option.id}, Type: {option.type}, Unlock Time: {option.unlockSeconds} seconds, Occupied: {option.occupied}");
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendRespawnOptions()
	{
		using RespawnInformation respawnInformation = Facepunch.Pool.Get<RespawnInformation>();
		respawnInformation.spawnOptions = Facepunch.Pool.Get<List<RespawnInformation.SpawnOptions>>();
		SleepingBag[] array = SleepingBag.FindForPlayer(userID, ignoreTimers: true);
		foreach (SleepingBag sleepingBag in array)
		{
			RespawnInformation.SpawnOptions spawnOptions = Facepunch.Pool.Get<RespawnInformation.SpawnOptions>();
			spawnOptions.id = sleepingBag.net.ID;
			spawnOptions.name = sleepingBag.niceName;
			spawnOptions.worldPosition = sleepingBag.transform.position;
			spawnOptions.type = sleepingBag.RespawnType;
			spawnOptions.unlockSeconds = sleepingBag.GetUnlockSeconds(userID);
			spawnOptions.occupied = sleepingBag.IsOccupied();
			respawnInformation.spawnOptions.Add(spawnOptions);
		}
		respawnInformation.previousLife = previousLifeStory;
		respawnInformation.fadeIn = previousLifeStory != null && previousLifeStory.timeDied > Epoch.Current - 5;
		Interface.CallHook("OnRespawnInformationGiven", this, respawnInformation);
		ClientRPCPlayer(null, this, "OnRespawnInformation", respawnInformation);
	}

```

## OnPlayerVoice(BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a player sends voice data.
/// </summary>
/// <param name="player">The player sending the voice data.</param>
/// <param name="data">The voice data sent by the player.</param>
/// <returns>
/// Returns `null` to allow the voice data to be broadcasted, or any non-null value to prevent it from being broadcasted.
/// </returns>
object OnPlayerVoice(BasePlayer player, byte[] data)
{
    Puts($"Player {player.UserIDString} sent voice data.");
    if (data.Length > 1024)
    {
        Puts($"Player {player.UserIDString} tried to send too much voice data.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void OnReceivedVoice(byte[] data)
	{
		if (Interface.CallHook("OnPlayerVoice", this, data) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.VoiceData);
			netWrite.EntityID(net.ID);
			netWrite.BytesWithSize(data);
			netWrite.Send(new SendInfo(BaseNetworkable.GetConnectionsWithin(base.transform.position, 100f))
			{
				priority = Priority.Immediate
			});
			if (activeTelephone != null)
			{
				activeTelephone.OnReceivedVoiceFromUser(data);
			}
		}
	}

```

## OnStructureRotate(BuildingBlock,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a structure is rotated.
/// </summary>
/// <param name="block">The building block being rotated.</param>
/// <param name="player">The player performing the rotation.</param>
/// <returns>
/// Returns `null` to allow the structure to be rotated, or any non-null value to prevent it from rotating.
/// </returns>
object OnStructureRotate(BuildingBlock block, BasePlayer player)
{
    Puts($"Structure at {block.Position} has been rotated by player {player.UserIDString}");
    if (block.IsSpecialBlock())
    {
        Puts($"Cannot rotate special block at {block.Position}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void DoRotation(RPCMessage msg)
	{
		if (msg.player.CanInteract() && CanRotate(msg.player) && blockDefinition.canRotateAfterPlacement && Interface.CallHook("OnStructureRotate", this, msg.player) == null)
		{
			base.transform.localRotation *= Quaternion.Euler(blockDefinition.rotationAmount);
			RefreshEntityLinks();
			UpdateSurroundingEntities();
			UpdateSkin(force: true);
			RefreshNeighbours(linkToNeighbours: false);
			SendNetworkUpdateImmediate();
			ClientRPC(null, "RefreshSkin");
		}
	}

```

## OnCargoShipSpawnCrate(CargoShip)

```csharp
```csharp
/// <summary>
/// Called when a cargo ship spawns a crate.
/// </summary>
/// <param name="cargoShip">The cargo ship that spawned the crate.</param>
/// <returns>
/// Returns `null` to allow the cargo ship to spawn crates as normal, or any non-null value to override this behavior.
/// If a string is returned, it will be used as a message to display when spawning crates.
/// </returns>
object OnCargoShipSpawnCrate(CargoShip cargoShip)
{
    Puts($"Cargo ship {cargoShip.name} has spawned a crate.");
    if (cargoShip.isElite)
    {
        Puts($"Cargo ship {cargoShip.name} is an elite cargo ship, spawning rare crates.");
        return "Rare Crate Spawned!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RespawnLoot()
	{
		if (Interface.CallHook("OnCargoShipSpawnCrate", this) == null)
		{
			InvokeRepeating(PlayHorn, 0f, 8f);
			SpawnCrate(lockedCratePrefab.resourcePath);
			SpawnCrate(eliteCratePrefab.resourcePath);
			for (int i = 0; i < 4; i++)
			{
				SpawnCrate(militaryCratePrefab.resourcePath);
			}
			for (int j = 0; j < 4; j++)
			{
				SpawnCrate(junkCratePrefab.resourcePath);
			}
			lootRoundsPassed++;
			if (lootRoundsPassed >= loot_rounds)
			{
				CancelInvoke(RespawnLoot);
			}
		}
	}

```

## OnNpcEquipWeapon(NPCPlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when an NPC equips a weapon.
/// </summary>
/// <param name="npc">The NPC equipping the weapon.</param>
/// <param name="item">The item being equipped as a weapon.</param>
/// <returns>
/// Returns `null` to allow the NPC to equip the weapon, or any non-null value to prevent them from equipping it.
/// </returns>
object OnNpcEquipWeapon(NPCPlayer npc, Item item)
{
    Puts($"NPC {npc.Name} is equipping {item.Name} as a weapon.");
    if (item.IsMelee)
    {
        Puts($"NPC {npc.Name} is being prevented from equipping {item.Name} due to it being a melee weapon.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void EquipWeapon(bool skipDeployDelay = false)
	{
		if (inventory == null || inventory.containerBelt == null)
		{
			return;
		}
		Item slot = inventory.containerBelt.GetSlot(0);
		if (Interface.CallHook("OnNpcEquipWeapon", this, slot) != null || slot == null)
		{
			return;
		}
		UpdateActiveItem(inventory.containerBelt.GetSlot(0).uid);
		BaseEntity heldEntity = slot.GetHeldEntity();
		if (!(heldEntity != null))
		{
			return;
		}
		AttackEntity component = heldEntity.GetComponent<AttackEntity>();
		if (component != null)
		{
			if (skipDeployDelay)
			{
				component.ResetAttackCooldown();
			}
			component.TopUpAmmo();
		}
	}

```

## OnExcavatorGather(ExcavatorArm,Item)

```csharp
```csharp
/// <summary>
/// Called when an excavator arm gathers resources.
/// </summary>
/// <param name="excavatorArm">The excavator arm that gathered the resources.</param>
/// <param name="item">The item that was gathered.</param>
object OnExcavatorGather(ExcavatorArm excavatorArm, Item item)
{
    Puts($"Excavator {excavatorArm.GetDisplayName()} gathered {item.GetItemDefinition().name}.");
    if (item.GetItemDefinition().name == "rareResource")
    {
        Puts($"Excavator {excavatorArm.GetDisplayName()} found a rare resource!");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ProduceResources()
	{
		float num = resourceProductionTickRate / timeForFullResources;
		float num2 = resourcesToMine[resourceMiningIndex].amount * num;
		pendingResources[resourceMiningIndex].amount += num2;
		ItemAmount[] array = pendingResources;
		foreach (ItemAmount itemAmount in array)
		{
			if (!(itemAmount.amount >= (float)outputPiles.Count))
			{
				continue;
			}
			int num3 = Mathf.FloorToInt(itemAmount.amount / (float)outputPiles.Count);
			itemAmount.amount -= num3 * 2;
			foreach (ExcavatorOutputPile outputPile in outputPiles)
			{
				Item item = ItemManager.Create(resourcesToMine[resourceMiningIndex].itemDef, num3, 0uL);
				if (Interface.CallHook("OnExcavatorGather", this, item) != null)
				{
					return;
				}
				Facepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);
				if (!item.MoveToContainer(outputPile.inventory))
				{
					item.Drop(outputPile.GetDropPosition(), outputPile.GetDropVelocity());
				}
			}
		}
	}

```

## CanSpectateTarget(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can spectate a specific target.
/// </summary>
/// <param name="player">The player attempting to spectate.</param>
/// <param name="targetName">The name of the target the player is trying to spectate.</param>
/// <returns>
/// Returns `null` to allow the player to spectate the target, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for denying spectating access.
/// </returns>
object CanSpectateTarget(BasePlayer player, string targetName)
{
    Puts($"Player {player.displayName} is trying to spectate {targetName}.");
    if (targetName == "admin")
    {
        return "Denied: Admins cannot be spectated.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateSpectateTarget(string strName)
	{
		if (Interface.CallHook("CanSpectateTarget", this, strName) != null)
		{
			return;
		}
		spectateFilter = strName;
		IEnumerable<BaseEntity> enumerable = null;
		if (spectateFilter.StartsWith("@"))
		{
			string filter = spectateFilter.Substring(1);
			enumerable = (from x in BaseNetworkable.serverEntities
				where x.name.Contains(filter, CompareOptions.IgnoreCase)
				where x != this
				select x).Cast<BaseEntity>();
		}
		else
		{
			IEnumerable<BasePlayer> source = activePlayerList.Where((BasePlayer x) => !x.IsSpectating() && !x.IsDead() && !x.IsSleeping());
			if (strName.Length > 0)
			{
				source = from x in source
					where x.displayName.Contains(spectateFilter, CompareOptions.IgnoreCase) || x.UserIDString.Contains(spectateFilter)
					where x != this
					select x;
			}
			source = source.OrderBy((BasePlayer x) => x.displayName);
			enumerable = source.Cast<BaseEntity>();
		}
		BaseEntity[] array = enumerable.ToArray();
		if (array.Length == 0)
		{
			ChatMessage("No valid spectate targets!");
			return;
		}
		BaseEntity baseEntity = array[SpectateOffset % array.Length];
		if (baseEntity != null)
		{
			SpectatePlayer(baseEntity);
		}
	}

```

## OnShopCancelClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the cancel button is clicked on a shop front.
/// </summary>
/// <param name="shopFront">The shop front where the cancel button was clicked.</param>
/// <param name="player">The player who clicked the cancel button.</param>
/// <returns>
/// Returns `null` to allow the trade to be cancelled, or any non-null value to prevent the trade from being cancelled.
/// </returns>
object OnShopCancelClick(ShopFront shopFront, BasePlayer player)
{
    Puts($"Player {player.UserIDString} clicked cancel on shop front {shopFront.name}");
    if (player.HasTag("admin"))
    {
        Puts($"Admin player {player.UserIDString} cannot be cancelled from trade.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void CancelClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && Interface.CallHook("OnShopCancelClick", this, msg.player) == null)
		{
			_ = (bool)vendorPlayer;
			_ = (bool)customerPlayer;
			ResetTrade();
		}
	}

```

## OnShopCompleteTrade(ShopFront)

```csharp
```csharp
/// <summary>
/// Called when a trade is completed in the shop.
/// </summary>
/// <param name="shopFront">The shop front where the trade was completed.</param>
/// <returns>
/// Returns `null` to allow the trade completion, or any non-null value to prevent the trade from being completed.
/// If a string is returned, it will be displayed as a message in the chat.
/// </returns>
object OnShopCompleteTrade(ShopFront shopFront)
{
    Puts($"Trade has been completed at {shopFront.name}.");
    if (shopFront.owner == "trusted_vendor")
    {
        Puts($"Trade was completed by trusted vendor {shopFront.owner}.");
        return null;
    }
    else
    {
        Puts($"Trade was attempted by untrusted player {shopFront.customerPlayer.displayName}.");
        return "Trade cancelled: Untrusted player.";
    }
}
```
```

### Source Code from the Library

```csharp

	public void CompleteTrade()
	{
		if (vendorPlayer != null && customerPlayer != null && HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
		{
			if (Interface.CallHook("OnShopCompleteTrade", this) != null)
			{
				return;
			}
			try
			{
				swappingItems = true;
				for (int num = vendorInventory.capacity - 1; num >= 0; num--)
				{
					Item slot = vendorInventory.GetSlot(num);
					Item slot2 = customerInventory.GetSlot(num);
					if ((bool)customerPlayer && slot != null)
					{
						customerPlayer.GiveItem(slot);
					}
					if ((bool)vendorPlayer && slot2 != null)
					{
						vendorPlayer.GiveItem(slot2);
					}
				}
			}
			finally
			{
				swappingItems = false;
			}
			Effect.server.Run(transactionCompleteEffect.resourcePath, this, 0u, new Vector3(0f, 1f, 0f), Vector3.zero);
		}
		ResetTrade();
		SendNetworkUpdate();
	}

```

## OnPlayerWantsMount(BaseVehicle,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player wants to mount the vehicle.
/// </summary>
/// <param name="vehicle">The vehicle being mounted.</param>
/// <param name="mountable">The object being mounted onto the vehicle.</param>
/// <returns>
/// Returns `null` to allow the player to mount the vehicle, or any non-null value to prevent them from mounting.
/// </returns>
object OnPlayerWantsMount(BaseVehicle vehicle, BaseMountable mountable)
{
    Puts($"Player is trying to mount {vehicle.displayName} with {mountable.displayName}");
    if (vehicle.IsBroken())
    {
        Puts($"Player cannot mount {vehicle.displayName} because it's broken.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void WantsMount(BasePlayer player)
	{
		if (!player.IsValid() || !player.CanInteract())
		{
			return;
		}
		BaseVehicle baseVehicle = default(BaseVehicle);
		if (!DirectlyMountable())
		{
			baseVehicle = VehicleParent();
			if (baseVehicle != null)
			{
				baseVehicle.WantsMount(player);
				return;
			}
		}
		if (Interface.CallHook("OnPlayerWantsMount", baseVehicle, this) == null)
		{
			AttemptMount(player);
		}
	}

```

## OnLootEntityEnd(BasePlayer,ItemBasedFlowRestrictor)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="restrictor">The item-based flow restrictor that was being looted.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, ItemBasedFlowRestrictor restrictor)
{
    Puts($"Player {player.UserIDString} stopped looting the {restrictor.GetType().Name}.");
}
```
```

### Source Code from the Library

```csharp

	public void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
	}

```

## OnPlayerCorpseSpawn(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's corpse is spawned.
/// </summary>
/// <param name="corpse">The player's corpse.</param>
/// <returns>
/// Returns `null` to allow the default corpse spawning behavior. 
/// If a non-null value is returned, it will override the default behavior and be used as the new corpse.
/// </returns>
BaseCorpse OnPlayerCorpseSpawn(BasePlayer player)
{
    Puts($"Player {player.displayName}'s corpse has been spawned.");
    // You can add custom logic here to modify or replace the default corpse
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual BaseCorpse CreateCorpse()
	{
		if (Interface.CallHook("OnPlayerCorpseSpawn", this) != null)
		{
			return null;
		}
		using (TimeWarning.New("Create corpse"))
		{
			string strCorpsePrefab = "assets/prefabs/player/player_corpse.prefab";
			bool flag = false;
			if (ConVar.Global.cinematicGingerbreadCorpses)
			{
				foreach (Item item in inventory.containerWear.itemList)
				{
					if (item != null && item.info.TryGetComponent<ItemCorpseOverride>(out var component))
					{
						strCorpsePrefab = ((GetFloatBasedOnUserID(userID, 4332uL) > 0.5f) ? component.FemaleCorpse.resourcePath : component.MaleCorpse.resourcePath);
						flag = component.BlockWearableCopy;
						break;
					}
				}
			}
			PlayerCorpse playerCorpse = DropCorpse(strCorpsePrefab) as PlayerCorpse;
			if ((bool)playerCorpse)
			{
				playerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				if (!flag)
				{
					playerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				}
				playerCorpse.playerName = displayName;
				playerCorpse.playerSteamID = userID;
				playerCorpse.underwearSkin = GetUnderwearSkin();
				playerCorpse.Spawn();
				playerCorpse.TakeChildren(this);
				ResourceDispenser component2 = playerCorpse.GetComponent<ResourceDispenser>();
				int num = 2;
				if (lifeStory != null)
				{
					num += Mathf.Clamp(Mathf.FloorToInt(lifeStory.secondsAlive / 180f), 0, 20);
				}
				component2.containedItems.Add(new ItemAmount(ItemManager.FindItemDefinition("fat.animal"), num));
				Interface.CallHook("OnPlayerCorpseSpawned", this, playerCorpse);
				return playerCorpse;
			}
		}
		return null;
		static float GetFloatBasedOnUserID(ulong steamid, ulong seed)
		{
			UnityEngine.Random.State state = UnityEngine.Random.state;
			UnityEngine.Random.InitState((int)(seed + steamid));
			float result = UnityEngine.Random.Range(0f, 1f);
			UnityEngine.Random.state = state;
			return result;
		}
	}

```

## OnTechTreeNodeUnlock(Workbench,TechTreeData.NodeInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a tech tree node is unlocked.
/// </summary>
/// <param name="node">The unlocked tech tree node.</param>
/// <param name="player">The player who unlocked the node.</param>
/// <returns>
/// Returns `null` to allow the default unlock behavior. 
/// If a non-null value is returned, it will override the default unlock behavior.
/// </returns>
object OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
{
    Puts($"Node {node.groupName} has been unlocked by player {player.displayName}.");
    if (node.itemDef == null || !player.blueprints.IsUnlocked(node.itemDef))
    {
        return null;
    }
    // Additional logic can be added here to handle the unlock event.
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_TechTreeUnlock(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int num = msg.read.Int32();
		TechTreeData.NodeInstance byID = techTree.GetByID(num);
		if (byID == null)
		{
			Debug.Log("Node for unlock not found :" + num);
		}
		else
		{
			if (!techTree.PlayerCanUnlock(player, byID))
			{
				return;
			}
			if (byID.IsGroup())
			{
				foreach (int output in byID.outputs)
				{
					TechTreeData.NodeInstance byID2 = techTree.GetByID(output);
					if (byID2 != null && byID2.itemDef != null)
					{
						player.blueprints.Unlock(byID2.itemDef);
						Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID2.itemDef, "techtree", this);
					}
				}
				Debug.Log("Player unlocked group :" + byID.groupName);
			}
			else if (byID.itemDef != null && Interface.CallHook("OnTechTreeNodeUnlock", this, byID, player) == null)
			{
				int num2 = ResearchTable.ScrapForResearch(byID.itemDef, ResearchTable.ResearchType.TechTree);
				int itemid = ItemManager.FindItemDefinition("scrap").itemid;
				if (player.inventory.GetAmount(itemid) >= num2)
				{
					player.inventory.Take(null, itemid, num2);
					player.blueprints.Unlock(byID.itemDef);
					Interface.CallHook("OnTechTreeNodeUnlocked", this, byID, player);
					Facepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, "techtree", this);
				}
			}
		}
	}

```

## OnItemCraftFinished(ItemCraftTask,Item)

```csharp
```csharp
/// <summary>
/// Called when an item crafting task is finished.
/// </summary>
/// <param name="task">The ItemCraftTask that was completed.</param>
/// <param name="item">The crafted item.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the item will be added to the player's inventory.
/// </returns>
object OnItemCraftFinished(ItemCraftTask task, Item item)
{
    Puts($"Item crafting task {task.taskUID} has been completed.");
    if (item.info.itemid == 12345)
    {
        Puts($"Item with ID {item.info.itemid} has been flagged for special handling.");
        return "Special handling required.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void FinishCrafting(ItemCraftTask task)
	{
		task.amount--;
		task.numCrafted++;
		ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
		Item item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, 1, skin);
		item.amount = task.blueprint.amountToCreate;
		int amount = item.amount;
		_ = task.owner.currentCraftLevel;
		bool inSafezone = task.owner.InSafeZone();
		if (item.hasCondition && task.conditionScale != 1f)
		{
			item.maxCondition *= task.conditionScale;
			item.condition = item.maxCondition;
		}
		item.OnVirginSpawn();
		foreach (ItemAmount ingredient in task.blueprint.ingredients)
		{
			int num = (int)ingredient.amount;
			if (task.takenItems == null)
			{
				continue;
			}
			foreach (Item takenItem in task.takenItems)
			{
				if (takenItem.info == ingredient.itemDef)
				{
					int num2 = Mathf.Min(takenItem.amount, num);
					Facepunch.Rust.Analytics.Azure.OnCraftMaterialConsumed(takenItem.info.shortname, num, base.baseEntity, task.workbenchEntity, inSafezone, item.info.shortname);
					takenItem.UseItem(num);
					num -= num2;
				}
				_ = 0;
			}
		}
		Facepunch.Rust.Analytics.Server.Crafting(task.blueprint.targetItem.shortname, task.skinID);
		Facepunch.Rust.Analytics.Azure.OnCraftItem(item.info.shortname, item.amount, base.baseEntity, task.workbenchEntity, inSafezone);
		task.owner.Command("note.craft_done", task.taskUID, 1, task.amount);
		Interface.CallHook("OnItemCraftFinished", task, item);
		if (task.instanceData != null)
		{
			item.instanceData = task.instanceData;
		}
		if (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))
		{
			task.owner.GiveAchievement(task.blueprint.UnlockAchievment);
		}
		if (task.owner.inventory.GiveItem(item))
		{
			task.owner.Command("note.inv", item.info.itemid, amount);
			return;
		}
		ItemContainer itemContainer = containers.First();
		task.owner.Command("note.inv", item.info.itemid, amount);
		task.owner.Command("note.inv", item.info.itemid, -item.amount);
		item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity);
	}

```

## OnEngineStart(MotorRowboat,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the engine of a motorized vehicle is started.
/// </summary>
/// <param name="vehicle">The motorized vehicle starting its engine.</param>
/// <param name="driver">The player driving the vehicle.</param>
/// <returns>
/// Returns `null` to allow the engine to start, or any non-null value to prevent it from starting.
/// </returns>
object OnEngineStart(MotorRowboat vehicle, BasePlayer driver)
{
    Puts($"Engine started on {vehicle.name} driven by {driver.displayName}");
    if (driver.GetDistanceFromVehicle(vehicle) > 5f)
    {
        Puts($"Driver {driver.displayName} is too far away from the vehicle to start its engine.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void EngineToggle(bool wantsOn)
	{
		if (!fuelSystem.HasFuel(forceCheck: true))
		{
			return;
		}
		BasePlayer driver = GetDriver();
		if (!wantsOn || Interface.CallHook("OnEngineStart", this, driver) == null)
		{
			SetFlag(Flags.Reserved1, wantsOn);
			if (wantsOn)
			{
				Interface.CallHook("OnEngineStarted", this, driver);
			}
		}
	}

```

## OnVendingTransaction(VendingMachine,BasePlayer,int,int,ItemContainer)

```csharp
Here is the method structure for `OnVendingTransaction`:

```csharp
/// <summary>
/// Called when a vending machine transaction occurs.
/// </summary>
/// <param name="vendingMachine">The vending machine that triggered the transaction.</param>
/// <param name="buyer">The player who initiated the transaction.</param>
/// <param name="sellOrderId">The ID of the sell order being executed.</param>
/// <param name="numberOfTransactions">The number of transactions to execute.</param>
/// <param name="targetContainer">The container where items will be placed (optional).</param>
/// <returns>
/// Returns a non-null value to override the default transaction behavior.
/// If a bool is returned, it indicates whether the transaction was successful or not.
/// If null is returned, the transaction proceeds as normal.
/// </returns>
public object OnVendingTransaction(VendingMachine vendingMachine, Player buyer, int sellOrderId, int numberOfTransactions, Container targetContainer)
{
    // Implementation...
}
```

Note that this method takes in several parameters to reflect the various aspects of a vending machine transaction. The return type is also an `object` to allow for flexibility in what can be returned by the hook.
```

### Source Code from the Library

```csharp

	public bool DoTransaction(BasePlayer buyer, int sellOrderId, int numberOfTransactions = 1, ItemContainer targetContainer = null, Action<BasePlayer, Item> onCurrencyRemoved = null, Action<BasePlayer, Item> onItemPurchased = null, MarketTerminal droneMarketTerminal = null)
	{
		if (sellOrderId < 0 || sellOrderId >= sellOrders.sellOrders.Count)
		{
			return false;
		}
		if (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)
		{
			return false;
		}
		object obj = Interface.CallHook("OnVendingTransaction", this, buyer, sellOrderId, numberOfTransactions, targetContainer);
		if (obj is bool)
		{
			return (bool)obj;
		}
		ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[sellOrderId];
		List<Item> obj2 = Facepunch.Pool.GetList<Item>();
		GetItemsToSell(sellOrder, obj2);
		if (obj2 == null || obj2.Count == 0)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, obj2[0].hasCondition ? 1 : 1000000);
		int num = sellOrder.itemToSellAmount * numberOfTransactions;
		int num2 = obj2.Sum((Item x) => x.amount);
		if (num > num2)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		List<Item> source = buyer.inventory.FindItemIDs(sellOrder.currencyID);
		if (sellOrder.currencyIsBP)
		{
			source = (from x in buyer.inventory.FindItemIDs(blueprintBaseDef.itemid)
				where x.blueprintTarget == sellOrder.currencyID
				select x).ToList();
		}
		source = source.Where((Item x) => !x.hasCondition || (x.conditionNormalized >= 0.5f && x.maxConditionNormalized > 0.5f)).ToList();
		if (source.Count == 0)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		int num3 = source.Sum((Item x) => x.amount);
		int num4 = sellOrder.currencyAmountPerItem * numberOfTransactions;
		if (num3 < num4)
		{
			Facepunch.Pool.FreeList(ref obj2);
			return false;
		}
		transactionActive = true;
		int num5 = 0;
		foreach (Item item3 in source)
		{
			int num6 = Mathf.Min(num4 - num5, item3.amount);
			Item item = ((item3.amount > num6) ? item3.SplitItem(num6) : item3);
			TakeCurrencyItem(item);
			onCurrencyRemoved?.Invoke(buyer, item);
			num5 += num6;
			if (num5 >= num4)
			{
				break;
			}
		}
		Facepunch.Rust.Analytics.Azure.OnBuyFromVendingMachine(buyer, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount * numberOfTransactions, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem * numberOfTransactions, sellOrder.currencyIsBP, numberOfTransactions, droneMarketTerminal);
		int num7 = 0;
		foreach (Item item4 in obj2)
		{
			int num8 = num - num7;
			Item item2 = ((item4.amount > num8) ? item4.SplitItem(num8) : item4);
			if (item2 == null)
			{
				Debug.LogError("Vending machine error, contact developers!");
			}
			else
			{
				num7 += item2.amount;
				object obj3 = Interface.CallHook("CanPurchaseItem", buyer, item2, onItemPurchased, this, targetContainer);
				if (obj3 is bool)
				{
					return (bool)obj3;
				}
				RecordSaleAnalytics(item2);
				if (targetContainer == null)
				{
					GiveSoldItem(item2, buyer);
				}
				else if (!item2.MoveToContainer(targetContainer))
				{
					item2.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
				}
				onItemPurchased?.Invoke(buyer, item2);
			}
			if (num7 >= num)
			{
				break;
			}
		}
		Facepunch.Pool.FreeList(ref obj2);
		UpdateEmptyFlag();
		transactionActive = false;
		return true;
	}

```

## OnClientCommand(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client sends a command.
/// </summary>
/// <param name="connection">The connection of the client sending the command.</param>
/// <param name="command">The command sent by the client.</param>
/// <returns>
/// Returns `null` to allow the command to be executed, or any non-null value to prevent the command from being executed.
/// </returns>
object OnClientCommand(Network.Connection connection, string command)
{
    Puts($"Client {connection.UserIDString} sent command: {command}");
    if (command == "invalid")
    {
        Puts($"Client {connection.UserIDString} tried to run invalid command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	internal static void OnClientCommand(Message packet)
	{
		if (packet.read.Unread > ConVar.Server.maxpacketsize_command)
		{
			Debug.LogWarning("Dropping client command due to size");
			return;
		}
		string text = packet.read.StringRaw();
		if (packet.connection == null || !packet.connection.connected)
		{
			Debug.LogWarning("Client without connection tried to run command: " + text);
		}
		else if (Interface.CallHook("OnClientCommand", packet.connection, text) == null)
		{
			string text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text);
			if (!string.IsNullOrEmpty(text2))
			{
				SendClientReply(packet.connection, text2);
			}
		}
	}

```

## OnResearchCostDetermine(ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine the research cost for an item.
/// </summary>
/// <param name="info">The ItemDefinition of the item being researched.</param>
/// <returns>
/// Returns a non-null value to override the default research cost. If `null` is returned, the default research cost will be used.
/// The return value can be either an int (the new research cost) or any other type (in which case the default research cost will still be used).
/// </returns>
object OnResearchCostDetermine(ItemDefinition info)
{
    Puts($"Determining research cost for item {info.name}...");
    if (info.rarity == Rarity.VeryRare)
    {
        return 1000;
    }
    else if (info.rarity == Rarity.Rare)
    {
        return 200;
    }
    // Add more conditions as needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static int ScrapForResearch(ItemDefinition info, ResearchType type)
	{
		object obj = Interface.CallHook("OnResearchCostDetermine", info);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (info.rarity == Rarity.Common)
		{
			num = 20;
		}
		if (info.rarity == Rarity.Uncommon)
		{
			num = 75;
		}
		if (info.rarity == Rarity.Rare)
		{
			num = 125;
		}
		if (info.rarity == Rarity.VeryRare || info.rarity == Rarity.None)
		{
			num = 500;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null)
		{
			BaseGameMode.ResearchCostResult scrapCostForResearch = activeGameMode.GetScrapCostForResearch(info, type);
			if (scrapCostForResearch.Scale.HasValue)
			{
				num = Mathf.RoundToInt((float)num * scrapCostForResearch.Scale.Value);
			}
			else if (scrapCostForResearch.Amount.HasValue)
			{
				num = scrapCostForResearch.Amount.Value;
			}
		}
		return num;
	}

```

## OnPlayerSleep(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts sleeping.
/// </summary>
/// <param name="player">The player starting to sleep.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleep(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has started sleeping.");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot be put to sleep.");
        // Add custom logic here for admins
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void StartSleeping()
	{
		if (!IsSleeping())
		{
			Interface.CallHook("OnPlayerSleep", this);
			if (InSafeZone() && !IsInvoking(ScheduledDeath))
			{
				Invoke(ScheduledDeath, NPCAutoTurret.sleeperhostiledelay);
			}
			BaseMountable baseMountable = GetMounted();
			if (baseMountable != null && !baseMountable.allowSleeperMounting)
			{
				EnsureDismounted();
			}
			SetPlayerFlag(PlayerFlags.Sleeping, b: true);
			sleepStartTime = UnityEngine.Time.time;
			sleepingPlayerList.Add(this);
			bots.Remove(this);
			CancelInvoke(InventoryUpdate);
			CancelInvoke(TeamUpdate);
			inventory.loot.Clear();
			inventory.crafting.CancelAll(returnItems: true);
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			TurnOffAllLights();
			EnablePlayerCollider();
			RemovePlayerRigidbody();
			SetServerFall(wantsOn: true);
		}
	}

```

## OnItemStacked(IItemContainerEntity,Item,ItemContainer)

```csharp
This is a C# method that appears to be part of a larger system for managing items in a game or simulation. The method is responsible for moving an item from one container to another, taking into account various rules and constraints.

Here's a breakdown of the method:

1. The method takes several parameters:
	* `itemModWearable`: An item that may be worn by a player.
	* `newcontainer`: The target container where the item will be moved.
	* `iTargetPos`: The position in the new container where the item will be placed (defaults to -1).
	* `allowStack`: Whether the item can be stacked with other items of the same type.
	* `ignoreStackLimit`: Whether to ignore the maximum stack size for the item.
	* `sourcePlayer`: The player who owns the item being moved.
2. The method first checks if the item is already in the new container, and if so, whether it can be stacked with other items of the same type. If not, it returns false.
3. It then checks if there are any conflicting slots in the new container that would prevent the item from being placed at the specified position. If so, it sets `iTargetPos` to -1 and continues.
4. If `iTargetPos` is still -1, it means that the item cannot be moved to the new container, so the method returns false.
5. The method then checks if the item can be moved to the specified position in the new container. If not, it returns false.
6. If the item can be moved, but there's already an item at the target position, the method checks if the existing item is of the same type and can be stacked with the item being moved. If so, it merges the two items by adding their amounts together.
7. If the item cannot be merged with the existing item, or if the merge would exceed the maximum stack size, the method returns false.
8. Finally, if all checks pass, the method moves the item to the new container and updates its position.

The method uses various hooks and callbacks to notify other parts of the system about the item's movement, such as `OnItemStacked` and `RemoveConflictingSlots`.
```

### Source Code from the Library

```csharp

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		using (TimeWarning.New("MoveToContainer"))
		{
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			IItemContainerEntity itemContainerEntity = default(IItemContainerEntity);
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					foreach (Item item2 in from x in newcontainer.FindItemsByItemID(info.itemid)
						orderby x.position
						select x)
					{
						if (item2.CanStack(this) && (ignoreStackLimit || item2.amount < item2.MaxStackable()))
						{
							iTargetPos = item2.position;
						}
					}
				}
				if (iTargetPos == -1)
				{
					itemContainerEntity = newcontainer.GetEntityOwner(returnHeldEntity: true) as IItemContainerEntity;
					if (itemContainerEntity != null)
					{
						iTargetPos = itemContainerEntity.GetIdealSlot(sourcePlayer, this);
						if (iTargetPos == int.MinValue)
						{
							return false;
						}
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.availableSlots != null && newcontainer.availableSlots.Count > 0 && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						amount -= num2;
						slot2.MarkDirty();
						MarkDirty();
						Interface.CallHook("OnItemStacked", slot2, this, newcontainer, num2);
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer itemContainer3 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(itemContainer3);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item = SplitItem(newcontainer.maxStackSize);
				if (item != null && !item.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					Vector3 dropPosition = newcontainer.dropPosition;
					Vector3 dropVelocity = newcontainer.dropVelocity;
					Interface.CallHook("OnItemStacked", itemContainerEntity, this, newcontainer);
					item.Drop(dropPosition, dropVelocity);
				}
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
	}

```

## OnXmasLootDistribute(XMasRefill)

```csharp
```csharp
/// <summary>
/// Called when Christmas loot is being distributed.
/// </summary>
/// <param name="refill">The XMasRefill object containing information about the loot distribution.</param>
/// <returns>
/// Returns `null` to allow the loot distribution to proceed as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display to players during the loot distribution process.
/// </returns>
object OnXmasLootDistribute(XMasRefill refill)
{
    Puts($"Christmas loot is being distributed with {refill.lootCount} items.");
    if (refill.lootCount == 0)
    {
        Puts("No loot to distribute. Skipping distribution process.");
        return "No loot available.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerInit()
	{
		base.ServerInit();
		if (!XMas.enabled)
		{
			Invoke(RemoveMe, 0.1f);
			return;
		}
		goodKids = ((BasePlayer.activePlayerList != null) ? new List<BasePlayer>(BasePlayer.activePlayerList) : new List<BasePlayer>());
		stockings = ((Stocking.stockings != null) ? new List<Stocking>(Stocking.stockings.Values) : new List<Stocking>());
		Invoke(RemoveMe, 60f);
		if (Interface.CallHook("OnXmasLootDistribute", this) == null)
		{
			InvokeRepeating(DistributeLoot, 3f, 0.02f);
			Invoke(SendBells, 0.5f);
		}
	}

```

## OnItemStacked(Item,Item,ItemContainer,int)

```csharp
This is a C# method that appears to be part of a larger system for managing items in a game or simulation. The method is responsible for moving an item from one container to another, taking into account various rules and constraints.

Here's a breakdown of the method:

1. The method takes several parameters:
	* `itemModWearable`: An item that may be worn by a player.
	* `newcontainer`: The target container where the item will be moved.
	* `iTargetPos`: The position in the new container where the item will be placed (defaults to -1).
	* `allowStack`: Whether the item can be stacked with other items of the same type.
	* `ignoreStackLimit`: Whether to ignore the maximum stack size for the item.
	* `sourcePlayer`: The player who owns the item being moved.
2. The method first checks if the item is already in the new container, and if so, whether it can be stacked with other items of the same type. If not, it returns false.
3. It then checks if there are any conflicting slots in the new container that would prevent the item from being placed at the specified position. If so, it sets `iTargetPos` to -1 and continues.
4. If `iTargetPos` is still -1, it means that the item cannot be moved to the new container, so the method returns false.
5. The method then checks if the item can be moved to the specified position in the new container. If not, it returns false.
6. If the item can be moved, but there's already an item at the target position, the method checks if the existing item is of the same type and can be stacked with the item being moved. If so, it merges the two items by adding their amounts together.
7. If the item cannot be merged with the existing item, or if the merge would exceed the maximum stack size, the method returns false.
8. Finally, if all checks pass, the method moves the item to the new container and updates its position.

The method uses various hooks and callbacks to notify other parts of the system about the item's movement, such as `OnItemStacked` and `RemoveConflictingSlots`.
```

### Source Code from the Library

```csharp

	public bool MoveToContainer(ItemContainer newcontainer, int iTargetPos = -1, bool allowStack = true, bool ignoreStackLimit = false, BasePlayer sourcePlayer = null, bool allowSwap = true)
	{
		using (TimeWarning.New("MoveToContainer"))
		{
			bool flag = iTargetPos == -1;
			ItemContainer itemContainer = parent;
			IItemContainerEntity itemContainerEntity = default(IItemContainerEntity);
			if (iTargetPos == -1)
			{
				if (allowStack && info.stackable > 1)
				{
					foreach (Item item2 in from x in newcontainer.FindItemsByItemID(info.itemid)
						orderby x.position
						select x)
					{
						if (item2.CanStack(this) && (ignoreStackLimit || item2.amount < item2.MaxStackable()))
						{
							iTargetPos = item2.position;
						}
					}
				}
				if (iTargetPos == -1)
				{
					itemContainerEntity = newcontainer.GetEntityOwner(returnHeldEntity: true) as IItemContainerEntity;
					if (itemContainerEntity != null)
					{
						iTargetPos = itemContainerEntity.GetIdealSlot(sourcePlayer, this);
						if (iTargetPos == int.MinValue)
						{
							return false;
						}
					}
				}
				if (iTargetPos == -1)
				{
					if (newcontainer == parent)
					{
						return false;
					}
					bool flag2 = newcontainer.HasFlag(ItemContainer.Flag.Clothing) && info.isWearable;
					ItemModWearable itemModWearable = info.ItemModWearable;
					for (int i = 0; i < newcontainer.capacity; i++)
					{
						Item slot = newcontainer.GetSlot(i);
						if (slot == null)
						{
							if (CanMoveTo(newcontainer, i))
							{
								iTargetPos = i;
								break;
							}
							continue;
						}
						if (flag2 && slot != null && !slot.info.ItemModWearable.CanExistWith(itemModWearable))
						{
							iTargetPos = i;
							break;
						}
						if (newcontainer.availableSlots != null && newcontainer.availableSlots.Count > 0 && DoItemSlotsConflict(slot))
						{
							iTargetPos = i;
							break;
						}
					}
					if (flag2 && iTargetPos == -1)
					{
						iTargetPos = newcontainer.capacity - 1;
					}
				}
			}
			if (iTargetPos == -1)
			{
				return false;
			}
			if (!CanMoveTo(newcontainer, iTargetPos))
			{
				return false;
			}
			if (iTargetPos >= 0 && newcontainer.SlotTaken(this, iTargetPos))
			{
				Item slot2 = newcontainer.GetSlot(iTargetPos);
				if (slot2 == this)
				{
					return false;
				}
				if (allowStack && slot2 != null)
				{
					int num = slot2.MaxStackable();
					if (slot2.CanStack(this))
					{
						if (ignoreStackLimit)
						{
							num = int.MaxValue;
						}
						if (slot2.amount >= num)
						{
							return false;
						}
						int num2 = Mathf.Min(num - slot2.amount, amount);
						slot2.amount += num2;
						amount -= num2;
						slot2.MarkDirty();
						MarkDirty();
						Interface.CallHook("OnItemStacked", slot2, this, newcontainer, num2);
						if (amount <= 0)
						{
							RemoveFromWorld();
							RemoveFromContainer();
							Remove();
							return true;
						}
						if (flag)
						{
							return MoveToContainer(newcontainer, -1, allowStack, ignoreStackLimit, sourcePlayer);
						}
						return false;
					}
				}
				if (parent != null && allowSwap && slot2 != null)
				{
					ItemContainer itemContainer2 = parent;
					int iTargetPos2 = position;
					ItemContainer itemContainer3 = slot2.parent;
					int num3 = slot2.position;
					if (!slot2.CanMoveTo(itemContainer2, iTargetPos2))
					{
						return false;
					}
					BaseEntity entityOwner = GetEntityOwner();
					BaseEntity entityOwner2 = slot2.GetEntityOwner();
					RemoveFromContainer();
					slot2.RemoveFromContainer();
					RemoveConflictingSlots(newcontainer, entityOwner, sourcePlayer);
					slot2.RemoveConflictingSlots(itemContainer2, entityOwner2, sourcePlayer);
					if (!slot2.MoveToContainer(itemContainer2, iTargetPos2, allowStack: true, ignoreStackLimit: false, sourcePlayer) || !MoveToContainer(newcontainer, iTargetPos, allowStack: true, ignoreStackLimit: false, sourcePlayer))
					{
						RemoveFromContainer();
						slot2.RemoveFromContainer();
						SetParent(itemContainer2);
						position = iTargetPos2;
						slot2.SetParent(itemContainer3);
						slot2.position = num3;
						return true;
					}
					return true;
				}
				return false;
			}
			if (parent == newcontainer)
			{
				if (iTargetPos >= 0 && iTargetPos != position && !parent.SlotTaken(this, iTargetPos))
				{
					position = iTargetPos;
					MarkDirty();
					return true;
				}
				return false;
			}
			if (newcontainer.maxStackSize > 0 && newcontainer.maxStackSize < amount)
			{
				Item item = SplitItem(newcontainer.maxStackSize);
				if (item != null && !item.MoveToContainer(newcontainer, iTargetPos, allowStack: false, ignoreStackLimit: false, sourcePlayer) && (itemContainer == null || !item.MoveToContainer(itemContainer, -1, allowStack: true, ignoreStackLimit: false, sourcePlayer)))
				{
					Vector3 dropPosition = newcontainer.dropPosition;
					Vector3 dropVelocity = newcontainer.dropVelocity;
					Interface.CallHook("OnItemStacked", itemContainerEntity, this, newcontainer);
					item.Drop(dropPosition, dropVelocity);
				}
				return true;
			}
			if (!newcontainer.CanAccept(this))
			{
				return false;
			}
			BaseEntity entityOwner3 = GetEntityOwner();
			RemoveFromContainer();
			RemoveFromWorld();
			RemoveConflictingSlots(newcontainer, entityOwner3, sourcePlayer);
			position = iTargetPos;
			SetParent(newcontainer);
			return true;
		}
	}

```

## OnPhoneAnswered(PhoneController,PhoneController)

```csharp
```csharp
/// <summary>
/// Called when a phone is answered.
/// </summary>
/// <param name="caller">The PhoneController of the caller.</param>
/// <param name="callee">The PhoneController of the callee.</param>
/// <returns>
/// Returns `null` to allow the call to be answered, or any non-null value to prevent the call from being answered.
/// </returns>
object OnPhoneAnswered(PhoneController caller, PhoneController callee)
{
    Puts($"Phone {caller.GetCallId()} has been answered by {callee.GetCallId()}");
    if (caller.GetCallId() == "blocked")
    {
        Puts($"Phone call from {caller.GetCallId()} has been blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AnswerPhone(BaseEntity.RPCMessage msg)
	{
		if (IsInvoking(TimeOutDialing))
		{
			CancelInvoke(TimeOutDialing);
		}
		if (!(activeCallTo == null))
		{
			BasePlayer player = msg.player;
			if (Interface.CallHook("OnPhoneAnswer", this, activeCallTo) == null)
			{
				UpdateServerPlayer(player);
				BeginCall();
				activeCallTo.BeginCall();
				Interface.CallHook("OnPhoneAnswered", this, activeCallTo);
			}
		}
	}

```

## IOnRconInitialize()

```csharp
```csharp
/// <summary>
/// Called when the RCON system is initialized.
/// </summary>
void IOnRconInitialize()
{
    Puts("RCon initialization complete.");
}
```
```

### Source Code from the Library

```csharp

	public static void Initialize()
	{
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", ""));
		if (Password == "password" || Password == "")
		{
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", null);
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", null);
			listenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)
			{
				lock (Commands)
				{
					Command item = JsonConvert.DeserializeObject<Command>(msg);
					item.Ip = ip;
					item.ConnectionId = id;
					Commands.Enqueue(item);
				}
			};
			listenerNew.Start();
			Debug.Log("WebSocket RCon Started on " + Port);
		}
		else
		{
			listener = new RConListener();
			Debug.Log("RCon Started on " + Port);
			Debug.Log("Source style TCP Rcon is deprecated. Please switch to Websocket Rcon before it goes away.");
		}
	}

```

## OnTeamCreate(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a team is created.
/// </summary>
/// <param name="player">The player who created the team.</param>
/// <param name="team">The newly created team.</param>
/// <returns>No return behavior.</returns>
void OnTeamCreate(BasePlayer player, PlayerTeam team)
{
    Puts($"Team {team.teamID} created by player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void trycreateteam(ConsoleSystem.Arg arg)
	{
		if (maxTeamSize == 0)
		{
			arg.ReplyWith("Teams are disabled on this server");
			return;
		}
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer.currentTeam == 0L && Interface.CallHook("OnTeamCreate", basePlayer) == null)
		{
			PlayerTeam playerTeam = ServerInstance.CreateTeam();
			PlayerTeam playerTeam2 = playerTeam;
			playerTeam2.teamLeader = basePlayer.userID;
			playerTeam2.AddPlayer(basePlayer);
			Facepunch.Rust.Analytics.Azure.OnTeamChanged("created", playerTeam2.teamID, basePlayer.userID, basePlayer.userID, playerTeam2.members);
			Interface.CallHook("OnTeamCreated", basePlayer, playerTeam);
		}
	}

```

## OnRocketLaunched(BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a rocket is launched.
/// </summary>
/// <param name="player">The player who launched the rocket.</param>
/// <param name="baseEntity">The base entity of the launched rocket.</param>
void OnRocketLaunched(BasePlayer player, BaseEntity baseEntity)
{
    Puts("Rocket launched by " + player.displayName);
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SV_Launch(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (primaryMagazine.contents <= 0)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "magazine_empty");
			return;
		}
		primaryMagazine.contents--;
		SignalBroadcast(Signal.Attack, string.Empty, player.net.connection);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3().normalized;
		bool num = msg.read.Bit();
		BaseEntity mounted = player.GetParentEntity();
		if (mounted == null)
		{
			mounted = player.GetMounted();
		}
		if (num)
		{
			if (mounted != null)
			{
				vector = mounted.transform.TransformPoint(vector);
				vector2 = mounted.transform.TransformDirection(vector2);
			}
			else
			{
				vector = player.eyes.position;
				vector2 = player.eyes.BodyForward();
			}
		}
		if (!ValidateEyePos(player, vector))
		{
			return;
		}
		ItemModProjectile component = primaryMagazine.ammoType.GetComponent<ItemModProjectile>();
		if (!component)
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		float num2 = GetAimCone() + component.projectileSpread;
		if (num2 > 0f)
		{
			vector2 = AimConeUtil.GetModifiedAimConeDirection(num2, vector2);
		}
		float num3 = 1f;
		if (UnityEngine.Physics.Raycast(vector, vector2, out var hitInfo, num3, 1236478737))
		{
			num3 = hitInfo.distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, vector + vector2 * num3);
		if (!(baseEntity == null))
		{
			baseEntity.creatorEntity = player;
			ServerProjectile component2 = baseEntity.GetComponent<ServerProjectile>();
			if ((bool)component2)
			{
				component2.InitializeVelocity(GetInheritedVelocity(player, vector2) + vector2 * component2.speed);
			}
			baseEntity.Spawn();
			Facepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity, this);
			StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
			Interface.CallHook("OnRocketLaunched", player, baseEntity);
			GetOwnerItem()?.LoseCondition(UnityEngine.Random.Range(1f, 2f));
		}
	}

```

## OnSleepingBagDestroyed(SleepingBag,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a sleeping bag is destroyed.
/// </summary>
/// <param name="sleepingBag">The destroyed sleeping bag.</param>
/// <param name="player">The player who destroyed the sleeping bag.</param>
/// <returns>No return behavior.</returns>
void OnSleepingBagDestroyed(SleepingBag sleepingBag, BasePlayer player)
{
    Puts($"Sleeping bag of player {player.UserIDString} has been destroyed.");
    if (sleepingBag.deployerUserID == 123456)
    {
        Puts($"The sleeping bag was deployed by a trusted user.");
        // Add custom logic here
    }
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyBag(BasePlayer player, NetworkableId sleepingBag)
	{
		SleepingBag sleepingBag2 = FindForPlayer(player.userID, sleepingBag, ignoreTimers: false);
		if (sleepingBag2 == null)
		{
			return false;
		}
		if (Interface.CallHook("OnSleepingBagDestroy", sleepingBag2, player) != null)
		{
			return false;
		}
		if (sleepingBag2.canBePublic)
		{
			sleepingBag2.SetPublic(isPublic: true);
			sleepingBag2.deployerUserID = 0uL;
		}
		else
		{
			sleepingBag2.Kill();
		}
		player.SendRespawnOptions();
		Interface.CallHook("OnSleepingBagDestroyed", sleepingBag2, player);
		return true;
	}

```

## OnHorseHitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is hitched to a hitch trough.
/// </summary>
/// <param name="horse">The RidableHorse being hitched.</param>
/// <param name="hitchSpot">The HitchTrough.HitchSpot where the horse is being hitched.</param>
/// <returns>
/// Returns `true` if the horse was successfully hitched, or `false` if the hitching failed.
/// If a non-bool value is returned, it will be ignored and the default behavior of returning `true` will occur.
/// </returns>
object OnHorseHitch(RidableHorse horse, HitchSpot hitchSpot)
{
    Puts($"Horse {horse.name} has been hitched to {hitchSpot.name}.");
    if (hitchSpot == null || horse == null)
    {
        return true;
    }
    // Additional logic can be added here as needed
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool AttemptToHitch(RidableHorse horse, HitchSpot hitch = null)
	{
		if (horse == null)
		{
			return false;
		}
		if (hitch == null)
		{
			hitch = GetClosest(horse.transform.position);
		}
		if (hitch != null)
		{
			object obj = Interface.CallHook("OnHorseHitch", horse, hitch);
			if (obj is bool)
			{
				return (bool)obj;
			}
			hitch.SetOccupiedBy(horse);
			horse.SetHitch(this);
			horse.transform.SetPositionAndRotation(hitch.spot.position, hitch.spot.rotation);
			horse.DismountAllPlayers();
			return true;
		}
		return false;
	}

```

## OnBookmarkControl(ComputerStation,BasePlayer,string,IRemoteControllable)

```csharp
```csharp
/// <summary>
/// Called when a bookmark is controlled.
/// </summary>
/// <param name="computerStation">The computer station controlling the bookmark.</param>
/// <param name="player">The player controlling the bookmark.</param>
/// <param name="bookmarkName">The name of the bookmark being controlled.</param>
/// <param name="remoteControllable">The remote controllable entity being controlled.</param>
/// <returns>
/// Returns a non-null value to override the default control behavior. 
/// If `null` is returned, the bookmark will be controlled as normal.
/// </returns>
object OnBookmarkControl(BaseComputerStation computerStation, BasePlayer player, string bookmarkName, IRemoteControllable remoteControllable)
{
    Puts($"Bookmark {bookmarkName} has been controlled by player {player.UserIDString}.");
    if (remoteControllable is CCTV_RC && player.UserID == 123456)
    {
        Puts($"Player {player.UserIDString} has been blocked from controlling the CCTV bookmark.");
        return "Blocked: Unauthorized player.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void BeginControllingBookmark(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!IsPlayerAdmin(player))
		{
			return;
		}
		string text = msg.read.String();
		if (!IsValidIdentifier(text) || !controlBookmarks.Contains(text))
		{
			return;
		}
		IRemoteControllable remoteControllable = RemoteControlEntity.FindByID(text);
		if (remoteControllable == null)
		{
			return;
		}
		BaseEntity ent = remoteControllable.GetEnt();
		if (ent == null)
		{
			Debug.LogWarning("RC identifier " + text + " was found but has a null or destroyed entity, this should never happen");
		}
		else if (remoteControllable.CanControl(player.userID) && !(Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange) && Interface.CallHook("OnBookmarkControl", this, player, text, remoteControllable) == null)
		{
			BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
			if ((bool)baseEntity)
			{
				IRemoteControllable component = baseEntity.GetComponent<IRemoteControllable>();
				component?.StopControl(new CameraViewerId(currentPlayerID, 0L));
				Interface.CallHook("OnBookmarkControlEnded", this, player, component);
			}
			player.net.SwitchSecondaryGroup(ent.net.group);
			currentlyControllingEnt.uid = ent.net.ID;
			currentPlayerID = player.userID;
			bool b = remoteControllable.InitializeControl(new CameraViewerId(currentPlayerID, 0L));
			SetFlag(Flags.Reserved2, b, recursive: false, networkupdate: false);
			SendNetworkUpdateImmediate();
			SendControlBookmarks(player);
			if (Rust.GameInfo.HasAchievements && remoteControllable.GetEnt() is CCTV_RC)
			{
				InvokeRepeating(CheckCCTVAchievement, 1f, 3f);
			}
			InvokeRepeating(ControlCheck, 0f, 0f);
			Interface.CallHook("OnBookmarkControlStarted", this, player, text, remoteControllable);
		}
	}

```

## CanAssignBed(BasePlayer,SleepingBag,ulong)

```csharp
```csharp
/// <summary>
/// Called when a player tries to assign a sleeping bag.
/// </summary>
/// <param name="player">The player trying to assign the sleeping bag.</param>
/// <param name="sleepingBag">The sleeping bag being assigned.</param>
/// <param name="targetID">The ID of the target player.</param>
/// <returns>
/// Returns `true` if the assignment is allowed, and `false` otherwise.
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
bool CanAssignBed(BasePlayer player, SleepingBag sleepingBag, ulong targetID)
{
    Puts($"Player {player.displayName} is trying to assign a sleeping bag to {targetID}.");
    if (targetID == 1234567890) // Example ID
    {
        Puts($"Assignment denied for target ID {targetID}.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		if (!msg.player.CanInteract() || deployerUserID != msg.player.userID)
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num == 0L || Interface.CallHook("CanAssignBed", msg.player, this, num) != null)
		{
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null)
		{
			BaseGameMode.CanAssignBedResult? canAssignBedResult = activeGameMode.CanAssignBed(msg.player, this, num, 1, -1);
			if (canAssignBedResult.HasValue)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(num);
				if (!canAssignBedResult.Value.Result)
				{
					msg.player.ShowToast(GameTip.Styles.Red_Normal, cannotAssignBedPhrase, basePlayer?.displayName ?? "other player");
				}
				else
				{
					basePlayer?.ShowToast(GameTip.Styles.Blue_Long, assignedBagPhrase, canAssignBedResult.Value.Count.ToString(), canAssignBedResult.Value.Max.ToString());
				}
				if (!canAssignBedResult.Value.Result)
				{
					return;
				}
			}
		}
		deployerUserID = num;
		Facepunch.Rust.Analytics.Azure.OnSleepingBagAssigned(msg.player, this, num);
		SendNetworkUpdate();
		CheckForOnlineAndDead();
	}

```

## CanSwapToSeat(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can swap to this seat.
/// </summary>
/// <param name="player">The player attempting to swap.</param>
/// <param name="seat">The seat being swapped into.</param>
/// <returns>
/// Returns `true` to allow the player to swap, or `false` to prevent them from swapping.
/// If a non-bool value is returned, it will be treated as `true` and the player will be allowed to swap.
/// </returns>
object CanSwapToSeat(BasePlayer player, BaseMountable seat)
{
    Puts($"Player {player.UserIDString} attempting to swap into seat {seat.GetDisplayName()}");
    if (seat.IsLocked())
    {
        Puts($"Seat {seat.GetDisplayName()} is locked and cannot be swapped into.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

```

## OnEntityDestroy(BradleyAPC)

```csharp
```csharp
/// <summary>
/// Called when a Bradley APC is destroyed.
/// </summary>
void OnEntityDestroy(BradleyAPC bradley)
{
    Puts("Bradley APC has been destroyed.");
    
    // Create an explosion effect at the Bradley's position
    Effect.server.Run(explosionEffect.resourcePath, bradley.transform.position, Vector3.up, null, broadcast: true);
    
    // Spawn server gibs from the Bradley's position
    GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
    List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, bradley.gameObject, gibSource, Vector3.zero, 3f);
    
    // Spawn fireballs and crates from the Bradley's position
    for (int i = 0; i < 12 - maxCratesToSpawn; i++)
    {
        BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, bradley.transform.position, bradley.transform.rotation);
        if (!baseEntity)
        {
            continue;
        }
        
        // Set the fireball's position and velocity
        float min = 3f;
        float max = 10f;
        Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
        baseEntity.transform.position = bradley.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * UnityEngine.Random.Range(-4f, 4f);
        baseEntity.SetVelocity(Vector3.zero + onUnitSphere * UnityEngine.Random.Range(min, max));
        
        // Ignore collisions between the fireball and server gibs
        Collider component = baseEntity.GetComponent<Collider>();
        foreach (ServerGib item in list)
        {
            UnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);
        }
    }
    
    for (int j = 0; j < maxCratesToSpawn; j++)
    {
        // Spawn a crate from the Bradley's position
        Vector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;
        onUnitSphere2.y = 0f;
        onUnitSphere2.Normalize();
        Vector3 pos = bradley.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);
        BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
        
        // Set the crate's position and velocity
        baseEntity2.Spawn();
        LootContainer lootContainer = baseEntity2 as LootContainer;
        if ((bool)lootContainer)
        {
            lootContainer.Invoke(lootContainer.RemoveMe, 1800f);
        }
        Collider component2 = baseEntity2.GetComponent<Collider>();
        Rigidbody rigidbody = baseEntity2.gameObject.AddComponent<Rigidbody>();
        rigidbody.useGravity = true;
        rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
        rigidbody.mass = 2f;
        rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
        rigidbody.velocity = Vector3.zero + onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);
        rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
        rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
        rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);
        
        // Spawn a fireball from the crate's position
        FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
        if ((bool)fireBall)
        {
            fireBall.SetParent(baseEntity2);
            fireBall.Spawn();
            fireBall.GetComponent<Rigidbody>().isKinematic = true;
            fireBall.GetComponent<Collider>().enabled = false;
        }
        
        // Ignore collisions between the crate and server gibs
        foreach (ServerGib item2 in list)
        {
            UnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);
        }
    }
}
```
```

### Source Code from the Library

```csharp

	public override void OnKilled(HitInfo info)
	{
		if (base.isClient || Interface.CallHook("OnEntityDestroy", this) != null)
		{
			return;
		}
		CreateExplosionMarker(10f);
		Effect.server.Run(explosionEffect.resourcePath, mainTurretEyePos.transform.position, Vector3.up, null, broadcast: true);
		Vector3 zero = Vector3.zero;
		GameObject gibSource = servergibs.Get().GetComponent<ServerGib>()._gibSource;
		List<ServerGib> list = ServerGib.CreateGibs(servergibs.resourcePath, base.gameObject, gibSource, zero, 3f);
		for (int i = 0; i < 12 - maxCratesToSpawn; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(this.fireBall.resourcePath, base.transform.position, base.transform.rotation);
			if (!baseEntity)
			{
				continue;
			}
			float min = 3f;
			float max = 10f;
			Vector3 onUnitSphere = UnityEngine.Random.onUnitSphere;
			baseEntity.transform.position = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere * UnityEngine.Random.Range(-4f, 4f);
			Collider component = baseEntity.GetComponent<Collider>();
			baseEntity.Spawn();
			baseEntity.SetVelocity(zero + onUnitSphere * UnityEngine.Random.Range(min, max));
			foreach (ServerGib item in list)
			{
				UnityEngine.Physics.IgnoreCollision(component, item.GetCollider(), ignore: true);
			}
		}
		for (int j = 0; j < maxCratesToSpawn; j++)
		{
			Vector3 onUnitSphere2 = UnityEngine.Random.onUnitSphere;
			onUnitSphere2.y = 0f;
			onUnitSphere2.Normalize();
			Vector3 pos = base.transform.position + new Vector3(0f, 1.5f, 0f) + onUnitSphere2 * UnityEngine.Random.Range(2f, 3f);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(crateToDrop.resourcePath, pos, Quaternion.LookRotation(onUnitSphere2));
			baseEntity2.Spawn();
			LootContainer lootContainer = baseEntity2 as LootContainer;
			if ((bool)lootContainer)
			{
				lootContainer.Invoke(lootContainer.RemoveMe, 1800f);
			}
			Collider component2 = baseEntity2.GetComponent<Collider>();
			Rigidbody rigidbody = baseEntity2.gameObject.AddComponent<Rigidbody>();
			rigidbody.useGravity = true;
			rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
			rigidbody.mass = 2f;
			rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
			rigidbody.velocity = zero + onUnitSphere2 * UnityEngine.Random.Range(1f, 3f);
			rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
			rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
			rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);
			FireBall fireBall = GameManager.server.CreateEntity(this.fireBall.resourcePath) as FireBall;
			if ((bool)fireBall)
			{
				fireBall.SetParent(baseEntity2);
				fireBall.Spawn();
				fireBall.GetComponent<Rigidbody>().isKinematic = true;
				fireBall.GetComponent<Collider>().enabled = false;
			}
			baseEntity2.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);
			foreach (ServerGib item2 in list)
			{
				UnityEngine.Physics.IgnoreCollision(component2, item2.GetCollider(), ignore: true);
			}
		}
		base.OnKilled(info);
	}

```

## CanAcceptItem(ItemContainer,Item,int)

```csharp
```csharp
/// <summary>
/// Called to determine if an item can be accepted into the container.
/// </summary>
/// <param name="container">The container that is accepting the item.</param>
/// <param name="item">The item being considered for acceptance.</param>
/// <param name="targetPos">The position in the container where the item would be placed.</param>
/// <returns>
/// Returns a non-null value to override the default acceptance behavior. 
/// If `CanAcceptResult.CannotAccept` is returned, the item cannot be accepted into the container.
/// If `CanAcceptResult.CanAcceptRightNow` is returned, the item can be accepted into the container immediately.
/// If `null` is returned, the default acceptance behavior will be used.
/// </returns>
object CanAcceptItem(ItemContainer container, Item item, int targetPos)
{
    Puts($"Checking if item {item.info.name} can be accepted into container {container.info.name} at position {targetPos}.");
    if (item.info.occupySlots == ItemSlot.None && !container.HasEmptySlots())
    {
        return CanAcceptResult.CannotAcceptRightNow;
    }
    if ((uint)container.allowedContents & (uint)item.info.itemType) != (uint)item.info.itemType)
    {
        return CanAcceptResult.CannotAccept;
    }
    // Additional checks can be added here as needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public CanAcceptResult CanAcceptItem(Item item, int targetPos)
	{
		if (canAcceptItem != null && !canAcceptItem(item, targetPos))
		{
			return CanAcceptResult.CannotAccept;
		}
		if (isServer && availableSlots != null && availableSlots.Count > 0)
		{
			if (item.info.occupySlots == (ItemSlot)0 || item.info.occupySlots == ItemSlot.None)
			{
				return CanAcceptResult.CannotAccept;
			}
			if (item.isBroken)
			{
				return CanAcceptResult.CannotAccept;
			}
			int num = 0;
			foreach (ItemSlot availableSlot in availableSlots)
			{
				num |= (int)availableSlot;
			}
			if (((uint)num & (uint)item.info.occupySlots) != (uint)item.info.occupySlots)
			{
				return CanAcceptResult.CannotAcceptRightNow;
			}
		}
		if ((allowedContents & item.info.itemType) != item.info.itemType)
		{
			return CanAcceptResult.CannotAccept;
		}
		if (HasLimitedAllowedItems)
		{
			bool flag = false;
			for (int i = 0; i < onlyAllowedItems.Length; i++)
			{
				if (onlyAllowedItems[i] == item.info)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return CanAcceptResult.CannotAccept;
			}
		}
		object obj = Interface.CallHook("CanAcceptItem", this, item, targetPos);
		if (obj is CanAcceptResult)
		{
			return (CanAcceptResult)obj;
		}
		return CanAcceptResult.CanAccept;
	}

```

## OnItemSplit(Item,int)

```csharp
```csharp
/// <summary>
/// Called when an item is split into multiple items.
/// </summary>
/// <param name="item">The original item being split.</param>
/// <param name="splitAmount">The amount to split the item by.</param>
/// <returns>
/// Returns a new item that represents the split portion of the original item. 
/// If `null` is returned, the item will not be split.
/// </returns>
Item OnItemSplit(Item item, int splitAmount)
{
    Puts($"Item {item.info.itemid} has been split into {splitAmount} portions.");
    if (splitAmount == 0)
    {
        return null;
    }
    // Custom logic to handle splitting the item can go here
    Item new_item = ItemManager.CreateByItemID(item.info.itemid, splitAmount, 0uL);
    new_item.skin = item.skin;
    return new_item;
}
```
```

### Source Code from the Library

```csharp

	public Item SplitItem(int split_Amount)
	{
		Assert.IsTrue(split_Amount > 0, "split_Amount <= 0");
		if (split_Amount <= 0)
		{
			return null;
		}
		if (split_Amount >= amount)
		{
			return null;
		}
		object obj = Interface.CallHook("OnItemSplit", this, split_Amount);
		if (obj is Item)
		{
			return (Item)obj;
		}
		amount -= split_Amount;
		Item item = ItemManager.CreateByItemID(info.itemid, 1, 0uL);
		item.amount = split_Amount;
		item.skin = skin;
		if (IsBlueprint())
		{
			item.blueprintTarget = blueprintTarget;
		}
		if (info.amountType == ItemDefinition.AmountType.Genetics && instanceData != null && instanceData.dataInt != 0)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
		}
		if (instanceData != null && instanceData.dataInt > 0 && info != null && info.Blueprint != null && info.Blueprint.workbenchLevelRequired == 3)
		{
			item.instanceData = new ProtoBuf.Item.InstanceData();
			item.instanceData.dataInt = instanceData.dataInt;
			item.instanceData.ShouldPool = false;
			item.SetFlag(Flag.IsOn, IsOn());
		}
		MarkDirty();
		return item;
	}

```

## OnItemUpgrade(Item,Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is upgraded.
/// </summary>
/// <param name="oldItem">The original item being upgraded.</param>
/// <param name="newItem">The upgraded item.</param>
/// <param name="player">The player who performed the upgrade.</param>
/// <returns>No return behavior.</returns>
void OnItemUpgrade(Item oldItem, Item newItem, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has successfully upgraded their {oldItem.info.name} to a {newItem.info.name}.");
    if (newItem.info.category == "rare")
    {
        Puts($"The upgraded item is rare! Player {player.UserIDString} will receive a bonus reward.");
        // Add code here to give the player a bonus reward
    }
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (!(command == "upgrade_item") || item.amount < numForUpgrade)
		{
			return;
		}
		if (UnityEngine.Random.Range(0f, 1f) <= upgradeSuccessChance)
		{
			item.UseItem(numForUpgrade);
			Item item2 = ItemManager.Create(upgradedItem, numUpgradedItem, 0uL);
			Interface.CallHook("OnItemUpgrade", item, item2, player);
			if (!item2.MoveToContainer(player.inventory.containerMain))
			{
				item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
		else
		{
			item.UseItem(numToLoseOnFail);
			if (failEffect.isValid)
			{
				Effect.server.Run(failEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnHelicopterDropDoorOpen(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when the helicopter's drop door is opened or closed.
/// </summary>
/// <param name="controller">The AI controller of the CH47 helicopter.</param>
/// <returns>No return behavior.</returns>
void OnHelicopterDropDoorOpen(CH47HelicopterAIController controller)
{
    Puts($"Drop door on {controller.GetDisplayName()} has been {(controller.GetFlag(Flags.Reserved8)) ? "opened" : "closed"}}");
}
```
```

### Source Code from the Library

```csharp

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

```

## OnLootEntityEnd(BasePlayer,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when a player stops looting an entity.
/// </summary>
/// <param name="player">The player who stopped looting.</param>
/// <param name="container">The storage container being used for looting.</param>
/// <returns>No return behavior.</returns>
void OnLootEntityEnd(BasePlayer player, StorageContainer container)
{
    Puts($"Player {player.UserIDString} stopped looting entity.");
    if (container != null && container.IsLocked)
    {
        Puts($"Storage container is locked. Player cannot loot.");
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void PlayerStoppedLooting(BasePlayer player)
	{
		Interface.CallHook("OnLootEntityEnd", player, this);
		SetFlag(Flags.Open, b: false);
		SendNetworkUpdate();
	}

```

## OnItemCraft(IndustrialCrafter,ItemBlueprint)

```csharp
```csharp
/// <summary>
/// Called when an item is crafted using the industrial crafter.
/// </summary>
/// <param name="industrialCrafter">The industrial crafter that performed the craft.</param>
/// <param name="blueprint">The blueprint used for crafting.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the item will be crafted as normal.
/// </returns>
object OnItemCraft(IndustrialCrafter industrialCrafter, ItemBlueprint blueprint)
{
    Puts($"Item {blueprint.name} has been crafted using the industrial crafter.");
    if (blueprint.name == "Forbidden Item")
    {
        Puts($"Item {blueprint.name} cannot be crafted due to restrictions.");
        return "Crafting restricted.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected override void RunJob()
	{
		base.RunJob();
		if (ConVar.Server.industrialCrafterFrequency <= 0f || HasFlag(Flags.Reserved1) || currentlyCrafting != null)
		{
			return;
		}
		for (int i = 0; i <= 3; i++)
		{
			Item targetBlueprint = GetTargetBlueprint(i);
			if (targetBlueprint == null || GetWorkbench() == null || GetWorkbench().Workbenchlevel < targetBlueprint.blueprintTargetDef.Blueprint.workbenchLevelRequired)
			{
				continue;
			}
			ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;
			if (Interface.CallHook("OnItemCraft", this, blueprint) != null)
			{
				break;
			}
			bool flag = true;
			foreach (ItemAmount ingredient in blueprint.ingredients)
			{
				if ((float)GetInputAmount(ingredient.itemDef) < ingredient.amount)
				{
					flag = false;
					break;
				}
			}
			if (!flag)
			{
				continue;
			}
			flag = false;
			for (int j = 8; j <= 11; j++)
			{
				Item slot = inventory.GetSlot(j);
				if (slot == null || (slot.info == targetBlueprint.blueprintTargetDef && slot.amount + blueprint.amountToCreate <= slot.MaxStackable()))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				SetFlag(Flags.Reserved2, b: true);
				continue;
			}
			SetFlag(Flags.Reserved2, b: false);
			foreach (ItemAmount ingredient2 in blueprint.ingredients)
			{
				ConsumeInputIngredient(ingredient2);
			}
			currentlyCrafting = targetBlueprint.blueprintTargetDef;
			currentlyCraftingAmount = blueprint.amountToCreate;
			float time = blueprint.time;
			Invoke(CompleteCraft, time);
			jobFinishes = time;
			SetFlag(Flags.Reserved1, b: true);
			ClientRPC((Connection)null, "ClientUpdateCraftTimeRemaining", (float)jobFinishes, jobFinishes.Duration);
			break;
		}
	}

```

## OnExperimentStarted(Workbench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an experiment is started.
/// </summary>
/// <param name="workbench">The workbench where the experiment was started.</param>
/// <param name="player">The player who started the experiment.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the experiment is started as normal.
/// </returns>
object OnExperimentStarted(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment started by {player} on workbench {workbench}.");
    if (player == null || IsWorking())
    {
        return;
    }
    // Additional logic can be added here to handle the experiment start
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## CanChangeCode(BasePlayer,CodeLock,string,bool)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to change the code of a CodeLock.
/// </summary>
/// <param name="player">The player attempting to change the code.</param>
/// <param name="codeLock">The CodeLock being changed.</param>
/// <param name="newCode">The new code being set.</param>
/// <param name="isGuest">Whether the new code is for a guest or not.</param>
/// <returns>
/// Returns `true` to prevent the code from being changed, or `false` to allow it.
/// </returns>
bool CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuest)
{
    Puts($"Player {player.UserIDString} attempted to change the code of CodeLock {codeLock.GetID()} to '{newCode}' as a guest: {isGuest}");
    if (newCode.Length != 4 || !newCode.IsNumeric())
    {
        Puts($"Invalid new code: {newCode}. Only numeric codes of length 4 are allowed.");
        return true;
    }
    // Additional checks can be added here
    return false;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void RPC_ChangeCode(RPCMessage rpc)
	{
		if (!rpc.player.CanInteract())
		{
			return;
		}
		string text = rpc.read.String();
		bool flag = rpc.read.Bit();
		if (!IsLocked() && text.Length == 4 && text.IsNumeric() && !(!hasCode && flag) && Interface.CallHook("CanChangeCode", rpc.player, this, text, flag) == null)
		{
			if (!hasCode && !flag)
			{
				SetFlag(Flags.Locked, b: true);
			}
			Facepunch.Rust.Analytics.Azure.OnCodelockChanged(rpc.player, this, flag ? guestCode : code, text, flag);
			if (!flag)
			{
				code = text;
				hasCode = code.Length > 0;
				whitelistPlayers.Clear();
				whitelistPlayers.Add(rpc.player.userID);
			}
			else
			{
				guestCode = text;
				hasGuestCode = guestCode.Length > 0;
				guestPlayers.Clear();
				guestPlayers.Add(rpc.player.userID);
			}
			DoEffect(effectCodeChanged.resourcePath);
			SendNetworkUpdate();
		}
	}

```

## OnTurretStartup(AutoTurret)

```csharp
```csharp
/// <summary>
/// Called when a turret starts up.
/// </summary>
/// <param name="turret">The AutoTurret instance starting up.</param>
/// <returns>
/// Returns `null` to allow the turret to start up normally, or any non-null value to prevent it from starting up.
/// </returns>
object OnTurretStartup(AutoTurret turret)
{
    Puts($"Turret {turret.name} has started up.");
    if (turret.isMalfunctioning)
    {
        Puts($"Turret {turret.name} is malfunctioning and will not start up.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void InitiateStartup()
	{
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			Invoke(SetOnline, 2f);
			booting = true;
		}
	}

```

## OnEntityReskin(BaseEntity,ItemSkinDirectory.Skin,BasePlayer)

```csharp
This is a C# code snippet that appears to be part of a game server's logic for reskining entities. Here's a breakdown of the code:

**Purpose**: The purpose of this code is to reskin an entity with a new skin, which involves replacing the old skin with a new one and updating any related data.

**Key Functions**:

1. `ReskinEntity`: This function takes in several parameters:
	* `entity`: The entity to be reskinned.
	* `skin`: The new skin to apply.
	* `msg`: A message object containing information about the player who initiated the reskin request.
	* `targetSkin`: The ID of the target skin (not used in this code snippet).
2. `SaveEntityStorage` and `RestoreEntityStorage`: These functions are used to save and restore the inventory of an entity during the reskining process.

**Logic Flow**:

1. The function first checks if the entity is a decay entity, and if so, attaches it to a building.
2. It then saves the current state of the entity's storage (inventory) using `SaveEntityStorage`.
3. If the new skin has a redirect ID, it sets the entity's skin ID to 0 (which means it will use the default skin).
4. The function creates a new entity with the new skin and sets its health and last attacked time.
5. It then restores the saved state of the entity's storage using `RestoreEntityStorage`.
6. If there are any child entities that need to be reskinned, it calls `ReskinEntity` recursively on them.

**Other Functions**:

1. `LoseCondition`: This function is called with a condition loss value (not used in this code snippet).
2. `ClientRPC`: This function sends a message to the client to update its state.
3. `ClearBusy`: This function clears the busy flag after a certain cooldown period.

Overall, this code snippet appears to be part of a larger system for managing entity reskining and inventory management in a game.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void ChangeItemSkin(RPCMessage msg)
	{
		if (IsBusy())
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		int targetSkin = msg.read.Int32();
		if (msg.player == null || !msg.player.CanBuild())
		{
			return;
		}
		bool flag = false;
		if (msg.player.UnlockAllSkins)
		{
			flag = true;
		}
		if (targetSkin != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(targetSkin, msg.player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return;
		}
		if (baseNetworkable != null && baseNetworkable is BaseEntity baseEntity2)
		{
			Vector3 position = baseEntity2.WorldSpaceBounds().ClosestPoint(msg.player.eyes.position);
			if (!msg.player.IsVisible(position, 3f))
			{
				SprayFailResponse(SprayFailReason.LineOfSight);
				return;
			}
			if (baseNetworkable is Door door)
			{
				if (!door.GetPlayerLockPermission(msg.player))
				{
					msg.player.ChatMessage("Door must be openable");
					return;
				}
				if (door.IsOpen())
				{
					msg.player.ChatMessage("Door must be closed");
					return;
				}
			}
			if (!GetItemDefinitionForEntity(baseEntity2, out var def))
			{
				SprayFailResponse(SprayFailReason.InvalidItem);
				return;
			}
			ItemDefinition itemDefinition = null;
			ulong num = ItemDefinition.FindSkin(def.itemid, targetSkin);
			ItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
			if (Interface.CallHook("OnEntityReskin", baseEntity2, skin, msg.player) != null)
			{
				return;
			}
			if (skin.invItem != null && skin.invItem is ItemSkin itemSkin)
			{
				if (itemSkin.Redirect != null)
				{
					itemDefinition = itemSkin.Redirect;
				}
				else if (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) && def.isRedirectOf != null)
				{
					itemDefinition = def.isRedirectOf;
				}
			}
			else if (def.isRedirectOf != null || (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) && def.isRedirectOf != null))
			{
				itemDefinition = def.isRedirectOf;
			}
			if (itemDefinition == null)
			{
				baseEntity2.skinID = num;
				baseEntity2.SendNetworkUpdate();
				Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
			}
			else
			{
				if (!CanEntityBeRespawned(baseEntity2, out var reason2))
				{
					SprayFailResponse(reason2);
					return;
				}
				if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
				{
					Debug.LogWarning("Cannot find resource path of redirect entity to spawn! " + itemDefinition.gameObject.name);
					SprayFailResponse(SprayFailReason.InvalidItem);
					return;
				}
				Vector3 position2 = baseEntity2.transform.position;
				Quaternion rotation = baseEntity2.transform.rotation;
				BaseEntity entity = baseEntity2.GetParentEntity();
				float health = baseEntity2.Health();
				EntityRef[] slots = baseEntity2.GetSlots();
				float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
				bool flag2 = baseEntity2 is Door;
				Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
				SaveEntityStorage(baseEntity2, dictionary2, 0);
				List<ChildPreserveInfo> obj = Facepunch.Pool.GetList<ChildPreserveInfo>();
				if (flag2)
				{
					foreach (BaseEntity child in baseEntity2.children)
					{
						obj.Add(new ChildPreserveInfo
						{
							TargetEntity = child,
							TargetBone = child.parentBone,
							LocalPosition = child.transform.localPosition,
							LocalRotation = child.transform.localRotation
						});
					}
					foreach (ChildPreserveInfo item in obj)
					{
						item.TargetEntity.SetParent(null, worldPositionStays: true);
					}
				}
				else
				{
					for (int i = 0; i < baseEntity2.children.Count; i++)
					{
						SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
					}
				}
				baseEntity2.Kill();
				baseEntity2 = GameManager.server.CreateEntity(resourcePath, position2, rotation);
				baseEntity2.SetParent(entity);
				if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)
				{
					baseEntity2.skinID = 0uL;
				}
				else
				{
					baseEntity2.skinID = num;
				}
				if (baseEntity2 is DecayEntity decayEntity)
				{
					decayEntity.AttachToBuilding(null);
				}
				baseEntity2.Spawn();
				if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
				{
					baseCombatEntity2.SetHealth(health);
					baseCombatEntity2.lastAttackedTime = lastAttackedTime;
				}
				if (dictionary2.Count > 0)
				{
					RestoreEntityStorage(baseEntity2, 0, dictionary2);
					if (!flag2)
					{
						for (int j = 0; j < baseEntity2.children.Count; j++)
						{
							RestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);
						}
					}
					foreach (KeyValuePair<ContainerSet, List<Item>> item2 in dictionary2)
					{
						foreach (Item item3 in item2.Value)
						{
							Debug.Log($"Deleting {item3} as it has no new container");
							item3.Remove();
						}
					}
					Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
				}
				if (flag2)
				{
					foreach (ChildPreserveInfo item4 in obj)
					{
						item4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);
						item4.TargetEntity.transform.localPosition = item4.LocalPosition;
						item4.TargetEntity.transform.localRotation = item4.LocalRotation;
						item4.TargetEntity.SendNetworkUpdate();
					}
					baseEntity2.SetSlots(slots);
				}
				Interface.CallHook("OnEntityReskinned", baseEntity2, skin, msg.player);
				Facepunch.Pool.FreeList(ref obj);
			}
			ClientRPC(null, "Client_ReskinResult", 1, baseEntity2.net.ID);
		}
		LoseCondition(ConditionLossPerReskin);
		ClientRPC(null, "Client_ChangeSprayColour", -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (copy.ContainsKey(key))
				{
					foreach (Item item5 in copy[key])
					{
						item5.MoveToContainer(itemContainerEntity.inventory);
					}
					copy.Remove(key);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (!dictionary.ContainsKey(key2))
				{
					dictionary.Add(key2, new List<Item>());
					foreach (Item item6 in itemContainerEntity2.inventory.itemList)
					{
						dictionary[key2].Add(item6);
					}
					{
						foreach (Item item7 in dictionary[key2])
						{
							item7.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log("Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
		void SprayFailResponse(SprayFailReason reason)
		{
			ClientRPC(null, "Client_ReskinResult", 0, (int)reason);
		}
	}

```

## OnPlayerSpawn(BasePlayer,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a player spawns.
/// </summary>
/// <param name="player">The player spawning.</param>
/// <param name="connection">The connection of the player spawning.</param>
/// <returns>
/// Returns `null` to override the default spawn behavior. 
/// If a non-null value is returned, the player will not be spawned.
/// </returns>
object OnPlayerSpawn(BasePlayer player, Network.Connection connection)
{
    Puts($"Player {player.displayName} with SteamID {player.userID} and IP {connection.ipaddress} is spawning.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} has been blocked from spawning.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private BasePlayer SpawnNewPlayer(Network.Connection connection)
	{
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint();
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", basePlayer, connection) != null)
		{
			return null;
		}
		basePlayer.health = 0f;
		basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
		basePlayer.ResetLifeStateOnSpawn = false;
		basePlayer.limitNetworking = true;
		basePlayer.Spawn();
		basePlayer.limitNetworking = false;
		basePlayer.PlayerInit(connection);
		if ((bool)BaseGameMode.GetActiveGameMode(serverside: true))
		{
			BaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer);
		}
		else if (UnityEngine.Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife))
		{
			basePlayer.Respawn();
		}
		else
		{
			basePlayer.SendRespawnOptions();
		}
		DebugEx.Log($"{basePlayer.displayName} with steamid {basePlayer.userID} joined from ip {basePlayer.net.connection.ipaddress}");
		DebugEx.Log($"\tNetworkId {basePlayer.userID} is {basePlayer.net.ID} ({basePlayer.displayName})");
		if (basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
		{
			DebugEx.Log($"\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}");
		}
		return basePlayer;
	}

```

## CanRenameBed(BasePlayer,SleepingBag,string)

```csharp
```csharp
/// <summary>
/// Called to check if a player can rename a bed.
/// </summary>
/// <param name="player">The player attempting to rename the bed.</param>
/// <param name="bed">The bed being renamed.</param>
/// <param name="newName">The proposed new name for the bed.</param>
/// <returns>
/// Returns `null` if the player can rename the bed with the given name, or any non-null value to prevent renaming.
/// </returns>
object CanRenameBed(BasePlayer player, SleepingBag bed, string newName)
{
    Puts($"Player {player.UserIDString} is trying to rename their sleeping bag to '{newName}'");
    if (newName == "Admin's Bed")
    {
        Puts($"Player {player.displayName} cannot rename their sleeping bag to '{newName}'");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Rename(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		string text = msg.read.String();
		if (Interface.CallHook("CanRenameBed", msg.player, this, text) == null)
		{
			text = WordFilter.Filter(text);
			if (string.IsNullOrEmpty(text))
			{
				text = "Unnamed Sleeping Bag";
			}
			if (text.Length > 24)
			{
				text = text.Substring(0, 22) + "..";
			}
			niceName = text;
			SendNetworkUpdate();
		}
	}

```

## OnAirdrop(CargoPlane,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when an airdrop is performed.
/// </summary>
/// <param name="cargoPlane">The cargo plane performing the airdrop.</param>
/// <param name="dropPosition">The position where the airdrop will be dropped.</param>
/// <returns>No return behavior.</returns>
void OnAirdrop(CargoPlane cargoPlane, Vector3 dropPosition)
{
    Puts($"Airdrop performed by {cargoPlane.name} at position: {dropPosition}");
    if (Vector3.Distance(dropPosition, new Vector3(0f, 100f, 0f)) < 10f)
    {
        Puts($"Airdrop dropped too close to the base.");
        // Handle airdrop being dropped too close to the base
    }
}
```
```

### Source Code from the Library

```csharp

	public void UpdateDropPosition(Vector3 newDropPosition)
	{
		float x = TerrainMeta.Size.x;
		float y = TerrainMeta.HighestPoint.y + 250f;
		startPos = Vector3Ex.Range(-1f, 1f);
		startPos.y = 0f;
		startPos.Normalize();
		startPos *= x * 2f;
		startPos.y = y;
		endPos = startPos * -1f;
		endPos.y = startPos.y;
		startPos += newDropPosition;
		endPos += newDropPosition;
		secondsToTake = Vector3.Distance(startPos, endPos) / 50f;
		secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);
		base.transform.position = startPos;
		base.transform.rotation = Quaternion.LookRotation(endPos - startPos);
		dropPosition = newDropPosition;
		Interface.CallHook("OnAirdrop", this, newDropPosition);
	}

```

## CanFireLiquidWeapon(BasePlayer,LiquidWeapon)

```csharp
```csharp
/// <summary>
/// Called to determine if a liquid weapon can be fired.
/// </summary>
/// <param name="player">The player attempting to fire the liquid weapon.</param>
/// <param name="liquidWeapon">The liquid weapon being fired.</param>
/// <returns>
/// Returns `true` if the liquid weapon can be fired, or `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanFireLiquidWeapon(BasePlayer player, LiquidWeapon liquidWeapon)
{
    Puts($"Checking if {player.UserIDString} can fire liquid weapon {liquidWeapon.Name}");
    if (liquidWeapon.IsEmpty())
    {
        Puts($"Liquid weapon is empty, cannot fire.");
        return false;
    }
    if (!player.HasPermission(Permissions.UseLiquidWeapons))
    {
        Puts($"Player does not have permission to use liquid weapons.");
        return false;
    }
    // Additional checks can be added here as needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	private bool CanFire(BasePlayer player)
	{
		object obj = Interface.CallHook("CanFireLiquidWeapon", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (RequiresPumping && pressure < PressureLossPerTick)
		{
			return false;
		}
		if (player == null)
		{
			return false;
		}
		if (HasFlag(Flags.Open))
		{
			return false;
		}
		if (AmountHeld() <= 0)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (!player.CanAttack() || player.IsRunning())
		{
			return false;
		}
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return false;
		}
		return true;
	}

```

## OnNetworkGroupLeft(BaseNetworkable,Network.Visibility.Group)

```csharp
```csharp
/// <summary>
/// Called when a network group is left.
/// </summary>
/// <param name="networkable">The network object that left the group.</param>
/// <param name="group">The group that was left.</param>
/// <returns>No return behavior.</returns>
void OnNetworkGroupLeft(BaseNetworkable networkable, Network.Visibility.Group group)
{
    Puts($"Network group {group} has been left by {networkable.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", this, group);
	}

```

## OnBigWheelLoss(BigWheelGame,Item,BigWheelBettingTerminal)

```csharp
```csharp
/// <summary>
/// Called when a player loses money on the Big Wheel.
/// </summary>
/// <param name="game">The Big Wheel game instance.</param>
/// <param name="item">The item that was lost.</param>
/// <param name="terminal">The betting terminal where the loss occurred.</param>
/// <returns>
/// Returns a non-null value to override the default loss behavior. 
/// If `null` is returned, the player loses money as normal.
/// </returns>
object OnBigWheelLoss(BigWheelGame game, Item item, BigWheelBettingTerminal terminal)
{
    Puts($"Player lost {item.amount} units on the Big Wheel at terminal {terminal.id}.");
    if (item.amount > 1000)
    {
        Puts($"Player's loss exceeded the threshold of 1000 units. No payout will be made.");
        return null;
    }
    // Additional logic can go here to handle the loss in a custom way
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) == null)
				{
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(null, "WinOrLoseSound", flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanAssignMission(BasePlayer,BaseMission,IMissionProvider)

```csharp
```csharp
/// <summary>
/// Called when a mission is assigned to a player.
/// </summary>
/// <param name="player">The player who was assigned the mission.</param>
/// <param name="mission">The mission that was assigned.</param>
/// <param name="provider">The provider of the mission.</param>
/// <returns>
/// Returns `true` if the mission can be assigned, or any non-null value to override the default assignment behavior.
/// If a string is returned, the player will not receive the mission and an error message will be displayed.
/// </returns>
object OnMissionAssigned(BasePlayer player, BaseMission mission, IMissionProvider provider)
{
    Puts($"Player {player.UserIDString} has been assigned mission {mission.id} by {provider.ProviderID()}");
    if (mission.id == "high-risk")
    {
        Puts($"Player {player.displayName} does not have the required clearance for mission {mission.id}");
        return "Insufficient clearance";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", assignee, mission, provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.createdEntities = Pool.GetList<MissionEntity>();
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			missionInstance.objectiveStatuses[i] = new MissionInstance.ObjectiveStatus();
		}
		assignee.AddMission(missionInstance);
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(assignee.missions.Count - 1);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", mission, provider, assignee);
		return true;
	}

```

## OnWeaponModChange(BaseProjectile,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a weapon mod is changed.
/// </summary>
/// <param name="projectile">The projectile that the mod was changed on.</param>
/// <param name="player">The player who made the change.</param>
/// <returns>
/// Returns `null` to allow the default behavior of updating the magazine capacity and sending a network update. 
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnWeaponModChange(BaseProjectile projectile, BasePlayer player)
{
    Puts($"Player {player.displayName} changed a weapon mod on projectile {projectile.name}.");
    // You can add custom logic here to handle the mod change
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DelayedModsChanged()
	{
		if (Interface.CallHook("OnWeaponModChange", this, GetOwnerPlayer()) != null)
		{
			return;
		}
		int num = Mathf.CeilToInt(ProjectileWeaponMod.Mult(this, (ProjectileWeaponMod x) => x.magazineCapacity, (ProjectileWeaponMod.Modifier y) => y.scalar, 1f) * (float)primaryMagazine.definition.builtInSize);
		if (num == primaryMagazine.capacity)
		{
			return;
		}
		if (primaryMagazine.contents > 0 && primaryMagazine.contents > num)
		{
			_ = primaryMagazine.ammoType;
			int contents = primaryMagazine.contents;
			BasePlayer ownerPlayer = GetOwnerPlayer();
			ItemContainer itemContainer = null;
			if (ownerPlayer != null)
			{
				itemContainer = ownerPlayer.inventory.containerMain;
			}
			else if (GetCachedItem() != null)
			{
				itemContainer = GetCachedItem().parent;
			}
			primaryMagazine.contents = 0;
			if (itemContainer != null)
			{
				Item item = ItemManager.Create(primaryMagazine.ammoType, contents, 0uL);
				if (!item.MoveToContainer(itemContainer))
				{
					Vector3 vPos = base.transform.position;
					if (itemContainer.entityOwner != null)
					{
						vPos = itemContainer.entityOwner.transform.position + Vector3.up * 0.25f;
					}
					item.Drop(vPos, Vector3.up * 5f);
				}
			}
		}
		primaryMagazine.capacity = num;
		SendNetworkUpdate();
	}

```

## OnTakeCurrencyItem(NPCVendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called when a currency item is taken from the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine that was used to take the currency.</param>
/// <param name="takenItem">The currency item that was taken.</param>
/// <returns>
/// Returns `null` to allow the currency item to be taken, or any non-null value to prevent it from being taken.
/// </returns>
object OnTakeCurrencyItem(NPCVendingMachine vendingMachine, Item takenItem)
{
    Puts($"Currency item {takenItem.info.name} was taken from vending machine {vendingMachine.info.name}");
    if (takenItem.info.name == "Gold Coin")
    {
        Puts($"Player tried to take a Gold Coin but it's not available.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null)
		{
			takenCurrencyItem.MoveToContainer(base.inventory);
			takenCurrencyItem.RemoveFromContainer();
			takenCurrencyItem.Remove();
		}
	}

```

## OnCorpsePopulate(FrankensteinPet,NPCPlayerCorpse)

```csharp
```csharp
/// <summary>
/// Called when a corpse is populated.
/// </summary>
/// <param name="pet">The FrankensteinPet instance that created the corpse.</param>
/// <param name="corpse">The NPCPlayerCorpse instance being populated.</param>
/// <returns>
/// Returns a non-null value to override the default corpse population behavior. 
/// If a `BaseCorpse` is returned, it will be used as the new corpse instead of the original one.
/// </returns>
object OnCorpsePopulate(FrankensteinPet pet, NPCPlayerCorpse corpse)
{
    Puts($"A corpse has been populated for FrankensteinPet {pet.name}.");
    if (corpse.playerSteamID == userID)
    {
        Puts($"The corpse belongs to the player with Steam ID {userID}, so it will be treated as a special case.");
        // Add custom logic here to handle the special case
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override BaseCorpse CreateCorpse()
	{
		using (TimeWarning.New("Create corpse"))
		{
			NPCPlayerCorpse nPCPlayerCorpse = DropCorpse("assets/rust.ai/agents/NPCPlayer/pet/frankensteinpet_corpse.prefab") as NPCPlayerCorpse;
			if ((bool)nPCPlayerCorpse)
			{
				nPCPlayerCorpse.transform.position = nPCPlayerCorpse.transform.position + Vector3.down * NavAgent.baseOffset;
				nPCPlayerCorpse.SetLootableIn(2f);
				nPCPlayerCorpse.SetFlag(Flags.Reserved5, HasPlayerFlag(PlayerFlags.DisplaySash));
				nPCPlayerCorpse.SetFlag(Flags.Reserved2, b: true);
				nPCPlayerCorpse.TakeFrom(inventory.containerMain, inventory.containerWear, inventory.containerBelt);
				nPCPlayerCorpse.playerName = OverrideCorpseName();
				nPCPlayerCorpse.playerSteamID = userID;
				nPCPlayerCorpse.Spawn();
				ItemContainer[] containers = nPCPlayerCorpse.containers;
				for (int i = 0; i < containers.Length; i++)
				{
					containers[i].Clear();
				}
			}
			object obj = Interface.CallHook("OnCorpsePopulate", this, nPCPlayerCorpse);
			if (obj is BaseCorpse)
			{
				return (BaseCorpse)obj;
			}
			return nPCPlayerCorpse;
		}
	}

```

## OnItemAction(Item,string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is used or interacted with.
/// </summary>
/// <param name="item">The item being interacted with.</param>
/// <param name="action">The action being performed on the item (e.g. "use", "drop", etc.).</param>
/// <param name="player">The player performing the action.</param>
/// <returns>
/// Returns a non-null value to override the default behavior for this action.
/// If `null` is returned, the default behavior will be used.
/// </returns>
object OnItemAction(Item item, string action, BasePlayer player)
{
    Puts($"Player {player.UserID} has performed action '{action}' on item {item.ItemID}.");
    if (action == "use" && item.IsLocked())
    {
        Puts($"Player {player.UserID} attempted to use locked item {item.ItemID}.");
        return "Item is locked.";
    }
    else if (action == "drop" && !CanDropItems(player))
    {
        Puts($"Player {player.UserID} does not have permission to drop items.");
        return "You do not have permission to drop items.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	private void ItemCmd(BaseEntity.RPCMessage msg)
	{
		if (msg.player != null && msg.player.IsWounded())
		{
			return;
		}
		ItemId id = msg.read.ItemID();
		string text = msg.read.String();
		Item item = FindItemUID(id);
		if (item == null || Interface.CallHook("OnItemAction", item, text, msg.player) != null || item.IsLocked() || (item.parent != null && item.parent.IsLocked()) || !CanMoveItemsFrom(item.GetEntityOwner(), item))
		{
			return;
		}
		if (text == "drop")
		{
			int num = item.amount;
			if (msg.read.Unread >= 4)
			{
				num = msg.read.Int32();
			}
			base.baseEntity.stats.Add("item_drop", 1, (Stats)5);
			if (num < item.amount)
			{
				Item item2 = item.SplitItem(num);
				if (item2 != null)
				{
					DroppedItem droppedItem = item2.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;
					if (droppedItem != null)
					{
						droppedItem.DropReason = DroppedItem.DropReasonEnum.Player;
						droppedItem.DroppedBy = base.baseEntity.userID;
						Facepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem, DroppedItem.DropReasonEnum.Player);
					}
				}
			}
			else
			{
				DroppedItem droppedItem2 = item.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity()) as DroppedItem;
				if (droppedItem2 != null)
				{
					droppedItem2.DropReason = DroppedItem.DropReasonEnum.Player;
					droppedItem2.DroppedBy = base.baseEntity.userID;
					Facepunch.Rust.Analytics.Azure.OnItemDropped(base.baseEntity, droppedItem2, DroppedItem.DropReasonEnum.Player);
				}
			}
			base.baseEntity.SignalBroadcast(BaseEntity.Signal.Gesture, "drop_item");
		}
		else
		{
			item.ServerCommand(text, base.baseEntity);
			ItemManager.DoRemoves();
			ServerUpdate(0f);
		}
	}

```

## OnItemUnwrap(Item,BasePlayer,ItemModUnwrap)

```csharp
```csharp
/// <summary>
/// Called when an item is unwrapped.
/// </summary>
/// <param name="item">The item being unwrapped.</param>
/// <param name="player">The player who is unwrapping the item.</param>
/// <param name="unwrapData">Additional data related to the unwrap operation, such as the item mod used for unwrapping.</param>
/// <returns>
/// Returns `null` to allow the item to be unwrapped normally. 
/// If a non-null value is returned, it will override the default unwrap behavior.
/// </returns>
object OnItemUnwrap(Item item, BasePlayer player, ItemModUnwrap unwrapData)
{
    Puts($"Player {player.UserIDString} has unwrapped item {item.info.name}.");
    if (unwrapData.itemModName == "Prohibited Mod")
    {
        Puts($"Player {player.displayName} is not allowed to use the Prohibited Mod.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "unwrap" && item.amount > 0 && Interface.CallHook("OnItemUnwrap", item, player, this) == null)
		{
			item.UseItem();
			int num = UnityEngine.Random.Range(minTries, maxTries + 1);
			for (int i = 0; i < num; i++)
			{
				revealList.SpawnIntoContainer(player.inventory.containerMain);
			}
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnItemDeployed(Deployer,ItemModDeployable,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an item is deployed.
/// </summary>
/// <param name="deployer">The entity that deployed the item.</param>
/// <param name="modDeployable">The mod deployable item being deployed.</param>
/// <param name="baseEntity">The base entity created from the deployment.</param>
object OnItemDeployed(BaseEntity deployer, ItemModDeployable modDeployable, BaseEntity baseEntity)
{
    Puts($"Item {modDeployable.name} has been deployed by {deployer.name}.");
    if (baseEntity is null || !baseEntity.IsValid())
    {
        return;
    }
    
    // Add custom logic here if needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoDeploy_Regular(Deployable deployable, Ray ray)
	{
		if (!HasItemAmount())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (!ownerPlayer.CanBuild())
		{
			ownerPlayer.ChatMessage("Building is blocked at player position!");
		}
		else if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
		}
		else
		{
			if (!CheckPlacement(deployable, ray, 8f) || !UnityEngine.Physics.Raycast(ray, out var hitInfo, 8f, 1235288065))
			{
				return;
			}
			Vector3 point = hitInfo.point;
			Quaternion deployedRotation = GetDeployedRotation(hitInfo.normal, ray.direction);
			Item ownerItem = GetOwnerItem();
			ItemModDeployable modDeployable = GetModDeployable();
			if (ownerPlayer.Distance(point) > 3f)
			{
				ownerPlayer.ChatMessage("Too far away!");
				return;
			}
			if (!ownerPlayer.CanBuild(point, deployedRotation, deployable.bounds))
			{
				ownerPlayer.ChatMessage("Building is blocked at placement position!");
				return;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(modDeployable.entityPrefab.resourcePath, point, deployedRotation);
			if (!baseEntity)
			{
				Debug.LogWarning("Couldn't create prefab:" + modDeployable.entityPrefab.resourcePath);
				return;
			}
			baseEntity.skinID = ownerItem.skin;
			baseEntity.SendMessage("SetDeployedBy", ownerPlayer, SendMessageOptions.DontRequireReceiver);
			baseEntity.OwnerID = ownerPlayer.userID;
			baseEntity.Spawn();
			modDeployable.OnDeployed(baseEntity, ownerPlayer);
			Interface.CallHook("OnItemDeployed", this, modDeployable, baseEntity);
			Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
			UseItemAmount(1);
		}
	}

```

## OnMissionStarted(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is started.
/// </summary>
/// <param name="mission">The mission being started.</param>
/// <param name="instance">The mission instance being started.</param>
/// <param name="assignee">The player assigned to the mission.</param>
/// <returns>
/// Returns `null` to allow the mission to start normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnMissionStarted(BaseMission mission, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts($"Mission {mission.name} has been started for player {assignee.displayName}.");
    if (instance.missionType == "HighRisk")
    {
        Puts($"Warning: Mission {mission.name} is a high-risk mission. Proceed with caution.");
        return "High-Risk Warning";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", this, instance, assignee) != null)
		{
			return;
		}
		SetupRewards(instance, assignee);
		SetupPositions(instance, assignee);
		AddBlockers(instance);
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.entityRef.isValid)
			{
				Vector3 missionPoint = instance.GetMissionPoint(missionEntityEntry.spawnPositionToUse, assignee);
				BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);
				MissionEntity missionEntity = baseEntity.gameObject.AddComponent<MissionEntity>();
				missionEntity.Setup(assignee, instance, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
				instance.createdEntities.Add(missionEntity);
				baseEntity.Spawn();
			}
		}
		foreach (MissionEntity createdEntity in instance.createdEntities)
		{
			createdEntity.MissionStarted(assignee, instance);
		}
		Interface.CallHook("OnMissionStarted", this, instance, assignee);
	}

```

## OnMessagePlayer(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="message">The text of the chat message.</param>
/// <param name="player">The player who sent the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be displayed as normal, or any non-null value to prevent the message from being displayed.
/// </returns>
object OnMessagePlayer(string message, BasePlayer player)
{
    Puts($"Player {player.UserIDString} sent a chat message: {message}");
    if (message.ToLower() == "admin command")
    {
        Puts($"Player {player.displayName} is not allowed to send admin commands.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ChatMessage(string msg)
	{
		if (base.isServer && Interface.CallHook("OnMessagePlayer", msg, this) == null)
		{
			SendConsoleCommand("chat.add", 2, 0, msg);
		}
	}

```

## OnFireBallSpread(FireBall,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when a fireball spreads.
/// </summary>
/// <param name="fireBall">The fireball that is spreading.</param>
/// <param name="newFireBall">The new fireball entity created by the spread.</param>
/// <returns>No return behavior.</returns>
void OnFireBallSpread(FireBall fireBall, BaseEntity newFireBall)
{
    Puts($"Fireball {fireBall.id} has spawned a new fireball at position: {newFireBall.transform.position}");
    if (newFireBall.transform.position.x > 10f)
    {
        Puts($"New fireball {newFireBall.id} is too far away from the original fireball.");
        return;
    }
    // Additional logic can be added here to handle the spread of the fireball
}
```
```

### Source Code from the Library

```csharp

	public void TryToSpread()
	{
		float num = 0.9f - generation * 0.1f;
		if (UnityEngine.Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if ((bool)baseEntity)
			{
				baseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = ((creatorEntity == null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", this, baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));
				baseEntity.SendMessage("SetGeneration", generation + 1f);
			}
		}
	}

```

## OnPortalUse(BasePlayer,BasePortal)

```csharp
```csharp
/// <summary>
/// Called when a player uses a portal.
/// </summary>
/// <param name="player">The player using the portal.</param>
/// <param name="portal">The portal being used.</param>
/// <returns>
/// Returns `null` to allow the player to use the portal, or any non-null value to prevent them from using it.
/// </returns>
object OnPortalUse(BasePlayer player, BasePortal portal)
{
    Puts($"Player {player.UserIDString} is using portal {portal.name}");
    if (portal.isLocked)
    {
        Puts($"Player {player.UserIDString} cannot use locked portal {portal.name}");
        return "Portal is locked";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void UsePortal(BasePlayer player)
	{
		if (Interface.CallHook("OnPortalUse", player, this) != null)
		{
			return;
		}
		LinkPortal();
		if (targetPortal != null)
		{
			player.PauseFlyHackDetection();
			player.PauseSpeedHackDetection();
			Vector3 position = player.transform.position;
			Vector3 vector = targetPortal.GetLocalEntryExitPosition();
			Vector3 vector2 = base.transform.InverseTransformDirection(player.eyes.BodyForward());
			Vector3 vector3 = vector2;
			if (isMirrored)
			{
				Vector3 position2 = base.transform.InverseTransformPoint(player.transform.position);
				vector = targetPortal.relativeAnchor.transform.TransformPoint(position2);
				vector3 = targetPortal.relativeAnchor.transform.TransformDirection(vector2);
			}
			else
			{
				vector3 = targetPortal.GetLocalEntryExitRotation() * Vector3.forward;
			}
			if (disappearEffect.isValid)
			{
				Effect.server.Run(disappearEffect.resourcePath, position, Vector3.up);
			}
			if (appearEffect.isValid)
			{
				Effect.server.Run(appearEffect.resourcePath, vector, Vector3.up);
			}
			player.SetParent(null, worldPositionStays: true);
			player.Teleport(vector);
			player.ForceUpdateTriggers();
			player.ClientRPCPlayer(null, player, "ForceViewAnglesTo", vector3);
			if (transitionSoundEffect.isValid)
			{
				Effect.server.Run(transitionSoundEffect.resourcePath, targetPortal.relativeAnchor.transform.position, Vector3.up);
			}
			player.UpdateNetworkGroup();
			player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, b: true);
			SendNetworkUpdateImmediate();
			player.ClientRPCPlayer(null, player, "StartLoading_Quick", arg1: true);
			Interface.CallHook("OnPortalUsed", player, this);
		}
		else
		{
			Debug.Log("No portal...");
		}
	}

```

## OnTrapTrigger(BearTrap,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="trap">The trap that was triggered.</param>
/// <param name="target">The object that triggered the trap.</param>
/// <returns>No return behavior.</returns>
void OnTrapTrigger(BearTrap trap, GameObject target)
{
    Puts($"Trap {trap.name} triggered by {target.name}");
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (Armed() && Interface.CallHook("OnTrapTrigger", this, obj) == null)
		{
			hurtTarget = obj;
			Invoke(DelayedFire, 0.05f);
		}
	}

```

## OnRidableAnimalClaim(BaseRidableAnimal,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a player claims a ridable animal.
/// </summary>
/// <param name="animal">The ridable animal being claimed.</param>
/// <param name="player">The player claiming the animal.</param>
/// <param name="item">The item used to claim the animal, if any.</param>
/// <returns>
/// Returns `null` to allow the player to claim the animal, or any non-null value to prevent them from claiming it.
/// </returns>
object OnRidableAnimalClaim(BaseRidableAnimal animal, BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} is attempting to claim ridable animal {animal.ShortPrefabName}.");
    if (item != null && item.info.name == "Golden Key")
    {
        Puts($"Player {player.displayName} used a Golden Key to claim the ridable animal.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsForSale())
		{
			int tokenItemID = msg.read.Int32();
			Item item = GetPurchaseToken(player, tokenItemID);
			if (item != null && Interface.CallHook("OnRidableAnimalClaim", this, player, item) == null)
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(item);
				item.UseItem();
				Facepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);
				Facepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## CanLock(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to lock the object.
/// </summary>
/// <param name="player">The player attempting to lock the object.</param>
/// <param name="lock">The KeyLock instance being locked or unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to lock the object, or any non-null value to prevent them from locking it.
/// </returns>
object CanLock(BasePlayer player, KeyLock lock)
{
    Puts($"Player {player.UserIDString} is attempting to lock the object.");
    if (lock.IsLocked())
    {
        Puts($"Object is already locked by another player.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	private void Lock(BasePlayer player)
	{
		if (!(player == null) && player.CanInteract() && !IsLocked() && Interface.CallHook("CanLock", player, this) == null && HasLockPermission(player))
		{
			LockLock(player);
			SendNetworkUpdate();
		}
	}

```

## OnNpcDuck(HumanNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC's duck state is updated.
/// </summary>
/// <param name="npc">The HumanNPC instance whose duck state has been updated.</param>
/// <returns>No return behavior.</returns>
void OnNpcDuck(HumanNPC npc)
{
    Puts($"NPC {npc.name} has {(npc.modelState.ducked ? "ducked" : "un-ducked")}.");
}
```
```

### Source Code from the Library

```csharp

	public void SetDucked(bool flag)
	{
		if (Interface.CallHook("OnNpcDuck", this) == null)
		{
			modelState.ducked = flag;
			SendNetworkUpdate();
		}
	}

```

## OnElevatorButtonPress(ElevatorLift,BasePlayer,Elevator.Direction,bool)

```csharp
```csharp
/// <summary>
/// Called when an elevator button is pressed.
/// </summary>
/// <param name="elevator">The elevator that received the button press.</param>
/// <param name="player">The player who pressed the button.</param>
/// <param name="direction">The direction in which the elevator will move (Up or Down).</param>
/// <param name="isButtonPress">Whether this is a button press event or not.</param>
/// <returns>
/// Returns `null` to allow the elevator to move, or any non-null value to prevent it from moving.
/// </returns>
object OnElevatorButtonPress(ElevatorLift elevator, BasePlayer player, Elevator.Direction direction, bool isButtonPress)
{
    Puts($"Elevator {elevator.name} received button press from player {player.UserIDString} in direction {direction}.");
    if (isButtonPress && direction == Elevator.Direction.Up)
    {
        Puts($"Player {player.displayName} pressed the up button on elevator {elevator.name}.");
        return "Up button pressed.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Server_RaiseLowerFloor(RPCMessage msg)
	{
		if (!CanMove())
		{
			return;
		}
		Elevator.Direction direction = (Elevator.Direction)msg.read.Int32();
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnElevatorButtonPress", this, msg.player, direction, flag) == null)
		{
			SetFlag((direction == Elevator.Direction.Up) ? Flags.Reserved1 : Flags.Reserved2, b: true);
			owner.Server_RaiseLowerElevator(direction, flag);
			Invoke(ClearDirection, 0.7f);
			if (liftButtonPressedEffect.isValid)
			{
				Effect.server.Run(liftButtonPressedEffect.resourcePath, base.transform.position, Vector3.up);
			}
		}
	}

```

## OnTrapTrigger(Landmine,UnityEngine.GameObject)

```csharp
```csharp
/// <summary>
/// Called when a trap is triggered.
/// </summary>
/// <param name="landmine">The landmine that was triggered.</param>
/// <param name="victim">The player who triggered the landmine.</param>
/// <returns>
/// Returns `null` to allow the trap to trigger normally, or any non-null value to prevent the trap from triggering.
/// </returns>
object OnTrapTrigger(Landmine landmine, BasePlayer victim)
{
    Puts($"Landmine {landmine.name} triggered by player {victim.displayName}");
    if (victim.isSuperAdmin)
    {
        Puts($"Player {victim.displayName} is a super admin and cannot trigger the landmine.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ObjectEntered(GameObject obj)
	{
		if (!base.isClient)
		{
			if (!Armed())
			{
				CancelInvoke(Arm);
				blocked = true;
			}
			else if (Interface.CallHook("OnTrapTrigger", this, obj) == null)
			{
				BasePlayer ply = GameObjectEx.ToBaseEntity(obj) as BasePlayer;
				Trigger(ply);
			}
		}
	}

```

## OnRidableAnimalClaimed(BaseRidableAnimal,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a ridable animal is claimed by a player.
/// </summary>
/// <param name="animal">The ridable animal being claimed.</param>
/// <param name="player">The player claiming the animal.</param>
/// <returns>
/// Returns `null` to allow the player to claim the animal, or any non-null value to prevent them from claiming it.
/// </returns>
object OnRidableAnimalClaimed(BaseRidableAnimal animal, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has claimed ridable animal {animal.ShortPrefabName}.");
    if (player.IsAdmin)
    {
        Puts($"Player {player.displayName} is an admin and cannot claim the ridable animal.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Claim(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!(player == null) && IsForSale())
		{
			int tokenItemID = msg.read.Int32();
			Item item = GetPurchaseToken(player, tokenItemID);
			if (item != null && Interface.CallHook("OnRidableAnimalClaim", this, player, item) == null)
			{
				SetFlag(Flags.Reserved2, b: false);
				OnClaimedWithToken(item);
				item.UseItem();
				Facepunch.Rust.Analytics.Server.VehiclePurchased(base.ShortPrefabName);
				Facepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);
				AttemptMount(player, doMountChecks: false);
				Interface.CallHook("OnRidableAnimalClaimed", this, player);
			}
		}
	}

```

## OnTeamKick(RelationshipManager.PlayerTeam,BasePlayer,ulong)

```csharp
```csharp
/// <summary>
/// Called when a team member is kicked.
/// </summary>
/// <param name="team">The team from which the player was kicked.</param>
/// <param name="kickedPlayer">The player who was kicked.</param>
/// <param name="newTeamID">The ID of the new team to which the player will be moved.</param>
/// <returns>
/// Returns `null` to allow the kick operation to proceed, or any non-null value to prevent the kick.
/// </returns>
object OnTeamKick(PlayerTeam team, BasePlayer kickedPlayer, ulong newTeamID)
{
    Puts($"Player {kickedPlayer.UserIDString} was kicked from team {team.Name} and moved to team with ID {newTeamID}");
    if (newTeamID == 1234567890)
    {
        Puts($"Player {kickedPlayer.UserIDString} cannot be moved to team with ID {newTeamID} due to security restrictions.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[ServerUserVar]
	public static void kickmember(ConsoleSystem.Arg arg)
	{
		BasePlayer basePlayer = ArgEx.Player(arg);
		if (basePlayer == null)
		{
			return;
		}
		PlayerTeam playerTeam = ServerInstance.FindTeam(basePlayer.currentTeam);
		if (playerTeam != null && !(playerTeam.GetLeader() != basePlayer))
		{
			ulong uLong = arg.GetULong(0, 0uL);
			if (basePlayer.userID != uLong && Interface.CallHook("OnTeamKick", playerTeam, basePlayer, uLong) == null)
			{
				playerTeam.RemovePlayer(uLong);
			}
		}
	}

```

## CanBeTargeted(BasePlayer,FlameTurret)

```csharp
```csharp
/// <summary>
/// Called to check if a player can be targeted by the turret.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="turret">The turret doing the targeting.</param>
/// <returns>
/// Returns `true` if the player can be targeted, `false` otherwise.
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeTargeted(BasePlayer player, FlameTurret turret)
{
    Puts($"Checking if {player.displayName} can be targeted by {turret.name}.");
    if (player.IsSleeping() || !player.IsAlive())
    {
        return false;
    }
    object result = Interface.CallHook("CanBeTargeted", player, turret);
    if (result is bool)
    {
        return result;
    }
    // Add custom logic here to determine if the player can be targeted
    // For example:
    if (player.GetRole() == "Admin")
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CheckTrigger()
	{
		if (Time.realtimeSinceStartup < nextTriggerCheckTime)
		{
			return false;
		}
		nextTriggerCheckTime = Time.realtimeSinceStartup + 1f / triggerCheckRate;
		List<RaycastHit> obj = Pool.GetList<RaycastHit>();
		HashSet<BaseEntity> entityContents = trigger.entityContents;
		bool flag = false;
		if (entityContents != null)
		{
			foreach (BaseEntity item in entityContents)
			{
				BasePlayer component = item.GetComponent<BasePlayer>();
				if (component.IsSleeping() || !component.IsAlive())
				{
					continue;
				}
				object obj2 = Interface.CallHook("CanBeTargeted", component, this);
				if (obj2 is bool)
				{
					Pool.FreeList(ref obj);
					return (bool)obj2;
				}
				if (!(component.transform.position.y <= GetEyePosition().y + 0.5f) || component.IsBuildingAuthed())
				{
					continue;
				}
				obj.Clear();
				GamePhysics.TraceAll(new Ray(component.eyes.position, (GetEyePosition() - component.eyes.position).normalized), 0f, obj, 9f, 1218519297);
				for (int i = 0; i < obj.Count; i++)
				{
					BaseEntity entity = RaycastHitEx.GetEntity(obj[i]);
					if (entity != null && (entity == this || entity.EqualNetID(this)))
					{
						flag = true;
						break;
					}
					if (!(entity != null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		Pool.FreeList(ref obj);
		return flag;
	}

```

## OnPlayerSpectateEnd(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player ends spectating.
/// </summary>
/// <param name="player">The player ending spectation.</param>
/// <param name="filter">The filter used for spectating, which could be a player name or other identifier.</param>
/// <returns>
/// Returns `null` to allow the player to end spectating normally. 
/// If a non-null value is returned, it will override the default behavior and prevent the player from ending spectation.
/// </returns>
object OnPlayerSpectateEnd(BasePlayer player, string filter)
{
    Puts($"Player {player.UserIDString} ended spectating with filter: {filter}");
    if (filter == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to end spectation with filter: {filter}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopSpectating()
	{
		if (IsSpectating() && Interface.CallHook("OnPlayerSpectateEnd", this, spectateFilter) == null)
		{
			SetParent(null);
			SetPlayerFlag(PlayerFlags.Spectating, b: false);
			UnityEngine.TransformEx.SetLayerRecursive(base.gameObject, 17);
		}
	}

```

## CanUseVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the vending machine.
/// </summary>
/// <param name="player">The player attempting to use the vending machine.</param>
/// <param name="vendingMachine">The vending machine being used.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the vending machine, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} attempted to use vending machine {vendingMachine.name}");
    if (player.IsAdmin)
    {
        Puts("Admins are allowed to use the vending machine.");
        return true;
    }
    else if (player.HasPermission("use_vending_machine"))
    {
        Puts("Player has permission to use the vending machine.");
        return true;
    }
    else
    {
        Puts("Player does not have permission to use the vending machine.");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool CanOpenLootPanel(BasePlayer player, string panelName)
	{
		object obj = Interface.CallHook("CanUseVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (panelName == customerPanel)
		{
			return true;
		}
		if (base.CanOpenLootPanel(player, panelName))
		{
			return CanPlayerAdmin(player);
		}
		return false;
	}

```

## OnServerInitialize()

```csharp
```csharp
/// <summary>
/// Called when the server is initializing.
/// </summary>
void OnServerInitialize()
{
    Puts("Server initialization started.");
    // Add any necessary code here to perform custom server initialization tasks.
    // For example, you could load custom maps or spawn entities.
    // If you need to access specific components or services, you can do so here as well.
    
    // Example: Load a custom map
    // MapManager.LoadMap("CustomMap");
    
    // Example: Spawn a custom entity
    // EntitySpawner.SpawnEntity("CustomEntity", Vector3.zero);
    
    Puts("Server initialization complete.");
}
```
```

### Source Code from the Library

```csharp

	public void Initialize(bool loadSave = true, string saveFile = "", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)
	{
		Interface.CallHook("OnServerInitialize");
		persistance = new UserPersistance(ConVar.Server.rootFolder);
		playerStateManager = new PlayerStateManager(persistance);
		SpawnMapEntities();
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			using (TimeWarning.New("SpawnHandler.UpdateDistributions"))
			{
				SingletonComponent<SpawnHandler>.Instance.UpdateDistributions();
			}
		}
		if (loadSave)
		{
			World.LoadedFromSave = true;
			World.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));
		}
		else
		{
			SaveRestore.SaveCreatedTime = DateTime.UtcNow;
			World.LoadedFromSave = false;
		}
		SaveRestore.InitializeWipeId();
		if ((bool)SingletonComponent<SpawnHandler>.Instance)
		{
			if (!skipInitialSpawn)
			{
				using (TimeWarning.New("SpawnHandler.InitialSpawn", 200))
				{
					SingletonComponent<SpawnHandler>.Instance.InitialSpawn();
				}
			}
			using (TimeWarning.New("SpawnHandler.StartSpawnTick", 200))
			{
				SingletonComponent<SpawnHandler>.Instance.StartSpawnTick();
			}
		}
		CreateImportantEntities();
		auth = GetComponent<ConnectionAuth>();
		Facepunch.Rust.Analytics.Azure.Initialize();
	}

```

## IOnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved.
/// </summary>
/// <param name="entity">The entity being saved.</param>
/// <param name="saveInfo">Information about the save operation.</param>
/// <returns>No return behavior.</returns>
void IOnEntitySaved(BaseNetworkable entity, SaveInfo saveInfo)
{
    Puts($"Entity {entity} has been saved with info: {saveInfo}");
    if (entity is BasePlayer player && player.IsSpectating())
    {
        Puts($"Entity {player} is a spectating player.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void ToStream(Stream stream, SaveInfo saveInfo)
	{
		using (saveInfo.msg = Facepunch.Pool.Get<ProtoBuf.Entity>())
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError(string.Concat(this, ": ToStream - no BaseEntity!?"));
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError(string.Concat(this, ": ToStream - no baseNetworkable!?"));
			}
			Interface.CallHook("IOnEntitySaved", this, saveInfo);
			saveInfo.msg.ToProto(stream);
			PostSave(saveInfo);
		}
	}

```

## OnTeamDisbanded(RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team is disbanded.
/// </summary>
/// <param name="team">The team that was disbanded.</param>
/// <returns>
/// Returns `null` to allow the team to be disbanded, or any non-null value to prevent the team from being disbanded.
/// </returns>
object OnTeamDisbanded(RelationshipManager.PlayerTeam team)
{
    Puts($"Team {team.teamName} has been disbanded.");
    if (team.teamName == "Admins")
    {
        Puts($"Team {team.teamName} cannot be disbanded.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Facepunch.Pool.Free(ref teamToDisband);
		}
	}

```

## OnHorseUnhitch(RidableHorse,HitchTrough.HitchSpot)

```csharp
```csharp
/// <summary>
/// Called when a horse is unhitched from its hitch spot.
/// </summary>
/// <param name="horse">The horse being unhitched.</param>
/// <param name="hitchSpot">The hitch spot where the horse was previously hitched.</param>
/// <returns>
/// Returns `null` to allow the horse to be unhitched, or any non-null value to prevent the horse from being unhitched.
/// </returns>
object OnHorseUnhitch(RidableHorse horse, HitchSpot hitchSpot)
{
    Puts($"Horse {horse.GetDisplayName()} has been unhitched from hitch spot {hitchSpot.GetDisplayName()}");
    if (hitchSpot.GetOccupiedBy() == null)
    {
        Puts($"Hitch spot {hitchSpot.GetDisplayName()} is already empty.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Unhitch(RidableHorse horse)
	{
		HitchSpot[] array = hitchSpots;
		foreach (HitchSpot hitchSpot in array)
		{
			if (hitchSpot.GetHorse(base.isServer) == horse)
			{
				if (Interface.CallHook("OnHorseUnhitch", horse, hitchSpot) != null)
				{
					break;
				}
				hitchSpot.SetOccupiedBy(null);
				horse.SetHitch(null);
			}
		}
	}

```

## OnMissionAssigned(BaseMission,IMissionProvider,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission is assigned to a player.
/// </summary>
/// <param name="mission">The mission being assigned.</param>
/// <param name="provider">The mission provider that provided the mission.</param>
/// <param name="assignee">The player who was assigned the mission.</param>
/// <returns>
/// Returns `true` if the mission assignment should be allowed, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a reason for rejecting the mission assignment.
/// </returns>
object OnMissionAssigned(BaseMission mission, IMissionProvider provider, BasePlayer assignee)
{
    Puts($"Mission {mission.name} assigned to player {assignee.displayName} by provider {provider.ProviderID()}");
    if (provider.ProviderID() == "Invalid Provider")
    {
        Puts($"Mission assignment rejected: Invalid mission provider.");
        return "Invalid mission provider.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AssignMission(BasePlayer assignee, IMissionProvider provider, BaseMission mission)
	{
		if (!missionsenabled)
		{
			return false;
		}
		if (!mission.IsEligableForMission(assignee, provider))
		{
			return false;
		}
		object obj = Interface.CallHook("CanAssignMission", assignee, mission, provider);
		if (obj is bool)
		{
			return (bool)obj;
		}
		MissionInstance missionInstance = Pool.Get<MissionInstance>();
		missionInstance.missionID = mission.id;
		missionInstance.startTime = Time.time;
		missionInstance.providerID = provider.ProviderID();
		missionInstance.status = MissionStatus.Active;
		missionInstance.createdEntities = Pool.GetList<MissionEntity>();
		missionInstance.objectiveStatuses = new MissionInstance.ObjectiveStatus[mission.objectives.Length];
		for (int i = 0; i < mission.objectives.Length; i++)
		{
			missionInstance.objectiveStatuses[i] = new MissionInstance.ObjectiveStatus();
		}
		assignee.AddMission(missionInstance);
		mission.MissionStart(missionInstance, assignee);
		assignee.SetActiveMission(assignee.missions.Count - 1);
		assignee.MissionDirty();
		Interface.CallHook("OnMissionAssigned", mission, provider, assignee);
		return true;
	}

```

## OnRefreshVendingStock(VendingMachine,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called when the stock of a vending machine is refreshed.
/// </summary>
/// <param name="vendingMachine">The vending machine whose stock is being refreshed.</param>
/// <param name="itemDefinition">The item definition for which the stock is being refreshed (optional).</param>
/// <returns>
/// Returns `null` to allow the default behavior of refreshing the stock. 
/// If a non-null value is returned, it will override the default behavior and be used as the new stock level.
/// </returns>
object OnRefreshVendingStock(VendingMachine vendingMachine, ItemDefinition itemDefinition)
{
    Puts($"Refreshing stock for vending machine {vendingMachine.name} with item definition {itemDefinition.itemid}.");
    // You can put your custom logic here to override the default behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RefreshSellOrderStockLevel(ItemDefinition itemDef = null)
	{
		foreach (ProtoBuf.VendingMachine.SellOrder sellOrder in sellOrders.sellOrders)
		{
			if (!(itemDef == null) && itemDef.itemid != sellOrder.itemToSellID)
			{
				continue;
			}
			List<Item> obj = Facepunch.Pool.GetList<Item>();
			GetItemsToSell(sellOrder, obj);
			int inStock;
			if (obj.Count < 0)
			{
				inStock = 0;
			}
			else
			{
				List<Item> source = obj;
				Func<Item, int> selector = (Item x) => x.amount;
				Interface.CallHook("OnRefreshVendingStock", this, itemDef);
				inStock = source.Sum(selector) / sellOrder.itemToSellAmount;
			}
			sellOrder.inStock = inStock;
			float itemCondition = 0f;
			float itemConditionMax = 0f;
			int instanceData = 0;
			if (obj.Count > 0)
			{
				if (obj[0].hasCondition)
				{
					itemCondition = obj[0].condition;
					itemConditionMax = obj[0].maxCondition;
				}
				if (obj[0].info != null && obj[0].info.amountType == ItemDefinition.AmountType.Genetics && obj[0].instanceData != null)
				{
					instanceData = obj[0].instanceData.dataInt;
					sellOrder.inStock = obj[0].amount;
				}
			}
			sellOrder.itemCondition = itemCondition;
			sellOrder.itemConditionMax = itemConditionMax;
			sellOrder.instanceData = instanceData;
			Facepunch.Pool.FreeList(ref obj);
		}
	}

```

## OnTreeMarkerHit(TreeEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a tree marker is hit.
/// </summary>
/// <param name="treeEntity">The entity of the tree that was hit.</param>
/// <param name="hitInfo">Information about the hit, including the position and normal of the hit.</param>
/// <returns>
/// Returns `true` if the hit should be considered a marker hit, or `false` otherwise.
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnTreeMarkerHit(TreeEntity treeEntity, HitInfo hitInfo)
{
    Puts($"Tree {treeEntity.name} was hit at position {hitInfo.HitPositionWorld} with normal {hitInfo.attackNormal}");
    if (Vector3.Distance(treeEntity.transform.position, hitInfo.HitPositionWorld) <= 0.1f && Vector3.Dot(hitInfo.attackNormal, treeEntity.transform.up) >= 0.5f)
    {
        Puts($"Hit was within 10cm of the tree's center and had a normal pointing up");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool DidHitMarker(HitInfo info)
	{
		if (xMarker == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnTreeMarkerHit", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PrefabAttribute.server.Find<TreeMarkerData>(prefabID) != null)
		{
			if (new Bounds(xMarker.transform.position, Vector3.one * 0.2f).Contains(info.HitPositionWorld))
			{
				return true;
			}
		}
		else
		{
			Vector3 lhs = Vector3Ex.Direction2D(base.transform.position, xMarker.transform.position);
			Vector3 attackNormal = info.attackNormal;
			float num = Vector3.Dot(lhs, attackNormal);
			float num2 = Vector3.Distance(xMarker.transform.position, info.HitPositionWorld);
			if (num >= 0.3f && num2 <= 0.2f)
			{
				return true;
			}
		}
		return false;
	}

```

## OnShopAcceptClick(ShopFront,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player clicks the "Accept" button in a shop.
/// </summary>
/// <param name="shopFront">The shop front where the click occurred.</param>
/// <param name="player">The player who clicked the button.</param>
/// <returns>
/// Returns `null` to allow the trade to proceed, or any non-null value to cancel the trade.
/// </returns>
object OnShopAcceptClick(ShopFront shopFront, BasePlayer player)
{
    Puts($"Player {player.UserIDString} has accepted a trade at shop front {shopFront.name}.");
    if (player.HasFlag(Flags.Reserved1) && player.HasFlag(Flags.Reserved2))
    {
        Puts($"Both vendor and customer have locked their inventories. Trade will be completed in 2 seconds.");
        return null;
    }
    return "Trade cancelled: Vendor or customer inventory not locked.";
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AcceptClicked(RPCMessage msg)
	{
		if (IsTradingPlayer(msg.player) && !(vendorPlayer == null) && !(customerPlayer == null) && Interface.CallHook("OnShopAcceptClick", this, msg.player) == null)
		{
			if (IsPlayerVendor(msg.player))
			{
				SetFlag(Flags.Reserved1, b: true);
				vendorInventory.SetLocked(isLocked: true);
			}
			else if (IsPlayerCustomer(msg.player))
			{
				SetFlag(Flags.Reserved2, b: true);
				customerInventory.SetLocked(isLocked: true);
			}
			if (HasFlag(Flags.Reserved1) && HasFlag(Flags.Reserved2))
			{
				SetFlag(Flags.Reserved3, b: true);
				Invoke(CompleteTrade, 2f);
			}
		}
	}

```

## OnEngineLoadoutRefresh(Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called when the engine loadout is refreshed.
/// </summary>
/// <param name="storage">The engine storage data.</param>
/// <returns>
/// Returns `null` to allow the loadout to be refreshed normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for the player.
/// </returns>
object OnEngineLoadoutRefresh(Rust.Modular.EngineStorage storage)
{
    Puts("Engine loadout has been refreshed.");
    if (storage.GetBoostsAcceleration() < 50)
    {
        Puts("Warning: Acceleration boost is low.");
        return "Warning: Acceleration boost is low.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RefreshLoadoutData()
	{
		if (Interface.CallHook("OnEngineLoadoutRefresh", this) == null)
		{
			isUsable = base.inventory.IsFull() && base.inventory.itemList.All((Item item) => !item.isBroken);
			accelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;
			topSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;
			fuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;
			SendNetworkUpdate();
			GetEngineModule()?.RefreshPerformanceStats(this);
		}
	}

```

## OnItemRecycle(Item,Recycler)

```csharp
```csharp
/// <summary>
/// Called when an item is recycled.
/// </summary>
/// <param name="item">The item being recycled.</param>
/// <param name="recycler">The recycler that is recycling the item.</param>
/// <returns>
/// Returns a non-null value to override the default recycling behavior. 
/// If a string is returned, the item will be kicked with the provided message as the reason. 
/// If `null` is returned, the item is recycled as normal.
/// </returns>
object OnItemRecycle(Item item, Recycler recycler)
{
    Puts($"Item {item.info.shortname} has been recycled by {recycler}.");
    if (item.amount > 1 && UnityEngine.Random.Range(0f, 1f) <= 0.5f)
    {
        Puts($"Only half of the item {item.info.shortname} was recycled.");
        return "Half recycled: " + item.amount / 2;
    }
    else
    {
        Facepunch.Rust.Analytics.Azure.OnItemRecycled(item.info.shortname, item.amount, recycler);
        // Rest of the recycling logic remains the same
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = recycleEfficiency;
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", slot, this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", slot, num3, this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					int num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 = Mathf.CeilToInt((float)num4 * slot.conditionNormalized);
					}
					if (num4 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num4, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj2 = Facepunch.Pool.GetList<BasePlayer>();
					Vis.Entities(base.transform.position, 3f, obj2, 131072);
					foreach (BasePlayer item3 in obj2)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Facepunch.Pool.FreeList(ref obj2);
				}
				Facepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num5 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
					int num6 = 0;
					if (num5 <= 1f)
					{
						for (int i = 0; i < num3; i++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= num5 * num)
							{
								num6++;
							}
						}
					}
					else
					{
						num6 = Mathf.CeilToInt(Mathf.Clamp(num5 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount)) * num3;
					}
					if (num6 <= 0)
					{
						continue;
					}
					int num7 = Mathf.CeilToInt((float)num6 / (float)ingredient.itemDef.stackable);
					for (int j = 0; j < num7; j++)
					{
						int num8 = ((num6 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num6);
						Item item2 = ItemManager.Create(ingredient.itemDef, num8, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
						if (!MoveItemToOutput(item2))
						{
							flag = true;
						}
						num6 -= num8;
						if (num6 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

```

## CanCraft(ItemCrafter,ItemBlueprint,int,bool)

```csharp
```csharp
/// <summary>
/// Called to check if a craft can be performed.
/// </summary>
/// <param name="craftTask">The item crafter performing the craft.</param>
/// <param name="blueprint">The blueprint being used for crafting.</param>
/// <param name="amount">The amount of items to craft. Defaults to 1.</param>
/// <param name="free">Whether the craft is free or not. Defaults to false.</param>
/// <returns>
/// Returns `true` if the craft can be performed, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for why the craft cannot be performed.
/// </returns>
object CanCraft(ItemCrafter craftTask, ItemBlueprint blueprint, int amount = 1, bool free = false)
{
    Puts($"Checking if craft of {amount}x {blueprint.targetItem.name} can be performed by {craftTask.name}.");
    if (amount < 0 || amount > blueprint.targetItem.craftingStackable)
    {
        return "Invalid amount: must be between 1 and " + blueprint.targetItem.craftingStackable;
    }
    object result = Interface.CallHook("CanCraft", craftTask, blueprint, amount, free);
    if (result is bool)
    {
        return result;
    }
    foreach (ItemAmount ingredient in blueprint.ingredients)
    {
        if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
        {
            return "Missing required ingredients: " + ingredient.itemid;
        }
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanCraft(ItemBlueprint bp, int amount = 1, bool free = false)
	{
		float num = (float)amount / (float)bp.targetItem.craftingStackable;
		foreach (ItemCraftTask item in queue)
		{
			if (!item.cancelled)
			{
				num += (float)item.amount / (float)item.blueprint.targetItem.craftingStackable;
			}
		}
		if (num > 8f)
		{
			return false;
		}
		if (amount < 1 || amount > bp.targetItem.craftingStackable)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", this, bp, amount, free);
		if (obj is bool)
		{
			return (bool)obj;
		}
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			if (!DoesHaveUsableItem(ingredient.itemid, (int)ingredient.amount * amount))
			{
				return false;
			}
		}
		return true;
	}

```

## CanUseLockedEntity(BasePlayer,KeyLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="entity">The locked entity in question.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the locked entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
bool CanUseLockedEntity(BasePlayer player, KeyLock entity)
{
    Puts($"Player {player.UserIDString} attempted to use locked entity {entity.EntityID}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.UserIDString} is an admin and can access the locked entity");
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (HasLockPermission(player))
		{
			return true;
		}
		return !IsLocked();
	}

```

## OnBookmarkControlEnd(ComputerStation,BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when control of a bookmarked entity ends.
/// </summary>
/// <param name="computerStation">The computer station that was controlling the entity.</param>
/// <param name="player">The player who was controlling the entity.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>
/// Returns `null` to allow control to end normally, or any non-null value to prevent control from ending.
/// </returns>
object OnBookmarkControlEnd(ComputerStation computerStation, BasePlayer player, BaseEntity entity)
{
    Puts($"Control of bookmarked entity {entity.EntityID} has ended.");
    if (player.UserIDString == "admin")
    {
        Puts($"Admin {player.displayName} is not allowed to end control of bookmarked entities.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if ((bool)ply)
		{
			ply.net.SwitchSecondaryGroup(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
		CancelInvoke(CheckCCTVAchievement);
		Interface.CallHook("OnBookmarkControlEnded", this, ply, baseEntity);
	}

```

## OnElevatorCall(Elevator,Elevator)

```csharp
```csharp
/// <summary>
/// Called when an elevator is called.
/// </summary>
/// <param name="elevator">The elevator being called.</param>
/// <param name="caller">The entity that called the elevator.</param>
/// <returns>
/// Returns `null` to allow the elevator to be called, or any non-null value to prevent it from being called.
/// </returns>
object OnElevatorCall(Elevator caller, Elevator elevator)
{
    Puts($"Elevator {elevator.Name} has been called by {caller.Name}");
    if (elevator.IsBroken)
    {
        Puts($"Elevator {elevator.Name} is currently broken and cannot be called.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void CallElevator()
	{
		EntityLinkBroadcast(delegate(Elevator elevatorEnt)
		{
			if (elevatorEnt.IsTop && Interface.CallHook("OnElevatorCall", this, elevatorEnt) == null)
			{
				elevatorEnt.RequestMoveLiftTo(Floor, out var _, this);
			}
		}, (ConstructionSocket socket) => socket.socketType == ConstructionSocket.Type.Elevator);
	}

```

## CanHideStash(BasePlayer,StashContainer)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can hide their stash.
/// </summary>
/// <param name="player">The player attempting to hide their stash.</param>
/// <param name="stashContainer">The stash container being hidden.</param>
/// <returns>
/// Returns `null` to allow the player to hide their stash, or any non-null value to prevent them from hiding it.
/// </returns>
object CanHideStash(BasePlayer player, StashContainer stashContainer)
{
    Puts($"Player {player.UserIDString} is trying to hide their stash.");
    if (stashContainer.IsLocked)
    {
        Puts($"Player {player.UserIDString} cannot hide a locked stash.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_HideStash(RPCMessage rpc)
	{
		if (Interface.CallHook("CanHideStash", rpc.player, this) == null)
		{
			Facepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);
			SetHidden(isHidden: true);
			Interface.CallHook("OnStashHidden", this, rpc.player);
		}
	}

```

## OnPlayerDismountFailed(BasePlayer,BaseMountable)

```csharp
```csharp
/// <summary>
/// Called when a player fails to dismount from an object.
/// </summary>
/// <param name="player">The player who failed to dismount.</param>
/// <param name="objectBeingDismountedFrom">The object the player was trying to dismount from.</param>
/// <returns>No return behavior.</returns>
void OnPlayerDismountFailed(BasePlayer player, BaseMountable objectBeingDismountedFrom)
{
    Puts($"Player {player.UserIDString} failed to dismount from {objectBeingDismountedFrom.DisplayName}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", player, this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", player, this) == null)
		{
			AttemptDismount(player);
		}
	}

```

## OnTurretDeauthorize(AutoTurret,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a turret is deauthorized from a player.
/// </summary>
/// <param name="turret">The AutoTurret instance that was deauthorized.</param>
/// <param name="player">The BasePlayer instance that the turret was deauthorized for.</param>
/// <returns>No return behavior.</returns>
void OnTurretDeauthorize(AutoTurret turret, BasePlayer player)
{
    Puts($"Turret {turret.entityID} has been deauthorized from player {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", this, rpc.player) == null)
		{
			authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc2.player.userID);
			Facepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

```

## OnItemPickup(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player picks up an item.
/// </summary>
/// <param name="item">The item being picked up.</param>
/// <param name="player">The player picking up the item.</param>
/// <returns>
/// Returns `null` to allow the player to pick up the item, or any non-null value to prevent them from picking it up.
/// </returns>
object OnItemPickup(Item item, BasePlayer player)
{
    Puts($"Player {player.UserIDString} picked up item {item.name}");
    if (item.name == "rare_item")
    {
        Puts($"Player {player.displayName} is not allowed to pick up the rare item");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void Pickup(RPCMessage msg)
	{
		if (msg.player.CanInteract() && this.item != null && allowPickup && Interface.CallHook("OnItemPickup", this.item, msg.player) == null)
		{
			ClientRPC(null, "PickupSound");
			Item item = this.item;
			Facepunch.Rust.Analytics.Azure.OnItemPickup(msg.player, this);
			RemoveItem();
			msg.player.GiveItem(item, GiveItemReason.PickedUp);
			msg.player.SignalBroadcast(Signal.Gesture, "pickup_item");
		}
	}

```

## OnItemDespawn(Item)

```csharp
```csharp
/// <summary>
/// Called when an item despawns.
/// </summary>
/// <param name="item">The item that has despawned.</param>
/// <returns>No return behavior.</returns>
void OnItemDespawn(Item item)
{
    Puts($"Item {item.info.name} with ID {item.info.id} has despawned.");
}
```
```

### Source Code from the Library

```csharp

	public void IdleDestroy()
	{
		Interface.CallHook("OnItemDespawn", item);
		Facepunch.Rust.Analytics.Azure.OnItemDespawn(this, item, (int)DropReason, DroppedBy);
		DestroyItem();
		Kill();
	}

```

## OnNpcTarget(HumanNPC,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC is targeting a player.
/// </summary>
/// <param name="npc">The NPC doing the targeting.</param>
/// <param name="target">The player being targeted.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the player, or any non-null value to prevent them from targeting that player.
/// </returns>
object OnNpcTarget(HumanNPC npc, BaseEntity target)
{
    Puts($"NPC {npc.name} is targeting player {target.UserIDString}.");
    if (target == Brain.Senses.Players[0])
    {
        Puts($"NPC {npc.name} has been instructed not to target the first player in its senses.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public BaseEntity GetBestTarget()
	{
		BaseEntity result = null;
		float num = -1f;
		foreach (BaseEntity player in Brain.Senses.Players)
		{
			if (!(player == null) && !(player.Health() <= 0f) && Interface.CallHook("OnNpcTarget", this, player) == null)
			{
				float value = Vector3.Distance(player.transform.position, base.transform.position);
				float num2 = 1f - Mathf.InverseLerp(1f, Brain.SenseRange, value);
				float value2 = Vector3.Dot((player.transform.position - eyes.position).normalized, eyes.BodyForward());
				num2 += Mathf.InverseLerp(Brain.VisionCone, 1f, value2) / 2f;
				num2 += (Brain.Senses.Memory.IsLOS(player) ? 2f : 0f);
				if (num2 > num)
				{
					result = player;
					num = num2;
				}
			}
		}
		return result;
	}

```

## OnSprayCreate(SprayCan,UnityEngine.Vector3,UnityEngine.Quaternion)

```csharp
```csharp
/// <summary>
/// Called when a spray can is created.
/// </summary>
/// <param name="sprayCan">The spray can entity.</param>
/// <param name="position">The position of the spray can.</param>
/// <param name="rotation">The rotation of the spray can.</param>
/// <returns>
/// Returns `null` to allow the default creation behavior. 
/// If a non-null value is returned, it will override the default creation behavior.
/// </returns>
object OnSprayCreate(BaseEntity sprayCan, Vector3 position, Quaternion rotation)
{
    Puts($"Spray can created at {position} with rotation {rotation}");
    // Example: override the default creation behavior to set a custom skin
    if (Interface.CallHook("OnCustomSkinOverride") != null)
    {
        sprayCan.skinID = Interface.CallHook("OnCustomSkinOverride");
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void CreateSpray(RPCMessage msg)
	{
		if (IsBusy())
		{
			return;
		}
		ClientRPC(null, "Client_ChangeSprayColour", -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		Vector3 vector = msg.read.Vector3();
		Vector3 vector2 = msg.read.Vector3();
		Vector3 point = msg.read.Vector3();
		int num = msg.read.Int32();
		if (!(Vector3.Distance(vector, base.transform.position) > 4.5f))
		{
			Quaternion quaternion = Quaternion.LookRotation((new Plane(vector2, vector).ClosestPointOnPlane(point) - vector).normalized, vector2);
			quaternion *= Quaternion.Euler(0f, 0f, 90f);
			bool flag = false;
			if (msg.player.IsDeveloper)
			{
				flag = true;
			}
			if (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))
			{
				Debug.Log($"SprayCan.ChangeItemSkin player does not have item :{num}:");
			}
			else if (Interface.CallHook("OnSprayCreate", this, vector, quaternion) == null)
			{
				ulong num2 = ItemDefinition.FindSkin(SprayDecalItem.itemid, num);
				BaseEntity baseEntity = GameManager.server.CreateEntity(SprayDecalEntityRef.resourcePath, vector, quaternion);
				baseEntity.skinID = num2;
				baseEntity.OnDeployed(null, GetOwnerPlayer(), GetItem());
				baseEntity.Spawn();
				CheckAchievementPosition(vector);
				LoseCondition(ConditionLossPerSpray);
			}
		}
	}

```

## CanUpdateSign(BasePlayer,Signage)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can update a sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="signage">The signage being updated (not used in this implementation).</param>
/// <returns>
/// Returns `true` if the player is allowed to update the sign, or `false` otherwise.
/// </returns>
bool CanUpdateSign(BasePlayer player, Signage signage)
{
    Puts($"Player {player.UserIDString} attempted to update a sign.");
    if (signage.IsLocked && player.userID != signage.OwnerID)
    {
        Puts($"Player {player.UserIDString} does not own the locked sign.");
        return false;
    }
    if (!player.CanBuild())
    {
        Puts($"Player {player.UserIDString} is not allowed to build.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		if (!HeldEntityCheck(player))
		{
			return false;
		}
		return true;
	}

```

## OnPlayerRespawn(BasePlayer,SleepingBag)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player who is respawning.</param>
/// <param name="sleepingBag">The sleeping bag that the player is using to respawn.</param>
/// <returns>
/// Returns a non-null value to override the default respawn behavior. 
/// If a `SleepingBag` object is returned, it will be used instead of the original sleeping bag.
/// </returns>
object OnPlayerRespawn(BasePlayer player, SleepingBag sleepingBag)
{
    Puts($"Player {player.UserIDString} has respawned using sleeping bag {sleepingBag.net.ID}.");
    if (sleepingBag.net.ID == "CustomSleepingBag")
    {
        Puts($"Player {player.displayName} is using a custom sleeping bag to respawn.");
        return new SleepingBag("CustomRespawnBag");
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool SpawnPlayer(BasePlayer player, NetworkableId sleepingBag)
	{
		BasePlayer player2 = player;
		SleepingBag[] array = FindForPlayer(player2.userID, ignoreTimers: true);
		SleepingBag sleepingBag2 = array.FirstOrDefault((SleepingBag x) => x.ValidForPlayer(player2.userID, ignoreTimers: false) && x.net.ID == sleepingBag && x.unlockTime < UnityEngine.Time.realtimeSinceStartup);
		if (sleepingBag2 == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", player, sleepingBag2);
		if (obj is SleepingBag)
		{
			sleepingBag2 = (SleepingBag)obj;
		}
		if (sleepingBag2.IsOccupied())
		{
			return false;
		}
		sleepingBag2.GetSpawnPos(out var pos, out var rot);
		player2.RespawnAt(pos, rot, sleepingBag2);
		sleepingBag2.PostPlayerSpawn(player2);
		SleepingBag[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			SetBagTimer(array2[i], pos, SleepingBagResetReason.Respawned);
		}
		return true;
	}

```

## CanUnlockTechTreeNodePath(BasePlayer,TechTreeData.NodeInstance,TechTreeData)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can unlock a tech tree node path.
/// </summary>
/// <param name="player">The player attempting to unlock the path.</param>
/// <param name="node">The starting node of the path.</param>
/// <param name="techTreeData">The data for the tech tree being unlocked.</param>
/// <returns>
/// Returns `true` if the player can unlock the path, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUnlockTechTreeNodePath(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTreeData)
{
    Puts($"Player {player.UserIDString} attempting to unlock tech tree path starting from node {node.Name}");
    if (techTreeData.LockedNodes.Contains(node))
    {
        Puts($"Node {node.Name} is locked in the tech tree.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool PlayerHasPathForUnlock(BasePlayer player, NodeInstance node)
	{
		object obj = Interface.CallHook("CanUnlockTechTreeNodePath", player, node, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		NodeInstance entryNode = GetEntryNode();
		if (entryNode == null)
		{
			return false;
		}
		return CheckChainRecursive(player, entryNode, node);
	}

```

## OnEntityReskinned(BaseEntity,ItemSkinDirectory.Skin,BasePlayer)

```csharp
This is a C# code snippet that appears to be part of a game server's logic for reskining entities. Here's a breakdown of the code:

**Purpose**: The purpose of this code is to reskin an entity with a new skin, which involves replacing the old skin with a new one and updating any related data.

**Key Functions**:

1. `ReskinEntity`: This function takes in several parameters:
	* `entity`: The entity to be reskinned.
	* `skin`: The new skin to apply.
	* `msg`: A message object containing information about the player who initiated the reskin request.
	* `targetSkin`: The ID of the target skin (not used in this code snippet).
2. `SaveEntityStorage` and `RestoreEntityStorage`: These functions are used to save and restore the inventory of an entity during the reskining process.

**Logic Flow**:

1. The function first checks if the entity is a decay entity, and if so, attaches it to a building.
2. It then saves the current state of the entity's storage (inventory) using `SaveEntityStorage`.
3. If the new skin has a redirect ID, it sets the entity's skin ID to 0 (which means it will use the default skin).
4. The function creates a new entity with the new skin and sets its health and last attacked time.
5. It then restores the saved state of the entity's storage using `RestoreEntityStorage`.
6. If there are any child entities that need to be reskinned, it calls `ReskinEntity` recursively on them.

**Other Functions**:

1. `LoseCondition`: This function is called with a condition loss value (not used in this code snippet).
2. `ClientRPC`: This function sends a message to the client to update its state.
3. `ClearBusy`: This function clears the busy flag after a certain cooldown period.

Overall, this code snippet appears to be part of a larger system for managing entity reskining and inventory management in a game.
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void ChangeItemSkin(RPCMessage msg)
	{
		if (IsBusy())
		{
			return;
		}
		NetworkableId uid = msg.read.EntityID();
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(uid);
		int targetSkin = msg.read.Int32();
		if (msg.player == null || !msg.player.CanBuild())
		{
			return;
		}
		bool flag = false;
		if (msg.player.UnlockAllSkins)
		{
			flag = true;
		}
		if (targetSkin != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(targetSkin, msg.player.userID))
		{
			SprayFailResponse(SprayFailReason.SkinNotOwned);
			return;
		}
		if (baseNetworkable != null && baseNetworkable is BaseEntity baseEntity2)
		{
			Vector3 position = baseEntity2.WorldSpaceBounds().ClosestPoint(msg.player.eyes.position);
			if (!msg.player.IsVisible(position, 3f))
			{
				SprayFailResponse(SprayFailReason.LineOfSight);
				return;
			}
			if (baseNetworkable is Door door)
			{
				if (!door.GetPlayerLockPermission(msg.player))
				{
					msg.player.ChatMessage("Door must be openable");
					return;
				}
				if (door.IsOpen())
				{
					msg.player.ChatMessage("Door must be closed");
					return;
				}
			}
			if (!GetItemDefinitionForEntity(baseEntity2, out var def))
			{
				SprayFailResponse(SprayFailReason.InvalidItem);
				return;
			}
			ItemDefinition itemDefinition = null;
			ulong num = ItemDefinition.FindSkin(def.itemid, targetSkin);
			ItemSkinDirectory.Skin skin = def.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => x.id == targetSkin);
			if (Interface.CallHook("OnEntityReskin", baseEntity2, skin, msg.player) != null)
			{
				return;
			}
			if (skin.invItem != null && skin.invItem is ItemSkin itemSkin)
			{
				if (itemSkin.Redirect != null)
				{
					itemDefinition = itemSkin.Redirect;
				}
				else if (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) && def.isRedirectOf != null)
				{
					itemDefinition = def.isRedirectOf;
				}
			}
			else if (def.isRedirectOf != null || (GetItemDefinitionForEntity(baseEntity2, out def, useRedirect: false) && def.isRedirectOf != null))
			{
				itemDefinition = def.isRedirectOf;
			}
			if (itemDefinition == null)
			{
				baseEntity2.skinID = num;
				baseEntity2.SendNetworkUpdate();
				Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
			}
			else
			{
				if (!CanEntityBeRespawned(baseEntity2, out var reason2))
				{
					SprayFailResponse(reason2);
					return;
				}
				if (!GetEntityPrefabPath(itemDefinition, out var resourcePath))
				{
					Debug.LogWarning("Cannot find resource path of redirect entity to spawn! " + itemDefinition.gameObject.name);
					SprayFailResponse(SprayFailReason.InvalidItem);
					return;
				}
				Vector3 position2 = baseEntity2.transform.position;
				Quaternion rotation = baseEntity2.transform.rotation;
				BaseEntity entity = baseEntity2.GetParentEntity();
				float health = baseEntity2.Health();
				EntityRef[] slots = baseEntity2.GetSlots();
				float lastAttackedTime = ((baseEntity2 is BaseCombatEntity baseCombatEntity) ? baseCombatEntity.lastAttackedTime : 0f);
				bool flag2 = baseEntity2 is Door;
				Dictionary<ContainerSet, List<Item>> dictionary2 = new Dictionary<ContainerSet, List<Item>>();
				SaveEntityStorage(baseEntity2, dictionary2, 0);
				List<ChildPreserveInfo> obj = Facepunch.Pool.GetList<ChildPreserveInfo>();
				if (flag2)
				{
					foreach (BaseEntity child in baseEntity2.children)
					{
						obj.Add(new ChildPreserveInfo
						{
							TargetEntity = child,
							TargetBone = child.parentBone,
							LocalPosition = child.transform.localPosition,
							LocalRotation = child.transform.localRotation
						});
					}
					foreach (ChildPreserveInfo item in obj)
					{
						item.TargetEntity.SetParent(null, worldPositionStays: true);
					}
				}
				else
				{
					for (int i = 0; i < baseEntity2.children.Count; i++)
					{
						SaveEntityStorage(baseEntity2.children[i], dictionary2, -1);
					}
				}
				baseEntity2.Kill();
				baseEntity2 = GameManager.server.CreateEntity(resourcePath, position2, rotation);
				baseEntity2.SetParent(entity);
				if (GetItemDefinitionForEntity(baseEntity2, out var def2, useRedirect: false) && def2.isRedirectOf != null)
				{
					baseEntity2.skinID = 0uL;
				}
				else
				{
					baseEntity2.skinID = num;
				}
				if (baseEntity2 is DecayEntity decayEntity)
				{
					decayEntity.AttachToBuilding(null);
				}
				baseEntity2.Spawn();
				if (baseEntity2 is BaseCombatEntity baseCombatEntity2)
				{
					baseCombatEntity2.SetHealth(health);
					baseCombatEntity2.lastAttackedTime = lastAttackedTime;
				}
				if (dictionary2.Count > 0)
				{
					RestoreEntityStorage(baseEntity2, 0, dictionary2);
					if (!flag2)
					{
						for (int j = 0; j < baseEntity2.children.Count; j++)
						{
							RestoreEntityStorage(baseEntity2.children[j], -1, dictionary2);
						}
					}
					foreach (KeyValuePair<ContainerSet, List<Item>> item2 in dictionary2)
					{
						foreach (Item item3 in item2.Value)
						{
							Debug.Log($"Deleting {item3} as it has no new container");
							item3.Remove();
						}
					}
					Facepunch.Rust.Analytics.Server.SkinUsed(def.shortname, targetSkin);
				}
				if (flag2)
				{
					foreach (ChildPreserveInfo item4 in obj)
					{
						item4.TargetEntity.SetParent(baseEntity2, item4.TargetBone, worldPositionStays: true);
						item4.TargetEntity.transform.localPosition = item4.LocalPosition;
						item4.TargetEntity.transform.localRotation = item4.LocalRotation;
						item4.TargetEntity.SendNetworkUpdate();
					}
					baseEntity2.SetSlots(slots);
				}
				Interface.CallHook("OnEntityReskinned", baseEntity2, skin, msg.player);
				Facepunch.Pool.FreeList(ref obj);
			}
			ClientRPC(null, "Client_ReskinResult", 1, baseEntity2.net.ID);
		}
		LoseCondition(ConditionLossPerReskin);
		ClientRPC(null, "Client_ChangeSprayColour", -1);
		SetFlag(Flags.Busy, b: true);
		Invoke(ClearBusy, SprayCooldown);
		static void RestoreEntityStorage(BaseEntity baseEntity, int index, Dictionary<ContainerSet, List<Item>> copy)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity)
			{
				ContainerSet containerSet = default(ContainerSet);
				containerSet.ContainerIndex = index;
				containerSet.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key = containerSet;
				if (copy.ContainsKey(key))
				{
					foreach (Item item5 in copy[key])
					{
						item5.MoveToContainer(itemContainerEntity.inventory);
					}
					copy.Remove(key);
				}
			}
		}
		static void SaveEntityStorage(BaseEntity baseEntity, Dictionary<ContainerSet, List<Item>> dictionary, int index)
		{
			if (baseEntity is IItemContainerEntity itemContainerEntity2)
			{
				ContainerSet containerSet2 = default(ContainerSet);
				containerSet2.ContainerIndex = index;
				containerSet2.PrefabId = ((index != 0) ? baseEntity.prefabID : 0u);
				ContainerSet key2 = containerSet2;
				if (!dictionary.ContainsKey(key2))
				{
					dictionary.Add(key2, new List<Item>());
					foreach (Item item6 in itemContainerEntity2.inventory.itemList)
					{
						dictionary[key2].Add(item6);
					}
					{
						foreach (Item item7 in dictionary[key2])
						{
							item7.RemoveFromContainer();
						}
						return;
					}
				}
				Debug.Log("Multiple containers with the same prefab id being added during vehicle reskin");
			}
		}
		void SprayFailResponse(SprayFailReason reason)
		{
			ClientRPC(null, "Client_ReskinResult", 0, (int)reason);
		}
	}

```

## OnPlayerAddModifiers(BasePlayer,Item,ItemModConsumable)

```csharp
```csharp
/// <summary>
/// Called when a player adds modifiers to their character.
/// </summary>
/// <param name="player">The player who is adding modifiers.</param>
/// <param name="item">The item that triggered the modifier addition.</param>
/// <param name="consumable">The consumable item that added the modifiers.</param>
object OnPlayerAddModifiers(BasePlayer player, Item item, ItemModConsumable consumable)
{
    Puts($"Player {player.displayName} has added modifiers to their character.");
    // Add custom logic here if needed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void DoAction(Item item, BasePlayer player)
	{
		if (item.amount < 1)
		{
			return;
		}
		GameObjectRef gameObjectRef = GetConsumeEffect();
		if (gameObjectRef.isValid)
		{
			Vector3 posLocal = (player.IsDucked() ? new Vector3(0f, 1f, 0f) : new Vector3(0f, 2f, 0f));
			Effect.server.Run(gameObjectRef.resourcePath, player, 0u, posLocal, Vector3.zero);
		}
		player.metabolism.MarkConsumption();
		ItemModConsumable consumable = GetConsumable();
		if (!string.IsNullOrEmpty(consumable.achievementWhenEaten))
		{
			player.GiveAchievement(consumable.achievementWhenEaten);
		}
		Facepunch.Rust.Analytics.Azure.OnConsumableUsed(player, item);
		float num = Mathf.Max(consumable.amountToConsume, 1);
		float num2 = Mathf.Min(item.amount, num);
		float num3 = num2 / num;
		float num4 = item.conditionNormalized;
		if (consumable.conditionFractionToLose > 0f)
		{
			num4 = consumable.conditionFractionToLose;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in consumable.effects)
		{
			if (Mathf.Clamp01(player.healthFraction + player.metabolism.pending_health.Fraction()) > effect.onlyIfHealthLessThan)
			{
				continue;
			}
			if (effect.type == MetabolismAttribute.Type.Health)
			{
				if (effect.amount < 0f)
				{
					player.OnAttacked(new HitInfo(player, player, DamageType.Generic, (0f - effect.amount) * num3 * num4, player.transform.position + player.transform.forward * 1f));
				}
				else
				{
					player.health += effect.amount * num3 * num4;
				}
			}
			else
			{
				player.metabolism.ApplyChange(effect.type, effect.amount * num3 * num4, effect.time * num3 * num4);
			}
		}
		if (player.modifiers != null && Interface.CallHook("OnPlayerAddModifiers", player, item, consumable) == null)
		{
			player.modifiers.Add(consumable.modifiers);
		}
		if (product != null)
		{
			ItemAmountRandom[] array = product;
			foreach (ItemAmountRandom itemAmountRandom in array)
			{
				int num5 = Mathf.RoundToInt((float)itemAmountRandom.RandomAmount() * num4);
				if (num5 > 0)
				{
					Item item2 = ItemManager.Create(itemAmountRandom.itemDef, num5, 0uL);
					player.GiveItem(item2);
				}
			}
		}
		if (string.IsNullOrEmpty(eatGesture))
		{
			player.SignalBroadcast(BaseEntity.Signal.Gesture, eatGesture);
		}
		Facepunch.Rust.Analytics.Server.Consume(base.gameObject.name);
		if (consumable.conditionFractionToLose > 0f)
		{
			item.LoseCondition(consumable.conditionFractionToLose * item.maxCondition);
		}
		else
		{
			item.UseItem((int)num2);
		}
	}

```

## CanSeeStash(BasePlayer,StashContainer)

```csharp
```csharp
/// <summary>
/// Called when a player wants to see the stash.
/// </summary>
/// <param name="player">The player trying to see the stash.</param>
/// <param name="stashContainer">The stash container being accessed.</param>
/// <returns>
/// Returns `null` if the player is allowed to see the stash, or any non-null value to prevent them from seeing it.
/// </returns>
object CanSeeStash(BasePlayer player, StashContainer stashContainer)
{
    Puts($"Player {player.UserIDString} tried to access stash container {stashContainer.GetID()}");
    if (player.IsAdmin())
    {
        return null;
    }
    else
    {
        return "Access denied: Only admins can see the stash.";
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_WantsUnhide(RPCMessage rpc)
	{
		if (IsHidden())
		{
			BasePlayer player = rpc.player;
			if (PlayerInRange(player) && Interface.CallHook("CanSeeStash", player, this) == null)
			{
				Facepunch.Rust.Analytics.Azure.OnStashRevealed(rpc.player, this);
				SetHidden(isHidden: false);
				Interface.CallHook("OnStashExposed", this, player);
			}
		}
	}

```

## OnHelicopterAttacked(BaseHelicopter,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a helicopter is attacked.
/// </summary>
/// <param name="helicopter">The helicopter being attacked.</param>
/// <param name="info">Information about the attack, including the damage type and hit bone.</param>
/// <returns>
/// Returns `null` to allow the helicopter's normal hurt behavior to occur. 
/// If a non-null value is returned, it will override the helicopter's hurt behavior.
/// </returns>
object OnHelicopterAttacked(BaseHelicopter helicopter, HitInfo info)
{
    Puts($"Helicopter {helicopter.GetDisplayName()} has been attacked with damage type {info.damageTypes} and hit bone {info.HitBone}.");
    if (info.damageTypes == "Critical")
    {
        Puts($"Helicopter {helicopter.GetDisplayName()} has taken critical damage.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void Hurt(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttacked", this, info) != null)
		{
			return;
		}
		bool flag = false;
		if (info.damageTypes.Total() >= base.health)
		{
			base.health = 1000000f;
			myAI.CriticalDamage();
			flag = true;
		}
		base.Hurt(info);
		if (flag)
		{
			return;
		}
		weakspot[] array = weakspots;
		foreach (weakspot weakspot in array)
		{
			string[] bonenames = weakspot.bonenames;
			foreach (string str in bonenames)
			{
				if (info.HitBone == StringPool.Get(str))
				{
					weakspot.Hurt(info.damageTypes.Total(), info);
					myAI.WeakspotDamaged(weakspot, info);
				}
			}
		}
	}

```

## OnDeleteVendingOffer(VendingMachine,int)

```csharp
```csharp
/// <summary>
/// Called when a vending machine offer is deleted.
/// </summary>
/// <param name="vendingMachine">The vending machine that the offer was on.</param>
/// <param name="offerIndex">The index of the offer being deleted.</param>
/// <returns>No return behavior.</returns>
void OnDeleteVendingOffer(VendingMachine vendingMachine, int offerIndex)
{
    Puts($"Offer {offerIndex} deleted from vending machine {vendingMachine.name}");
    Facepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(null, vendingMachine, 0, 0, false, 0, 0, false, added: false);
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_DeleteSellOrder(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (CanPlayerAdmin(player))
		{
			int num = msg.read.Int32();
			Interface.CallHook("OnDeleteVendingOffer", this, num);
			if (num >= 0 && num < sellOrders.sellOrders.Count)
			{
				ProtoBuf.VendingMachine.SellOrder sellOrder = sellOrders.sellOrders[num];
				Facepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, added: false);
				sellOrders.sellOrders.RemoveAt(num);
			}
			RefreshSellOrderStockLevel();
			UpdateMapMarker();
			SendSellOrders(player);
		}
	}

```

## OnIORefCleared(IOEntity.IORef,IOEntity)

```csharp
```csharp
/// <summary>
/// Called when an IO reference is cleared.
/// </summary>
/// <param name="ioEntity">The IO entity whose reference was cleared.</param>
/// <param name="clearedObject">The object that was being referenced by the cleared IO entity.</param>
/// <returns>No return behavior.</returns>
void OnIORefCleared(IOEntity ioEntity, object clearedObject)
{
    Puts($"IO reference for {ioEntity} has been cleared.");
}
```
```

### Source Code from the Library

```csharp

		public void Clear()
		{
			IOEntity obj = ioEnt;
			ioEnt = null;
			entityRef.Set(null);
			Interface.CallHook("OnIORefCleared", this, obj);
		}

```

## OnPlayerRespawn(BasePlayer,BasePlayer.SpawnPoint)

```csharp
```csharp
/// <summary>
/// Called when a player respawns.
/// </summary>
/// <param name="player">The player respawning.</param>
/// <param name="spawnPoint">The point where the player will respawn.</param>
/// <returns>
/// Returns `null` to allow the player to respawn at the default spawn point, or any non-null value to override the spawn point.
/// If a SpawnPoint object is returned, it will be used as the new spawn point for the player.
/// </returns>
object OnPlayerRespawn(BasePlayer player, SpawnPoint spawnPoint)
{
    Puts($"Player {player.UserIDString} has respawned at position: {spawnPoint.pos}");
    if (spawnPoint.name == "SafeZone")
    {
        Puts($"Player {player.displayName} is respawning in the Safe Zone.");
        return new SpawnPoint(player.transform.position, player.transform.rotation);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Respawn()
	{
		SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(this);
		if (ConVar.Server.respawnAtDeathPosition && ServerCurrentDeathNote != null)
		{
			spawnPoint.pos = ServerCurrentDeathNote.worldPosition;
		}
		object obj = Interface.CallHook("OnPlayerRespawn", this, spawnPoint);
		if (obj is SpawnPoint)
		{
			spawnPoint = (SpawnPoint)obj;
		}
		RespawnAt(spawnPoint.pos, spawnPoint.rot);
	}

```

## OnWeaponReload(BaseProjectile,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player starts reloading their weapon.
/// </summary>
/// <param name="projectile">The projectile being reloaded.</param>
/// <param name="player">The player performing the reload.</param>
/// <returns>
/// Returns `null` to allow the player to start reloading, or any non-null value to prevent them from reloading.
/// </returns>
object OnWeaponReload(BaseProjectile projectile, BasePlayer player)
{
    Puts($"Player {player.UserIDString} started reloading their weapon.");
    if (projectile.ammoType == "restricted")
    {
        Puts($"Player {player.displayName} is not allowed to reload with restricted ammo.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void StartReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
			reloadStarted = false;
			reloadFinished = false;
		}
		else if (Interface.CallHook("OnWeaponReload", this, player) == null)
		{
			reloadFinished = false;
			reloadStarted = true;
			fractionalInsertCounter = 0;
			if (CanRefundAmmo)
			{
				primaryMagazine.SwitchAmmoTypesIfNeeded(player);
			}
			StartReloadCooldown(GetReloadDuration());
		}
	}

```

## OnServerMessage(string,string,string,ulong)

```csharp
```csharp
/// <summary>
/// Called when a server message is broadcasted.
/// </summary>
/// <param name="message">The message being broadcasted.</param>
/// <param name="username">The username of the user who sent the message, defaults to "SERVER" if not provided.</param>
/// <param name="color">The color of the message, defaults to "#eee" if not provided.</param>
/// <param name="userid">The ID of the user who sent the message, defaults to 0 if not provided.</param>
/// <returns>
/// Returns `null` to allow the message to be broadcasted as normal. 
/// If a non-null value is returned, it will override the default behavior and prevent the message from being broadcasted.
/// </returns>
object OnServerMessage(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
{
    Puts($"Server message: {message} from {username} with ID {userid}");
    if (userid == 1234567890uL)
    {
        Puts($"Server message from user with ID {userid} has been blocked.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", message, username, color, userid) == null)
		{
			string text = username.EscapeRichText();
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=" + color + ">" + text + "</color> " + message);
			ChatEntry ce = default(ChatEntry);
			ce.Channel = ChatChannel.Server;
			ce.Message = message;
			ce.UserId = userid.ToString();
			ce.Username = username;
			ce.Color = color;
			ce.Time = Epoch.Current;
			Record(ce);
		}
	}

```

## OnCrateHackEnd(HackableLockedCrate)

```csharp
```csharp
/// <summary>
/// Called when a crate hack has ended.
/// </summary>
/// <param name="crate">The hacked crate.</param>
/// <returns>No return behavior.</returns>
void OnCrateHackEnd(HackableLockedCrate crate)
{
    Puts($"Crate hack on {crate.GetLabel()} has ended.");
    if (crate.IsLootable())
    {
        Puts($"Crate {crate.GetLabel()} is now lootable.");
    }
    else
    {
        Puts($"Crate {crate.GetLabel()} is still not lootable.");
    }
}
```
```

### Source Code from the Library

```csharp

	public void HackProgress()
	{
		hackSeconds += 1f;
		if (hackSeconds > requiredHackSeconds)
		{
			Interface.CallHook("OnCrateHackEnd", this);
			Facepunch.Rust.Analytics.Azure.OnLockedCrateFinished(OriginalHackerPlayer, this);
			RefreshDecay();
			SetFlag(Flags.Reserved2, b: true);
			isLootable = true;
			CancelInvoke(HackProgress);
		}
		ClientRPC(null, "UpdateHackProgress", (int)hackSeconds, (int)requiredHackSeconds);
	}

```

## OnMeleeThrown(BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a melee item is thrown.
/// </summary>
/// <param name="player">The player who threw the item.</param>
/// <param name="item">The item that was thrown.</param>
void OnMeleeThrown(BasePlayer player, Item item)
{
    Puts($"Player {player.displayName} has thrown a melee item.");
    Interface.CallHook("OnMeleeThrown", player, item);
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server.IsActiveItem]
	[RPC_Server]
	[RPC_Server.FromOwner]
	private void CLProject(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (player == null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsProjectile)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "item_missing");
				return;
			}
			ItemModProjectile component = item.info.GetComponent<ItemModProjectile>();
			if (component == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "mod_missing");
				return;
			}
			ProjectileShoot projectileShoot = ProjectileShoot.Deserialize(msg.read);
			if (projectileShoot.projectiles.Count != 1)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "count_mismatch");
				return;
			}
			player.CleanupExpiredProjectiles();
			Guid projectileGroupId = Guid.NewGuid();
			foreach (ProjectileShoot.Projectile projectile in projectileShoot.projectiles)
			{
				if (player.HasFiredProjectile(projectile.projectileID))
				{
					AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
					player.stats.combat.LogInvalid(player, this, "duplicate_id");
				}
				else if (ValidateEyePos(player, projectile.startPos))
				{
					player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, projectileGroupId, item);
					Effect effect = new Effect();
					effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
					effect.scale = 1f;
					effect.pooledString = component.projectileObject.resourcePath;
					effect.number = projectile.seed;
					EffectNetwork.Send(effect);
				}
			}
			projectileShoot?.Dispose();
			item.SetParent(null);
			Interface.CallHook("OnMeleeThrown", player, item);
			if (!canAiHearIt)
			{
				return;
			}
			float num = 0f;
			if (component.projectileObject != null)
			{
				GameObject gameObject = component.projectileObject.Get();
				if (gameObject != null)
				{
					Projectile component2 = gameObject.GetComponent<Projectile>();
					if (component2 != null)
					{
						foreach (DamageTypeEntry damageType in component2.damageTypes)
						{
							num += damageType.amount;
						}
					}
				}
			}
			if (player != null)
			{
				Sensation sensation = default(Sensation);
				sensation.Type = SensationType.ThrownWeapon;
				sensation.Position = player.transform.position;
				sensation.Radius = 50f;
				sensation.DamagePotential = num;
				sensation.InitiatorPlayer = player;
				sensation.Initiator = player;
				Sense.Stimulate(sensation);
			}
		}
	}

```

## OnMapMarkerAdded(BasePlayer,ProtoBuf.MapNote)

```csharp
```csharp
/// <summary>
/// Called when a new map marker is added.
/// </summary>
/// <param name="player">The player who added the marker.</param>
/// <param name="mapNote">The details of the newly added map marker.</param>
/// <returns>No return behavior.</returns>
void OnMapMarkerAdded(BasePlayer player, ProtoBuf.MapNote mapNote)
{
    Puts($"Player {player.UserIDString} has added a new map marker at position: {mapNote.position} with note: {mapNote.note}");
    if (mapNote.note == "Restricted Area")
    {
        Puts($"Player {player.displayName} has marked a restricted area.");
        // Send a warning to other players in the area
        foreach (var otherPlayer in player.GetNearbyPlayers(100))
        {
            otherPlayer.ShowToast(GameTip.Styles.Red_Short, "Warning: Restricted Area", "");
        }
    }
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(8uL)]
	public void Server_AddMarker(RPCMessage msg)
	{
		if (Interface.CallHook("OnMapMarkerAdd", this, MapNote.Deserialize(msg.read)) == null)
		{
			msg.read.Position = 13L;
			if (State.pointsOfInterest == null)
			{
				State.pointsOfInterest = Facepunch.Pool.GetList<MapNote>();
			}
			if (State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers)
			{
				msg.player.ShowToast(GameTip.Styles.Blue_Short, MarkerLimitPhrase, ConVar.Server.maximumMapMarkers.ToString());
				return;
			}
			MapNote mapNote = MapNote.Deserialize(msg.read);
			ValidateMapNote(mapNote);
			mapNote.colourIndex = State.pointsOfInterest.Count;
			State.pointsOfInterest.Add(mapNote);
			DirtyPlayerState();
			SendMarkersToClient();
			TeamUpdate();
			Interface.CallHook("OnMapMarkerAdded", this, mapNote);
		}
	}

```

## OnDemoRecordingStop(string,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a demo recording is stopped.
/// </summary>
/// <param name="recordedFilename">The filename of the recorded demo.</param>
/// <param name="player">The player who was being recorded.</param>
/// <returns>No return behavior.</returns>
void OnDemoRecordingStop(string recordedFilename, BasePlayer player)
{
    Puts($"Demo recording stopped for {player.UserIDString} with filename: {recordedFilename}");
}
```
```

### Source Code from the Library

```csharp

	public void StopDemoRecording()
	{
		if (net != null && net.connection != null && net.connection.IsRecording && Interface.CallHook("OnDemoRecordingStop", net.connection.recordFilename, this) == null)
		{
			Debug.Log(ToString() + " recording stopped: " + net.connection.RecordFilename);
			net.connection.StopRecording();
			CancelInvoke(MonitorDemoRecording);
			Interface.CallHook("OnDemoRecordingStopped", net.connection.recordFilename, this);
		}
	}

```

## OnDefaultItemsReceive(PlayerInventory)

```csharp
```csharp
/// <summary>
/// Called when default items are received by the player.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
void OnDefaultItemsReceive(PlayerInventory inventory)
{
    Puts("Default items have been received.");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public void GiveDefaultItems()
	{
		if (Interface.CallHook("OnDefaultItemsReceive", this) != null)
		{
			return;
		}
		Strip();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (activeGameMode != null && activeGameMode.HasLoadouts())
		{
			BaseGameMode.GetActiveGameMode(serverside: true).LoadoutPlayer(base.baseEntity);
			return;
		}
		GiveDefaultItemWithSkin("client.rockskin", "rock");
		GiveDefaultItemWithSkin("client.torchskin", "torch");
		if (IsBirthday())
		{
			GiveItem(ItemManager.CreateByName("cakefiveyear", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("partyhat", 1, 0uL), containerWear);
		}
		if (IsChristmas())
		{
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
			GiveItem(ItemManager.CreateByName("snowball", 1, 0uL), containerBelt);
		}
		Interface.CallHook("OnDefaultItemsReceived", this);
		void GiveDefaultItemWithSkin(string convarSkinName, string itemShortName)
		{
			ulong num = 0uL;
			int infoInt = base.baseEntity.GetInfoInt(convarSkinName, 0);
			bool flag = false;
			bool flag2 = false;
			flag2 = base.baseEntity?.UnlockAllSkins ?? false;
			if (infoInt > 0 && (base.baseEntity.blueprints.steamInventory.HasItem(infoInt) || flag2))
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemShortName);
				if (itemDefinition != null && ItemDefinition.FindSkin(itemDefinition.itemid, infoInt) != 0L)
				{
					IPlayerItemDefinition itemDefinition2 = PlatformService.Instance.GetItemDefinition(infoInt);
					if (itemDefinition2 != null)
					{
						num = itemDefinition2.WorkshopDownload;
					}
					if (num == 0L && itemDefinition.skins != null)
					{
						ItemSkinDirectory.Skin[] skins = itemDefinition.skins;
						for (int i = 0; i < skins.Length; i++)
						{
							ItemSkinDirectory.Skin skin = skins[i];
							if (skin.id == infoInt && skin.invItem != null && skin.invItem is ItemSkin itemSkin && itemSkin.Redirect != null)
							{
								GiveItem(ItemManager.CreateByName(itemSkin.Redirect.shortname, 1, 0uL), containerBelt);
								flag = true;
								break;
							}
						}
					}
				}
			}
			if (!flag)
			{
				GiveItem(ItemManager.CreateByName(itemShortName, 1, num), containerBelt);
			}
		}
	}

```

## CanBeWounded(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can be wounded.
/// </summary>
/// <param name="player">The player to check.</param>
/// <param name="info">Information about the hit that caused the wounding check.</param>
/// <returns>
/// Returns `true` if the player can be wounded, and `false` otherwise. 
/// If a non-bool value is returned, it will override the default behavior.
/// </returns>
object CanBeWounded(BasePlayer player, HitInfo info)
{
    Puts($"Checking if {player.Name} can be wounded by {info.WeaponPrefab?.Name}.");
    object result = Interface.CallHook("CanBeWounded", player, info);
    if (result is bool)
    {
        return result;
    }
    // Default behavior
    if (!ConVar.Server.woundingenabled)
    {
        return false;
    }
    if (player.IsWounded())
    {
        return false;
    }
    if (player.IsSleeping())
    {
        return false;
    }
    if (info == null)
    {
        return false;
    }
    // Check rewound delay
    if (!player.IsWounded() && UnityEngine.Time.realtimeSinceStartup - player.lastWoundedStartTime < ConVar.Server.rewounddelay)
    {
        return false;
    }
    BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
    if ((bool)activeGameMode && !activeGameMode.allowWounding)
    {
        return false;
    }
    // Check triggers
    if (player.triggers != null)
    {
        for (int i = 0; i < player.triggers.Count; i++)
        {
            if (player.triggers[i] is IHurtTrigger)
            {
                return false;
            }
        }
    }
    // Default behavior based on weapon type
    if (info.WeaponPrefab is BaseMelee)
    {
        return true;
    }
    if (info.WeaponPrefab is BaseProjectile)
    {
        return !info.isHeadshot;
    }
    // Check damage types
    switch (info.damageTypes.GetMajorityDamageType())
    {
        case DamageType.Suicide:
            return false;
        case DamageType.Fall:
            return true;
        case DamageType.Bite:
            return true;
        case DamageType.Bleeding:
            return true;
        case DamageType.Hunger:
            return true;
        case DamageType.Thirst:
            return true;
        case DamageType.Poison:
            return true;
        default:
            return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool EligibleForWounding(HitInfo info)
	{
		object obj = Interface.CallHook("CanBeWounded", this, info);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!ConVar.Server.woundingenabled)
		{
			return false;
		}
		if (IsWounded())
		{
			return false;
		}
		if (IsSleeping())
		{
			return false;
		}
		if (isMounted)
		{
			return false;
		}
		if (info == null)
		{
			return false;
		}
		if (!IsWounded() && UnityEngine.Time.realtimeSinceStartup - lastWoundedStartTime < ConVar.Server.rewounddelay)
		{
			return false;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((bool)activeGameMode && !activeGameMode.allowWounding)
		{
			return false;
		}
		if (triggers != null)
		{
			for (int i = 0; i < triggers.Count; i++)
			{
				if (triggers[i] is IHurtTrigger)
				{
					return false;
				}
			}
		}
		if (info.WeaponPrefab is BaseMelee)
		{
			return true;
		}
		if (info.WeaponPrefab is BaseProjectile)
		{
			return !info.isHeadshot;
		}
		return info.damageTypes.GetMajorityDamageType() switch
		{
			DamageType.Suicide => false, 
			DamageType.Fall => true, 
			DamageType.Bite => true, 
			DamageType.Bleeding => true, 
			DamageType.Hunger => true, 
			DamageType.Thirst => true, 
			DamageType.Poison => true, 
			_ => false, 
		};
	}

```

## OnItemRecycleAmount(Item,int,Recycler)

```csharp
Here is the method structure for `OnItemRecycleAmount(Item,int,Recycler)`:

```csharp
/// <summary>
/// Called when an item is being recycled.
/// </summary>
/// <param name="item">The item being recycled.</param>
/// <param name="amount">The amount of items to recycle.</param>
/// <param name="recycler">The recycler that called this method.</param>
/// <returns>
/// Returns the number of items to actually recycle. If a value is returned, it will override the default recycling behavior.
/// If `null` is returned, the item will be recycled as normal.
/// </returns>
object OnItemRecycleAmount(Item item, int amount, Recycler recycler)
{
    Puts($"Item {item.info.shortname} with amount {amount} is being recycled.");
    // Minimal code to demonstrate functionality
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RecycleThink()
	{
		bool flag = false;
		float num = recycleEfficiency;
		int num2 = 0;
		while (true)
		{
			if (num2 < 6)
			{
				Item slot = base.inventory.GetSlot(num2);
				if (!CanBeRecycled(slot))
				{
					num2++;
					continue;
				}
				if (Interface.CallHook("OnItemRecycle", slot, this) != null)
				{
					if (!HasRecyclable())
					{
						StopRecycling();
					}
					break;
				}
				if (slot.hasCondition)
				{
					num = Mathf.Clamp01(num * Mathf.Clamp(slot.conditionNormalized * slot.maxConditionNormalized, 0.1f, 1f));
				}
				int num3 = 1;
				if (slot.amount > 1)
				{
					num3 = Mathf.CeilToInt(Mathf.Min(slot.amount, (float)slot.MaxStackable() * 0.1f));
				}
				object obj = Interface.CallHook("OnItemRecycleAmount", slot, num3, this);
				if (obj is int)
				{
					num3 = (int)obj;
				}
				if (slot.info.Blueprint.scrapFromRecycle > 0)
				{
					int num4 = slot.info.Blueprint.scrapFromRecycle * num3;
					if (slot.MaxStackable() == 1 && slot.hasCondition)
					{
						num4 = Mathf.CeilToInt((float)num4 * slot.conditionNormalized);
					}
					if (num4 >= 1)
					{
						Item item = ItemManager.CreateByName("scrap", num4, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item.info.shortname, item.amount, this, slot);
						MoveItemToOutput(item);
					}
				}
				if (!string.IsNullOrEmpty(slot.info.Blueprint.RecycleStat))
				{
					List<BasePlayer> obj2 = Facepunch.Pool.GetList<BasePlayer>();
					Vis.Entities(base.transform.position, 3f, obj2, 131072);
					foreach (BasePlayer item3 in obj2)
					{
						if (item3.IsAlive() && !item3.IsSleeping() && item3.inventory.loot.entitySource == this)
						{
							item3.stats.Add(slot.info.Blueprint.RecycleStat, num3, (Stats)5);
							item3.stats.Save();
						}
					}
					Facepunch.Pool.FreeList(ref obj2);
				}
				Facepunch.Rust.Analytics.Azure.OnItemRecycled(slot.info.shortname, num3, this);
				slot.UseItem(num3);
				foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
				{
					if (ingredient.itemDef.shortname == "scrap")
					{
						continue;
					}
					float num5 = ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
					int num6 = 0;
					if (num5 <= 1f)
					{
						for (int i = 0; i < num3; i++)
						{
							if (UnityEngine.Random.Range(0f, 1f) <= num5 * num)
							{
								num6++;
							}
						}
					}
					else
					{
						num6 = Mathf.CeilToInt(Mathf.Clamp(num5 * num * UnityEngine.Random.Range(1f, 1f), 0f, ingredient.amount)) * num3;
					}
					if (num6 <= 0)
					{
						continue;
					}
					int num7 = Mathf.CeilToInt((float)num6 / (float)ingredient.itemDef.stackable);
					for (int j = 0; j < num7; j++)
					{
						int num8 = ((num6 > ingredient.itemDef.stackable) ? ingredient.itemDef.stackable : num6);
						Item item2 = ItemManager.Create(ingredient.itemDef, num8, 0uL);
						Facepunch.Rust.Analytics.Azure.OnRecyclerItemProduced(item2.info.shortname, item2.amount, this, slot);
						if (!MoveItemToOutput(item2))
						{
							flag = true;
						}
						num6 -= num8;
						if (num6 <= 0)
						{
							break;
						}
					}
				}
			}
			if (flag || !HasRecyclable())
			{
				StopRecycling();
			}
			break;
		}
	}

```

## OnQueueMessage(Network.Connection,int)

```csharp
```csharp
/// <summary>
/// Called when a message is sent to the queue.
/// </summary>
/// <param name="connection">The connection that sent the message.</param>
/// <param name="position">The position of the sender in the queue.</param>
/// <returns>
/// Returns `null` to allow the message to be sent as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the message instead of the default one.
/// </returns>
object OnQueueMessage(Network.Connection connection, int position)
{
    Puts($"Connection {connection.UserIDString} has sent a queue message with position {position}");
    if (position == 0 && connection.UserIDString == "admin")
    {
        return "YOU'RE NEXT - Admin is ahead of you";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendMessage(Connection c, int position)
	{
		if (Interface.CallHook("OnQueueMessage", c, position) == null)
		{
			string empty = string.Empty;
			empty = ((position <= 0) ? string.Format("YOU'RE NEXT - {1:N0} PLAYERS BEHIND YOU", position, queue.Count - position - 1) : $"{position:N0} PLAYERS AHEAD OF YOU, {queue.Count - position - 1:N0} PLAYERS BEHIND");
			NetWrite netWrite = Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.Message);
			netWrite.String("QUEUE");
			netWrite.String(empty);
			netWrite.Send(new SendInfo(c));
		}
	}

```

## OnEntityGroundMissing(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an entity is missing its ground.
/// </summary>
/// <param name="entity">The BaseEntity that is missing its ground.</param>
/// <returns>
/// Returns `null` to allow the entity to be destroyed, or any non-null value to prevent it from being destroyed.
/// </returns>
object OnEntityGroundMissing(BaseEntity entity)
{
    Puts($"Entity {entity.UserIDString} has lost contact with the ground.");
    if (entity is BaseCombatEntity combatEntity && combatEntity.IsPlayerControlled)
    {
        Puts($"Player-controlled entity {entity.UserIDString} has been destroyed due to losing ground contact.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp
	private void OnGroundMissing()
	{
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(base.gameObject);
		if (baseEntity != null && Interface.CallHook("OnEntityGroundMissing", baseEntity) == null)
		{
			BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
			if (baseCombatEntity != null)
			{
				baseCombatEntity.Die();
			}
			else
			{
				baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
			}
		}
	}

```

## CanNetworkTo(BaseEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to determine if a BasePlayer should be networked to.
/// </summary>
/// <param name="entity">The BaseEntity that is being checked.</param>
/// <param name="player">The BasePlayer that is being checked against.</param>
/// <returns>
/// Returns `true` to allow the player to be networked, or `false` to prevent it.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanNetworkTo(BaseEntity entity, BasePlayer player)
{
    Puts($"Checking if {player.UserIDString} can be networked to {entity.GetType().Name}");
    // Example: if (entity == null || player == null) return false;
    // Example: if (entity is MySpecialEntity && player.IsAdmin) return true;
    return null; // Default to allowing the player to be networked
}
```
```

### Source Code from the Library

```csharp

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		if (player == this)
		{
			return true;
		}
		BaseEntity baseEntity = GetParentEntity();
		if (base.limitNetworking)
		{
			if (baseEntity == null)
			{
				return false;
			}
			if (baseEntity != player)
			{
				return false;
			}
		}
		if (baseEntity != null)
		{
			object obj = Interface.CallHook("CanNetworkTo", this, player);
			if (obj is bool)
			{
				return (bool)obj;
			}
			return baseEntity.ShouldNetworkTo(player);
		}
		return base.ShouldNetworkTo(player);
	}

```

## OnWindmillUpdated(ElectricWindmill)

```csharp
```csharp
/// <summary>
/// Called when a windmill's state is updated.
/// </summary>
/// <param name="windmill">The windmill whose state was updated.</param>
/// <returns>No return behavior.</returns>
void OnWindmillUpdated(ElectricWindmill windmill)
{
    Puts($"Windmill {windmill.windmillName} has been updated.");
    if (windmill.currentEnergy > 50f)
    {
        Puts($"Windmill {windmill.windmillName} is producing excess energy.");
        // Handle excess energy production
    }
}
```
```

### Source Code from the Library

```csharp

	public void WindUpdate()
	{
		if (Interface.CallHook("OnWindmillUpdate", this) == null)
		{
			serverWindSpeed = GetWindSpeedScale();
			if (!AmIVisible())
			{
				serverWindSpeed = 0f;
			}
			int num = Mathf.FloorToInt((float)maxPowerGeneration * serverWindSpeed);
			bool num2 = currentEnergy != num;
			currentEnergy = num;
			if (num2)
			{
				MarkDirty();
			}
			SendNetworkUpdate();
			Interface.CallHook("OnWindmillUpdated", this);
		}
	}

```

## OnEntityBuilt(Planner,UnityEngine.GameObject)

```csharp
Here is the method structure for `OnEntityBuilt`:

```csharp
/// <summary>
/// Called when an entity is built.
/// </summary>
/// <param name="entity">The entity that was built.</param>
/// <param name="ownerPlayer">The player who built the entity.</param>
public void OnEntityBuilt(BaseEntity entity, BasePlayer ownerPlayer)
{
    // Code to be executed when an entity is built
}
```

Note: This method structure assumes that `OnEntityBuilt` is a server-side hook and should be called on the server. If it's a client-side hook, you would need to modify the method signature accordingly.

Also, keep in mind that this is just a basic method structure, and you may need to add additional parameters or modify the existing ones based on your specific use case.
```

### Source Code from the Library

```csharp

	public void DoBuild(Construction.Target target, Construction component)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer || RayEx.IsNaNOrInfinity(target.ray) || target.position.IsNaNOrInfinity() || target.normal.IsNaNOrInfinity())
		{
			return;
		}
		if (target.socket != null)
		{
			if (!target.socket.female)
			{
				ownerPlayer.ChatMessage("Target socket is not female. (" + target.socket.socketName + ")");
				return;
			}
			if (target.entity != null && target.entity.IsOccupied(target.socket))
			{
				ownerPlayer.ChatMessage("Target socket is occupied. (" + target.socket.socketName + ")");
				return;
			}
			if (target.onTerrain)
			{
				ownerPlayer.ChatMessage("Target on terrain is not allowed when attaching to socket. (" + target.socket.socketName + ")");
				return;
			}
		}
		Vector3 vector = ((target.entity != null && target.socket != null) ? target.GetWorldPosition() : target.position);
		if (AntiHack.TestIsBuildingInsideSomething(target, vector))
		{
			ownerPlayer.ChatMessage("Can't deploy inside objects");
			return;
		}
		if (ConVar.AntiHack.eye_protection >= 2)
		{
			Vector3 center = ownerPlayer.eyes.center;
			Vector3 position = ownerPlayer.eyes.position;
			Vector3 origin = target.ray.origin;
			Vector3 p = vector;
			int num = 2097152;
			int num2 = (ConVar.AntiHack.build_terraincheck ? 10551296 : 2162688);
			float num3 = ConVar.AntiHack.build_losradius;
			float padding = ConVar.AntiHack.build_losradius + 0.01f;
			int layerMask = num2;
			if (target.socket != null)
			{
				num3 = 0f;
				padding = 0.5f;
				layerMask = num;
			}
			if (component.isSleepingBag)
			{
				num3 = ConVar.AntiHack.build_losradius_sleepingbag;
				padding = ConVar.AntiHack.build_losradius_sleepingbag + 0.01f;
				layerMask = num2;
			}
			if (num3 > 0f)
			{
				p += target.normal.normalized * num3;
			}
			if (target.entity != null)
			{
				DeployShell deployShell = PrefabAttribute.server.Find<DeployShell>(target.entity.prefabID);
				if (deployShell != null)
				{
					p += target.normal.normalized * deployShell.LineOfSightPadding();
				}
			}
			if (!GamePhysics.LineOfSightRadius(center, position, layerMask, num3) || !GamePhysics.LineOfSightRadius(position, origin, layerMask, num3) || !GamePhysics.LineOfSightRadius(origin, p, layerMask, num3, 0f, padding))
			{
				ownerPlayer.ChatMessage("Line of sight blocked.");
				return;
			}
		}
		Construction.lastPlacementError = "No Error";
		GameObject gameObject = DoPlacement(target, component);
		if (gameObject == null)
		{
			ownerPlayer.ChatMessage("Can't place: " + Construction.lastPlacementError);
		}
		if (!(gameObject != null))
		{
			return;
		}
		Interface.CallHook("OnEntityBuilt", this, gameObject);
		Deployable deployable = GetDeployable();
		BaseEntity baseEntity = GameObjectEx.ToBaseEntity(gameObject);
		if (deployable != null)
		{
			if (deployable.setSocketParent && target.entity != null && target.entity.SupportsChildDeployables() && (bool)baseEntity)
			{
				baseEntity.SetParent(target.entity, worldPositionStays: true);
			}
			if (deployable.wantsInstanceData && GetOwnerItem().instanceData != null)
			{
				(baseEntity as IInstanceDataReceiver).ReceiveInstanceData(GetOwnerItem().instanceData);
			}
			if (deployable.copyInventoryFromItem)
			{
				StorageContainer component2 = baseEntity.GetComponent<StorageContainer>();
				if ((bool)component2)
				{
					component2.ReceiveInventoryFromItem(GetOwnerItem());
				}
			}
			ItemModDeployable modDeployable = GetModDeployable();
			if (modDeployable != null)
			{
				modDeployable.OnDeployed(baseEntity, ownerPlayer);
			}
			baseEntity.OnDeployed(baseEntity.GetParentEntity(), ownerPlayer, GetOwnerItem());
			if (deployable.placeEffect.isValid)
			{
				if ((bool)target.entity && target.socket != null)
				{
					Effect.server.Run(deployable.placeEffect.resourcePath, target.entity.transform.TransformPoint(target.socket.worldPosition), target.entity.transform.up);
				}
				else
				{
					Effect.server.Run(deployable.placeEffect.resourcePath, target.position, target.normal);
				}
			}
		}
		if (baseEntity != null)
		{
			Facepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);
		}
		PayForPlacement(ownerPlayer, component);
	}

```

## OnDispenserBonus(ResourceDispenser,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a dispenser bonus is assigned to a player.
/// </summary>
/// <param name="dispenser">The dispenser that triggered the bonus.</param>
/// <param name="player">The player who received the bonus.</param>
/// <param name="item">The item that was given as a bonus.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If an `Item` is returned, it will be used instead of the original item.
/// </returns>
object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
{
    Puts($"Player {player.UserIDString} received a bonus from dispenser {dispenser.baseEntity} with item {item.info.shortname}.");
    if (item.info.shortname == "gold")
    {
        Puts($"Player {player.UserIDString} received a gold bonus from dispenser {dispenser.baseEntity}.");
        return new Item(item.info, 10, 0uL);
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		SendMessage("FinishBonusAssigned", SendMessageOptions.DontRequireReceiver);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", this, player, item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				Facepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

```

## OnBookmarksSendControl(ComputerStation,BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when control bookmarks are sent to a player.
/// </summary>
/// <param name="station">The computer station sending the bookmarks.</param>
/// <param name="player">The player receiving the bookmarks.</param>
/// <param name="bookmarks">The bookmark string being sent.</param>
/// <returns>
/// Returns `null` to allow the bookmarks to be sent, or any non-null value to prevent them from being sent.
/// </returns>
object OnBookmarksSendControl(ComputerStation station, BasePlayer player, string bookmarks)
{
    Puts($"Sending control bookmarks to {player.UserIDString} with string: {bookmarks}");
    if (bookmarks == "invalid")
    {
        Puts($"Invalid bookmark string detected.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendControlBookmarks(BasePlayer player)
	{
		if (!(player == null))
		{
			string text = GenerateControlBookmarkString();
			if (Interface.CallHook("OnBookmarksSendControl", this, player, text) == null)
			{
				ClientRPCPlayer(null, player, "ReceiveBookmarks", text);
			}
		}
	}

```

## OnEntityFlagsNetworkUpdate(BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when the entity's network flags are updated.
/// </summary>
/// <param name="entity">The BaseEntity whose flags were updated.</param>
/// <returns>
/// Returns `null` to allow the update to be sent as normal, or any non-null value to prevent the update from being sent.
/// </returns>
object OnEntityFlagsNetworkUpdate(BaseEntity entity)
{
    Puts($"Entity {entity.baseEntityID} has had its flags updated.");
    if (entity.flags == 1)
    {
        Puts($"Entity {entity.baseEntityID} is now flagged as 'Admin'.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendNetworkUpdate_Flags()
	{
		if (Rust.Application.isLoading || Rust.Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		using (TimeWarning.New("SendNetworkUpdate_Flags"))
		{
			LogEntry(LogEntryType.Network, 2, "SendNetworkUpdate_Flags");
			if (Interface.CallHook("OnEntityFlagsNetworkUpdate", this) == null)
			{
				List<Connection> subscribers = GetSubscribers();
				if (subscribers != null && subscribers.Count > 0)
				{
					NetWrite netWrite = Network.Net.sv.StartWrite();
					netWrite.PacketID(Message.Type.EntityFlags);
					netWrite.EntityID(net.ID);
					netWrite.Int32((int)flags);
					SendInfo info = new SendInfo(subscribers);
					netWrite.Send(info);
				}
				base.gameObject.SendOnSendNetworkUpdate(this);
			}
		}
	}

```

## OnEntityControl(PoweredRemoteControlEntity,ulong)

```csharp
```csharp
/// <summary>
/// Called when a player attempts to control the entity.
/// </summary>
/// <param name="entity">The entity being controlled.</param>
/// <param name="playerID">The ID of the player attempting to control the entity.</param>
/// <returns>
/// Returns `true` if the player can control the entity, or `false` otherwise.
/// If a non-bool value is returned, it will be ignored and the default behavior will apply.
/// </returns>
object OnEntityControl(PoweredRemoteControlEntity entity, ulong playerID)
{
    Puts($"Player {playerID} attempted to control entity {entity.EntityID}");
    if (playerID == 1234567890)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", this, playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsPowered())
		{
			return IsStatic();
		}
		return true;
	}

```

## OnWireClear(BasePlayer,IOEntity,int,IOEntity,bool)

```csharp
```csharp
/// <summary>
/// Called when a wire is cleared.
/// </summary>
/// <param name="player">The player who cleared the wire.</param>
/// <param name="entity">The entity that owns the wire.</param>
/// <param name="clearIndex">The index of the slot being cleared.</param>
/// <param name="connectedEntity">The entity connected to the slot being cleared.</param>
/// <param name="isInput">Whether the slot being cleared is an input or output.</param>
/// <returns>
/// Returns a non-null value to override the default wire clearing behavior.
/// If `null` is returned, the wire will be cleared as normal.
/// </returns>
object OnWireClear(BasePlayer player, IOEntity entity, int clearIndex, IOEntity connectedEntity, bool isInput)
{
    Puts($"Player {player.displayName} has cleared a wire on entity {entity.name} at index {clearIndex}.");
    if (connectedEntity == null || !CanModifyEntity(player, connectedEntity))
    {
        return null;
    }
    // Add custom logic here to override the default wire clearing behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void AttemptClearSlot(BaseNetworkable clearEnt, BasePlayer ply, int clearIndex, bool isInput)
	{
		IOEntity iOEntity = ((clearEnt == null) ? null : clearEnt.GetComponent<IOEntity>());
		if (iOEntity == null || (ply != null && !CanModifyEntity(ply, iOEntity)) || clearIndex >= (isInput ? iOEntity.inputs.Length : iOEntity.outputs.Length))
		{
			return;
		}
		IOEntity.IOSlot iOSlot = (isInput ? iOEntity.inputs[clearIndex] : iOEntity.outputs[clearIndex]);
		if (iOSlot.connectedTo.Get() == null)
		{
			return;
		}
		IOEntity iOEntity2 = iOSlot.connectedTo.Get();
		if (Interface.CallHook("OnWireClear", ply, iOEntity, clearIndex, iOEntity2, isInput) != null)
		{
			return;
		}
		IOEntity.IOSlot obj = (isInput ? iOEntity2.outputs[iOSlot.connectedToSlot] : iOEntity2.inputs[iOSlot.connectedToSlot]);
		if (isInput)
		{
			iOEntity.UpdateFromInput(0, clearIndex);
		}
		else if ((bool)iOEntity2)
		{
			iOEntity2.UpdateFromInput(0, iOSlot.connectedToSlot);
		}
		iOSlot.Clear();
		obj.Clear();
		iOEntity.MarkDirtyForceUpdateOutputs();
		iOEntity.SendNetworkUpdate();
		iOEntity.RefreshIndustrialPreventBuilding();
		if (iOEntity2 != null)
		{
			iOEntity2.RefreshIndustrialPreventBuilding();
		}
		if (isInput && iOEntity2 != null)
		{
			iOEntity2.SendChangedToRoot(forceUpdate: true);
		}
		else if (!isInput)
		{
			IOEntity.IOSlot[] inputs = iOEntity.inputs;
			foreach (IOEntity.IOSlot iOSlot2 in inputs)
			{
				if (iOSlot2.mainPowerSlot && (bool)iOSlot2.connectedTo.Get())
				{
					iOSlot2.connectedTo.Get().SendChangedToRoot(forceUpdate: true);
				}
			}
		}
		iOEntity2.SendNetworkUpdate();
		if (iOEntity != null && iOEntity.ioType == IOEntity.IOType.Industrial)
		{
			iOEntity.NotifyIndustrialNetworkChanged();
		}
		if (iOEntity2 != null && iOEntity2.ioType == IOEntity.IOType.Industrial)
		{
			iOEntity2.NotifyIndustrialNetworkChanged();
		}
	}

```

## OnBroadcastCommand(string,object[])

```csharp
```csharp
/// <summary>
/// Called when a broadcast command is sent to all clients.
/// </summary>
/// <param name="command">The command being broadcast.</param>
/// <param name="args">Any arguments associated with the command.</param>
/// <returns>
/// Returns `null` to allow the command to be broadcast, or any non-null value to prevent it from being broadcast.
/// </returns>
object OnBroadcastCommand(string command, params object[] args)
{
    Puts($"Broadcasting command: {command} with arguments: [{string.Join(", ", args)}]");
    if (command == "admin-only")
    {
        Puts("Admin-only command detected. Broadcasting cancelled.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void BroadcastToAllClients(string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnBroadcastCommand", strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			netWrite.String(ConsoleSystem.BuildCommand(strCommand, args));
			netWrite.Send(new SendInfo(Network.Net.sv.connections));
		}
	}

```

## CanUnlock(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called when a player tries to unlock the code lock.
/// </summary>
/// <param name="player">The player trying to unlock.</param>
/// <param name="codeLock">The code lock being unlocked.</param>
/// <returns>
/// Returns `null` to allow the player to unlock, or any non-null value to prevent them from unlocking.
/// </returns>
object CanUnlock(BasePlayer player, CodeLock codeLock)
{
    Puts($"Player {player.UserIDString} is trying to unlock the code lock.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is not allowed to unlock the code lock.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	private void TryUnlock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && IsLocked() && Interface.CallHook("CanUnlock", rpc.player, this) == null && !IsCodeEntryBlocked() && whitelistPlayers.Contains(rpc.player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			SetFlag(Flags.Locked, b: false);
			SendNetworkUpdate();
		}
	}

```

## CanMoveItem(Item,PlayerInventory,ItemContainerId,int,int)

```csharp
Based on the provided code snippet, I will create a method structure for `CanMoveItem` with minimal code to demonstrate functionality.

```csharp
/// <summary>
/// Called when an item is moved from one container to another.
/// </summary>
/// <param name="item">The item being moved.</param>
/// <param name="playerInventory">The player's inventory.</param>
/// <param name="itemContainerId">The ID of the destination container.</param>
/// <param name="num">The number of items to move.</param>
/// <param name="num2">The maximum stack size of the item in the destination container.</param>
/// <returns>
/// Returns a non-null value if the item cannot be moved, and null otherwise.
/// If a string is returned, the player will receive a message with the provided reason as the cause.
/// </returns>
object CanMoveItem(Item item, PlayerInventory playerInventory, ItemContainerId itemContainerId, int num, int num2)
{
    Puts($"Checking if item {item.name} can be moved to container {itemContainerId}.");
    
    // Check if the item is locked or has a maximum stack size
    if (item.IsLocked() || item.MaxStackable() > 0 && num > item.MaxStackable())
    {
        return "Item is locked or has a maximum stack size.";
    }
    
    // Check if the destination container is valid and not locked
    ItemContainer container = FindContainer(itemContainerId);
    if (container == null || container.IsLocked())
    {
        return "Invalid or locked container.";
    }
    
    // Check if the player's inventory has enough space for the item
    if (!playerInventory.HasSpaceForItem(item))
    {
        return "Player's inventory is full.";
    }
    
    // If all checks pass, return null to allow the item to be moved
    return null;
}
```

This method structure takes into account the provided code snippet and includes checks for locked items, maximum stack sizes, valid destination containers, and available space in the player's inventory. It returns a non-null value if any of these conditions are not met, along with a reason message for the player. If all checks pass, it returns null to allow the item to be moved.
```

### Source Code from the Library

```csharp

	[BaseEntity.RPC_Server]
	[BaseEntity.RPC_Server.FromOwner]
	public void MoveItem(BaseEntity.RPCMessage msg)
	{
		ItemId itemId = msg.read.ItemID();
		ItemContainerId itemContainerId = msg.read.ItemContainerID();
		int num = msg.read.Int8();
		int num2 = (int)msg.read.UInt32();
		bool flag = msg.read.Bit();
		Item item = FindItemUID(itemId);
		if (item == null)
		{
			msg.player.ChatMessage(string.Concat("Invalid item (", itemId, ")"));
		}
		else
		{
			if (Interface.CallHook("CanMoveItem", item, this, itemContainerId, num, num2) != null)
			{
				return;
			}
			BaseEntity entityOwner = item.GetEntityOwner();
			if (!CanMoveItemsFrom(entityOwner, item))
			{
				msg.player.ChatMessage("Cannot move item!");
				return;
			}
			if (num2 <= 0)
			{
				num2 = item.amount;
			}
			num2 = Mathf.Clamp(num2, 1, item.MaxStackable());
			if (msg.player.GetActiveItem() == item)
			{
				msg.player.UpdateActiveItem(default(ItemId));
			}
			if (!itemContainerId.IsValid)
			{
				BaseEntity baseEntity = entityOwner;
				if (loot.containers.Count > 0)
				{
					if (entityOwner == base.baseEntity)
					{
						if (!flag)
						{
							baseEntity = loot.entitySource;
						}
					}
					else
					{
						baseEntity = base.baseEntity;
					}
				}
				if (baseEntity is IIdealSlotEntity idealSlotEntity)
				{
					itemContainerId = idealSlotEntity.GetIdealContainer(base.baseEntity, item, flag);
				}
				ItemContainer parent = item.parent;
				if (parent != null && parent.IsLocked())
				{
					msg.player.ChatMessage("Container is locked!");
					return;
				}
				if (!itemContainerId.IsValid)
				{
					if (baseEntity == loot.entitySource)
					{
						foreach (ItemContainer container in loot.containers)
						{
							if (!container.PlayerItemInputBlocked() && !container.IsLocked() && item.MoveToContainer(container, -1, allowStack: true, ignoreStackLimit: false, base.baseEntity))
							{
								break;
							}
						}
						return;
					}
					if (!GiveItem(item, null, flag))
					{
						msg.player.ChatMessage("GiveItem failed!");
					}
					return;
				}
			}
			ItemContainer itemContainer = FindContainer(itemContainerId);
			if (itemContainer == null)
			{
				msg.player.ChatMessage(string.Concat("Invalid container (", itemContainerId, ")"));
				return;
			}
			if (itemContainer.IsLocked())
			{
				msg.player.ChatMessage("Container is locked!");
				return;
			}
			if (itemContainer.PlayerItemInputBlocked())
			{
				msg.player.ChatMessage("Container does not accept player items!");
				return;
			}
			using (TimeWarning.New("Split"))
			{
				if (item.amount > num2)
				{
					int split_Amount = num2;
					if (itemContainer.maxStackSize > 0)
					{
						split_Amount = Mathf.Min(num2, itemContainer.maxStackSize);
					}
					Item item2 = item.SplitItem(split_Amount);
					if (!item2.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))
					{
						item.amount += item2.amount;
						item2.Remove();
					}
					ItemManager.DoRemoves();
					ServerUpdate(0f);
					return;
				}
			}
			if (item.MoveToContainer(itemContainer, num, allowStack: true, ignoreStackLimit: false, base.baseEntity))
			{
				ItemManager.DoRemoves();
				ServerUpdate(0f);
			}
		}
	}

```

## OnComposterUpdate(Composter)

```csharp
```csharp
/// <summary>
/// Called when the composter is updated.
/// </summary>
/// <param name="composter">The composter instance.</param>
/// <returns>
/// Returns `null` to allow the composter update to proceed normally, or any non-null value to prevent the update from happening.
/// </returns>
object OnComposterUpdate(Composter composter)
{
    Puts($"Composter {composter.compostLevel} is being updated.");
    if (composter.compostLevel >= 90)
    {
        Puts($"Composter {composter.compostLevel} is already at maximum capacity.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateComposting()
	{
		if (Interface.CallHook("OnComposterUpdate", this) != null)
		{
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				CompostItem(slot);
			}
		}
	}

```

## OnTakeCurrencyItem(VendingMachine,Item)

```csharp
```csharp
/// <summary>
/// Called when a currency item is taken from the vending machine.
/// </summary>
/// <param name="vendingMachine">The vending machine that the item was taken from.</param>
/// <param name="item">The currency item that was taken.</param>
/// <returns>
/// Returns `null` to allow the item to be taken, or any non-null value to prevent it from being taken.
/// </returns>
object OnTakeCurrencyItem(VendingMachine vendingMachine, Item item)
{
    Puts($"Currency item {item.name} has been taken from vending machine {vendingMachine.name}");
    if (item.amount > 10)
    {
        Puts($"Warning: Attempted to take more than 10 currency items from vending machine {vendingMachine.name}");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void TakeCurrencyItem(Item takenCurrencyItem)
	{
		if (Interface.CallHook("OnTakeCurrencyItem", this, takenCurrencyItem) == null && !takenCurrencyItem.MoveToContainer(base.inventory))
		{
			takenCurrencyItem.Drop(base.inventory.dropPosition, Vector3.zero);
		}
	}

```

## OnXmasGiftsDistribute(XMasRefill,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when Christmas gifts are being distributed to a player.
/// </summary>
/// <param name="refill">The XMasRefill object.</param>
/// <param name="player">The BasePlayer receiving the gifts.</param>
/// <returns>
/// Returns `true` if the gift distribution should proceed, or `false` to cancel it.
/// </returns>
bool OnXmasGiftsDistribute(XMasRefill refill, BasePlayer player)
{
    Puts($"Distributing Christmas gifts for player {player.UserIDString}.");
    // Check if the player has already received their maximum number of gifts
    int maxGifts = 5;
    if (player.GetDataContainer().Get<int>("xmas_gifts") >= maxGifts)
    {
        Puts("Player has already received their maximum number of gifts.");
        return false;
    }
    
    // If the player's gift count is still below the maximum, proceed with distribution
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool DistributeGiftsForPlayer(BasePlayer player)
	{
		if (Interface.CallHook("OnXmasGiftsDistribute", this, player) != null)
		{
			return false;
		}
		int num = GiftsPerPlayer();
		int num2 = GiftSpawnAttempts();
		for (int i = 0; i < num2; i++)
		{
			if (num <= 0)
			{
				break;
			}
			Vector2 vector = UnityEngine.Random.insideUnitCircle * GiftRadius();
			Vector3 pos = player.transform.position + new Vector3(vector.x, 10f, vector.y);
			Quaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);
			if (DropToGround(ref pos))
			{
				string resourcePath = giftPrefabs[UnityEngine.Random.Range(0, giftPrefabs.Length)].resourcePath;
				BaseEntity baseEntity = GameManager.server.CreateEntity(resourcePath, pos, rot);
				if ((bool)baseEntity)
				{
					baseEntity.Spawn();
					num--;
				}
			}
		}
		return true;
	}

```

## OnFuelItemCheck(EntityFuelSystem,StorageContainer)

```csharp
```csharp
/// <summary>
/// Called when checking the fuel item in a fuel system.
/// </summary>
/// <param name="fuelSystem">The fuel system being checked.</param>
/// <param name="container">The storage container holding the fuel item.</param>
/// <returns>
/// Returns an `Item` object if a valid fuel item is found, or `null` otherwise.
/// If multiple return types are possible, returns `object` to allow for flexibility in the calling code.
/// </returns>
object OnFuelItemCheck(EntityFuelSystem fuelSystem, StorageContainer container)
{
    Puts($"Checking fuel item in {fuelSystem.name} with container {container.name}");
    if (container == null || container.inventory.GetSlot(0) is null)
    {
        return null;
    }
    Item fuelItem = container.inventory.GetSlot(0);
    if (fuelItem != null && fuelItem.info.category == "Fuel")
    {
        Puts($"Found valid fuel item: {fuelItem.name}");
        return fuelItem;
    }
    else
    {
        Puts($"No valid fuel item found in {container.name}");
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public Item GetFuelItem()
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("OnFuelItemCheck", this, fuelContainer);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (fuelContainer == null)
		{
			return null;
		}
		return fuelContainer.inventory.GetSlot(0);
	}

```

## OnItemRefill(Item,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an item is refilled.
/// </summary>
/// <param name="item">The item being refilled.</param>
/// <param name="player">The player who initiated the refill.</param>
/// <returns>
/// Returns `null` to allow the item to be refilled, or any non-null value to prevent the item from being refilled.
/// </returns>
object OnItemRefill(Item item, BasePlayer player)
{
    Puts($"Item {item.info.name} has been refilled for player {player.displayName}");
    if (item.info.category == "explosive")
    {
        Puts($"Item {item.info.name} is an explosive and cannot be refilled.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void ServerCommand(Item item, string command, BasePlayer player)
	{
		if (command == "refill" && !player.IsSwimming() && HasCraftLevel(player) && !(item.conditionNormalized >= 1f) && Interface.CallHook("OnItemRefill", item, player) == null)
		{
			item.DoRepair(conditionLost);
			if (successEffect.isValid)
			{
				Effect.server.Run(successEffect.resourcePath, player.eyes.position);
			}
		}
	}

```

## OnMlrsTarget(MLRS,UnityEngine.Vector3,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a MLRS target is set.
/// </summary>
/// <param name="mlrs">The MLRS instance.</param>
/// <param name="worldPosition">The world position of the target.</param>
/// <param name="player">The player who fired the MLRS.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the target is set as normal.
/// </returns>
object OnMlrsTarget(MLRS mlrs, Vector3 worldPosition, BasePlayer player)
{
    Puts($"MLRS {mlrs} fired by {player} hit a target at position {worldPosition}");
    if (worldPosition.x < 0f || worldPosition.z < 0f || worldPosition.y < 0f)
    {
        Puts($"Target position is invalid: x={worldPosition.x}, z={worldPosition.z}, y={worldPosition.y}");
        return "Invalid target position.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetUserTargetHitPos(Vector3 worldPos)
	{
		if (UserTargetHitPos == worldPos)
		{
			return;
		}
		if (base.isServer)
		{
			Vector3 position = TerrainMeta.Position;
			Vector3 vector = position + TerrainMeta.Size;
			worldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);
			worldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);
			worldPos.y = GetSurfaceHeight(worldPos);
		}
		if (Interface.CallHook("OnMlrsTarget", this, worldPos, _mounted) != null)
		{
			return;
		}
		UserTargetHitPos = worldPos;
		if (base.isServer)
		{
			trueTargetHitPos = UserTargetHitPos;
			foreach (TriggerSafeZone allSafeZone in TriggerSafeZone.allSafeZones)
			{
				Vector3 center = allSafeZone.triggerCollider.bounds.center;
				center.y = 0f;
				float num = ColliderEx.GetRadius(allSafeZone.triggerCollider, allSafeZone.transform.localScale) + targetAreaRadius;
				trueTargetHitPos.y = 0f;
				if (Vector3.Distance(center, trueTargetHitPos) < num)
				{
					Vector3 vector2 = trueTargetHitPos - center;
					trueTargetHitPos = center + vector2.normalized * num;
					trueTargetHitPos.y = GetSurfaceHeight(trueTargetHitPos);
					break;
				}
			}
		}
		Interface.CallHook("OnMlrsTargetSet", this, trueTargetHitPos, _mounted);
	}

```

## OnHelicopterOutOfCrates(CH47HelicopterAIController)

```csharp
```csharp
/// <summary>
/// Called when a helicopter runs out of crates.
/// </summary>
/// <param name="helicopter">The helicopter that ran out of crates.</param>
/// <returns>
/// Returns `true` if the helicopter should stop flying, and `false` otherwise.
/// If no return value is specified, the helicopter will continue to fly until it runs out of crates.
/// </returns>
bool OnHelicopterOutOfCrates(CH47HelicopterAIController helicopter)
{
    Puts($"Helicopter {helicopter.GetReference().name} has run out of crates.");
    if (helicopter.GetReference().GetDistanceToBase() < 100f)
    {
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

```

## OnNpcAlert(ScientistNPC)

```csharp
```csharp
/// <summary>
/// Called when an NPC alerts.
/// </summary>
/// <param name="npc">The NPC that alerted.</param>
/// <returns>
/// Returns `null` to allow the NPC to alert, or any non-null value to prevent them from alerting.
/// </returns>
object OnNpcAlert(ScientistNPC npc)
{
    Puts($"NPC {npc.Name} has alerted.");
    if (npc.IsInDanger())
    {
        Puts($"NPC {npc.Name} is in danger and will not alert again for 5 minutes.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Alert()
	{
		if (Interface.CallHook("OnNpcAlert", this) == null)
		{
			lastAlertedTime = Time.time;
			SetChatterType(RadioChatterType.Alert);
		}
	}

```

## OnIngredientsCollect(ItemCrafter,ItemBlueprint,ItemCraftTask,int,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when ingredients are collected for crafting.
/// </summary>
/// <param name="itemCrafter">The item crafter collecting the ingredients.</param>
/// <param name="blueprint">The blueprint being crafted.</param>
/// <param name="task">The craft task being executed.</param>
/// <param name="amount">The amount of ingredients to collect (default: 1).</param>
/// <param name="player">The player collecting the ingredients (default: null).</param>
/// <returns>
/// Returns `null` if the ingredients are collected normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message to inform the player about the collection result.
/// </returns>
object OnIngredientsCollect(ItemCrafter itemCrafter, ItemBlueprint blueprint, ItemCraftTask task, int amount = 1, BasePlayer player = null)
{
    Puts($"Player {player?.displayName} is collecting ingredients for crafting {blueprint.name}.");
    if (task.potentialOwners.Contains(player?.userID))
    {
        Puts($"Player {player.displayName} has already collected ingredients for this task.");
        return "Already collected ingredients.";
    }
    // Additional logic can be added here to override the default behavior
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void CollectIngredients(ItemBlueprint bp, ItemCraftTask task, int amount = 1, BasePlayer player = null)
	{
		if (Interface.CallHook("OnIngredientsCollect", this, bp, task, amount, player) != null)
		{
			return;
		}
		List<Item> list = new List<Item>();
		foreach (ItemAmount ingredient in bp.ingredients)
		{
			CollectIngredient(ingredient.itemid, (int)ingredient.amount * amount, list);
		}
		task.potentialOwners = new List<ulong>();
		foreach (Item item in list)
		{
			item.CollectedForCrafting(player);
			if (!task.potentialOwners.Contains(player.userID))
			{
				task.potentialOwners.Add(player.userID);
			}
		}
		task.takenItems = list;
	}

```

## OnEngineStatsRefresh(VehicleModuleEngine,Rust.Modular.EngineStorage)

```csharp
```csharp
/// <summary>
/// Called when the engine performance stats are refreshed.
/// </summary>
/// <param name="engine">The engine module.</param>
/// <param name="storage">The engine storage data.</param>
/// <returns>
/// Returns `null` to allow the engine stats to be refreshed, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for the "OnEngineStatsRefreshed" hook.
/// </returns>
object OnEngineStatsRefresh(VehicleModuleEngine engine, Rust.Modular.EngineStorage storage)
{
    Puts($"Engine {engine.GetType().Name} performance stats refreshed.");
    if (storage == null || !storage.isUsable)
    {
        return "Error: Engine storage is invalid or unusable.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void RefreshPerformanceStats(EngineStorage engineStorage)
	{
		if (Interface.CallHook("OnEngineStatsRefresh", this, engineStorage) == null)
		{
			if (engineStorage == null)
			{
				IsUsable = false;
				PerformanceFractionAcceleration = 0f;
				PerformanceFractionTopSpeed = 0f;
				PerformanceFractionFuelEconomy = 0f;
			}
			else
			{
				IsUsable = engineStorage.isUsable;
				PerformanceFractionAcceleration = GetPerformanceFraction(engineStorage.accelerationBoostPercent);
				PerformanceFractionTopSpeed = GetPerformanceFraction(engineStorage.topSpeedBoostPercent);
				PerformanceFractionFuelEconomy = GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);
			}
			OverallPerformanceFraction = (PerformanceFractionAcceleration + PerformanceFractionTopSpeed + PerformanceFractionFuelEconomy) / 3f;
			Interface.CallHook("OnEngineStatsRefreshed", this, engineStorage);
		}
	}

```

## CanSwapToSeat(BasePlayer,ModularCarSeat)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can swap to this seat.
/// </summary>
/// <param name="player">The player attempting to swap.</param>
/// <param name="seat">The seat being swapped into.</param>
/// <returns>
/// Returns `true` if the player can swap, or `false` if they cannot. If a non-bool value is returned, it will be used as the reason for denying the swap.
/// </returns>
object CanSwapToSeat(BasePlayer player, ModularCarSeat seat)
{
    Puts($"Player {player.UserIDString} attempting to swap into seat {seat.SeatNumber}");
    if (player.IsAdmin)
    {
        return true;
    }
    else if (seat.Locked)
    {
        return "Locked: Seat is locked";
    }
    else
    {
        return null;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (associatedSeatingModule.DoorsAreLockable)
		{
			ModularCar modularCar = associatedSeatingModule.Vehicle as ModularCar;
			if (modularCar != null)
			{
				return modularCar.PlayerCanUseThis(player, ModularCarCodeLock.LockType.Door);
			}
		}
		return true;
	}

```

## OnVehicleModuleSelected(Item,ModularCarGarage,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a vehicle module is selected.
/// </summary>
/// <param name="item">The item that was selected.</param>
/// <param name="garage">The modular car garage where the selection occurred.</param>
/// <param name="player">The player who made the selection.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the module will be added to the player's inventory as normal.
/// </returns>
object OnVehicleModuleSelected(Item item, ModularCarGarage garage, BasePlayer player)
{
    Puts($"Player {player.displayName} has selected vehicle module {item.name} in garage {garage.name}.");
    if (item.name == "Special Module")
    {
        Puts($"Player {player.displayName} has been granted access to the special module.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	public void RPC_SelectedLootItem(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		ItemId itemUID = msg.read.ItemID();
		if (player == null || !player.inventory.loot.IsLooting() || player.inventory.loot.entitySource != this || !HasOccupant)
		{
			return;
		}
		Item vehicleItem = carOccupant.GetVehicleItem(itemUID);
		if (vehicleItem == null || Interface.CallHook("OnVehicleModuleSelect", vehicleItem, this, player) != null)
		{
			return;
		}
		bool flag = player.inventory.loot.RemoveContainerAt(3);
		if (TryGetModuleForItem(vehicleItem, out var result))
		{
			if (result is VehicleModuleStorage vehicleModuleStorage)
			{
				IItemContainerEntity container = vehicleModuleStorage.GetContainer();
				if (!ObjectEx.IsUnityNull(container))
				{
					player.inventory.loot.AddContainer(container.inventory);
					flag = true;
				}
			}
			else if (result is VehicleModuleCamper vehicleModuleCamper)
			{
				IItemContainerEntity container2 = vehicleModuleCamper.GetContainer();
				if (!ObjectEx.IsUnityNull(container2))
				{
					player.inventory.loot.AddContainer(container2.inventory);
					flag = true;
				}
			}
		}
		if (flag)
		{
			player.inventory.loot.SendImmediate();
		}
		Interface.CallHook("OnVehicleModuleSelected", vehicleItem, this, player);
	}

```

## OnPlayerReported(BasePlayer,string,string,string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player reports another player.
/// </summary>
/// <param name="reporter">The player who made the report.</param>
/// <param name="targetId">The ID of the player being reported.</param>
/// <param name="targetName">The name of the player being reported.</param>
/// <param name="subject">The subject of the report (e.g. "cheating").</param>
/// <param name="message">A message describing the reason for the report.</param>
/// <param name="type">The type of report (e.g. "harassment", "cheating", etc.).</param>
object OnPlayerReported(BasePlayer reporter, string targetId, string targetName, string subject, string message, string type)
{
    Puts($"Player {reporter.displayName} reported player {targetName} with ID {targetId} for {subject}: {message}");
    // You can add custom logic here to handle the report, such as sending a notification to staff or logging the incident.
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.CallsPerSecond(1uL)]
	public void OnPlayerReported(RPCMessage msg)
	{
		string text = msg.read.String();
		string text2 = msg.read.StringMultiLine();
		string text3 = msg.read.String();
		string text4 = msg.read.String();
		string text5 = msg.read.String();
		DebugEx.Log($"[PlayerReport] {this} reported {text5}[{text4}] - \"{text}\"");
		RCon.Broadcast(RCon.LogType.Report, new
		{
			PlayerId = UserIDString,
			PlayerName = displayName,
			TargetId = text4,
			TargetName = text5,
			Subject = text,
			Message = text2,
			Type = text3
		});
		Interface.CallHook("OnPlayerReported", this, text5, text4, text, text2, text3);
	}

```

## OnPhotoCapture(PhotoEntity,Item,BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a photo is captured.
/// </summary>
/// <param name="photoEntity">The entity of the captured photo.</param>
/// <param name="item">The item used to capture the photo.</param>
/// <param name="player">The player who captured the photo.</param>
/// <param name="imageData">The image data of the captured photo.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the photo is captured as normal.
/// </returns>
object OnPhotoCapture(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] imageData)
{
    Puts($"Photo captured by {player.displayName} using {item.info.name}.");
    if (imageData.Length > 102400)
    {
        Puts("Image data is too large.");
        return "Error: Image data is too large.";
    }
    // Additional logic can be added here to handle the photo capture event
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(3uL)]
	private void TakePhoto(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Item item = GetItem();
		if (player == null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError("Failed to create photo item");
			return;
		}
		if (!item2.instanceData.subEntity.IsValid)
		{
			item2.Remove();
			Debug.LogError("Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if (baseNetworkable == null)
		{
			item2.Remove();
			Debug.LogError("Sub-entity was not found");
			return;
		}
		if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError("Sub-entity is not a photo");
			return;
		}
		photoEntity.SetImageData(player.userID, array);
		if (Interface.CallHook("OnPhotoCapture", photoEntity, item, player, array) != null)
		{
			return;
		}
		if (!player.inventory.GiveItem(item2))
		{
			item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
		}
		EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));
		if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
		{
			Vector3 position = GetOwnerPlayer().eyes.position;
			Vector3 vector = GetOwnerPlayer().eyes.HeadForward();
			List<BasePlayer> obj = Facepunch.Pool.GetList<BasePlayer>();
			Vis.Entities(position + vector * 5f, 5f, obj, 131072);
			foreach (BasePlayer item3 in obj)
			{
				if (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
				{
					hasSentAchievement = true;
					GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
					break;
				}
			}
			Facepunch.Pool.FreeList(ref obj);
		}
		item.LoseCondition(1f);
		Interface.CallHook("OnPhotoCaptured", photoEntity, item, player, array);
	}

```

## CanExplosiveStick(TimedExplosive,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called to determine if an explosive can stick to a given entity.
/// </summary>
/// <param name="explosive">The explosive trying to stick.</param>
/// <param name="entity">The entity the explosive is trying to stick to.</param>
/// <returns>
/// Returns `true` if the explosive can stick, and `false` otherwise.
/// If a non-null value other than `bool` is returned, it will override the default behavior.
/// </returns>
object CanExplosiveStick(TimedExplosive explosive, BaseEntity entity)
{
    Puts($"Trying to stick {explosive} to {entity}");
    if (entity is Player && ((Player)entity).IsAdmin)
    {
        Puts("Cannot stick to admin player.");
        return false;
    }
    object result = Interface.CallHook("CanExplosiveStick", explosive, entity);
    if (result is bool)
    {
        return (bool)result;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanStickTo(BaseEntity entity)
	{
		object obj = Interface.CallHook("CanExplosiveStick", this, entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (entity.TryGetComponent<DecorDeployable>(out var _))
		{
			return false;
		}
		if (entity is Drone)
		{
			return false;
		}
		return true;
	}

```

## OnVehicleLockableCheck(ModularCarCodeLock)

```csharp
```csharp
/// <summary>
/// Called to check if a vehicle can have a lock.
/// </summary>
/// <param name="vehicle">The vehicle being checked.</param>
/// <returns>
/// Returns `true` if the vehicle can have a lock, and `false` otherwise.
/// If any non-bool value is returned from this hook, it will be ignored and the default behavior will be used instead.
/// </returns>
bool OnVehicleLockableCheck(ModularCarCodeLock vehicle)
{
    Puts($"Checking if {vehicle.GetType().Name} can have a lock...");
    // Default implementation: return true
    return true;
}
```
```

### Source Code from the Library

```csharp

	public bool CanHaveALock()
	{
		object obj = Interface.CallHook("OnVehicleLockableCheck", this);
		if (obj != null)
		{
			if (!(obj is bool))
			{
				return false;
			}
			return (bool)obj;
		}
		if (!owner.IsDead())
		{
			return owner.HasDriverMountPoints();
		}
		return false;
	}

```

## CanAdministerVending(BasePlayer,VendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can administer a vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanAdministerVending(BasePlayer player, VendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} attempting to administer vending machine {vendingMachine.name}");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.HasPermission("can_admin_vending"))
    {
        return true;
    }
    else
    {
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (PlayerBehind(player))
		{
			return OccupiedCheck(player);
		}
		return false;
	}

```

## OnItemResearched(ResearchTable,int)

```csharp
```csharp
/// <summary>
/// Called when an item is researched.
/// </summary>
/// <param name="researchTable">The research table used for the research.</param>
/// <param name="numScrapUsed">The number of scrap items used in the research.</param>
/// <returns>
/// Returns a non-null value to override the default behavior when an item is researched. 
/// If `null` is returned, the item is researched as normal.
/// </returns>
object OnItemResearched(ResearchTable researchTable, int numScrapUsed)
{
    Puts($"Item has been researched using {numScrapUsed} scrap items.");
    if (numScrapUsed < 10)
    {
        Puts($"Insufficient scrap used for research. Required: 10, Used: {numScrapUsed}");
        return "Error: Insufficient scrap used.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void ResearchAttemptFinished()
	{
		Item targetItem = GetTargetItem();
		Item scrapItem = GetScrapItem();
		if (targetItem != null && scrapItem != null)
		{
			int num = ScrapForResearch(targetItem);
			object obj = Interface.CallHook("OnItemResearched", this, num);
			if (obj is int)
			{
				num = (int)obj;
			}
			if (scrapItem.amount >= num)
			{
				if (scrapItem.amount == num)
				{
					base.inventory.Remove(scrapItem);
					scrapItem.RemoveFromContainer();
					scrapItem.Remove();
				}
				else
				{
					scrapItem.UseItem(num);
				}
				base.inventory.Remove(targetItem);
				targetItem.Remove();
				Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
				item.blueprintTarget = ((targetItem.info.isRedirectOf != null) ? targetItem.info.isRedirectOf.itemid : targetItem.info.itemid);
				if (!item.MoveToContainer(base.inventory, 0))
				{
					item.Drop(GetDropPosition(), GetDropVelocity());
				}
				if (researchSuccessEffect.isValid)
				{
					Effect.server.Run(researchSuccessEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
				}
			}
		}
		SendNetworkUpdateImmediate();
		if (user != null)
		{
			user.inventory.loot.SendImmediate();
		}
		EndResearch();
	}

```

## IOnPlayerChat(ulong,string,string,ConVar.Chat.ChatChannel,BasePlayer)

```csharp
Based on the provided code snippet, I will create a method structure for `IOnPlayerChat` with parameters `userId`, `username`, `text`, `targetChannel`, and `player`.

```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
public object IOnPlayerChat(int userId, string username, string text, ChatChannel targetChannel, BasePlayer player)
{
    // Code to handle the chat message goes here
}
```

This method structure includes all the parameters mentioned in the code snippet. The return type is `object` as it can return any type of data.

Please note that this is a basic implementation and you may need to modify it based on your specific requirements.
```

### Source Code from the Library

```csharp

	internal static bool sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)
	{
		if (!player)
		{
			player = null;
		}
		if (!enabled)
		{
			return false;
		}
		if (player != null && player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return false;
		}
		ServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;
		if (userGroup == ServerUsers.UserGroup.Banned)
		{
			return false;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (text.Length > 128)
		{
			text = text.Substring(0, 128);
		}
		if (text.Length <= 0)
		{
			return false;
		}
		if (text.StartsWith("/") || text.StartsWith("\\"))
		{
			Interface.CallHook("IOnPlayerCommand", player, message);
			return false;
		}
		text = text.EscapeRichText();
		object obj = Interface.CallHook("IOnPlayerChat", userId, username, text, targetChannel, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured(ConsoleColor.DarkYellow, string.Concat("[", targetChannel, "] ", username, ": "), ConsoleColor.DarkGreen, text);
			string text2 = player?.ToString() ?? $"{username}[{userId}]";
			switch (targetChannel)
			{
			case ChatChannel.Team:
				DebugEx.Log("[TEAM CHAT] " + text2 + " : " + text);
				break;
			case ChatChannel.Cards:
				DebugEx.Log("[CARDS CHAT] " + text2 + " : " + text);
				break;
			default:
				DebugEx.Log("[CHAT] " + text2 + " : " + text);
				break;
			}
		}
		bool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;
		bool num = ((player != null) ? player.IsDeveloper : DeveloperList.Contains(userId));
		string text3 = "#5af";
		if (flag)
		{
			text3 = "#af5";
		}
		if (num)
		{
			text3 = "#fa5";
		}
		string text4 = username.EscapeRichText();
		ChatEntry ce = default(ChatEntry);
		ce.Channel = targetChannel;
		ce.Message = text;
		ce.UserId = ((player != null) ? player.UserIDString : userId.ToString());
		ce.Username = username;
		ce.Color = text3;
		ce.Time = Epoch.Current;
		Record(ce);
		switch (targetChannel)
		{
		case ChatChannel.Cards:
		{
			if (player == null)
			{
				return false;
			}
			if (!player.isMounted)
			{
				return false;
			}
			BaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;
			if (baseCardGameEntity == null || !baseCardGameEntity.GameController.IsAtTable(player))
			{
				return false;
			}
			List<Network.Connection> obj2 = Facepunch.Pool.GetList<Network.Connection>();
			baseCardGameEntity.GameController.GetConnectionsInGame(obj2);
			if (obj2.Count > 0)
			{
				ConsoleNetwork.SendClientCommand(obj2, "chat.add2", 3, userId, text, text4, text3, 1f);
			}
			Facepunch.Pool.FreeList(ref obj2);
			return true;
		}
		case ChatChannel.Global:
			ConsoleNetwork.BroadcastToAllClients("chat.add2", 0, userId, text, text4, text3, 1f);
			return true;
		case ChatChannel.Local:
		{
			if (!(player != null))
			{
				break;
			}
			float num2 = localChatRange * localChatRange;
			foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
			{
				float sqrMagnitude = (activePlayer.transform.position - player.transform.position).sqrMagnitude;
				if (!(sqrMagnitude > num2))
				{
					ConsoleNetwork.SendClientCommand(activePlayer.net.connection, "chat.add2", 4, userId, text, text4, text3, Mathf.Clamp01(sqrMagnitude / num2 + 0.2f));
				}
			}
			return true;
		}
		case ChatChannel.Team:
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);
			if (playerTeam == null)
			{
				return false;
			}
			List<Network.Connection> onlineMemberConnections = playerTeam.GetOnlineMemberConnections();
			if (onlineMemberConnections != null)
			{
				ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add2", 1, userId, text, text4, text3, 1f);
			}
			playerTeam.BroadcastTeamChat(userId, text4, text, text3);
			return true;
		}
		}
		return false;
	}

```

## OnPhotoCaptured(PhotoEntity,Item,BasePlayer,byte[])

```csharp
```csharp
/// <summary>
/// Called when a photo is captured.
/// </summary>
/// <param name="photoEntity">The entity of the captured photo.</param>
/// <param name="item">The item used to capture the photo.</param>
/// <param name="player">The player who captured the photo.</param>
/// <param name="imageData">The image data of the captured photo.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. 
/// If `null` is returned, the photo is captured as normal.
/// </returns>
object OnPhotoCaptured(PhotoEntity photoEntity, Item item, BasePlayer player, byte[] imageData)
{
    Puts($"Photo captured by {player.displayName} using {item.info.name}.");
    if (imageData.Length > 102400)
    {
        Puts("Image data is too large.");
        return "Error: Image data is too large.";
    }
    // Add custom logic here
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.FromOwner]
	[RPC_Server.CallsPerSecond(3uL)]
	private void TakePhoto(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		Item item = GetItem();
		if (player == null || item == null || item.condition <= 0f)
		{
			return;
		}
		byte[] array = msg.read.BytesWithSize();
		if (array.Length > 102400 || !ImageProcessing.IsValidJPG(array, resolutionX, resolutionY))
		{
			return;
		}
		Item item2 = ItemManager.Create(photoItem, 1, 0uL);
		if (item2 == null)
		{
			Debug.LogError("Failed to create photo item");
			return;
		}
		if (!item2.instanceData.subEntity.IsValid)
		{
			item2.Remove();
			Debug.LogError("Photo has no sub-entity");
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item2.instanceData.subEntity);
		if (baseNetworkable == null)
		{
			item2.Remove();
			Debug.LogError("Sub-entity was not found");
			return;
		}
		if (!(baseNetworkable is PhotoEntity photoEntity))
		{
			item2.Remove();
			Debug.LogError("Sub-entity is not a photo");
			return;
		}
		photoEntity.SetImageData(player.userID, array);
		if (Interface.CallHook("OnPhotoCapture", photoEntity, item, player, array) != null)
		{
			return;
		}
		if (!player.inventory.GiveItem(item2))
		{
			item2.Drop(player.GetDropPosition(), player.GetDropVelocity());
		}
		EffectNetwork.Send(new Effect(screenshotEffect.resourcePath, base.transform.position, base.transform.forward, msg.connection));
		if (!hasSentAchievement && !string.IsNullOrEmpty("SUMMER_PAPARAZZI"))
		{
			Vector3 position = GetOwnerPlayer().eyes.position;
			Vector3 vector = GetOwnerPlayer().eyes.HeadForward();
			List<BasePlayer> obj = Facepunch.Pool.GetList<BasePlayer>();
			Vis.Entities(position + vector * 5f, 5f, obj, 131072);
			foreach (BasePlayer item3 in obj)
			{
				if (item3.isServer && item3 != GetOwnerPlayer() && item3.IsVisible(GetOwnerPlayer().eyes.position))
				{
					hasSentAchievement = true;
					GetOwnerPlayer().GiveAchievement("SUMMER_PAPARAZZI");
					break;
				}
			}
			Facepunch.Pool.FreeList(ref obj);
		}
		item.LoseCondition(1f);
		Interface.CallHook("OnPhotoCaptured", photoEntity, item, player, array);
	}

```

## OnRemoveDying(GrowableEntity,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a dying entity is removed.
/// </summary>
/// <param name="entity">The entity being removed.</param>
/// <param name="player">The player who initiated the removal, or null if it was done automatically.</param>
/// <returns>
/// Returns `null` to allow the entity to be removed normally. 
/// If a non-null value is returned, the removal will be cancelled and the entity will not be removed.
/// </returns>
object OnRemoveDying(GrowableEntity entity, BasePlayer player)
{
    Puts($"Removing dying entity {entity.name} for player {player.displayName}");
    if (player == null || player.UserIDString == "admin")
    {
        return null;
    }
    // Cancel removal
    return true;
}
```
```

### Source Code from the Library

```csharp

	public void RemoveDying(BasePlayer receiver)
	{
		if (State == PlantProperties.State.Dying && !(Properties.removeDyingItem == null) && Interface.CallHook("OnRemoveDying", this, receiver) == null)
		{
			if (Properties.removeDyingEffect.isValid)
			{
				Effect.server.Run(Properties.removeDyingEffect.resourcePath, base.transform.position, Vector3.up);
			}
			Item item = ItemManager.Create(Properties.removeDyingItem, 1, 0uL);
			if (receiver != null)
			{
				receiver.GiveItem(item, GiveItemReason.PickedUp);
			}
			else
			{
				item.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f);
			}
			Die();
		}
	}

```

## OnPlayerAttack(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a player attacks another entity.
/// </summary>
/// <param name="player">The player performing the attack.</param>
/// <param name="info">Information about the attack, including the hit entity and damage dealt.</param>
/// <returns>
/// Returns `null` to allow the default attack behavior. If a non-null value is returned, it will override the default behavior.
/// </returns>
object OnPlayerAttack(BasePlayer player, HitInfo info)
{
    Puts($"Player {player.UserIDString} attacked entity {info.HitEntity?.ToString()} with damage {info.Damage}.");
    if (info.HitEntity is BaseCombatEntity combatEntity && combatEntity.IsCritical)
    {
        Puts($"Critical hit on entity {combatEntity.ToString()}");
        return "Critical Hit";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", GetOwnerPlayer(), info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if (info.HitEntity != null)
		{
			using (TimeWarning.New("OnAttacked", 50))
			{
				info.HitEntity.OnAttacked(info);
			}
		}
		if (info.DoHitEffects)
		{
			if (base.isServer)
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.server.ImpactEffect(info);
				}
			}
			else
			{
				using (TimeWarning.New("ImpactEffect", 20))
				{
					Effect.client.ImpactEffect(info);
				}
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			using (TimeWarning.New("UpdateItemCondition", 50))
			{
				UpdateItemCondition(info);
			}
			StartAttackCooldown(repeatDelay);
		}
	}

```

## OnMlrsFired(MLRS,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when the MLRS is fired.
/// </summary>
/// <param name="mlrs">The MLRS instance that was fired.</param>
/// <param name="owner">The player who fired the MLRS.</param>
/// <returns>
/// Returns `null` to allow the MLRS to fire normally, or any non-null value to prevent it from firing.
/// </returns>
object OnMlrsFired(MLRS mlrs, BasePlayer owner)
{
    Puts($"MLRS fired by player {owner.displayName}.");
    if (mlrs.GetAmmoCount() <= 0)
    {
        Puts($"MLRS out of ammo. Cannot fire.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Fire(BasePlayer owner)
	{
		UpdateStorageState();
		if (CanFire && !(_mounted == null) && Interface.CallHook("OnMlrsFire", this, owner) == null)
		{
			SetFlag(Flags.Reserved6, b: true);
			radiusModIndex = 0;
			nextRocketIndex = Mathf.Min(RocketAmmoCount - 1, rocketTubes.Length - 1);
			rocketOwnerRef.Set(owner);
			InvokeRepeating(FireNextRocket, 0f, 0.5f);
			Interface.CallHook("OnMlrsFired", this, owner);
		}
	}

```

## CanUseLockedEntity(BasePlayer,CodeLock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use a locked entity.
/// </summary>
/// <param name="player">The player attempting to use the locked entity.</param>
/// <param name="entity">The locked entity being accessed.</param>
/// <returns>
/// Returns `true` if the player is allowed to use the locked entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanUseLockedEntity(BasePlayer player, CodeLock entity)
{
    Puts($"Player {player.UserIDString} attempted to access locked entity {entity.EntityID}");
    if (player.IsAdmin)
    {
        Puts($"Player {player.UserIDString} is an admin and can access the locked entity");
        return true;
    }
    else if (player.HasPermission(entity.GetPermissionName()))
    {
        Puts($"Player {player.UserIDString} has permission to access the locked entity");
        return true;
    }
    else
    {
        Puts($"Player {player.UserIDString} does not have permission to access the locked entity");
        return false;
    }
}
```
```

### Source Code from the Library

```csharp

	public override bool OnTryToOpen(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUseLockedEntity", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!IsLocked())
		{
			return true;
		}
		if (whitelistPlayers.Contains(player.userID) || guestPlayers.Contains(player.userID))
		{
			DoEffect(effectUnlocked.resourcePath);
			return true;
		}
		DoEffect(effectDenied.resourcePath);
		return false;
	}

```

## OnPlayerLootEnd(PlayerLoot)

```csharp
```csharp
/// <summary>
/// Called when a player's looting session ends.
/// </summary>
/// <param name="playerLoot">The PlayerLoot object associated with the ended looting session.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLootEnd(PlayerLoot playerLoot)
{
    Puts($"Player {playerLoot.Player.UserIDString} has finished looting.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	public void Clear()
	{
		if (!IsLooting())
		{
			return;
		}
		Interface.CallHook("OnPlayerLootEnd", this);
		MarkDirty();
		if ((bool)entitySource)
		{
			entitySource.SendMessage("PlayerStoppedLooting", base.baseEntity, SendMessageOptions.DontRequireReceiver);
		}
		foreach (ItemContainer container in containers)
		{
			if (container != null)
			{
				container.onDirty -= MarkDirty;
			}
		}
		containers.Clear();
		entitySource = null;
		itemSource = null;
	}

```

## OnRemoteIdentifierUpdate(PoweredRemoteControlEntity,string)

```csharp
```csharp
/// <summary>
/// Called when a remote identifier is updated.
/// </summary>
/// <param name="entity">The entity whose identifier was updated.</param>
/// <param name="newID">The new identifier assigned to the entity.</param>
/// <returns>
/// Returns `null` if the update should be allowed, or any non-null value to prevent the update from occurring.
/// </returns>
object OnRemoteIdentifierUpdate(PoweredRemoteControlEntity entity, string newID)
{
    Puts($"Remote identifier for {entity.EntityName} updated to {newID}");
    // If a custom ID is being assigned that's already in use by another entity, return a non-null value
    if (RemoteControlEntity.IDInUse(newID) && !entity.isServer)
    {
        Puts($"Cannot assign ID {newID} as it's already in use by another entity.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		if (Interface.CallHook("OnRemoteIdentifierUpdate", this, newID) != null)
		{
			return;
		}
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!RemoteControlEntity.IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			if (!Rust.Application.isLoadingSave)
			{
				SendNetworkUpdate();
			}
		}
	}

```

## OnEntitySnapshot(BaseNetworkable,Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when an entity's snapshot is sent over the network.
/// </summary>
/// <param name="entity">The entity being snapped.</param>
/// <param name="connection">The connection to which the snapshot is being sent.</param>
/// <returns>
/// Returns a non-null value to override the default behavior of sending the entity's snapshot. 
/// If `null` is returned, the entity's snapshot will be sent as normal.
/// </returns>
object OnEntitySnapshot(BaseNetworkable entity, Network.Connection connection)
{
    Puts($"Sending entity snapshot for {entity.name} to connection {connection.UserIDString}");
    if (entity == null || !entity.ShouldNetworkTo(connection))
    {
        return null;
    }
    // Custom logic to modify or cancel the entity's snapshot
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SendEntitySnapshot(BaseNetworkable ent)
	{
		if (Interface.CallHook("OnEntitySnapshot", ent, net.connection) != null)
		{
			return;
		}
		using (TimeWarning.New("SendEntitySnapshot"))
		{
			if (!(ent == null) && ent.net != null && ent.ShouldNetworkTo(this))
			{
				NetWrite netWrite = Network.Net.sv.StartWrite();
				net.connection.validate.entityUpdates++;
				SaveInfo saveInfo = default(SaveInfo);
				saveInfo.forConnection = net.connection;
				saveInfo.forDisk = false;
				SaveInfo saveInfo2 = saveInfo;
				netWrite.PacketID(Message.Type.Entities);
				netWrite.UInt32(net.connection.validate.entityUpdates);
				ent.ToStreamForNetwork(netWrite, saveInfo2);
				netWrite.Send(new SendInfo(net.connection));
			}
		}
	}

```

## OnPlayerKeepAlive(BasePlayer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player keeps alive another wounded player.
/// </summary>
/// <param name="woundedPlayer">The wounded player being kept alive.</param>
/// <param name="keeperPlayer">The player keeping the wounded player alive.</param>
/// <returns>
/// Returns `null` to allow the keep alive behavior, or any non-null value to prevent it.
/// </returns>
object OnPlayerKeepAlive(BasePlayer woundedPlayer, BasePlayer keeperPlayer)
{
    Puts($"Player {keeperPlayer.UserIDString} is keeping alive player {woundedPlayer.UserIDString}");
    if (woundedPlayer.IsAdmin())
    {
        Puts($"Player {woundedPlayer.UserIDString} is an admin and cannot be kept alive.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_KeepAlive(RPCMessage msg)
	{
		if (msg.player.CanInteract() && !(msg.player == this) && IsWounded() && Interface.CallHook("OnPlayerKeepAlive", this, msg.player) == null)
		{
			ProlongWounding(10f);
		}
	}

```

## OnCargoPlaneSignaled(BaseEntity,SupplySignal)

```csharp
```csharp
/// <summary>
/// Called when a cargo plane signals.
/// </summary>
/// <param name="plane">The cargo plane that signaled.</param>
/// <param name="signal">The signal type (e.g. SupplySignal).</param>
/// <returns>No return behavior.</returns>
void OnCargoPlaneSignaled(BaseEntity plane, SupplySignal signal)
{
    Puts($"Cargo plane {plane.UserIDString} has signaled with supply signal: {signal}");
}
```
```

### Source Code from the Library

```csharp

	public override void Explode()
	{
		BaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);
		if ((bool)baseEntity)
		{
			Vector3 vector = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));
			baseEntity.SendMessage("InitDropPosition", base.transform.position + vector, SendMessageOptions.DontRequireReceiver);
			baseEntity.Spawn();
			Interface.CallHook("OnCargoPlaneSignaled", baseEntity, this);
		}
		Invoke(FinishUp, 210f);
		SetFlag(Flags.On, b: true);
		SendNetworkUpdateImmediate();
	}

```

## OnBigWheelWin(BigWheelGame,Item,BigWheelBettingTerminal,int)

```csharp
```csharp
/// <summary>
/// Called when a player wins on the Big Wheel.
/// </summary>
/// <param name="game">The Big Wheel game instance.</param>
/// <param name="itemWon">The item won by the player.</param>
/// <param name="terminal">The betting terminal where the win occurred.</param>
/// <param name="multiplier">The multiplier applied to the win amount.</param>
/// <returns>
/// Returns a non-null value to override the default payout behavior. 
/// If `null` is returned, the player receives the standard payout.
/// </returns>
object OnBigWheelWin(BigWheelGame game, Item itemWon, BigWheelBettingTerminal terminal, int multiplier)
{
    Puts($"Player won {itemWon.amount} units on the Big Wheel with a multiplier of {multiplier}.");
    if (terminal.lastPlayer == "admin")
    {
        Puts($"Admin player won {itemWon.amount} units on the Big Wheel.");
        return null;
    }
    // Custom payout logic can be implemented here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void Payout()
	{
		HitNumber currentHitType = GetCurrentHitType();
		Guid value = Guid.NewGuid();
		foreach (BigWheelBettingTerminal terminal in terminals)
		{
			if (terminal.isClient)
			{
				continue;
			}
			bool flag = false;
			bool flag2 = false;
			Item slot = terminal.inventory.GetSlot((int)currentHitType.hitType);
			if (slot != null)
			{
				int num = currentHitType.ColorToMultiplier(currentHitType.hitType);
				int amount = slot.amount;
				if (Interface.CallHook("OnBigWheelWin", this, slot, terminal, num) == null)
				{
					slot.amount += slot.amount * num;
					slot.RemoveFromContainer();
					slot.MoveToContainer(terminal.inventory, 5);
					flag = true;
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, amount, slot.amount, value);
				}
			}
			for (int i = 0; i < 5; i++)
			{
				Item slot2 = terminal.inventory.GetSlot(i);
				if (slot2 != null && Interface.CallHook("OnBigWheelLoss", this, slot2, terminal) == null)
				{
					Facepunch.Rust.Analytics.Azure.OnGamblingResult(terminal.lastPlayer, terminal, slot2.amount, 0, value);
					slot2.Remove();
					flag2 = true;
				}
			}
			if (flag || flag2)
			{
				terminal.ClientRPC(null, "WinOrLoseSound", flag);
			}
		}
		ItemManager.DoRemoves();
		SetTerminalsLocked(isLocked: false);
	}

```

## CanEntityBeHostile(BasePlayer)

```csharp
```csharp
/// <summary>
/// Determines whether an entity can be hostile.
/// </summary>
/// <param name="entity">The entity to check.</param>
/// <returns>
/// Returns `true` if the entity can be hostile, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
bool CanEntityBeHostile(BasePlayer entity)
{
    Puts($"Checking if player {entity.UserIDString} can be hostile.");
    object result = Interface.CallHook("CanEntityBeHostile", entity);
    return result != null || !entity.IsUnhostile();
}
```
```

### Source Code from the Library

```csharp

	public override bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return State.unHostileTimestamp > TimeEx.currentTimestamp;
	}

```

## OnSamSiteModeToggle(SamSite,BasePlayer,bool)

```csharp
```csharp
/// <summary>
/// Called when the defender mode of a Sam Site is toggled.
/// </summary>
/// <param name="samSite">The Sam Site whose defender mode is being toggled.</param>
/// <param name="player">The player who triggered the toggle.</param>
/// <param name="enabled">Whether the defender mode should be enabled or disabled.</param>
/// <returns>
/// Returns `null` to allow the defender mode to be toggled, or any non-null value to prevent it from being toggled.
/// </returns>
object OnSamSiteModeToggle(SamSite samSite, BasePlayer player, bool enabled)
{
    Puts($"Defender mode of Sam Site {samSite.name} has been {(enabled ? "enabled" : "disabled")} by player {player.displayName}");
    if (enabled && !player.CanBuild())
    {
        Puts($"Player {player.displayName} does not have permission to build and cannot enable defender mode.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(1uL)]
	private void ToggleDefenderMode(RPCMessage msg)
	{
		if (staticRespawn)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!(player == null) && player.CanBuild())
		{
			bool flag = msg.read.Bit();
			if (flag != IsInDefenderMode() && Interface.CallHook("OnSamSiteModeToggle", this, player, flag) == null)
			{
				SetFlag(Flag_DefenderMode, flag);
			}
		}
	}

```

## OnHelicopterAttack(CH47HelicopterAIController,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when a helicopter is attacked.
/// </summary>
/// <param name="helicopter">The helicopter being attacked.</param>
/// <param name="info">Information about the attack, including the damage dealt and the attacker's details.</param>
/// <returns>
/// Returns `null` to allow the helicopter to be damaged normally. 
/// If a non-null value is returned, it will override the default behavior and determine how the helicopter should react to the attack.
/// </returns>
object OnHelicopterAttack(CH47HelicopterAIController helicopter, HitInfo info)
{
    Puts($"Helicopter {helicopter.GetDisplayName()} has been attacked with damage: {info.damage} by {info.attacker}");
    if (info.damage >= 50)
    {
        Puts($"Helicopter {helicopter.GetDisplayName()} is severely damaged and will likely crash.");
        return "Crash imminent";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttack", this, info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved7, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

```

## CanAdministerVending(BasePlayer,NPCVendingMachine)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can administer the vending machine.
/// </summary>
/// <param name="player">The player attempting to administer the vending machine.</param>
/// <param name="vendingMachine">The vending machine being administered.</param>
/// <returns>
/// Returns `true` if the player can administer the vending machine, and `false` otherwise.
/// If a non-bool value is returned, it will be ignored and the default behavior will apply.
/// </returns>
bool CanAdministerVending(BasePlayer player, NPCVendingMachine vendingMachine)
{
    Puts($"Player {player.UserIDString} is attempting to administer vending machine {vendingMachine.name}");
    if (player.IsSuperAdmin)
    {
        Puts($"Player {player.displayName} has been granted super admin privileges.");
        return true;
    }
    return false;
}
```
```

### Source Code from the Library

```csharp

	public override bool CanPlayerAdmin(BasePlayer player)
	{
		object obj = Interface.CallHook("CanAdministerVending", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

```

## OnHelicopterStrafeEnter(PatrolHelicopterAI,UnityEngine.Vector3)

```csharp
```csharp
/// <summary>
/// Called when a helicopter enters the strafe state.
/// </summary>
/// <param name="patrolHelicopterAI">The PatrolHelicopterAI instance.</param>
/// <param name="strafePos">The position where the helicopter will start strafing.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If null is returned, the helicopter will enter the strafe state as normal.
/// </returns>
object OnHelicopterStrafeEnter(PatrolHelicopterAI patrolHelicopterAI, Vector3 strafePos)
{
    Puts($"Helicopter entering strafe state at position {strafePos}.");
    if (patrolHelicopterAI.GetFuelLevel() < 0.5f)
    {
        Puts($"Helicopter is low on fuel and cannot enter strafe state.");
        return "Low Fuel";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void State_Strafe_Enter(Vector3 strafePos, bool shouldUseNapalm = false)
	{
		if (Interface.CallHook("OnHelicopterStrafeEnter", this, strafePos) == null)
		{
			if (CanUseNapalm() && shouldUseNapalm)
			{
				useNapalm = shouldUseNapalm;
				lastNapalmTime = UnityEngine.Time.realtimeSinceStartup;
			}
			lastStrafeTime = UnityEngine.Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			int mask = LayerMask.GetMask("Terrain", "World", "Construction", "Water");
			if (TransformUtil.GetGroundInfo(strafePos, out var pos, out var _, 100f, mask, base.transform))
			{
				strafe_target_position = pos;
			}
			else
			{
				strafe_target_position = strafePos;
			}
			numRocketsLeft = 12;
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafePos, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

```

## OnHelicopterTarget(HelicopterTurret,BaseCombatEntity)

```csharp
```csharp
/// <summary>
/// Called when a helicopter turret sets its target.
/// </summary>
/// <param name="turret">The helicopter turret setting the target.</param>
/// <param name="target">The entity being targeted by the helicopter turret.</param>
/// <returns>
/// Returns `null` to allow the helicopter turret to set its target, or any non-null value to prevent it from setting its target.
/// </returns>
object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity target)
{
    Puts($"Helicopter turret {turret.GetReference()} is targeting entity {target.UserIDString}.");
    if (target is Player player && player.IsAdmin)
    {
        Puts($"Player {player.UserIDString} is being targeted by helicopter turret {turret.GetReference()}.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", this, newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

```

## OnFishCaught(ItemDefinition,BaseFishingRod,BasePlayer)

```csharp
This is a C# code snippet that appears to be part of a fishing game mechanic in the Rust game. It's a server-side script that handles the process of catching a fish. Here's a breakdown of what it does:

1. **Input Handling**: The script checks for various input flags (e.g., `HasReelInInput`, `AllowPullInDirection`) to determine if the player is trying to catch a fish.
2. **State Management**: It updates the current state of the fishing process, which can be one of three states: Waiting, Catching, or Caught.
3. **Fish State Updates**: The script updates the fish's state based on the input flags and the current state of the fishing process.
4. **Strain Timer**: It increments a strain timer that affects the fish's behavior and ultimately determines whether it will be caught or not.
5. **Catch Logic**: If the fish is caught, the script:
	* Cancels any ongoing catch process.
	* Updates the player's inventory with the caught fish.
	* Triggers various hooks (e.g., `CanCatchFish`, `OnFishCatch`) to allow for custom behavior.
	* Resets the fishing line after a short delay.

Some notable aspects of this code include:

* The use of flags and state management to handle complex game logic.
* The incorporation of hooks to allow for customization by other scripts or plugins.
* The use of timers and delays to create a sense of realism and anticipation in the game.
```

### Source Code from the Library

```csharp

	private void CatchProcessBudgeted()
	{
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (ownerPlayer == null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || fishingBobber == null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ownerPlayer.transform.position;
		float num = Vector3.Angle((fishingBobber.transform.position.WithY(0f) - position.WithY(0f)).normalized, ownerPlayer.eyes.HeadForward().WithY(0f));
		float num2 = Vector3.Distance(position, fishingBobber.transform.position.WithY(position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && (float)lastSightCheck > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, fishingBobber.transform.position, 1218511105))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = 0f;
		}
		if (Vector3.Distance(position, fishingBobber.transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if ((float)catchTime < 0f)
			{
				ClientRPC(null, "Client_HookedSomething");
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = 0f;
				fishCatchDuration = 0f;
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if ((float)nextFishStateChange < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = UnityEngine.Random.Range(2f, 4f) * (num3 + 1f);
			}
			else
			{
				nextFishStateChange = UnityEngine.Random.Range(3f, 7f) * (1f - num3);
				if (UnityEngine.Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (UnityEngine.Random.Range(0, 100) > 60 && Vector3.Distance(fishingBobber.transform.position, ownerPlayer.transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if ((float)fishCatchDuration > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), fishingBobber.transform.position))
		{
			flag = false;
		}
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		if (flag4)
		{
			strainTimer += UnityEngine.Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, UnityEngine.Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if ((float)lastStrainUpdate > 0.4f || fishState != currentFishState)
		{
			ClientRPC(null, "Client_UpdateFishState", (int)currentFishState, num5);
			lastStrainUpdate = 0f;
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else
		{
			if (!(num2 <= FishCatchDistance) && !ForceSuccess)
			{
				return;
			}
			CurrentState = CatchState.Caught;
			if (currentFishTarget != null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				object obj = Interface.CallHook("CanCatchFish", ownerPlayer, this, item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", item, this, ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(UnityEngine.Random.Range(0, 1000));
				}
				if (Rust.GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					fishLookup.CheckCatchAllAchievement(ownerPlayer);
				}
			}
			Facepunch.Rust.Analytics.Server.FishCaught(currentFishTarget);
			ClientRPC(null, "Client_OnCaughtFish", currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			Invoke(ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			CancelInvoke(CatchProcess);
			Interface.CallHook("OnFishCaught", currentFishTarget, this, ownerPlayer);
		}
	}

```

## CanCreateWorldProjectile(HitInfo,ItemDefinition)

```csharp
```csharp
/// <summary>
/// Called to determine if a world projectile can be created.
/// </summary>
/// <param name="hitInfo">Information about the hit.</param>
/// <param name="itemDef">The definition of the item being used to create the projectile.</param>
/// <returns>
/// Returns `null` if the projectile can be created, or a non-null value to override the default behavior.
/// </returns>
object CanCreateWorldProjectile(HitInfo hitInfo, ItemDefinition itemDef)
{
    Puts($"Checking if world projectile can be created with item {itemDef.name} at position {hitInfo.hitPositionWorld}.");
    // Add custom logic here to determine if the projectile can be created
    return null;
}
```
```

### Source Code from the Library

```csharp

	protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)
	{
		if (Interface.CallHook("CanCreateWorldProjectile", info, itemDef) != null)
		{
			return;
		}
		Vector3 projectileVelocity = info.ProjectileVelocity;
		Item item = ((recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL));
		if (Interface.CallHook("OnWorldProjectileCreate", info, item) != null)
		{
			return;
		}
		BaseEntity baseEntity = null;
		if (!info.DidHit)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.breakProbability > 0f && UnityEngine.Random.value <= projectilePrefab.breakProbability)
		{
			baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
			baseEntity.Kill(DestroyMode.Gib);
			return;
		}
		if (projectilePrefab.conditionLoss > 0f)
		{
			item.LoseCondition(projectilePrefab.conditionLoss * 100f);
			if (item.isBroken)
			{
				baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
				baseEntity.Kill(DestroyMode.Gib);
				return;
			}
		}
		if (projectilePrefab.stickProbability > 0f && UnityEngine.Random.value <= projectilePrefab.stickProbability)
		{
			baseEntity = ((info.HitEntity == null) ? item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized)) : ((info.HitBone != 0) ? item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitNormalLocal * -1f), info.HitEntity, info.HitBone) : item.CreateWorldObject(info.HitPositionLocal, Quaternion.LookRotation(info.HitEntity.transform.InverseTransformDirection(projectileVelocity.normalized)), info.HitEntity)));
			baseEntity.GetComponent<Rigidbody>().isKinematic = true;
			return;
		}
		baseEntity = item.CreateWorldObject(info.HitPositionWorld, Quaternion.LookRotation(projectileVelocity.normalized));
		Rigidbody component = baseEntity.GetComponent<Rigidbody>();
		component.AddForce(projectileVelocity.normalized * 200f);
		component.WakeUp();
	}

```

## OnInventoryItemsCount(PlayerInventory,int)

```csharp
```csharp
/// <summary>
/// Called to get the count of a specific item in the player's inventory.
/// </summary>
/// <param name="inventory">The player's inventory.</param>
/// <param name="itemid">The ID of the item to count.</param>
/// <returns>
/// Returns an integer representing the count of the specified item, or `null` if the count should be calculated manually.
/// If a non-integer value is returned, it will be treated as the final count and no manual calculation will be performed.
/// </returns>
object OnInventoryItemsCount(PlayerInventory inventory, int itemid)
{
    Puts($"Getting amount of item {itemid} in player's inventory.");
    if (itemid == 123) // Example item ID
    {
        return 5; // Return a specific count for this item
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public int GetAmount(int itemid)
	{
		if (itemid == 0)
		{
			return 0;
		}
		object obj = Interface.CallHook("OnInventoryItemsCount", this, itemid);
		if (obj is int)
		{
			return (int)obj;
		}
		int num = 0;
		if (containerMain != null)
		{
			num += containerMain.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerBelt != null)
		{
			num += containerBelt.GetAmount(itemid, onlyUsableAmounts: true);
		}
		if (containerWear != null)
		{
			num += containerWear.GetAmount(itemid, onlyUsableAmounts: true);
		}
		return num;
	}

```

## OnMlrsRocketFired(MLRS,ServerProjectile)

```csharp
```csharp
/// <summary>
/// Called when an MLRS rocket is fired.
/// </summary>
/// <param name="mlrs">The MLRS that fired the rocket.</param>
/// <param name="projectile">The projectile fired by the MLRS.</param>
void OnMlrsRocketFired(MLRS mlrs, ServerProjectile projectile)
{
    Puts($"MLRS {mlrs.GetReference().Get(serverside: true).ToString()} has fired a rocket.");
    // You can add custom logic here to handle the firing of the rocket
}
```
```

### Source Code from the Library

```csharp

	public void FireNextRocket()
	{
		RocketAmmoCount = GetRocketContainer().inventory.GetAmmoAmount(AmmoTypes.MLRS_ROCKET);
		if (nextRocketIndex < 0 || nextRocketIndex >= RocketAmmoCount || IsBroken())
		{
			EndFiring();
			return;
		}
		StorageContainer rocketContainer = GetRocketContainer();
		Vector3 firingPos = firingPoint.position + firingPoint.rotation * rocketTubes[nextRocketIndex].firingOffset;
		float num = 1f;
		if (radiusModIndex < radiusMods.Length)
		{
			num = radiusMods[radiusModIndex];
		}
		radiusModIndex++;
		Vector2 vector = UnityEngine.Random.insideUnitCircle * (targetAreaRadius - RocketDamageRadius) * num;
		Vector3 targetPos = TrueHitPos + new Vector3(vector.x, 0f, vector.y);
		float g;
		Vector3 aimToTarget = GetAimToTarget(targetPos, out g);
		if (TryFireProjectile(rocketContainer, AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, rocketOwnerRef.Get(serverside: true) as BasePlayer, 0f, 0f, out var projectile))
		{
			projectile.gravityModifier = g / (0f - UnityEngine.Physics.gravity.y);
			Interface.CallHook("OnMlrsRocketFired", this, projectile);
			nextRocketIndex--;
		}
		else
		{
			EndFiring();
		}
	}

```

## OnEntityVisibilityCheck(BaseEntity,BasePlayer,uint,string,float)

```csharp
```csharp
/// <summary>
/// Called when checking the visibility of an entity.
/// </summary>
/// <param name="entity">The BaseEntity to check.</param>
/// <param name="player">The BasePlayer performing the check.</param>
/// <param name="id">A unique identifier for the check.</param>
/// <param name="debugName">A debug-friendly name for the entity.</param>
/// <param name="maximumDistance">The maximum distance to consider when checking visibility.</param>
/// <returns>
/// Returns `true` if the entity is visible, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as an error and the entity's visibility will not be considered.
/// </returns>
object OnEntityVisibilityCheck(BaseEntity entity, BasePlayer player, uint id, string debugName, float maximumDistance)
{
    Puts($"Checking visibility of {debugName} ({id}) for {player.displayName} at distance {maximumDistance}.");
    if (entity.IsDestroyed || !entity.IsValid())
    {
        return false;
    }
    // Perform custom visibility check logic here
    // For example:
    if (player.DistanceTo(entity) > maximumDistance)
    {
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				if (ent == null || player == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityVisibilityCheck", ent, player, id, debugName, maximumDistance);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 2162688))
				{
					if (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))
					{
						return ent.IsVisible(player.eyes.position, maximumDistance);
					}
					return true;
				}
				return false;
			}

```

## CanUpdateSign(BasePlayer,CarvablePumpkin)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can update the sign.
/// </summary>
/// <param name="player">The player attempting to update the sign.</param>
/// <param name="pumpkin">The CarvablePumpkin instance associated with this sign.</param>
/// <returns>
/// Returns `true` if the player is allowed to update the sign, or `false` otherwise.
/// If a non-null value other than `bool` is returned, it will override the default behavior.
/// </returns>
object CanUpdateSign(BasePlayer player, CarvablePumpkin pumpkin)
{
    Puts($"Player {player.UserIDString} attempted to update the sign.");
    if (pumpkin.IsLocked && player.userID != pumpkin.OwnerID)
    {
        Puts($"Player {player.UserIDString} does not own the locked pumpkin.");
        return false;
    }
    object result = Interface.CallHook("CanUpdateSign", player, pumpkin);
    if (result is bool)
    {
        return (bool)result;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual bool CanUpdateSign(BasePlayer player)
	{
		object obj = Interface.CallHook("CanUpdateSign", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (player.IsAdmin || player.IsDeveloper)
		{
			return true;
		}
		if (!player.CanBuild())
		{
			return false;
		}
		if (IsLocked())
		{
			return player.userID == base.OwnerID;
		}
		return true;
	}

```

## OnPlayerKicked(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player is kicked from the server.
/// </summary>
/// <param name="player">The player being kicked.</param>
/// <param name="reason">The reason for kicking the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerKicked(BasePlayer player, string reason)
{
    Puts($"Player {player.UserIDString} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	public void Kick(string reason)
	{
		if (IsConnected)
		{
			Network.Net.sv.Kick(net.connection, reason);
			Interface.CallHook("OnPlayerKicked", this, reason);
		}
	}

```

## OnExperimentStart(Workbench,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when an experiment starts.
/// </summary>
/// <param name="workbench">The workbench where the experiment is starting.</param>
/// <param name="player">The player who started the experiment.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the experiment starts as normal.
/// </returns>
object OnExperimentStart(Workbench workbench, BasePlayer player)
{
    Puts($"Experiment has started for player {player.displayName} on workbench {workbench.name}.");
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_BeginExperiment(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (player == null || IsWorking())
		{
			return;
		}
		PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
		int num = UnityEngine.Random.Range(0, experimentalItems.subSpawn.Length);
		for (int i = 0; i < experimentalItems.subSpawn.Length; i++)
		{
			int num2 = i + num;
			if (num2 >= experimentalItems.subSpawn.Length)
			{
				num2 -= experimentalItems.subSpawn.Length;
			}
			ItemDefinition itemDef = experimentalItems.subSpawn[num2].category.items[0].itemDef;
			if ((bool)itemDef.Blueprint && !itemDef.Blueprint.defaultBlueprint && itemDef.Blueprint.userCraftable && itemDef.Blueprint.isResearchable && !itemDef.Blueprint.NeedsSteamItem && !itemDef.Blueprint.NeedsSteamDLC && !persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
			{
				pendingBlueprint = itemDef;
				break;
			}
		}
		if (pendingBlueprint == null)
		{
			player.ChatMessage("You have already unlocked everything for this workbench tier.");
		}
		else
		{
			if (Interface.CallHook("OnExperimentStart", this, player) != null)
			{
				return;
			}
			Item slot = base.inventory.GetSlot(0);
			if (slot != null)
			{
				if (!slot.MoveToContainer(player.inventory.containerMain))
				{
					slot.Drop(GetDropPosition(), GetDropVelocity());
				}
				player.inventory.loot.SendImmediate();
			}
			if (experimentStartEffect.isValid)
			{
				Effect.server.Run(experimentStartEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			}
			SetFlag(Flags.On, b: true);
			base.inventory.SetLocked(isLocked: true);
			CancelInvoke(ExperimentComplete);
			Invoke(ExperimentComplete, 5f);
			SendNetworkUpdate();
			Interface.CallHook("OnExperimentStarted", this, player);
		}
	}

```

## CanSetRelationship(BasePlayer,BasePlayer,RelationshipManager.RelationshipType,int)

```csharp
```csharp
/// <summary>
/// Called when a relationship between two players is about to be set.
/// </summary>
/// <param name="player">The player whose relationship is being changed.</param>
/// <param name="otherPlayer">The other player involved in the relationship change.</param>
/// <param name="type">The type of relationship being set (e.g. Friend, Enemy, etc.)</param>
/// <param name="weight">The weight or importance of the relationship being set.</param>
/// <returns>
/// Returns a non-null value to override the default behavior and prevent the relationship from being set.
/// If null is returned, the relationship will be set as normal.
/// </returns>
object CanSetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipManager.RelationshipType type, int weight)
{
    Puts($"Attempting to set relationship between {player.displayName} and {otherPlayer.displayName}");
    if (type == RelationshipManager.RelationshipType.Enemy && player.SecondsSinceAttacked > 10f && !player.IsAiming)
    {
        Vector3 normalized = (otherPlayer.eyes.position - player.eyes.position).normalized;
        bool flag = Vector3.Dot(player.eyes.HeadForward(), normalized) >= 0.6f;
        float num = Vector3Ex.Distance2D(player.transform.position, otherPlayer.transform.position);
        if (flag && num < 100f)
        {
            Puts($"Cannot set enemy relationship while in combat with {otherPlayer.displayName}");
            return "Cannot set enemy relationship while in combat";
        }
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void SetRelationship(BasePlayer player, BasePlayer otherPlayer, RelationshipType type, int weight = 1, bool sendImmediate = false)
	{
		if (!contacts)
		{
			return;
		}
		ulong userID = player.userID;
		ulong userID2 = otherPlayer.userID;
		if (player == null || player == otherPlayer || player.IsNpc || (otherPlayer != null && otherPlayer.IsNpc) || Interface.CallHook("CanSetRelationship", player, otherPlayer, type, weight) != null)
		{
			return;
		}
		PlayerRelationships playerRelationships = GetRelationships(userID);
		if (!CleanupOldContacts(playerRelationships, userID))
		{
			CleanupOldContacts(playerRelationships, userID, RelationshipType.Enemy);
		}
		PlayerRelationshipInfo relations = playerRelationships.GetRelations(userID2);
		bool flag = false;
		if (relations.type != type)
		{
			flag = true;
			relations.weight = 0;
		}
		relations.type = type;
		relations.weight += weight;
		float num = UnityEngine.Time.realtimeSinceStartup - relations.lastMugshotTime;
		if (flag || relations.mugshotCrc == 0 || num >= mugshotUpdateInterval)
		{
			bool flag2 = otherPlayer.IsAlive();
			bool num2 = player.SecondsSinceAttacked > 10f && !player.IsAiming;
			float num3 = 100f;
			if (num2)
			{
				Vector3 normalized = (otherPlayer.eyes.position - player.eyes.position).normalized;
				bool flag3 = Vector3.Dot(player.eyes.HeadForward(), normalized) >= 0.6f;
				float num4 = Vector3Ex.Distance2D(player.transform.position, otherPlayer.transform.position);
				if (flag2 && num4 < num3 && flag3)
				{
					ClientRPCPlayer(null, player, "CLIENT_DoMugshot", userID2);
					relations.lastMugshotTime = UnityEngine.Time.realtimeSinceStartup;
				}
			}
		}
		if (sendImmediate)
		{
			SendRelationshipsFor(player);
		}
		else
		{
			MarkRelationshipsDirtyFor(player);
		}
	}

```

## OnPlayerSleepEnd(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player's sleeping ends.
/// </summary>
/// <param name="player">The player whose sleep has ended.</param>
/// <returns>No return behavior.</returns>
void OnPlayerSleepEnd(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has woken up from sleep.");
    if (player.userID == 1234567890)
    {
        Puts($"Player {player.displayName} is a VIP and will receive special treatment.");
        // Grant VIP privileges
    }
    else
    {
        Puts($"Player {player.displayName} is a regular player.");
        // No special treatment needed
    }
}
```
```

### Source Code from the Library

```csharp

	public virtual void EndSleeping()
	{
		if (IsSleeping() && Interface.CallHook("OnPlayerSleepEnd", this) == null)
		{
			SetPlayerFlag(PlayerFlags.Sleeping, b: false);
			sleepStartTime = -1f;
			sleepingPlayerList.Remove(this);
			if (userID < 10000000 && !bots.Contains(this))
			{
				bots.Add(this);
			}
			CancelInvoke(ScheduledDeath);
			InvokeRepeating(InventoryUpdate, 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
			if (RelationshipManager.TeamsEnabled())
			{
				InvokeRandomized(TeamUpdate, 1f, 4f, 1f);
			}
			EnablePlayerCollider();
			AddPlayerRigidbody();
			SetServerFall(wantsOn: false);
			if (HasParent())
			{
				SetParent(null, worldPositionStays: true);
				ForceUpdateTriggers();
			}
			inventory.containerMain.OnChanged();
			inventory.containerBelt.OnChanged();
			inventory.containerWear.OnChanged();
			Interface.CallHook("OnPlayerSleepEnded", this);
			EACServer.LogPlayerSpawn(this);
		}
	}

```

## OnMissionStart(BaseMission,BaseMission.MissionInstance,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a mission starts.
/// </summary>
/// <param name="missionInstance">The mission instance.</param>
/// <param name="assignee">The player assigned to the mission.</param>
/// <returns>
/// Returns `null` to allow the mission to start normally, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for the player.
/// </returns>
object OnMissionStart(BaseMission missionInstance, BaseMission.MissionInstance instance, BasePlayer assignee)
{
    Puts($"Mission {missionInstance.name} has started for player {assignee.displayName}");
    if (instance.missionType == "HighRisk")
    {
        Puts($"Warning: Mission {missionInstance.name} is a high-risk mission.");
        return "Be careful, this mission is high-risk.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void MissionStart(MissionInstance instance, BasePlayer assignee)
	{
		if (Interface.CallHook("OnMissionStart", this, instance, assignee) != null)
		{
			return;
		}
		SetupRewards(instance, assignee);
		SetupPositions(instance, assignee);
		AddBlockers(instance);
		for (int i = 0; i < objectives.Length; i++)
		{
			objectives[i].Get().MissionStarted(i, instance);
		}
		if (acceptEffect.isValid)
		{
			DoMissionEffect(acceptEffect.resourcePath, assignee);
		}
		MissionEntityEntry[] array = missionEntities;
		foreach (MissionEntityEntry missionEntityEntry in array)
		{
			if (missionEntityEntry.entityRef.isValid)
			{
				Vector3 missionPoint = instance.GetMissionPoint(missionEntityEntry.spawnPositionToUse, assignee);
				BaseEntity baseEntity = GameManager.server.CreateEntity(missionEntityEntry.entityRef.resourcePath, missionPoint, Quaternion.identity);
				MissionEntity missionEntity = baseEntity.gameObject.AddComponent<MissionEntity>();
				missionEntity.Setup(assignee, instance, missionEntityEntry.cleanupOnMissionSuccess, missionEntityEntry.cleanupOnMissionFailed);
				instance.createdEntities.Add(missionEntity);
				baseEntity.Spawn();
			}
		}
		foreach (MissionEntity createdEntity in instance.createdEntities)
		{
			createdEntity.MissionStarted(assignee, instance);
		}
		Interface.CallHook("OnMissionStarted", this, instance, assignee);
	}

```

## CanBuild(Planner,Construction,Construction.Target)

```csharp
```csharp
/// <summary>
/// Called to check if a build is allowed.
/// </summary>
/// <param name="construction">The Construction being built.</param>
/// <param name="target">The target of the build.</param>
/// <returns>
/// Returns a non-null value to override the default build behavior. 
/// If `null` is returned, the build is allowed as normal.
/// </returns>
object CanBuild(Construction construction, Construction.Target target)
{
    Puts($"Checking if build of {construction.name} at {target.position} is allowed.");
    // Add custom logic here to check if the build is allowed
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DoBuild(CreateBuilding msg)
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!ownerPlayer)
		{
			return;
		}
		if (ConVar.AntiHack.objectplacement && ownerPlayer.TriggeredAntiHack())
		{
			ownerPlayer.ChatMessage("AntiHack!");
			return;
		}
		Construction construction = PrefabAttribute.server.Find<Construction>(msg.blockID);
		if (construction == null)
		{
			ownerPlayer.ChatMessage("Couldn't find Construction " + msg.blockID);
			return;
		}
		if (!CanAffordToPlace(construction))
		{
			ownerPlayer.ChatMessage("Can't afford to place!");
			return;
		}
		if (!ownerPlayer.CanBuild() && !construction.canBypassBuildingPermission)
		{
			ownerPlayer.ChatMessage("Building is blocked!");
			return;
		}
		Deployable deployable = GetDeployable();
		if (construction.deployable != deployable)
		{
			ownerPlayer.ChatMessage("Deployable mismatch!");
			AntiHack.NoteAdminHack(ownerPlayer);
			return;
		}
		BaseGameMode.CanBuildResult? canBuildResult = BaseGameMode.GetActiveGameMode(serverside: true)?.CanBuildEntity(ownerPlayer, construction);
		if (canBuildResult.HasValue)
		{
			if (canBuildResult.Value.Phrase != null)
			{
				ownerPlayer.ShowToast((!canBuildResult.Value.Result) ? GameTip.Styles.Red_Normal : GameTip.Styles.Blue_Long, canBuildResult.Value.Phrase, canBuildResult.Value.Arguments);
			}
			if (!canBuildResult.Value.Result)
			{
				return;
			}
		}
		Construction.Target target = default(Construction.Target);
		if (msg.entity.IsValid)
		{
			target.entity = BaseNetworkable.serverEntities.Find(msg.entity) as BaseEntity;
			if (target.entity == null)
			{
				ownerPlayer.ChatMessage("Couldn't find entity " + msg.entity);
				return;
			}
			msg.position = target.entity.transform.TransformPoint(msg.position);
			msg.normal = target.entity.transform.TransformDirection(msg.normal);
			msg.rotation = target.entity.transform.rotation * msg.rotation;
			if (msg.socket != 0)
			{
				string text = StringPool.Get(msg.socket);
				if (text != "")
				{
					target.socket = FindSocket(text, target.entity.prefabID);
				}
				if (target.socket == null)
				{
					ownerPlayer.ChatMessage("Couldn't find socket " + msg.socket);
					return;
				}
			}
			else if (target.entity is Door)
			{
				ownerPlayer.ChatMessage("Can't deploy on door");
				return;
			}
		}
		target.ray = msg.ray;
		target.onTerrain = msg.onterrain;
		target.position = msg.position;
		target.normal = msg.normal;
		target.rotation = msg.rotation;
		target.player = ownerPlayer;
		target.valid = true;
		if (Interface.CallHook("CanBuild", this, construction, target) != null)
		{
			return;
		}
		if (target.entity != null && deployable != null && deployable.setSocketParent)
		{
			Vector3 position = ((target.socket != null) ? target.GetWorldPosition() : target.position);
			float num = target.entity.Distance(position);
			if (num > 1f)
			{
				ownerPlayer.ChatMessage("Parent too far away: " + num);
				return;
			}
		}
		DoBuild(target, construction);
	}

```

## OnTeamDisband(RelationshipManager.PlayerTeam)

```csharp
```csharp
/// <summary>
/// Called when a team is disbanded.
/// </summary>
/// <param name="team">The team being disbanded.</param>
/// <returns>
/// Returns `null` to allow the team to be disbanded, or any non-null value to prevent it from being disbanded.
/// </returns>
object OnTeamDisband(RelationshipManager.PlayerTeam team)
{
    Puts($"Team {team.teamID} has been disbanded.");
    if (team.teamID == "Red")
    {
        Puts($"Team Red cannot be disbanded.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DisbandTeam(PlayerTeam teamToDisband)
	{
		if (Interface.CallHook("OnTeamDisband", teamToDisband) == null)
		{
			teams.Remove(teamToDisband.teamID);
			Interface.CallHook("OnTeamDisbanded", teamToDisband);
			Facepunch.Pool.Free(ref teamToDisband);
		}
	}

```

## CanCheckFuel(EntityFuelSystem,StorageContainer,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called to check if a player can interact with the fuel system.
/// </summary>
/// <param name="fuelSystem">The fuel system being checked.</param>
/// <param name="container">The storage container containing the fuel.</param>
/// <param name="player">The player attempting to interact with the fuel system.</param>
/// <returns>
/// Returns `true` if the player can interact with the fuel system, and `false` otherwise.
/// If a non-bool value is returned, it will be treated as `true`.
/// </returns>
object CanCheckFuel(EntityFuelSystem fuelSystem, StorageContainer container, BasePlayer player)
{
    Puts($"Player {player.UserIDString} attempting to interact with fuel system.");
    if (container == null || !IsInFuelInteractionRange(player))
    {
        return true;
    }
    // Additional checks or logic can be added here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool IsInFuelInteractionRange(BasePlayer player)
	{
		StorageContainer fuelContainer = GetFuelContainer();
		object obj = Interface.CallHook("CanCheckFuel", this, fuelContainer, player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (fuelContainer != null)
		{
			float num = 0f;
			if (isServer)
			{
				num = 3f;
			}
			return fuelContainer.Distance(player.eyes.position) <= num;
		}
		return false;
	}

```

## OnEntityDismounted(BaseMountable,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player dismounts from an entity.
/// </summary>
/// <param name="entity">The entity the player is dismounting from.</param>
/// <param name="player">The player who is dismounting.</param>
/// <returns>
/// Returns a non-null value to override the default dismount behavior. 
/// If `null` is returned, the player dismounts as normal.
/// </returns>
object OnEntityDismounted(BaseMountable entity, BasePlayer player)
{
    Puts($"Player {player.displayName} has dismounted from {entity.GetType().Name}.");
    if (entity == null || player == null)
    {
        return null;
    }
    // Add custom logic here
    return null;
}
```
```

### Source Code from the Library

```csharp

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		if (_mounted == null || _mounted != player || Interface.CallHook("CanDismountEntity", player, this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		Vector3 res;
		if (lite)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
		else if (!GetDismountPosition(player, out res) || Distance(res) > 10f)
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = player.transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			_mounted.ClientRPCPlayer(null, _mounted, "ForcePositionTo", res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID + " on obj : " + base.gameObject.name);
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
		}
		else
		{
			if (baseVehicle != null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted.transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
			_mounted.MovePosition(res);
			_mounted.SendNetworkUpdateImmediate();
			_mounted.SendModelState(force: true);
			_mounted = null;
			if (baseVehicle != null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			player.ForceUpdateTriggers();
			if ((bool)player.GetParentEntity())
			{
				BaseEntity baseEntity = player.GetParentEntity();
				player.ClientRPCPlayer(null, player, "ForcePositionToParentOffset", baseEntity.transform.InverseTransformPoint(res), baseEntity.net.ID);
			}
			else
			{
				player.ClientRPCPlayer(null, player, "ForcePositionTo", res);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", this, player);
		}
	}

```

## OnActiveItemChanged(BasePlayer,Item,Item)

```csharp
```csharp
/// <summary>
/// Called when the active item of a player changes.
/// </summary>
/// <param name="player">The player whose active item has changed.</param>
/// <param name="oldItem">The old active item.</param>
/// <param name="newItem">The new active item.</param>
/// <returns>No return behavior, this method is used to notify other plugins of the change.</returns>
void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
{
    Puts($"Player {player.displayName}'s active item has changed from {oldItem.info.name} to {newItem.info.name}.");
    // Add custom logic here if needed
}
```
```

### Source Code from the Library

```csharp

	public void UpdateActiveItem(ItemId itemID)
	{
		Assert.IsTrue(base.isServer, "Realm should be server!");
		if (svActiveItemID == itemID)
		{
			return;
		}
		if (equippingBlocked)
		{
			itemID = default(ItemId);
		}
		Item item = inventory.containerBelt.FindItemByUID(itemID);
		if (IsItemHoldRestricted(item))
		{
			itemID = default(ItemId);
		}
		Item activeItem = GetActiveItem();
		if (Interface.CallHook("OnActiveItemChange", this, activeItem, itemID) != null)
		{
			return;
		}
		svActiveItemID = default(ItemId);
		if (activeItem != null)
		{
			HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
			if (heldEntity != null)
			{
				heldEntity.SetHeld(bHeld: false);
			}
		}
		svActiveItemID = itemID;
		SendNetworkUpdate();
		Item activeItem2 = GetActiveItem();
		if (activeItem2 != null)
		{
			HeldEntity heldEntity2 = activeItem2.GetHeldEntity() as HeldEntity;
			if (heldEntity2 != null)
			{
				heldEntity2.SetHeld(bHeld: true);
			}
			NotifyGesturesNewItemEquipped();
		}
		inventory.UpdatedVisibleHolsteredItems();
		Interface.CallHook("OnActiveItemChanged", this, activeItem, activeItem2);
	}

```

## OnSendCommand(System.Collections.Generic.List<Network.Connection>,string,object[])

```csharp
```csharp
/// <summary>
/// Called when a client command is sent.
/// </summary>
/// <param name="connections">The list of connections that received the command.</param>
/// <param name="commandName">The name of the command being sent.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns `null` to allow the command to be executed, or any non-null value to cancel the execution.
/// </returns>
object OnSendCommand(List<Connection> connections, string commandName, params object[] args)
{
    Puts($"Client command '{commandName}' with arguments {string.Join(", ", args)} has been sent.");
    if (commandName == "kick")
    {
        Puts($"Client command 'kick' is not allowed.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static void SendClientCommand(List<Connection> cn, string strCommand, params object[] args)
	{
		if (Network.Net.sv.IsConnected() && Interface.CallHook("OnSendCommand", cn, strCommand, args) == null)
		{
			NetWrite netWrite = Network.Net.sv.StartWrite();
			netWrite.PacketID(Message.Type.ConsoleCommand);
			netWrite.String(ConsoleSystem.BuildCommand(strCommand, args));
			netWrite.Send(new SendInfo(cn));
		}
	}

```

## IOnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
void IOnServerShutdown()
{
    Puts("Server shutdown initiated.");
    // Perform any necessary cleanup or actions before shutting down
    // For example, save game data, close connections, etc.
    
    // If you want to perform some specific action on shutdown, you can do so here
    ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
    ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
}
```
```

### Source Code from the Library

```csharp

	internal void Shutdown()
	{
		Interface.CallHook("IOnServerShutdown");
		BasePlayer[] array = BasePlayer.activePlayerList.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.save");
		ConsoleSystem.Run(ConsoleSystem.Option.Server, "server.writecfg");
	}

```

## OnDecayHeal(DecayEntity)

```csharp
```csharp
/// <summary>
/// Called when a decay entity is healed.
/// </summary>
/// <param name="decayEntity">The decay entity being healed.</param>
/// <returns>
/// Returns `null` to allow the decay entity to be healed normally, or any non-null value to override the default healing behavior.
/// If a string is returned, the decay entity will not be healed and the provided message will be logged as the reason.
/// </returns>
object OnDecayHeal(DecayEntity decayEntity)
{
    Puts($"Decay entity {decayEntity} has been healed.");
    if (decayEntity == "Critical Decay")
    {
        Puts($"Decay entity {decayEntity} has been blocked from healing.");
        return "Blocked: Critical Decay";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public virtual void DecayTick()
	{
		if (decay == null)
		{
			return;
		}
		float num = UnityEngine.Time.time - lastDecayTick;
		if (num < ConVar.Decay.tick)
		{
			return;
		}
		lastDecayTick = UnityEngine.Time.time;
		if (!decay.ShouldDecay(this))
		{
			return;
		}
		float num2 = num * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num2;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if (buildingPrivilege != null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && ConVar.Decay.upkeep_heal_scale > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", this) == null)
				{
					float num3 = num / decay.GetDecayDuration(this) * ConVar.Decay.upkeep_heal_scale;
					Heal(MaxHealth() * num3);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num2;
		if (decayTimer < decay.GetDecayDelay(this))
		{
			return;
		}
		using (TimeWarning.New("DecayTick"))
		{
			float num4 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num4 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num4 -= decayPoint.protection;
					}
				}
			}
			if (num4 > 0f && Interface.CallHook("OnDecayDamage", this) == null)
			{
				float num5 = num2 / decay.GetDecayDuration(this) * MaxHealth();
				Hurt(num5 * num4 * decayVariance, DamageType.Decay);
			}
		}
	}

```

## OnPhoneDialTimedOut(PhoneController,PhoneController,BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a phone dialing operation times out.
/// </summary>
/// <param name="phoneController">The phone controller that timed out.</param>
/// <param name="caller">The caller who initiated the call.</param>
/// <param name="currentPlayer">The player who is currently on the phone.</param>
/// <returns>No return behavior.</returns>
void OnPhoneDialTimedOut(PhoneController phoneController, PhoneController caller, BasePlayer currentPlayer)
{
    Puts($"Phone dialing operation for {caller.displayName} to {currentPlayer.UserIDString} has timed out.");
    if (phoneController == null)
    {
        Puts("Error: Phone controller is null.");
    }
}
```
```

### Source Code from the Library

```csharp

	private void TimeOutDialing()
	{
		if (Interface.CallHook("OnPhoneDialTimeout", activeCallTo, this, activeCallTo.currentPlayer) == null)
		{
			if (activeCallTo != null)
			{
				activeCallTo.ServerPlayAnsweringMessage(this);
			}
			SetPhoneState(Telephone.CallState.Idle);
			Interface.CallHook("OnPhoneDialTimedOut", activeCallTo, this, activeCallTo.currentPlayer);
		}
	}

```

## OnBookmarkControlEnded(ComputerStation,BasePlayer,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when bookmark control has ended.
/// </summary>
/// <param name="computerStation">The computer station that was controlling the entity.</param>
/// <param name="player">The player who was controlling the entity.</param>
/// <param name="entity">The entity that was being controlled.</param>
/// <returns>No return behavior.</returns>
void OnBookmarkControlEnded(ComputerStation computerStation, BasePlayer player, BaseEntity entity)
{
    Puts($"Bookmark control has ended for {player.displayName} on {computerStation.name} with entity {entity.displayName}");
    if (entity == null || !entity.IsValid())
    {
        Puts($"Entity {entity?.displayName ?? "null"} is invalid or does not exist.");
        return;
    }
    
    // Additional logic can be added here as needed
}
```
```

### Source Code from the Library

```csharp

	public void StopControl(BasePlayer ply)
	{
		BaseEntity baseEntity = currentlyControllingEnt.Get(serverside: true);
		if ((bool)baseEntity)
		{
			if (Interface.CallHook("OnBookmarkControlEnd", this, ply, baseEntity) != null)
			{
				return;
			}
			baseEntity.GetComponent<IRemoteControllable>().StopControl(new CameraViewerId(currentPlayerID, 0L));
		}
		if ((bool)ply)
		{
			ply.net.SwitchSecondaryGroup(null);
		}
		currentlyControllingEnt.uid = default(NetworkableId);
		currentPlayerID = 0uL;
		SetFlag(Flags.Reserved2, b: false, recursive: false, networkupdate: false);
		SendNetworkUpdate();
		SendControlBookmarks(ply);
		CancelInvoke(ControlCheck);
		CancelInvoke(CheckCCTVAchievement);
		Interface.CallHook("OnBookmarkControlEnded", this, ply, baseEntity);
	}

```

## CanDemolish(BasePlayer,BuildingBlock)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can demolish the current object.
/// </summary>
/// <param name="player">The player attempting to demolish.</param>
/// <param name="objectBeingDemolished">The object being demolished, which could be a building or other structure.</param>
/// <returns>
/// Returns `true` if the player can demolish the object, and `false` otherwise.
/// If a non-null value is returned, it will override the default behavior.
/// </returns>
object CanDemolish(BasePlayer player, BuildingBlock objectBeingDemolished)
{
    Puts($"Player {player.UserIDString} is attempting to demolish {objectBeingDemolished.GetType().Name}.");
    if (player.IsAdmin())
    {
        return true;
    }
    else if (player.HasPrivilege("demolish"))
    {
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool CanDemolish(BasePlayer player)
	{
		object obj = Interface.CallHook("CanDemolish", player, this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (IsDemolishable())
		{
			return HasDemolishPrivilege(player);
		}
		return false;
	}

```

## OnFishingRodCast(BaseFishingRod,BasePlayer,Item)

```csharp
```csharp
/// <summary>
/// Called when a fishing rod is cast.
/// </summary>
/// <param name="fishingRod">The fishing rod that was cast.</param>
/// <param name="player">The player who cast the fishing rod.</param>
/// <param name="lure">The lure used to catch fish.</param>
/// <returns>
/// Returns a non-null value to override the default casting behavior. 
/// If `null` is returned, the fishing rod is cast as normal.
/// </returns>
object OnFishingRodCast(BaseFishingRod fishingRod, BasePlayer player, Item lure)
{
    Puts($"Fishing rod {fishingRod} was cast by player {player} with lure {lure}.");
    if (lure == null)
    {
        Puts($"No lure was used to catch fish.");
        return "Error: No lure was used.";
    }
    Interface.CallHook("OnFishingCast", fishingRod, player, lure);
    return null;
}
```
```

### Source Code from the Library

```csharp

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void Server_RequestCast(RPCMessage msg)
	{
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		object obj = Interface.CallHook("CanCastFishingRod", ownerPlayer, this, currentLure, pos);
		if (!(obj is bool) || (bool)obj)
		{
			FishingBobber component = base.gameManager.CreateEntity(FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation).GetComponent<FishingBobber>();
			component.transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component.Spawn();
			component.InitialiseBobber(ownerPlayer, surfaceBody, pos);
			lureUsed = currentLure.info;
			currentLure.UseItem();
			if (fishLookup == null)
			{
				fishLookup = PrefabAttribute.server.Find<FishLookup>(prefabID);
			}
			currentFishTarget = fishLookup.GetFish(component.transform.position, surfaceBody, lureUsed, out fishableModifier, lastFish);
			lastFish = fishableModifier;
			currentBobber.Set(component);
			ClientRPC(null, "Client_ReceiveCastPoint", component.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = (ImmediateHook ? 0f : UnityEngine.Random.Range(10f, 20f));
			catchTime = (float)catchTime * fishableModifier.CatchWaitTimeMultiplier;
			float val = (lureUsed.TryGetComponent<ItemModCompostable>(out var component2) ? component2.BaitValue : 0f);
			val = Mathx.RemapValClamped(val, 0f, 20f, 1f, 10f);
			catchTime = Mathf.Clamp((float)catchTime - val, 3f, 20f);
			playerStartPosition = ownerPlayer.transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			InvokeRepeating(CatchProcess, 0f, 0f);
			inQueue = false;
			Interface.CallHook("OnFishingRodCast", this, ownerPlayer, currentLure);
		}
	}

```

## IOnRunCommandLine()

```csharp
```csharp
/// <summary>
/// Called when the command line is run.
/// </summary>
/// <returns>No return behavior.</returns>
void IOnRunCommandLine()
{
    Puts("Command line executed");
    // Minimal code to demonstrate functionality
}
```
```

### Source Code from the Library

```csharp

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

```

## IOnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The argument passed to the command.</param>
/// <returns>
/// Returns `true` if the command was handled successfully, or `false` otherwise.
/// If a non-null value other than `bool` is returned, it will override the default behavior.
/// </returns>
object IOnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Executing server command: {arg.cmd.FullName}");
    object result = Interface.CallHook("IOnServerCommand", arg);
    if (result is bool)
    {
        return result;
    }
    // Default behavior
    try
    {
        using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
        {
            arg.cmd.Call(arg);
        }
    }
    catch (Exception ex)
    {
        Debug.LogException(ex);
        arg.ReplyWith($"Error: {arg.cmd.FullName} - {ex.Message} ({ex.Source})");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null && string.IsNullOrWhiteSpace(arg.Reply))
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (text != @string)
			{
				arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
			else
			{
				arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
			}
		}
		return true;
	}

```

## OnClientDisconnected(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a client disconnects from the server.
/// </summary>
/// <param name="connection">The connection object representing the disconnected client.</param>
/// <param name="reason">The reason for the disconnection, if any.</param>
/// <returns>No return behavior.</returns>
void OnClientDisconnected(Connection connection, string reason)
{
    Puts($"Client {connection.UserIDString} disconnected: {reason}");
}
```
```

### Source Code from the Library

```csharp

	protected void OnDisconnected(string strReason, Connection cn)
	{
		if (cn != null)
		{
			cn.connected = false;
			cn.active = false;
			if (callbackHandler != null)
			{
				callbackHandler.OnDisconnected(strReason, cn);
			}
			Interface.CallHook("OnClientDisconnected", cn, strReason);
			RemoveConnection(cn);
		}
	}

```

## OnNetworkSubscriptionsUpdate(Network.Networkable,System.Collections.Generic.List<Network.Visibility.Group>,unknown)

```csharp
```csharp
/// <summary>
/// Called when network subscriptions are updated.
/// </summary>
/// <param name="networkable">The networkable object that triggered the update.</param>
/// <param name="groups">A list of groups that were added or removed from the subscription.</param>
/// <returns>
/// Returns `null` to allow the default behavior, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as a message for the update event.
/// </returns>
object OnNetworkSubscriptionsUpdate(Network.Networkable networkable, List<Network.Visibility.Group> groups)
{
    Puts($"Network subscriptions updated for {networkable.GetType().Name} with {groups.Count} new groups.");
    if (groups.Contains(new Network.Visibility.Group("Admins")))
    {
        Puts($"Admin group added to subscription.");
        return "Admin group added.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool UpdateHighPrioritySubscriptions()
	{
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateHighPrioritySubscriptions"))
		{
			List<Group> obj = Pool.GetList<Group>();
			List<Group> obj2 = Pool.GetList<Group>();
			sv.visibility.GetVisibleFromNear(this.group, obj2);
			AddVisibleFromNear(secondaryGroup, obj2);
			subscriber.subscribed.Compare(obj2, obj, null, null);
			if (Interface.CallHook("OnNetworkSubscriptionsUpdate", this, obj, null) == null)
			{
				for (int i = 0; i < obj.Count; i++)
				{
					Group group = obj[i];
					subscriber.Subscribe(group);
					if (handler != null)
					{
						handler.OnNetworkGroupEnter(group);
					}
				}
			}
			Pool.FreeList(ref obj);
			Pool.FreeList(ref obj2);
		}
		return true;
	}

```

## OnNetworkSubscriptionsUpdate(Network.Networkable,System.Collections.Generic.List<Network.Visibility.Group>,System.Collections.Generic.List<Network.Visibility.Group>)

```csharp
```csharp
/// <summary>
/// Called when network subscriptions are updated.
/// </summary>
/// <param name="networkable">The networkable that triggered the update.</param>
/// <param name="groupsToAdd">A list of groups to add to the subscription.</param>
/// <param name="groupsToRemove">A list of groups to remove from the subscription.</param>
/// <returns>
/// Returns `null` to allow the subscriptions to be updated as normal, or any non-null value to override the default behavior.
/// </returns>
object OnNetworkSubscriptionsUpdate(Network.Networkable networkable, List<Network.Visibility.Group> groupsToAdd, List<Network.Visibility.Group> groupsToRemove)
{
    Puts($"Network subscriptions have been updated for {networkable}.");
    if (groupsToRemove.Contains(new Network.Visibility.Group("Admins")))
    {
        Puts($"Admin group has been removed from subscription.");
        return "Admin group removed.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public bool UpdateSubscriptions(int removeLimit, int addLimit)
	{
		if (!updateSubscriptions)
		{
			return false;
		}
		if (subscriber == null)
		{
			return false;
		}
		using (TimeWarning.New("UpdateSubscriptions"))
		{
			updateSubscriptions = false;
			List<Group> obj = Pool.GetList<Group>();
			List<Group> obj2 = Pool.GetList<Group>();
			List<Group> obj3 = Pool.GetList<Group>();
			sv.visibility.GetVisibleFromFar(this.group, obj3);
			AddVisibleFromNear(secondaryGroup, obj3);
			subscriber.subscribed.Compare(obj3, obj, obj2, null);
			if (Interface.CallHook("OnNetworkSubscriptionsUpdate", this, obj, obj2) == null)
			{
				for (int i = 0; i < obj2.Count; i++)
				{
					Group group = obj2[i];
					if (removeLimit > 0)
					{
						subscriber.Unsubscribe(group);
						if (handler != null)
						{
							handler.OnNetworkGroupLeave(group);
						}
						removeLimit -= group.networkables.Count;
					}
					else
					{
						updateSubscriptions = true;
					}
				}
				for (int j = 0; j < obj.Count; j++)
				{
					Group group2 = obj[j];
					if (addLimit > 0)
					{
						subscriber.Subscribe(group2);
						if (handler != null)
						{
							handler.OnNetworkGroupEnter(group2);
						}
						addLimit -= group2.networkables.Count;
					}
					else
					{
						updateSubscriptions = true;
					}
				}
			}
			Pool.FreeList(ref obj);
			Pool.FreeList(ref obj2);
			Pool.FreeList(ref obj3);
		}
		return true;
	}

```

## OnGroupCreated(string,string,int)

```csharp
```csharp
/// <summary>
/// Called when a new group is created.
/// </summary>
/// <param name="groupName">The name of the newly created group.</param>
/// <param name="groupTitle">The title of the newly created group.</param>
/// <param name="groupRank">The rank of the newly created group.</param>
/// <returns>No return behavior.</returns>
void OnGroupCreated(string groupName, string groupTitle, int groupRank)
{
    Puts($"Group {groupName} with title '{groupTitle}' and rank {groupRank} has been created.");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("CreateGroup")]
	public bool CreateGroup(string groupName, string groupTitle, int groupRank)
	{
		if (GroupExists(groupName) || string.IsNullOrEmpty(groupName))
		{
			return false;
		}
		GroupData value = new GroupData
		{
			Title = groupTitle,
			Rank = groupRank
		};
		groupsData.Add(groupName, value);
		Interface.CallHook("OnGroupCreated", groupName, groupTitle, groupRank);
		return true;
	}

```

## OnUserNameUpdated(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a player's saved nickname is updated.
/// </summary>
/// <param name="id">The player's ID.</param>
/// <param name="oldName">The player's old nickname.</param>
/// <param name="newName">The player's new nickname.</param>
/// <returns>No return behavior.</returns>
void OnUserNameUpdated(string id, string oldName, string newName)
{
    Puts($"Player's name changed from {oldName} to {newName} for ID {id}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("UpdateNickname")]
	public void UpdateNickname(string playerId, string playerName)
	{
		if (UserExists(playerId))
		{
			UserData userData = GetUserData(playerId);
			string lastSeenNickname = userData.LastSeenNickname;
			string obj = playerName.Sanitize();
			userData.LastSeenNickname = playerName.Sanitize();
			Interface.CallHook("OnUserNameUpdated", playerId, lastSeenNickname, obj);
		}
	}

```

## OnGroupRankSet(string,int)

```csharp
```csharp
/// <summary>
/// Called when a group's rank is set.
/// </summary>
/// <param name="groupName">The name of the group whose rank is being changed.</param>
/// <param name="newRank">The new rank for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupRankSet(string groupName, int newRank)
{
    Puts($"Group {groupName} has been set to rank {newRank}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupRank")]
	public bool SetGroupRank(string groupName, int groupRank)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Rank == groupRank)
		{
			return true;
		}
		value.Rank = groupRank;
		Interface.CallHook("OnGroupRankSet", groupName, groupRank);
		return true;
	}

```

## OnGroupTitleSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's title is set.
/// </summary>
/// <param name="groupName">The name of the group whose title is being changed.</param>
/// <param name="newTitle">The new title for the group.</param>
/// <returns>No return behavior.</returns>
void OnGroupTitleSet(string groupName, string newTitle)
{
    Puts($"Group {groupName} has been renamed to {newTitle}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupTitle")]
	public bool SetGroupTitle(string groupName, string groupTitle)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (value.Title == groupTitle)
		{
			return true;
		}
		value.Title = groupTitle;
		Interface.CallHook("OnGroupTitleSet", groupName, groupTitle);
		return true;
	}

```

## OnPermissionRegistered(string,Oxide.Core.Plugins.Plugin)

```csharp
```csharp
/// <summary>
/// Called when a new permission is registered.
/// </summary>
/// <param name="permission">The newly registered permission.</param>
/// <param name="owner">The plugin that registered the permission.</param>
/// <returns>No return behavior.</returns>
void OnPermissionRegistered(string permission, Plugin owner)
{
    Puts($"Permission '{permission}' has been registered by plugin {owner.Title}");
    if (permission == "admin-only")
    {
        Puts($"Warning: Permission '{permission}' is reserved for core plugins only");
    }
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RegisterPermission")]
	public void RegisterPermission(string permission, Plugin owner)
	{
		if (string.IsNullOrEmpty(permission))
		{
			return;
		}
		if (PermissionExists(permission))
		{
			Interface.Oxide.LogWarning("Duplicate permission registered '{0}' (by plugin '{1}')", permission, owner.Title);
			return;
		}
		if (!registeredPermissions.TryGetValue(owner, out var value))
		{
			value = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
			registeredPermissions.Add(owner, value);
			owner.OnRemovedFromManager.Add(owner_OnRemovedFromManager);
		}
		value.Add(permission);
		Interface.CallHook("OnPermissionRegistered", permission, owner);
		if (!permission.StartsWith(owner.Name + ".", StringComparison.OrdinalIgnoreCase) && !owner.IsCorePlugin)
		{
			Interface.Oxide.LogWarning("Missing plugin name prefix '{0}' for permission '{1}' (by plugin '{2}')", owner.Name.ToLower(), permission, owner.Title);
		}
	}

```

## OnGroupParentSet(string,string)

```csharp
```csharp
/// <summary>
/// Called when a group's parent is set.
/// </summary>
/// <param name="groupName">The name of the group whose parent is being set.</param>
/// <param name="parentGroupName">The name of the new parent group.</param>
/// <returns>No return behavior.</returns>
void OnGroupParentSet(string groupName, string parentGroupName)
{
    Puts($"Group {groupName} has been assigned a new parent: {parentGroupName}");
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("SetGroupParent")]
	public bool SetGroupParent(string groupName, string parentGroupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		if (!groupsData.TryGetValue(groupName, out var value))
		{
			return false;
		}
		if (string.IsNullOrEmpty(parentGroupName))
		{
			value.ParentGroup = null;
			return true;
		}
		if (!GroupExists(parentGroupName) || groupName.Equals(parentGroupName))
		{
			return false;
		}
		if (!string.IsNullOrEmpty(value.ParentGroup) && value.ParentGroup.Equals(parentGroupName))
		{
			return true;
		}
		if (HasCircularParent(groupName, parentGroupName))
		{
			return false;
		}
		value.ParentGroup = parentGroupName;
		Interface.CallHook("OnGroupParentSet", groupName, parentGroupName);
		return true;
	}

```

## OnGroupDeleted(string)

```csharp
```csharp
/// <summary>
/// Called when a group is deleted.
/// </summary>
/// <param name="groupName">The name of the deleted group.</param>
/// <returns>No return behavior.</returns>
void OnGroupDeleted(string groupName)
{
    Puts($"Group {groupName} has been deleted.");
    // Additional logic can be added here if needed
}
```
```

### Source Code from the Library

```csharp

	[LibraryFunction("RemoveGroup")]
	public bool RemoveGroup(string groupName)
	{
		if (!GroupExists(groupName))
		{
			return false;
		}
		bool flag = groupsData.Remove(groupName);
		if (flag)
		{
			foreach (GroupData item in groupsData.Values.Where((GroupData g) => g.ParentGroup == groupName))
			{
				item.ParentGroup = string.Empty;
			}
		}
		if (usersData.Values.Aggregate(seed: false, (bool current, UserData userData) => current | userData.Groups.Remove(groupName)))
		{
			SaveUsers();
		}
		if (flag)
		{
			Interface.CallHook("OnGroupDeleted", groupName);
		}
		return true;
	}

```

## OnDestroyUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a UI element is destroyed.
/// </summary>
/// <param name="player">The player whose UI was destroyed.</param>
/// <param name="elem">The ID of the destroyed UI element.</param>
/// <returns>No return behavior.</returns>
void OnDestroyUI(BasePlayer player, string elem)
{
    Puts($"UI for player {player.UserIDString} with ID {elem} has been destroyed.");
}
```
```

### Source Code from the Library

```csharp

	public static bool DestroyUi(BasePlayer player, string elem)
	{
		if (player?.net != null)
		{
			Interface.CallHook("OnDestroyUI", player, elem);
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "DestroyUI", elem);
			return true;
		}
		return false;
	}

```

## OnUserCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a user issues a command.
/// </summary>
/// <param name="player">The player who issued the command.</param>
/// <param name="command">The command that was issued.</param>
/// <param name="args">The arguments provided with the command.</param>
/// <returns>
/// Returns a non-null value to override the default command handling behavior. 
/// If `null` is returned, the command will be handled as normal.
/// </returns>
object OnUserCommand(IPlayer player, string command, string[] args)
{
    Puts($"Player {player.Id} issued command '{command}' with arguments: [{string.Join(", ", args)}]");
    if (command == "kick")
    {
        Puts($"Player {player.Id} is being kicked for violating server rules.");
        return "Kicked: Violating server rules.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(BasePlayer basePlayer, string message)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(System.Environment.NewLine, " "), System.Environment.NewLine, stackTrace));
		}
	}

```

## OnApplicationCommand(BasePlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player executes an application command.
/// </summary>
/// <param name="player">The player who executed the command.</param>
/// <param name="commandName">The name of the command that was executed.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the command will be handled as normal.
/// </returns>
object OnApplicationCommand(BasePlayer player, string commandName, string[] args)
{
    Puts($"Player {player.Name} executed command '{commandName}' with arguments: [{string.Join(", ", args)}]");
    if (commandName == "kick")
    {
        Puts($"Player {player.Name} is being kicked from the server.");
        return "Kicked: You have been kicked from the server.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(BasePlayer basePlayer, string message)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(System.Environment.NewLine, " "), System.Environment.NewLine, stackTrace));
		}
	}

```

## OnPlayerLanguageChanged(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player's language is changed.
/// </summary>
/// <param name="player">The player whose language has been changed.</param>
/// <param name="languageCode">The new language code of the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(IPlayer player, string languageCode)
{
    Puts($"Player's language changed to {languageCode}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnPlayerLanguageChanged(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a player's language is changed.
/// </summary>
/// <param name="player">The player whose language has been changed.</param>
/// <param name="languageCode">The new language code of the player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerLanguageChanged(BasePlayer player, string languageCode)
{
    Puts($"Player's language changed to {languageCode} for ID {player.UserIDString}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerSetInfo")]
	private void OnPlayerSetInfo(Connection connection, string key, string val)
	{
		if (!(key == "global.language"))
		{
			return;
		}
		lang.SetLanguage(val, connection.userid.ToString());
		BasePlayer basePlayer = connection.player as BasePlayer;
		if (basePlayer != null)
		{
			Interface.CallHook("OnPlayerLanguageChanged", basePlayer, val);
			if (basePlayer.IPlayer != null)
			{
				Interface.CallHook("OnPlayerLanguageChanged", basePlayer.IPlayer, val);
			}
		}
	}

```

## OnUserRespawn(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>
/// Returns `null` to allow the player to respawn normally, or any non-null value to override the default respawn behavior.
/// If a string is returned, it will be used as a message to display to the player when they respawn.
/// </returns>
object OnUserRespawn(IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
    if (player.Name == "Admin")
    {
        Puts($"Player {player.Name} is an admin and will not be notified of their respawn.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawn")]
	private object OnPlayerRespawn(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer == null)
		{
			return null;
		}
		return Interface.CallHook("OnUserRespawn", iPlayer);
	}

```

## OnApplicationCommand(Oxide.Core.Libraries.Covalence.IPlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player sends an application command.
/// </summary>
/// <param name="player">The player who sent the command.</param>
/// <param name="command">The actual command that was sent (without leading '/').</param>
/// <param name="args">Any arguments provided with the command.</param>
/// <returns>
/// Returns a non-null value to override the default behavior. If `null` is returned, the command will be handled as normal.
/// </returns>
object OnApplicationCommand(IPlayer player, string command, string[] args)
{
    Puts($"Player {player.Id} sent application command '{command}' with arguments: [{string.Join(", ", args)}]");
    if (command == "test")
    {
        Puts("Test command received!");
        return "Test command executed!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(BasePlayer basePlayer, string message)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(System.Environment.NewLine, " "), System.Environment.NewLine, stackTrace));
		}
	}

```

## OnRconCommand(System.Net.IPAddress,string,string[])

```csharp
```csharp
/// <summary>
/// Called when an RCON command is received.
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the command.</param>
/// <param name="commandName">The name of the command being executed.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns `true` if the command should be blocked, or any non-null value to override the default behavior.
/// If `null` is returned, the command will be executed as normal.
/// </returns>
object OnRconCommand(IPAddress ipAddress, string commandName, string[] args)
{
    Puts($"Received RCON command from {ipAddress} with name '{commandName}' and arguments: [{string.Join(", ", args)}]");
    if (commandName == "shutdown" && !IsAdmin(ipAddress))
    {
        Puts($"User at {ipAddress} does not have permission to execute the 'shutdown' command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", ipAddress, message) != null)
			{
				return true;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnEntityTakeDamage(BaseCombatEntity,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity takes damage.
/// </summary>
/// <param name="entity">The entity that took the damage.</param>
/// <param name="hitInfo">Information about the hit, including the attacker and damage dealt.</param>
/// <returns>No return behavior.</returns>
void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.EntityID} took {hitInfo.Damage} damage from {hitInfo.Attacker.EntityID}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBaseCombatEntityHurt")]
	private object IOnBaseCombatEntityHurt(BaseCombatEntity entity, HitInfo hitInfo)
	{
		if (!(entity is BasePlayer))
		{
			return Interface.CallHook("OnEntityTakeDamage", entity, hitInfo);
		}
		return null;
	}

```

## OnUserRespawned(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user respawns.
/// </summary>
/// <param name="player">The player who respawned.</param>
/// <returns>No return behavior.</returns>
void OnUserRespawned(IPlayer player)
{
    Puts($"Player {player.Name} has respawned.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerRespawned")]
	private void OnPlayerRespawned(BasePlayer basePlayer)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserRespawned", iPlayer);
		}
	}

```

## OnUserDisconnected(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user disconnects from the server.
/// </summary>
/// <param name="iPlayer">The IPlayer instance representing the disconnected user.</param>
/// <param name="reason">The reason for the disconnection, if any.</param>
/// <returns>No return behavior.</returns>
void OnUserDisconnected(IPlayer iPlayer, string reason)
{
    Puts($"User {iPlayer.Name} has disconnected from the server: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerDisconnected")]
	private void OnPlayerDisconnected(BasePlayer basePlayer, string reason)
	{
		IPlayer iPlayer = basePlayer.IPlayer;
		if (iPlayer != null)
		{
			Interface.CallHook("OnUserDisconnected", iPlayer, reason);
		}
		Covalence.PlayerManager.PlayerDisconnected(basePlayer);
	}

```

## OnServerInitialized(bool)

```csharp
```csharp
/// <summary>
/// Called when the server is initialized.
/// </summary>
/// <param name="initialized">Whether the server has been successfully initialized.</param>
/// <returns>No return behavior.</returns>
void OnServerInitialized(bool initialized)
{
    Puts($"Server initialization complete: {initialized}");
    if (!initialized)
    {
        Puts("Error initializing server. Server will not start.");
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerInitialized")]
	private void IOnServerInitialized()
	{
		if (!serverInitialized)
		{
			Analytics.Collect();
			if (!Interface.Oxide.Config.Options.Modded)
			{
				Interface.Oxide.LogWarning("The server is currently listed under Community. Please be aware that Facepunch only allows admin tools (that do not affect gameplay) under the Community section");
			}
			serverInitialized = true;
			Interface.CallHook("OnServerInitialized", serverInitialized);
		}
	}

```

## CanUserLogin(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user attempts to login.
/// </summary>
/// <param name="username">The username of the user attempting to login.</param>
/// <param name="steamId">The Steam ID of the user attempting to login.</param>
/// <param name="ipAddress">The IP address of the user attempting to login.</param>
/// <returns>
/// Returns a non-null value to override the default login behavior. 
/// If `true` is returned, the user is allowed to login.
/// If `false` or a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object CanUserLogin(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} is attempting to login.");
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from logging in.");
        return false;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnPlayerChat(BasePlayer,string,ConVar.Chat.ChatChannel)

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The text of the chat message.</param>
/// <param name="channel">The channel on which the chat message was sent.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. 
/// If `null` is returned, the chat message will be displayed as normal.
/// </returns>
object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
{
    Puts($"Player {player.Name} sent chat message: {message} on channel {channel}");
    if (message.ToLower() == "test")
    {
        Puts($"Player {player.Name} sent a test message.");
        return "Test message received.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnUserUnbanned(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned user.</param>
/// <param name="steamId">The Steam ID of the unbanned user.</param>
/// <param name="ipAddress">The IP address of the unbanned user.</param>
/// <returns>No return behavior.</returns>
void OnUserUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## CanClientLogin(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a client attempts to login.
/// </summary>
/// <param name="connection">The connection object representing the client.</param>
/// <returns>
/// Returns `true` if the client should be allowed to login, or any non-null value to prevent them from logging in. 
/// If `null` is returned, the default login behavior will occur.
/// </returns>
object CanClientLogin(Connection connection)
{
    Puts($"Client {connection.username} with IP {connection.ipaddress} has attempted to login.");
    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"Client {connection.username} with IP {connection.ipaddress} has been blocked from logging in.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnRconMessage(System.Net.IPAddress,Oxide.Core.RemoteConsole.RemoteMessage)

```csharp
```csharp
/// <summary>
/// Called when an RCON message is received.
/// </summary>
/// <param name="ipAddress">The IP address of the client sending the RCON message.</param>
/// <param name="message">The RCON message itself, which can be a command or other type of message.</param>
/// <returns>
/// Returns `true` to override the default behavior and prevent the message from being processed further.
/// If `null` is returned, the message will be processed as normal.
/// </returns>
object OnRconMessage(IPAddress ipAddress, Oxide.Core.RemoteConsole.RemoteMessage message)
{
    Puts($"Received RCON message from {ipAddress} with command: {message.Message}");
    if (message.Message.ToLower() == "shutdown")
    {
        Puts($"Shutting down the server due to RCON command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnRconMessage")]
	private object IOnRconMessage(IPAddress ipAddress, string command)
	{
		if (ipAddress != null && !string.IsNullOrEmpty(command))
		{
			RemoteMessage message = RemoteMessage.GetMessage(command);
			if (string.IsNullOrEmpty(message?.Message))
			{
				return null;
			}
			if (Interface.CallHook("OnRconMessage", ipAddress, message) != null)
			{
				return true;
			}
			string[] array = Oxide.Core.CommandLine.Split(message.Message);
			if (array.Length >= 1)
			{
				string obj = array[0].ToLower();
				string[] obj2 = array.Skip(1).ToArray();
				if (Interface.CallHook("OnRconCommand", ipAddress, obj, obj2) != null)
				{
					return true;
				}
			}
		}
		return null;
	}

```

## OnPlayerBanned(string,ulong,string,string,long)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="playerName">The name of the banned player.</param>
/// <param name="steamId">The Steam ID of the banned player.</param>
/// <param name="ipAddress">The IP address of the banned player.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The time until the ban expires (in seconds).</param>
/// <returns>No return behavior.</returns>
void OnPlayerBanned(string playerName, ulong steamId, string ipAddress, string reason, long expiry)
{
    Puts($"Player {playerName} with SteamID {steamId}, IP {ipAddress} has been banned for {expiry} seconds. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnPlayerOfflineChat(ulong,string,string,ConVar.Chat.ChatChannel)

```csharp
```csharp
/// <summary>
/// Called when a player sends an offline chat message.
/// </summary>
/// <param name="playerId">The ID of the player sending the message.</param>
/// <param name="playerName">The name of the player sending the message.</param>
/// <param name="message">The text of the message being sent.</param>
/// <param name="channel">The channel on which the message is being sent.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. 
/// If `null` is returned, the message will be broadcast as normal.
/// </returns>
object OnPlayerOfflineChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel)
{
    Puts($"Player {playerName} with ID {playerId} has sent an offline chat message: {message} on channel {channel}");
    if (message == "test")
    {
        Puts($"Player {playerName} has sent a test message.");
        return null;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnNpcTarget(BaseNpc,BaseEntity)

```csharp
```csharp
/// <summary>
/// Called when an NPC targets a base entity.
/// </summary>
/// <param name="npc">The NPC that is targeting.</param>
/// <param name="target">The entity being targeted by the NPC.</param>
/// <returns>
/// Returns `null` to allow the NPC to target the entity normally, or any non-null value to override the default behavior.
/// If a float is returned, it will be used as the new player target decision start time for the NPC.
/// </returns>
object OnNpcTarget(BaseNpc npc, BaseEntity target)
{
    Puts($"NPC {npc.name} has targeted entity {target.UserIDString}");
    if (target is Player && ((Player)target).IsAdmin)
    {
        Puts($"NPC {npc.name} has been instructed to ignore admin players");
        return 5f;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnNpcTarget")]
	private object IOnNpcTarget(BaseNpc npc, BaseEntity target)
	{
		if (Interface.CallHook("OnNpcTarget", npc, target) != null)
		{
			npc.SetFact(BaseNpc.Facts.HasEnemy, 0);
			npc.SetFact(BaseNpc.Facts.EnemyRange, 3);
			npc.SetFact(BaseNpc.Facts.AfraidRange, 1);
			npc.playerTargetDecisionStartTime = 0f;
			return 0f;
		}
		return null;
	}

```

## OnPlayerBanned(Network.Connection,string)

```csharp
```csharp
/// <summary>
/// Called when a player is banned.
/// </summary>
/// <param name="connection">The network connection of the banned player.</param>
/// <param name="status">The ban status, which can be used to determine the reason for the ban.</param>
void OnPlayerBanned(Network.Connection connection, string status)
{
    Puts($"Player {connection.UserIDString} has been banned with status: {status}");
    if (status == "Permanent Ban")
    {
        Puts($"Player {connection.UserIDString} has been permanently banned.");
        // Additional actions can be taken here, such as removing the player's data or notifying administrators.
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerBanned")]
	private void IOnPlayerBanned(Connection connection, AuthResponse status)
	{
		Interface.CallHook("OnPlayerBanned", connection, status.ToString());
	}

```

## OnUserKicked(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user is kicked from the server.
/// </summary>
/// <param name="player">The player being kicked.</param>
/// <param name="reason">The reason for kicking the player.</param>
/// <returns>No return behavior.</returns>
void OnUserKicked(IPlayer player, string reason)
{
    Puts($"Player {player.Name} was kicked with reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnPlayerKicked")]
	private void OnPlayerKicked(BasePlayer basePlayer, string reason)
	{
		if (basePlayer.IPlayer != null)
		{
			Interface.CallHook("OnUserKicked", basePlayer.IPlayer, reason);
		}
	}

```

## OnUserConnected(Oxide.Core.Libraries.Covalence.IPlayer)

```csharp
```csharp
/// <summary>
/// Called when a user connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
/// <returns>No return behavior.</returns>
void OnUserConnected(IPlayer player)
{
    Puts($"Player {player.Name} has connected to the server.");
    if (player.IsAdmin())
    {
        Puts($"Player {player.Name} is an administrator.");
        // Grant admin privileges
    }
    else
    {
        Puts($"Player {player.Name} is a regular player.");
        // Do nothing
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnServerCommand(string,string[])

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="commandName">The name of the command being executed.</param>
/// <param name="args">The arguments passed to the command.</param>
/// <returns>
/// Returns `true` to allow the command to execute, or any non-null value to prevent it from executing.
/// </returns>
object OnServerCommand(string commandName, string[] args)
{
    Puts($"Server command {commandName} with arguments {string.Join(", ", args)} has been executed.");
    if (commandName == "adminonly" && !RustPermissions.UserHasGroup(RustPermissions.GetSteamId(), RustPermissions.DefaultGroups.Administrators))
    {
        Puts("User does not have admin permissions to execute this command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnLoseCondition(object[])

```csharp
```csharp
/// <summary>
/// Called when an item loses a certain amount of condition.
/// </summary>
/// <param name="item">The item losing condition.</param>
/// <param name="amount">The amount of condition lost.</param>
/// <returns>No return behavior.</returns>
void OnLoseCondition(object[] args)
{
    Item item = (Item)args[0];
    float amount = (float)args[1];
    Puts($"Item {item.name} has lost {amount} condition.");
    if (item.condition <= 0f && item.condition < ((Item)item).condition)
    {
        Puts($"Item {item.name} is now broken.");
        item.OnBroken();
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnLoseCondition")]
	private object IOnLoseCondition(Item item, float amount)
	{
		object[] array = new object[2] { item, amount };
		Interface.CallHook("OnLoseCondition", array);
		amount = (float)array[1];
		float condition = item.condition;
		item.condition -= amount;
		if (item.condition <= 0f && item.condition < condition)
		{
			item.OnBroken();
		}
		return true;
	}

```

## OnServerCommand(ConsoleSystem.Arg)

```csharp
```csharp
/// <summary>
/// Called when a server command is executed.
/// </summary>
/// <param name="arg">The argument containing the command and its parameters.</param>
/// <returns>
/// Returns `true` to allow the command to execute, or any non-null value to prevent it from executing.
/// If `null` is returned, the default behavior will be used.
/// </returns>
object OnServerCommand(ConsoleSystem.Arg arg)
{
    Puts($"Server command {arg.cmd.FullName} executed by player {arg.Player().displayName}");
    if (arg.cmd.FullName == "admin.kick")
    {
        Puts($"Player {arg.Player().displayName} is not allowed to use the admin.kick command.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerCommand")]
	private object IOnServerCommand(ConsoleSystem.Arg arg)
	{
		if (arg == null || (arg.Connection != null && arg.Player() == null))
		{
			return true;
		}
		if (arg.cmd.FullName == "chat.say" || arg.cmd.FullName == "chat.teamsay" || arg.cmd.FullName == "chat.localsay")
		{
			return null;
		}
		object obj = Interface.CallHook("OnServerCommand", arg);
		object obj2 = Interface.CallHook("OnServerCommand", arg.cmd.FullName, RustCommandSystem.ExtractArgs(arg));
		if (((obj == null) ? obj2 : obj) != null)
		{
			return true;
		}
		return null;
	}

```

## OnServerShutdown()

```csharp
```csharp
/// <summary>
/// Called when the server is shutting down.
/// </summary>
void OnServerShutdown()
{
    Puts("Server shutdown initiated.");
    // Perform any necessary cleanup or shutdown tasks here...
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnServerShutdown")]
	private void IOnServerShutdown()
	{
		Interface.Oxide.CallHook("OnServerShutdown");
		Interface.Oxide.OnShutdown();
		Covalence.PlayerManager.SavePlayerData();
	}

```

## OnUserBanned(string,string,string,string,long)

```csharp
```csharp
/// <summary>
/// Called when a user is banned from the server.
/// </summary>
/// <param name="username">The username of the banned user.</param>
/// <param name="steamId">The Steam ID of the banned user.</param>
/// <param name="ipAddress">The IP address of the banned user.</param>
/// <param name="reason">The reason for the ban.</param>
/// <param name="expiry">The time in seconds until the ban expires.</param>
/// <returns>No return behavior.</returns>
void OnUserBanned(string username, string steamId, string ipAddress, string reason, long expiry)
{
    Puts($"User {username} with SteamID {steamId}, IP {ipAddress} has been banned for {expiry} seconds. Reason: {reason}");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserSet")]
	private void OnServerUserSet(ulong steamId, ServerUsers.UserGroup group, string playerName, string reason, long expiry)
	{
		if (serverInitialized && group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerBanned", playerName, steamId, player?.Address ?? "0", reason, expiry);
			Interface.CallHook("OnUserBanned", playerName, text, player?.Address ?? "0", reason, expiry);
		}
	}

```

## OnEntityTakeDamage(BasePlayer,HitInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity (in this case, a player) takes damage.
/// </summary>
/// <param name="entity">The entity taking the damage.</param>
/// <param name="hitInfo">Information about the hit that caused the damage.</param>
/// <returns>
/// Returns `true` to allow the entity to take the damage, or any non-null value to prevent them from taking the damage.
/// If a string is returned, it will be used as a message to display to the player.
/// </returns>
object OnEntityTakeDamage(BasePlayer entity, HitInfo hitInfo)
{
    Puts($"Entity {entity.UserIDString} took {hitInfo.damageType} damage from {hitInfo.attacker.UserIDString}.");
    if (hitInfo.damageType == "explosive")
    {
        Puts($"Entity {entity.UserIDString} was damaged by an explosive attack.");
        return "You were hit with an explosive attack!";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnBasePlayerAttacked")]
	private object IOnBasePlayerAttacked(BasePlayer basePlayer, HitInfo hitInfo)
	{
		if (!serverInitialized || basePlayer == null || hitInfo == null || basePlayer.IsDead() || isPlayerTakingDamage || basePlayer is NPCPlayer)
		{
			return null;
		}
		if (Interface.CallHook("OnEntityTakeDamage", basePlayer, hitInfo) != null)
		{
			return true;
		}
		isPlayerTakingDamage = true;
		try
		{
			basePlayer.OnAttacked(hitInfo);
		}
		finally
		{
			isPlayerTakingDamage = false;
		}
		return true;
	}

```

## OnUserApproved(string,string,string)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="username">The username of the approved user.</param>
/// <param name="steamId">The Steam ID of the approved user.</param>
/// <param name="ipAddress">The IP address of the approved user.</param>
/// <returns>
/// Returns a non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason. 
/// If `null` is returned, the user is approved as normal.
/// </returns>
object OnUserApproved(string username, ulong steamId, string ipAddress)
{
    Puts($"User {username} with SteamID {steamId} and IP {ipAddress} has been approved to join the server.");
    if (ipAddress == "192.168.1.1")
    {
        Puts($"User {username} with IP {ipAddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    // Add custom approval logic here
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## OnUserChat(Oxide.Core.Libraries.Covalence.IPlayer,string)

```csharp
```csharp
/// <summary>
/// Called when a user sends a chat message.
/// </summary>
/// <param name="player">The player who sent the chat message.</param>
/// <param name="message">The text of the chat message.</param>
/// <returns>
/// Returns `null` to allow the message to be sent as normal, or any non-null value to override the default behavior.
/// If a string is returned, it will be used as the reason for rejecting the message.
/// </returns>
object OnUserChat(IPlayer player, string message)
{
    Puts($"Player {player.Name} sent chat message: {message}");
    if (message.ToLower() == "test")
    {
        Puts($"Player {player.Name} is testing the chat system.");
        return "Test message. Please ignore.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerChat")]
	private object IOnPlayerChat(ulong playerId, string playerName, string message, Chat.ChatChannel channel, BasePlayer basePlayer)
	{
		if (string.IsNullOrEmpty(message) || message.Equals("text"))
		{
			return true;
		}
		if (basePlayer == null || !basePlayer.IsConnected)
		{
			return Interface.CallHook("OnPlayerOfflineChat", playerId, playerName, message, channel);
		}
		object obj = Interface.CallHook("OnPlayerChat", basePlayer, message, channel);
		object result = Interface.CallHook("OnUserChat", basePlayer.IPlayer, message);
		if (obj != null)
		{
			return obj;
		}
		return result;
	}

```

## OnPlayerConnected(BasePlayer)

```csharp
```csharp
/// <summary>
/// Called when a player connects to the server.
/// </summary>
/// <param name="player">The connected player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerConnected(BasePlayer player)
{
    Puts($"Player {player.UserIDString} has connected to the server.");
    if (player.UserIDString == "admin")
    {
        Puts($"Admin {player.UserIDString} has connected to the server.");
        // Grant admin privileges
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerConnected")]
	private void IOnPlayerConnected(BasePlayer basePlayer)
	{
		lang.SetLanguage(basePlayer.net.connection.info.GetString("global.language", "en"), basePlayer.UserIDString);
		basePlayer.SendEntitySnapshot(CommunityEntity.ServerInstance);
		Covalence.PlayerManager.PlayerConnected(basePlayer);
		IPlayer player = Covalence.PlayerManager.FindPlayerById(basePlayer.UserIDString);
		if (player != null)
		{
			basePlayer.IPlayer = player;
			Interface.CallHook("OnUserConnected", player);
		}
		Interface.Oxide.CallHook("OnPlayerConnected", basePlayer);
	}

```

## OnEntitySaved(BaseNetworkable,BaseNetworkable.SaveInfo)

```csharp
```csharp
/// <summary>
/// Called when an entity is saved.
/// </summary>
/// <param name="entity">The entity being saved.</param>
/// <param name="saveInfo">Information about the save operation.</param>
/// <returns>No return behavior.</returns>
void OnEntitySaved(BaseNetworkable entity, BaseNetworkable.SaveInfo saveInfo)
{
    Puts($"Entity {entity.EntityID} has been saved.");
    
    // If the entity is a specific type (e.g. a player), perform additional actions
    if (entity is Player player && player.IsOnline)
    {
        Puts($"Player {player.UserIDString} has been saved.");
        
        // Perform any necessary actions for this specific entity type
        // For example, update the player's last seen timestamp
        player.LastSeenTimestamp = DateTime.Now;
    }
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnEntitySaved")]
	private void IOnEntitySaved(BaseNetworkable baseNetworkable, BaseNetworkable.SaveInfo saveInfo)
	{
		if (serverInitialized && saveInfo.forConnection != null)
		{
			Interface.CallHook("OnEntitySaved", baseNetworkable, saveInfo);
		}
	}

```

## OnPlayerCommand(BasePlayer,string,string[])

```csharp
```csharp
/// <summary>
/// Called when a player sends a chat message.
/// </summary>
/// <param name="player">The player who sent the message.</param>
/// <param name="command">The command that was entered by the player.</param>
/// <param name="args">Any arguments that were provided with the command.</param>
/// <returns>
/// Returns a non-null value to override the default chat behavior. 
/// If `null` is returned, the message will be processed as normal.
/// </returns>
object OnPlayerCommand(BasePlayer player, string command, string[] args)
{
    Puts($"Player {player.Name} has sent the command '/{command}' with arguments '{string.Join(", ", args)}'");
    if (command == "kick")
    {
        Puts($"Player {player.Name} is being kicked for violating server rules.");
        return "Kicked: Violation of server rules.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnPlayerCommand")]
	private void IOnPlayerCommand(BasePlayer basePlayer, string message)
	{
		if (basePlayer == null)
		{
			return;
		}
		string text = message.Replace("\n", "").Replace("\r", "").Trim();
		if (string.IsNullOrEmpty(text) || text[0] != '/' || text.Length <= 1)
		{
			return;
		}
		ParseCommand(text.TrimStart('/'), out var command, out var args);
		if (command == null)
		{
			return;
		}
		if (!basePlayer.IsConnected)
		{
			Interface.CallHook("OnApplicationCommand", basePlayer, command, args);
			Interface.CallHook("OnApplicationCommand", basePlayer.IPlayer, command, args);
			return;
		}
		object obj = Interface.CallHook("OnPlayerCommand", basePlayer, command, args);
		object obj2 = Interface.CallHook("OnUserCommand", basePlayer.IPlayer, command, args);
		if (((obj == null) ? obj2 : obj) != null)
		{
			return;
		}
		try
		{
			if (!Covalence.CommandSystem.HandleChatMessage(basePlayer.IPlayer, text) && !cmdlib.HandleChatCommand(basePlayer, command, args) && Interface.Oxide.Config.Options.Modded)
			{
				basePlayer.IPlayer.Reply(string.Format(lang.GetMessage("UnknownCommand", this, basePlayer.IPlayer.Id), command));
			}
		}
		catch (Exception ex)
		{
			Exception ex2 = ex;
			string text2 = string.Empty;
			string empty = string.Empty;
			StringBuilder stringBuilder = new StringBuilder();
			while (ex2 != null)
			{
				string text3 = ex2.GetType().Name;
				text2 = (text3 + ": " + ex2.Message).TrimEnd(' ', ':');
				stringBuilder.AppendLine(ex2.StackTrace);
				if (ex2.InnerException != null)
				{
					stringBuilder.AppendLine("Rethrow as " + text3);
				}
				ex2 = ex2.InnerException;
			}
			StackTrace stackTrace = new StackTrace(ex, 0, fNeedFileInfo: true);
			for (int i = 0; i < stackTrace.FrameCount; i++)
			{
				MethodBase method = stackTrace.GetFrame(i).GetMethod();
				if ((object)method != null && (object)method.DeclaringType != null && method.DeclaringType.Namespace == "Oxide.Plugins")
				{
					empty = method.DeclaringType.Name;
				}
			}
			Interface.Oxide.LogError(string.Format("Failed to run command '/{0}' on plugin '{1}'. ({2}){3}{4}", command, empty, text2.Replace(System.Environment.NewLine, " "), System.Environment.NewLine, stackTrace));
		}
	}

```

## CanUseUI(BasePlayer,string)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can use the UI.
/// </summary>
/// <param name="player">The player attempting to use the UI.</param>
/// <param name="json">The JSON data related to the UI.</param>
/// <returns>
/// Returns `null` to allow the player to use the UI, or any non-null value to prevent them from using it.
/// </returns>
object CanUseUI(BasePlayer player, string json)
{
    Puts($"Player {player.UserIDString} is attempting to use the UI with JSON: {json}");
    if (json == "restricted")
    {
        Puts($"Player {player.displayName} does not have permission to use the restricted UI.");
        return true;
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	public static bool AddUi(BasePlayer player, string json)
	{
		if (player?.net != null && Interface.CallHook("CanUseUI", player, json) == null)
		{
			CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo
			{
				connection = player.net.connection
			}, null, "AddUI", json);
			return true;
		}
		return false;
	}

```

## OnPlayerUnbanned(string,ulong,string)

```csharp
```csharp
/// <summary>
/// Called when a player is unbanned from the server.
/// </summary>
/// <param name="username">The username of the unbanned player.</param>
/// <param name="steamId">The Steam ID of the unbanned player.</param>
/// <param name="ipAddress">The IP address of the unbanned player.</param>
/// <returns>No return behavior.</returns>
void OnPlayerUnbanned(string username, ulong steamId, string ipAddress)
{
    Puts($"Player {username} with SteamID {steamId} and IP {ipAddress} has been unbanned from the server.");
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("OnServerUserRemove")]
	private void OnServerUserRemove(ulong steamId)
	{
		if (serverInitialized && ServerUsers.users.ContainsKey(steamId) && ServerUsers.users[steamId].group == ServerUsers.UserGroup.Banned)
		{
			string text = steamId.ToString();
			IPlayer player = Covalence.PlayerManager.FindPlayerById(text);
			Interface.CallHook("OnPlayerUnbanned", player?.Name ?? "Unnamed", steamId, player?.Address ?? "0");
			Interface.CallHook("OnUserUnbanned", player?.Name ?? "Unnamed", text, player?.Address ?? "0");
		}
	}

```

## OnUserApprove(Network.Connection)

```csharp
```csharp
/// <summary>
/// Called when a user is approved to join the server.
/// </summary>
/// <param name="connection">The connection object for the user being approved.</param>
/// <returns>
/// Returns `null` to allow the user to be approved, or any non-null value to override the default approval behavior. 
/// If a string is returned, the user will be kicked with the provided message as the reason.
/// </returns>
object OnUserApprove(Connection connection)
{
    Puts($"User {connection.username} has been approved to join the server.");
    if (connection.ipaddress == "192.168.1.1")
    {
        Puts($"User {connection.username} with IP {connection.ipaddress} has been blocked from joining.");
        return "Blocked: Unauthorized IP address.";
    }
    return null;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("IOnUserApprove")]
	private object IOnUserApprove(Connection connection)
	{
		string username = connection.username;
		string text = connection.userid.ToString();
		string obj = Regex.Replace(connection.ipaddress, ipPattern, "");
		uint authLevel = connection.authLevel;
		if (permission.IsLoaded)
		{
			permission.UpdateNickname(text, username);
			OxideConfig.DefaultGroups defaultGroups = Interface.Oxide.Config.Options.DefaultGroups;
			if (!permission.UserHasGroup(text, defaultGroups.Players))
			{
				permission.AddUserGroup(text, defaultGroups.Players);
			}
			if (authLevel >= 2 && !permission.UserHasGroup(text, defaultGroups.Administrators))
			{
				permission.AddUserGroup(text, defaultGroups.Administrators);
			}
		}
		Covalence.PlayerManager.PlayerJoin(connection.userid, username);
		object obj2 = Interface.CallHook("CanClientLogin", connection);
		object obj3 = Interface.CallHook("CanUserLogin", username, text, obj);
		object obj4 = ((obj2 == null) ? obj3 : obj2);
		if (obj4 is string || (obj4 is bool && !(bool)obj4))
		{
			ConnectionAuth.Reject(connection, (obj4 is string) ? obj4.ToString() : lang.GetMessage("ConnectionRejected", this, text));
			return true;
		}
		object obj5 = Interface.CallHook("OnUserApprove", connection);
		object result = Interface.CallHook("OnUserApproved", username, text, obj);
		if (obj5 != null)
		{
			return obj5;
		}
		return result;
	}

```

## CanPickupEntity(BasePlayer,DoorCloser)

```csharp
```csharp
/// <summary>
/// Called to determine if a player can pickup an entity.
/// </summary>
/// <param name="player">The player attempting to pick up the entity.</param>
/// <param name="entity">The entity being picked up.</param>
/// <returns>
/// Returns `true` if the player can pick up the entity, or `false` otherwise.
/// If a non-bool value is returned, it will be treated as `false`.
/// </returns>
object CanPickupEntity(BasePlayer player, DoorCloser entity)
{
    Puts($"Player {player.UserIDString} attempting to pick up {entity.GetType().Name} at position {entity.transform.position}");
    if (entity.IsLocked)
    {
        Puts($"Player {player.displayName} cannot pick up locked {entity.GetType().Name}.");
        return false;
    }
    return true;
}
```
```

### Source Code from the Library

```csharp

	[HookMethod("ICanPickupEntity")]
	private object ICanPickupEntity(BasePlayer basePlayer, DoorCloser entity)
	{
		object obj = Interface.CallHook("CanPickupEntity", basePlayer, entity);
		if (!(obj is bool) || (bool)obj)
		{
			return null;
		}
		return true;
	}

```

